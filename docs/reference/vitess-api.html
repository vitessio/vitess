<!DOCTYPE html>
<html lang="en" itemscope itemtype="https://schema.org/WebPage">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Vitess / Vitess API Reference</title>

        <!-- Webfont -->
    <link href='http://fonts.googleapis.com/css?family=Roboto:400,100,100italic,300,300italic,400italic,500,500italic,700,700italic,900,900italic' rel='stylesheet' type='text/css'>
    
    <!--<link rel="shortcut icon" type="image/png" href="/favicon.png">-->

    <!-- Bootstrap -->
    <link href="/libs/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Styles -->
    <link rel="stylesheet" type="text/css" href="/css/site.css" />
    <!-- Font Awesome icons -->
    <link href="/libs/font-awesome-4.4.0/css/font-awesome.min.css"
          rel="stylesheet"
          type="text/css">
    
    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="/libs/bootstrap/js/bootstrap.min.js"></script>


    <!-- metadata -->
    <meta name="og:title" content="Vitess / Vitess API Reference"/>
    <meta name="og:image" content="/images/vitess_logo_with_border.svg"/>
    <meta name="og:description" content="Vitess is a database clustering system for horizontal scaling of MySQL."/>

    <link rel="icon" href="/images/vitess_logo_icon_size.png" type="image/png">

    
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-60219601-1', 'auto');
  ga('send', 'pageview');
</script>

    
  </head>
  <body class="docs" id="top_of_page">

    <span id="toc-depth" data-toc-depth="h2,h3"></span>


    <nav id="common-nav" class="navbar navbar-fixed-top inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse-1">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/">
        <img class="logo" src="/images/vitess_logo_with_border.svg" alt="Vitess">
      </a>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="navbar-collapse-1">
      <ul class="nav navbar-nav navbar-right" id="standard-menu-links">
        <li><a href="/overview/">Overview</a></li>
        <li><a href="/user-guide/introduction.html">Guides</a></li>
        <li><a href="/reference/vitess-api.html">Reference</a></li>
        <li><a href="http://blog.vitess.io">Blog</a></li>
        <li><a href="https://github.com/youtube/vitess"><i class="fa fa-github"></i> GitHub</a></li>
        <!-- Hide link to blog unless we have actual posts -->
        <!-- <li><a href="/blog/" title="">Blog</a></li> -->
      </ul>
      <ul class="nav nav-stacked mobile-left-nav-menu" id="collapsed-left-menu">
                <li class="submenu">
          <h4 class="arrow-r no-top-margin">Overview</h4>
          <ul style="display: none">
            <li><a href="/overview/">What is Vitess</a></li>
            <li><a href="/overview/scaling-mysql.html">Scaling MySQL with Vitess</a></li>
            <li><a href="/overview/concepts.html">Key Concepts</a></li>
          </ul>
        </li>
        <li class="submenu">
          <h4 class="arrow-r">Getting Started</h4>
          <ul style="display: none">
            <li style="padding-bottom: 0"><a href="/getting-started/">Run Vitess on Kubernetes</a>
              <ul style="display: block">
                <li style="padding-bottom: 0"><a href="/getting-started/docker-build.html">Custom Docker Build</a></li>
              </ul>
            </li>
            <li><a href="/getting-started/local-instance.html">Run Vitess Locally</a></li>
          </ul>
        </li>
        <li class="submenu">
          <h4 class="arrow-r">User Guide</h4>
          <ul style="display: none">
            <li><a href="/user-guide/introduction.html">Introduction</a>
            <li><a href="/user-guide/client-libraries.html">Client Libraries</a>
            <li><a href="/user-guide/backup-and-restore.html">Backing Up Data</a>
            <li><a href="/user-guide/reparenting.html">Reparenting</a></li>
            <li style="padding-bottom: 0"><a href="/user-guide/schema-management.html">Schema Management</a></li>
              <ul style="display: block">
                <li style="padding-bottom: 0"><a href="/user-guide/vschema.html">VSchema Guide</a></li>
                <li style="padding-bottom: 0"><a href="/user-guide/schema-swap.html">Schema Swap (Tutorial)</a></li>
              </ul>
            <li style="padding-bottom: 0"><a href="/user-guide/sharding.html">Sharding</a>
              <ul style="display: block">
                <li><a href="/user-guide/horizontal-sharding.html">Horizontal Sharding (Codelab)</a></li>
                <li><a href="/user-guide/horizontal-sharding-workflow.html">Horizontal Sharding (Workflow)</a></li>
                <li style="padding-bottom: 0"><a href="/user-guide/sharding-kubernetes.html">Sharding in Kubernetes (Codelab)</a></li>
              </ul>
            </li>
            <li><a href="/user-guide/vitess-sequences.html">Vitess Sequences</a></li>
            <li><a href="/user-guide/mysql-server-protocol.html">MySQL Server Protocol</a></li>
            <li><a href="/user-guide/vitess-replication.html">Vitess and Replication</a></li>
            <li><a href="/user-guide/update-stream.html">Update Stream</a></li>
            <li><a href="/user-guide/row-based-replication.html">Row Based Replication</a></li>
            <li><a href="/user-guide/topology-service.html">Topology Service</a></li>
            <li><a href="/user-guide/transport-security-model.html">Transport Security Model</a></li>
            <li style="padding-bottom: 0"><a href="/user-guide/launching.html">Launching</a>
              <ul style="display: block">
                <li><a href="/user-guide/scalability-philosophy.html">Scalability Philosophy</a></li>
                <li><a href="/user-guide/production-planning.html">Production Planning</a></li>
                <li><a href="/user-guide/server-configuration.html">Server Configuration</a></li>
                <li><a href="/user-guide/twopc.html">2PC Guide</a></li>
                <li style="padding-bottom: 0"><a href="/user-guide/troubleshooting.html">Troubleshooting</a></li>
              </ul>
            </li>
            <li><a href="/user-guide/upgrading.html">Upgrading</a></li>
          </ul>
        </li>
        <li class="submenu">
          <h4 class="arrow-r">Reference Guides</h4>
          <ul style="display: none">
            <li><a href="/reference/vitess-api.html">Vitess API</a>
            <li><a href="/reference/vtctl.html">vtctl Commands</a>
          </ul>
        </li>
        <li class="submenu">
          <h4 class="arrow-r">Other Resources</h4>
          <ul style="display: none">
            <li><a href="/resources/presentations.html">Presentations</a>
            <li><a href="http://blog.vitess.io/">Blog</a>
            <li><a href="/resources/roadmap.html">Roadmap</a>
          </ul>
        </li>
        <li class="submenu">
          <h4 class="arrow-r">Contributing</h4>
          <ul style="display: none">
            <li><a href="/contributing/">Contributing to Vitess</a>
            <li><a href="/contributing/github-workflow.html">GitHub Workflow</a>
            <li><a href="/contributing/code-reviews.html">Code Reviews</a>
          </ul>
        </li>

        <div>
          <form method="get" action="/search/">
            <input id="search-form" name="q" type="text" placeholder="Search">
          </form>
        </div>

        <li><a href="https://github.com/youtube/vitess" id="collapsed-left-menu-repo-link"><i class="fa fa-github"></i> GitHub</a></li>
      </ul>
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

    
<div id="masthead">
  <div class="container">
    <div class="row">
      <div class="col-md-9">
        <h1>Vitess API Reference</h1>
      </div>
    </div>
  </div>
</div>


<div class="container">
    <div class="row scroll-margin" id="toc-content-row">
    <div class="col-md-2" id="leftCol">
      <ul class="nav nav-stacked mobile-left-nav-menu" id="sidebar">
                <li class="submenu">
          <h4 class="arrow-r no-top-margin">Overview</h4>
          <ul style="display: none">
            <li><a href="/overview/">What is Vitess</a></li>
            <li><a href="/overview/scaling-mysql.html">Scaling MySQL with Vitess</a></li>
            <li><a href="/overview/concepts.html">Key Concepts</a></li>
          </ul>
        </li>
        <li class="submenu">
          <h4 class="arrow-r">Getting Started</h4>
          <ul style="display: none">
            <li style="padding-bottom: 0"><a href="/getting-started/">Run Vitess on Kubernetes</a>
              <ul style="display: block">
                <li style="padding-bottom: 0"><a href="/getting-started/docker-build.html">Custom Docker Build</a></li>
              </ul>
            </li>
            <li><a href="/getting-started/local-instance.html">Run Vitess Locally</a></li>
          </ul>
        </li>
        <li class="submenu">
          <h4 class="arrow-r">User Guide</h4>
          <ul style="display: none">
            <li><a href="/user-guide/introduction.html">Introduction</a>
            <li><a href="/user-guide/client-libraries.html">Client Libraries</a>
            <li><a href="/user-guide/backup-and-restore.html">Backing Up Data</a>
            <li><a href="/user-guide/reparenting.html">Reparenting</a></li>
            <li style="padding-bottom: 0"><a href="/user-guide/schema-management.html">Schema Management</a></li>
              <ul style="display: block">
                <li style="padding-bottom: 0"><a href="/user-guide/vschema.html">VSchema Guide</a></li>
                <li style="padding-bottom: 0"><a href="/user-guide/schema-swap.html">Schema Swap (Tutorial)</a></li>
              </ul>
            <li style="padding-bottom: 0"><a href="/user-guide/sharding.html">Sharding</a>
              <ul style="display: block">
                <li><a href="/user-guide/horizontal-sharding.html">Horizontal Sharding (Codelab)</a></li>
                <li><a href="/user-guide/horizontal-sharding-workflow.html">Horizontal Sharding (Workflow)</a></li>
                <li style="padding-bottom: 0"><a href="/user-guide/sharding-kubernetes.html">Sharding in Kubernetes (Codelab)</a></li>
              </ul>
            </li>
            <li><a href="/user-guide/vitess-sequences.html">Vitess Sequences</a></li>
            <li><a href="/user-guide/mysql-server-protocol.html">MySQL Server Protocol</a></li>
            <li><a href="/user-guide/vitess-replication.html">Vitess and Replication</a></li>
            <li><a href="/user-guide/update-stream.html">Update Stream</a></li>
            <li><a href="/user-guide/row-based-replication.html">Row Based Replication</a></li>
            <li><a href="/user-guide/topology-service.html">Topology Service</a></li>
            <li><a href="/user-guide/transport-security-model.html">Transport Security Model</a></li>
            <li style="padding-bottom: 0"><a href="/user-guide/launching.html">Launching</a>
              <ul style="display: block">
                <li><a href="/user-guide/scalability-philosophy.html">Scalability Philosophy</a></li>
                <li><a href="/user-guide/production-planning.html">Production Planning</a></li>
                <li><a href="/user-guide/server-configuration.html">Server Configuration</a></li>
                <li><a href="/user-guide/twopc.html">2PC Guide</a></li>
                <li style="padding-bottom: 0"><a href="/user-guide/troubleshooting.html">Troubleshooting</a></li>
              </ul>
            </li>
            <li><a href="/user-guide/upgrading.html">Upgrading</a></li>
          </ul>
        </li>
        <li class="submenu">
          <h4 class="arrow-r">Reference Guides</h4>
          <ul style="display: none">
            <li><a href="/reference/vitess-api.html">Vitess API</a>
            <li><a href="/reference/vtctl.html">vtctl Commands</a>
          </ul>
        </li>
        <li class="submenu">
          <h4 class="arrow-r">Other Resources</h4>
          <ul style="display: none">
            <li><a href="/resources/presentations.html">Presentations</a>
            <li><a href="http://blog.vitess.io/">Blog</a>
            <li><a href="/resources/roadmap.html">Roadmap</a>
          </ul>
        </li>
        <li class="submenu">
          <h4 class="arrow-r">Contributing</h4>
          <ul style="display: none">
            <li><a href="/contributing/">Contributing to Vitess</a>
            <li><a href="/contributing/github-workflow.html">GitHub Workflow</a>
            <li><a href="/contributing/code-reviews.html">Code Reviews</a>
          </ul>
        </li>

        <div>
          <form method="get" action="/search/">
            <input id="search-form" name="q" type="text" placeholder="Search">
          </form>
        </div>

      </ul>
    </div>
    <div class="col-md-3" id="rightCol">
      <div class="nav nav-stacked" id="tocSidebar">
        <div id="toc"></div>
      </div>
    </div>
    <div class="col-md-7" id="centerCol">
      <div id="centerTextCol">
        <p>This document describes Vitess API methods that enable your client application to more easily talk to your storage system to query data. API methods are grouped into the following categories:</p>

<ul>
<li><a href="#range-based-sharding">Range-based Sharding</a></li>
<li><a href="#transactions">Transactions</a></li>
<li><a href="#custom-sharding">Custom Sharding</a></li>
<li><a href="#map-reduce">Map Reduce</a></li>
<li><a href="#topology">Topology</a></li>
<li><a href="#v3-api-(alpha)">v3 API (alpha)</a></li>
</ul>

<p>The following table lists the methods in each group and links to more detail about each method:</p>

<table id="api-method-summary">
<tr><td class="api-method-summary-group" colspan="2">Range-based Sharding</td></tr>
<tr>
<td><code><a href="#executebatchkeyspaceids">ExecuteBatchKeyspaceIds</a></code></td>
<td>ExecuteBatchKeyspaceIds executes the list of queries based on the specified keyspace ids.</td>
</tr>
<tr>
<td><code><a href="#executeentityids">ExecuteEntityIds</a></code></td>
<td>ExecuteEntityIds executes the query based on the specified external id to keyspace id map.</td>
</tr>
<tr>
<td><code><a href="#executekeyranges">ExecuteKeyRanges</a></code></td>
<td>ExecuteKeyRanges executes the query based on the specified key ranges.</td>
</tr>
<tr>
<td><code><a href="#executekeyspaceids">ExecuteKeyspaceIds</a></code></td>
<td>ExecuteKeyspaceIds executes the query based on the specified keyspace ids.</td>
</tr>
<tr>
<td><code><a href="#streamexecutekeyranges">StreamExecuteKeyRanges</a></code></td>
<td>StreamExecuteKeyRanges executes a streaming query based on key ranges. Use this method if the query returns a large number of rows.</td>
</tr>
<tr>
<td><code><a href="#streamexecutekeyspaceids">StreamExecuteKeyspaceIds</a></code></td>
<td>StreamExecuteKeyspaceIds executes a streaming query based on keyspace ids. Use this method if the query returns a large number of rows.</td>
</tr>
<tr><td class="api-method-summary-group" colspan="2">Transactions</td></tr>
<tr>
<td><code><a href="#begin">Begin</a></code></td>
<td>Begin a transaction.</td>
</tr>
<tr>
<td><code><a href="#commit">Commit</a></code></td>
<td>Commit a transaction.</td>
</tr>
<tr>
<td><code><a href="#resolvetransaction">ResolveTransaction</a></code></td>
<td>ResolveTransaction resolves a transaction.</td>
</tr>
<tr>
<td><code><a href="#rollback">Rollback</a></code></td>
<td>Rollback a transaction.</td>
</tr>
<tr><td class="api-method-summary-group" colspan="2">Custom Sharding</td></tr>
<tr>
<td><code><a href="#executebatchshards">ExecuteBatchShards</a></code></td>
<td>ExecuteBatchShards executes the list of queries on the specified shards.</td>
</tr>
<tr>
<td><code><a href="#executeshards">ExecuteShards</a></code></td>
<td>ExecuteShards executes the query on the specified shards.</td>
</tr>
<tr>
<td><code><a href="#streamexecuteshards">StreamExecuteShards</a></code></td>
<td>StreamExecuteShards executes a streaming query based on shards. Use this method if the query returns a large number of rows.</td>
</tr>
<tr><td class="api-method-summary-group" colspan="2">Map Reduce</td></tr>
<tr>
<td><code><a href="#splitquery">SplitQuery</a></code></td>
<td>Split a query into non-overlapping sub queries</td>
</tr>
<tr><td class="api-method-summary-group" colspan="2">Topology</td></tr>
<tr>
<td><code><a href="#getsrvkeyspace">GetSrvKeyspace</a></code></td>
<td>GetSrvKeyspace returns a SrvKeyspace object (as seen by this vtgate). This method is provided as a convenient way for clients to take a look at the sharding configuration for a Keyspace. Looking at the sharding information should not be used for routing queries (as the information may change, use the Execute calls for that). It is convenient for monitoring applications for instance, or if using custom sharding.</td>
</tr>
<tr><td class="api-method-summary-group" colspan="2">v3 API (alpha)</td></tr>
<tr>
<td><code><a href="#execute">Execute</a></code></td>
<td>Execute tries to route the query to the right shard. It depends on the query and bind variables to provide enough information in conjonction with the vindexes to route the query.</td>
</tr>
<tr>
<td><code><a href="#streamexecute">StreamExecute</a></code></td>
<td>StreamExecute executes a streaming query based on shards. It depends on the query and bind variables to provide enough information in conjonction with the vindexes to route the query. Use this method if the query returns a large number of rows.</td>
</tr>
</table>

<h2 id="range-based-sharding">Range-based Sharding</h2>

<h3 id="executebatchkeyspaceids">ExecuteBatchKeyspaceIds</h3>

<p>ExecuteBatchKeyspaceIds executes the list of queries based on the specified keyspace ids.</p>

<h4 id="request">Request</h4>

<p>ExecuteBatchKeyspaceIdsRequest is the payload to ExecuteBatchKeyspaceId.</p>

<h5 id="parameters">Parameters</h5>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>caller_id</code> <br><a href="#vtrpc.callerid">vtrpc.CallerID</a></td>
<td style="text-align: left">CallerID is passed along RPCs to identify the originating client for a request. It is not meant to be secure, but only informational.  The client can put whatever info they want in these fields, and they will be trusted by the servers. The fields will just be used for logging purposes, and to easily find a client. VtGate propagates it to VtTablet, and VtTablet may use this information for monitoring purposes, to display on dashboards, or for blacklisting purposes.</td>
</tr>
<tr>
<td style="text-align: left"><code>session</code> <br><a href="#session">Session</a></td>
<td style="text-align: left">Session objects are session cookies and are invalidated on use. Query results will contain updated session values. Their content should be opaque to the user.</td>
</tr>
<tr>
<td style="text-align: left"><code>queries</code> <br>list &lt;<a href="#boundkeyspaceidquery">BoundKeyspaceIdQuery</a>&gt;</td>
<td style="text-align: left">BoundKeyspaceIdQuery represents a single query request for the specified list of keyspace ids. This is used in a list for ExecuteBatchKeyspaceIdsRequest.</td>
</tr>
<tr>
<td style="text-align: left"><code>tablet_type</code> <br><a href="#topodata.tablettype">topodata.TabletType</a></td>
<td style="text-align: left">TabletType represents the type of a given tablet.</td>
</tr>
<tr>
<td style="text-align: left"><code>as_transaction</code> <br>bool</td>
<td style="text-align: left">as_transaction will execute the queries in this batch in a single transaction per shard, created for this purpose. (this can be seen as adding a &#39;begin&#39; before and &#39;commit&#39; after the queries). Only makes sense if tablet_type is master. If set, the Session is ignored.</td>
</tr>
<tr>
<td style="text-align: left"><code>options</code> <br><a href="#query.executeoptions">query.ExecuteOptions</a></td>
<td style="text-align: left">ExecuteOptions is passed around for all Execute calls.</td>
</tr>
</tbody></table>

<h4 id="response">Response</h4>

<p>ExecuteBatchKeyspaceIdsResponse is the returned value from ExecuteBatchKeyspaceId.</p>

<h5 id="properties">Properties</h5>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>error</code> <br><a href="#vtrpc.rpcerror">vtrpc.RPCError</a></td>
<td style="text-align: left">RPCError is an application-level error structure returned by VtTablet (and passed along by VtGate if appropriate). We use this so the clients don&#39;t have to parse the error messages, but instead can depend on the value of the code.</td>
</tr>
<tr>
<td style="text-align: left"><code>session</code> <br><a href="#session">Session</a></td>
<td style="text-align: left">Session objects are session cookies and are invalidated on use. Query results will contain updated session values. Their content should be opaque to the user.</td>
</tr>
<tr>
<td style="text-align: left"><code>results</code> <br>list &lt;<a href="#query.queryresult">query.QueryResult</a>&gt;</td>
<td style="text-align: left">QueryResult is returned by Execute and ExecuteStream.  As returned by Execute, len(fields) is always equal to len(row) (for each row in rows).  As returned by StreamExecute, the first QueryResult has the fields set, and subsequent QueryResult have rows set. And as Execute, len(QueryResult[0].fields) is always equal to len(row) (for each row in rows for each QueryResult in QueryResult[1:]).</td>
</tr>
</tbody></table>

<h3 id="executeentityids">ExecuteEntityIds</h3>

<p>ExecuteEntityIds executes the query based on the specified external id to keyspace id map.</p>

<h4 id="request">Request</h4>

<p>ExecuteEntityIdsRequest is the payload to ExecuteEntityIds.</p>

<h5 id="parameters">Parameters</h5>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>caller_id</code> <br><a href="#vtrpc.callerid">vtrpc.CallerID</a></td>
<td style="text-align: left">CallerID is passed along RPCs to identify the originating client for a request. It is not meant to be secure, but only informational.  The client can put whatever info they want in these fields, and they will be trusted by the servers. The fields will just be used for logging purposes, and to easily find a client. VtGate propagates it to VtTablet, and VtTablet may use this information for monitoring purposes, to display on dashboards, or for blacklisting purposes.</td>
</tr>
<tr>
<td style="text-align: left"><code>session</code> <br><a href="#session">Session</a></td>
<td style="text-align: left">Session objects are session cookies and are invalidated on use. Query results will contain updated session values. Their content should be opaque to the user.</td>
</tr>
<tr>
<td style="text-align: left"><code>query</code> <br><a href="#query.boundquery">query.BoundQuery</a></td>
<td style="text-align: left">BoundQuery is a query with its bind variables</td>
</tr>
<tr>
<td style="text-align: left"><code>keyspace</code> <br>string</td>
<td style="text-align: left">keyspace to target the query to.</td>
</tr>
<tr>
<td style="text-align: left"><code>entity_column_name</code> <br>string</td>
<td style="text-align: left">entity_column_name is the column name to use.</td>
</tr>
<tr>
<td style="text-align: left"><code>entity_keyspace_ids</code> <br>list &lt;<a href="#executeentityidsrequest.entityid">EntityId</a>&gt;</td>
<td style="text-align: left">entity_keyspace_ids are pairs of entity_column_name values associated with its corresponding keyspace_id.</td>
</tr>
<tr>
<td style="text-align: left"><code>tablet_type</code> <br><a href="#topodata.tablettype">topodata.TabletType</a></td>
<td style="text-align: left">TabletType represents the type of a given tablet.</td>
</tr>
<tr>
<td style="text-align: left"><code>not_in_transaction</code> <br>bool</td>
<td style="text-align: left">not_in_transaction is deprecated and should not be used.</td>
</tr>
<tr>
<td style="text-align: left"><code>options</code> <br><a href="#query.executeoptions">query.ExecuteOptions</a></td>
<td style="text-align: left">ExecuteOptions is passed around for all Execute calls.</td>
</tr>
</tbody></table>

<h4 id="messages">Messages</h4>

<h5 id="executeentityidsrequest-entityid">ExecuteEntityIdsRequest.EntityId</h5>

<p><em>Properties</em></p>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>type</code> <br><a href="#query.type">query.Type</a></td>
<td style="text-align: left">Type defines the various supported data types in bind vars and query results.</td>
</tr>
<tr>
<td style="text-align: left"><code>value</code> <br>bytes</td>
<td style="text-align: left">value is the value for the entity. Not set if type is NULL_TYPE.</td>
</tr>
<tr>
<td style="text-align: left"><code>keyspace_id</code> <br>bytes</td>
<td style="text-align: left">keyspace_id is the associated keyspace_id for the entity.</td>
</tr>
</tbody></table>

<h4 id="response">Response</h4>

<p>ExecuteEntityIdsResponse is the returned value from ExecuteEntityIds.</p>

<h5 id="properties">Properties</h5>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>error</code> <br><a href="#vtrpc.rpcerror">vtrpc.RPCError</a></td>
<td style="text-align: left">RPCError is an application-level error structure returned by VtTablet (and passed along by VtGate if appropriate). We use this so the clients don&#39;t have to parse the error messages, but instead can depend on the value of the code.</td>
</tr>
<tr>
<td style="text-align: left"><code>session</code> <br><a href="#session">Session</a></td>
<td style="text-align: left">Session objects are session cookies and are invalidated on use. Query results will contain updated session values. Their content should be opaque to the user.</td>
</tr>
<tr>
<td style="text-align: left"><code>result</code> <br><a href="#query.queryresult">query.QueryResult</a></td>
<td style="text-align: left">QueryResult is returned by Execute and ExecuteStream.  As returned by Execute, len(fields) is always equal to len(row) (for each row in rows).  As returned by StreamExecute, the first QueryResult has the fields set, and subsequent QueryResult have rows set. And as Execute, len(QueryResult[0].fields) is always equal to len(row) (for each row in rows for each QueryResult in QueryResult[1:]).</td>
</tr>
</tbody></table>

<h3 id="executekeyranges">ExecuteKeyRanges</h3>

<p>ExecuteKeyRanges executes the query based on the specified key ranges.</p>

<h4 id="request">Request</h4>

<p>ExecuteKeyRangesRequest is the payload to ExecuteKeyRanges.</p>

<h5 id="parameters">Parameters</h5>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>caller_id</code> <br><a href="#vtrpc.callerid">vtrpc.CallerID</a></td>
<td style="text-align: left">CallerID is passed along RPCs to identify the originating client for a request. It is not meant to be secure, but only informational.  The client can put whatever info they want in these fields, and they will be trusted by the servers. The fields will just be used for logging purposes, and to easily find a client. VtGate propagates it to VtTablet, and VtTablet may use this information for monitoring purposes, to display on dashboards, or for blacklisting purposes.</td>
</tr>
<tr>
<td style="text-align: left"><code>session</code> <br><a href="#session">Session</a></td>
<td style="text-align: left">Session objects are session cookies and are invalidated on use. Query results will contain updated session values. Their content should be opaque to the user.</td>
</tr>
<tr>
<td style="text-align: left"><code>query</code> <br><a href="#query.boundquery">query.BoundQuery</a></td>
<td style="text-align: left">BoundQuery is a query with its bind variables</td>
</tr>
<tr>
<td style="text-align: left"><code>keyspace</code> <br>string</td>
<td style="text-align: left">keyspace to target the query to</td>
</tr>
<tr>
<td style="text-align: left"><code>key_ranges</code> <br>list &lt;<a href="#topodata.keyrange">topodata.KeyRange</a>&gt;</td>
<td style="text-align: left">KeyRange describes a range of sharding keys, when range-based sharding is used.</td>
</tr>
<tr>
<td style="text-align: left"><code>tablet_type</code> <br><a href="#topodata.tablettype">topodata.TabletType</a></td>
<td style="text-align: left">TabletType represents the type of a given tablet.</td>
</tr>
<tr>
<td style="text-align: left"><code>not_in_transaction</code> <br>bool</td>
<td style="text-align: left">not_in_transaction is deprecated and should not be used.</td>
</tr>
<tr>
<td style="text-align: left"><code>options</code> <br><a href="#query.executeoptions">query.ExecuteOptions</a></td>
<td style="text-align: left">ExecuteOptions is passed around for all Execute calls.</td>
</tr>
</tbody></table>

<h4 id="response">Response</h4>

<p>ExecuteKeyRangesResponse is the returned value from ExecuteKeyRanges.</p>

<h5 id="properties">Properties</h5>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>error</code> <br><a href="#vtrpc.rpcerror">vtrpc.RPCError</a></td>
<td style="text-align: left">RPCError is an application-level error structure returned by VtTablet (and passed along by VtGate if appropriate). We use this so the clients don&#39;t have to parse the error messages, but instead can depend on the value of the code.</td>
</tr>
<tr>
<td style="text-align: left"><code>session</code> <br><a href="#session">Session</a></td>
<td style="text-align: left">Session objects are session cookies and are invalidated on use. Query results will contain updated session values. Their content should be opaque to the user.</td>
</tr>
<tr>
<td style="text-align: left"><code>result</code> <br><a href="#query.queryresult">query.QueryResult</a></td>
<td style="text-align: left">QueryResult is returned by Execute and ExecuteStream.  As returned by Execute, len(fields) is always equal to len(row) (for each row in rows).  As returned by StreamExecute, the first QueryResult has the fields set, and subsequent QueryResult have rows set. And as Execute, len(QueryResult[0].fields) is always equal to len(row) (for each row in rows for each QueryResult in QueryResult[1:]).</td>
</tr>
</tbody></table>

<h3 id="executekeyspaceids">ExecuteKeyspaceIds</h3>

<p>ExecuteKeyspaceIds executes the query based on the specified keyspace ids.</p>

<h4 id="request">Request</h4>

<p>ExecuteKeyspaceIdsRequest is the payload to ExecuteKeyspaceIds.</p>

<h5 id="parameters">Parameters</h5>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>caller_id</code> <br><a href="#vtrpc.callerid">vtrpc.CallerID</a></td>
<td style="text-align: left">CallerID is passed along RPCs to identify the originating client for a request. It is not meant to be secure, but only informational.  The client can put whatever info they want in these fields, and they will be trusted by the servers. The fields will just be used for logging purposes, and to easily find a client. VtGate propagates it to VtTablet, and VtTablet may use this information for monitoring purposes, to display on dashboards, or for blacklisting purposes.</td>
</tr>
<tr>
<td style="text-align: left"><code>session</code> <br><a href="#session">Session</a></td>
<td style="text-align: left">Session objects are session cookies and are invalidated on use. Query results will contain updated session values. Their content should be opaque to the user.</td>
</tr>
<tr>
<td style="text-align: left"><code>query</code> <br><a href="#query.boundquery">query.BoundQuery</a></td>
<td style="text-align: left">BoundQuery is a query with its bind variables</td>
</tr>
<tr>
<td style="text-align: left"><code>keyspace</code> <br>string</td>
<td style="text-align: left">keyspace to target the query to.</td>
</tr>
<tr>
<td style="text-align: left"><code>keyspace_ids</code> <br>list &lt;bytes&gt;</td>
<td style="text-align: left">keyspace_ids contains the list of keyspace_ids affected by this query. Will be used to find the shards to send the query to.</td>
</tr>
<tr>
<td style="text-align: left"><code>tablet_type</code> <br><a href="#topodata.tablettype">topodata.TabletType</a></td>
<td style="text-align: left">TabletType represents the type of a given tablet.</td>
</tr>
<tr>
<td style="text-align: left"><code>not_in_transaction</code> <br>bool</td>
<td style="text-align: left">not_in_transaction is deprecated and should not be used.</td>
</tr>
<tr>
<td style="text-align: left"><code>options</code> <br><a href="#query.executeoptions">query.ExecuteOptions</a></td>
<td style="text-align: left">ExecuteOptions is passed around for all Execute calls.</td>
</tr>
</tbody></table>

<h4 id="response">Response</h4>

<p>ExecuteKeyspaceIdsResponse is the returned value from ExecuteKeyspaceIds.</p>

<h5 id="properties">Properties</h5>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>error</code> <br><a href="#vtrpc.rpcerror">vtrpc.RPCError</a></td>
<td style="text-align: left">RPCError is an application-level error structure returned by VtTablet (and passed along by VtGate if appropriate). We use this so the clients don&#39;t have to parse the error messages, but instead can depend on the value of the code.</td>
</tr>
<tr>
<td style="text-align: left"><code>session</code> <br><a href="#session">Session</a></td>
<td style="text-align: left">Session objects are session cookies and are invalidated on use. Query results will contain updated session values. Their content should be opaque to the user.</td>
</tr>
<tr>
<td style="text-align: left"><code>result</code> <br><a href="#query.queryresult">query.QueryResult</a></td>
<td style="text-align: left">QueryResult is returned by Execute and ExecuteStream.  As returned by Execute, len(fields) is always equal to len(row) (for each row in rows).  As returned by StreamExecute, the first QueryResult has the fields set, and subsequent QueryResult have rows set. And as Execute, len(QueryResult[0].fields) is always equal to len(row) (for each row in rows for each QueryResult in QueryResult[1:]).</td>
</tr>
</tbody></table>

<h3 id="streamexecutekeyranges">StreamExecuteKeyRanges</h3>

<p>StreamExecuteKeyRanges executes a streaming query based on key ranges. Use this method if the query returns a large number of rows.</p>

<h4 id="request">Request</h4>

<p>StreamExecuteKeyRangesRequest is the payload to StreamExecuteKeyRanges.</p>

<h5 id="parameters">Parameters</h5>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>caller_id</code> <br><a href="#vtrpc.callerid">vtrpc.CallerID</a></td>
<td style="text-align: left">CallerID is passed along RPCs to identify the originating client for a request. It is not meant to be secure, but only informational.  The client can put whatever info they want in these fields, and they will be trusted by the servers. The fields will just be used for logging purposes, and to easily find a client. VtGate propagates it to VtTablet, and VtTablet may use this information for monitoring purposes, to display on dashboards, or for blacklisting purposes.</td>
</tr>
<tr>
<td style="text-align: left"><code>query</code> <br><a href="#query.boundquery">query.BoundQuery</a></td>
<td style="text-align: left">BoundQuery is a query with its bind variables</td>
</tr>
<tr>
<td style="text-align: left"><code>keyspace</code> <br>string</td>
<td style="text-align: left">keyspace to target the query to.</td>
</tr>
<tr>
<td style="text-align: left"><code>key_ranges</code> <br>list &lt;<a href="#topodata.keyrange">topodata.KeyRange</a>&gt;</td>
<td style="text-align: left">KeyRange describes a range of sharding keys, when range-based sharding is used.</td>
</tr>
<tr>
<td style="text-align: left"><code>tablet_type</code> <br><a href="#topodata.tablettype">topodata.TabletType</a></td>
<td style="text-align: left">TabletType represents the type of a given tablet.</td>
</tr>
<tr>
<td style="text-align: left"><code>options</code> <br><a href="#query.executeoptions">query.ExecuteOptions</a></td>
<td style="text-align: left">ExecuteOptions is passed around for all Execute calls.</td>
</tr>
</tbody></table>

<h4 id="response">Response</h4>

<p>StreamExecuteKeyRangesResponse is the returned value from StreamExecuteKeyRanges.</p>

<h5 id="properties">Properties</h5>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>result</code> <br><a href="#query.queryresult">query.QueryResult</a></td>
<td style="text-align: left">QueryResult is returned by Execute and ExecuteStream.  As returned by Execute, len(fields) is always equal to len(row) (for each row in rows).  As returned by StreamExecute, the first QueryResult has the fields set, and subsequent QueryResult have rows set. And as Execute, len(QueryResult[0].fields) is always equal to len(row) (for each row in rows for each QueryResult in QueryResult[1:]).</td>
</tr>
</tbody></table>

<h3 id="streamexecutekeyspaceids">StreamExecuteKeyspaceIds</h3>

<p>StreamExecuteKeyspaceIds executes a streaming query based on keyspace ids. Use this method if the query returns a large number of rows.</p>

<h4 id="request">Request</h4>

<p>StreamExecuteKeyspaceIdsRequest is the payload to StreamExecuteKeyspaceIds.</p>

<h5 id="parameters">Parameters</h5>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>caller_id</code> <br><a href="#vtrpc.callerid">vtrpc.CallerID</a></td>
<td style="text-align: left">CallerID is passed along RPCs to identify the originating client for a request. It is not meant to be secure, but only informational.  The client can put whatever info they want in these fields, and they will be trusted by the servers. The fields will just be used for logging purposes, and to easily find a client. VtGate propagates it to VtTablet, and VtTablet may use this information for monitoring purposes, to display on dashboards, or for blacklisting purposes.</td>
</tr>
<tr>
<td style="text-align: left"><code>query</code> <br><a href="#query.boundquery">query.BoundQuery</a></td>
<td style="text-align: left">BoundQuery is a query with its bind variables</td>
</tr>
<tr>
<td style="text-align: left"><code>keyspace</code> <br>string</td>
<td style="text-align: left">keyspace to target the query to.</td>
</tr>
<tr>
<td style="text-align: left"><code>keyspace_ids</code> <br>list &lt;bytes&gt;</td>
<td style="text-align: left">keyspace_ids contains the list of keyspace_ids affected by this query. Will be used to find the shards to send the query to.</td>
</tr>
<tr>
<td style="text-align: left"><code>tablet_type</code> <br><a href="#topodata.tablettype">topodata.TabletType</a></td>
<td style="text-align: left">TabletType represents the type of a given tablet.</td>
</tr>
<tr>
<td style="text-align: left"><code>options</code> <br><a href="#query.executeoptions">query.ExecuteOptions</a></td>
<td style="text-align: left">ExecuteOptions is passed around for all Execute calls.</td>
</tr>
</tbody></table>

<h4 id="response">Response</h4>

<p>StreamExecuteKeyspaceIdsResponse is the returned value from StreamExecuteKeyspaceIds.</p>

<h5 id="properties">Properties</h5>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>result</code> <br><a href="#query.queryresult">query.QueryResult</a></td>
<td style="text-align: left">QueryResult is returned by Execute and ExecuteStream.  As returned by Execute, len(fields) is always equal to len(row) (for each row in rows).  As returned by StreamExecute, the first QueryResult has the fields set, and subsequent QueryResult have rows set. And as Execute, len(QueryResult[0].fields) is always equal to len(row) (for each row in rows for each QueryResult in QueryResult[1:]).</td>
</tr>
</tbody></table>

<h2 id="transactions">Transactions</h2>

<h3 id="begin">Begin</h3>

<p>Begin a transaction.</p>

<h4 id="request">Request</h4>

<p>BeginRequest is the payload to Begin.</p>

<h5 id="parameters">Parameters</h5>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>caller_id</code> <br><a href="#vtrpc.callerid">vtrpc.CallerID</a></td>
<td style="text-align: left">CallerID is passed along RPCs to identify the originating client for a request. It is not meant to be secure, but only informational.  The client can put whatever info they want in these fields, and they will be trusted by the servers. The fields will just be used for logging purposes, and to easily find a client. VtGate propagates it to VtTablet, and VtTablet may use this information for monitoring purposes, to display on dashboards, or for blacklisting purposes.</td>
</tr>
<tr>
<td style="text-align: left"><code>single_db</code> <br>bool</td>
<td style="text-align: left">single_db specifies if the transaction should be restricted to a single database.</td>
</tr>
</tbody></table>

<h4 id="response">Response</h4>

<p>BeginResponse is the returned value from Begin.</p>

<h5 id="properties">Properties</h5>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>session</code> <br><a href="#session">Session</a></td>
<td style="text-align: left">Session objects are session cookies and are invalidated on use. Query results will contain updated session values. Their content should be opaque to the user.</td>
</tr>
</tbody></table>

<h3 id="commit">Commit</h3>

<p>Commit a transaction.</p>

<h4 id="request">Request</h4>

<p>CommitRequest is the payload to Commit.</p>

<h5 id="parameters">Parameters</h5>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>caller_id</code> <br><a href="#vtrpc.callerid">vtrpc.CallerID</a></td>
<td style="text-align: left">CallerID is passed along RPCs to identify the originating client for a request. It is not meant to be secure, but only informational.  The client can put whatever info they want in these fields, and they will be trusted by the servers. The fields will just be used for logging purposes, and to easily find a client. VtGate propagates it to VtTablet, and VtTablet may use this information for monitoring purposes, to display on dashboards, or for blacklisting purposes.</td>
</tr>
<tr>
<td style="text-align: left"><code>session</code> <br><a href="#session">Session</a></td>
<td style="text-align: left">Session objects are session cookies and are invalidated on use. Query results will contain updated session values. Their content should be opaque to the user.</td>
</tr>
<tr>
<td style="text-align: left"><code>atomic</code> <br>bool</td>
<td style="text-align: left">atomic specifies if the commit should go through the 2PC workflow to ensure atomicity.</td>
</tr>
</tbody></table>

<h4 id="response">Response</h4>

<p>CommitResponse is the returned value from Commit.</p>

<h5 id="properties">Properties</h5>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
</tbody></table>

<h3 id="resolvetransaction">ResolveTransaction</h3>

<p>ResolveTransaction resolves a transaction.</p>

<h4 id="request">Request</h4>

<p>ResolveTransactionRequest is the payload to ResolveTransaction.</p>

<h5 id="parameters">Parameters</h5>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>caller_id</code> <br><a href="#vtrpc.callerid">vtrpc.CallerID</a></td>
<td style="text-align: left">CallerID is passed along RPCs to identify the originating client for a request. It is not meant to be secure, but only informational.  The client can put whatever info they want in these fields, and they will be trusted by the servers. The fields will just be used for logging purposes, and to easily find a client. VtGate propagates it to VtTablet, and VtTablet may use this information for monitoring purposes, to display on dashboards, or for blacklisting purposes.</td>
</tr>
<tr>
<td style="text-align: left"><code>dtid</code> <br>string</td>
<td style="text-align: left">dtid is the dtid of the transaction to be resolved.</td>
</tr>
</tbody></table>

<h4 id="response">Response</h4>

<p>ResolveTransactionResponse is the returned value from Rollback.</p>

<h5 id="properties">Properties</h5>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
</tbody></table>

<h3 id="rollback">Rollback</h3>

<p>Rollback a transaction.</p>

<h4 id="request">Request</h4>

<p>RollbackRequest is the payload to Rollback.</p>

<h5 id="parameters">Parameters</h5>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>caller_id</code> <br><a href="#vtrpc.callerid">vtrpc.CallerID</a></td>
<td style="text-align: left">CallerID is passed along RPCs to identify the originating client for a request. It is not meant to be secure, but only informational.  The client can put whatever info they want in these fields, and they will be trusted by the servers. The fields will just be used for logging purposes, and to easily find a client. VtGate propagates it to VtTablet, and VtTablet may use this information for monitoring purposes, to display on dashboards, or for blacklisting purposes.</td>
</tr>
<tr>
<td style="text-align: left"><code>session</code> <br><a href="#session">Session</a></td>
<td style="text-align: left">Session objects are session cookies and are invalidated on use. Query results will contain updated session values. Their content should be opaque to the user.</td>
</tr>
</tbody></table>

<h4 id="response">Response</h4>

<p>RollbackResponse is the returned value from Rollback.</p>

<h5 id="properties">Properties</h5>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
</tbody></table>

<h2 id="custom-sharding">Custom Sharding</h2>

<h3 id="executebatchshards">ExecuteBatchShards</h3>

<p>ExecuteBatchShards executes the list of queries on the specified shards.</p>

<h4 id="request">Request</h4>

<p>ExecuteBatchShardsRequest is the payload to ExecuteBatchShards</p>

<h5 id="parameters">Parameters</h5>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>caller_id</code> <br><a href="#vtrpc.callerid">vtrpc.CallerID</a></td>
<td style="text-align: left">CallerID is passed along RPCs to identify the originating client for a request. It is not meant to be secure, but only informational.  The client can put whatever info they want in these fields, and they will be trusted by the servers. The fields will just be used for logging purposes, and to easily find a client. VtGate propagates it to VtTablet, and VtTablet may use this information for monitoring purposes, to display on dashboards, or for blacklisting purposes.</td>
</tr>
<tr>
<td style="text-align: left"><code>session</code> <br><a href="#session">Session</a></td>
<td style="text-align: left">Session objects are session cookies and are invalidated on use. Query results will contain updated session values. Their content should be opaque to the user.</td>
</tr>
<tr>
<td style="text-align: left"><code>queries</code> <br>list &lt;<a href="#boundshardquery">BoundShardQuery</a>&gt;</td>
<td style="text-align: left">BoundShardQuery represents a single query request for the specified list of shards. This is used in a list for ExecuteBatchShardsRequest.</td>
</tr>
<tr>
<td style="text-align: left"><code>tablet_type</code> <br><a href="#topodata.tablettype">topodata.TabletType</a></td>
<td style="text-align: left">TabletType represents the type of a given tablet.</td>
</tr>
<tr>
<td style="text-align: left"><code>as_transaction</code> <br>bool</td>
<td style="text-align: left">as_transaction will execute the queries in this batch in a single transaction per shard, created for this purpose. (this can be seen as adding a &#39;begin&#39; before and &#39;commit&#39; after the queries). Only makes sense if tablet_type is master. If set, the Session is ignored.</td>
</tr>
<tr>
<td style="text-align: left"><code>options</code> <br><a href="#query.executeoptions">query.ExecuteOptions</a></td>
<td style="text-align: left">ExecuteOptions is passed around for all Execute calls.</td>
</tr>
</tbody></table>

<h4 id="response">Response</h4>

<p>ExecuteBatchShardsResponse is the returned value from ExecuteBatchShards.</p>

<h5 id="properties">Properties</h5>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>error</code> <br><a href="#vtrpc.rpcerror">vtrpc.RPCError</a></td>
<td style="text-align: left">RPCError is an application-level error structure returned by VtTablet (and passed along by VtGate if appropriate). We use this so the clients don&#39;t have to parse the error messages, but instead can depend on the value of the code.</td>
</tr>
<tr>
<td style="text-align: left"><code>session</code> <br><a href="#session">Session</a></td>
<td style="text-align: left">Session objects are session cookies and are invalidated on use. Query results will contain updated session values. Their content should be opaque to the user.</td>
</tr>
<tr>
<td style="text-align: left"><code>results</code> <br>list &lt;<a href="#query.queryresult">query.QueryResult</a>&gt;</td>
<td style="text-align: left">QueryResult is returned by Execute and ExecuteStream.  As returned by Execute, len(fields) is always equal to len(row) (for each row in rows).  As returned by StreamExecute, the first QueryResult has the fields set, and subsequent QueryResult have rows set. And as Execute, len(QueryResult[0].fields) is always equal to len(row) (for each row in rows for each QueryResult in QueryResult[1:]).</td>
</tr>
</tbody></table>

<h3 id="executeshards">ExecuteShards</h3>

<p>ExecuteShards executes the query on the specified shards.</p>

<h4 id="request">Request</h4>

<p>ExecuteShardsRequest is the payload to ExecuteShards.</p>

<h5 id="parameters">Parameters</h5>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>caller_id</code> <br><a href="#vtrpc.callerid">vtrpc.CallerID</a></td>
<td style="text-align: left">CallerID is passed along RPCs to identify the originating client for a request. It is not meant to be secure, but only informational.  The client can put whatever info they want in these fields, and they will be trusted by the servers. The fields will just be used for logging purposes, and to easily find a client. VtGate propagates it to VtTablet, and VtTablet may use this information for monitoring purposes, to display on dashboards, or for blacklisting purposes.</td>
</tr>
<tr>
<td style="text-align: left"><code>session</code> <br><a href="#session">Session</a></td>
<td style="text-align: left">Session objects are session cookies and are invalidated on use. Query results will contain updated session values. Their content should be opaque to the user.</td>
</tr>
<tr>
<td style="text-align: left"><code>query</code> <br><a href="#query.boundquery">query.BoundQuery</a></td>
<td style="text-align: left">BoundQuery is a query with its bind variables</td>
</tr>
<tr>
<td style="text-align: left"><code>keyspace</code> <br>string</td>
<td style="text-align: left">keyspace to target the query to.</td>
</tr>
<tr>
<td style="text-align: left"><code>shards</code> <br>list &lt;string&gt;</td>
<td style="text-align: left">shards to target the query to. A DML can only target one shard.</td>
</tr>
<tr>
<td style="text-align: left"><code>tablet_type</code> <br><a href="#topodata.tablettype">topodata.TabletType</a></td>
<td style="text-align: left">TabletType represents the type of a given tablet.</td>
</tr>
<tr>
<td style="text-align: left"><code>not_in_transaction</code> <br>bool</td>
<td style="text-align: left">not_in_transaction is deprecated and should not be used.</td>
</tr>
<tr>
<td style="text-align: left"><code>options</code> <br><a href="#query.executeoptions">query.ExecuteOptions</a></td>
<td style="text-align: left">ExecuteOptions is passed around for all Execute calls.</td>
</tr>
</tbody></table>

<h4 id="response">Response</h4>

<p>ExecuteShardsResponse is the returned value from ExecuteShards.</p>

<h5 id="properties">Properties</h5>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>error</code> <br><a href="#vtrpc.rpcerror">vtrpc.RPCError</a></td>
<td style="text-align: left">RPCError is an application-level error structure returned by VtTablet (and passed along by VtGate if appropriate). We use this so the clients don&#39;t have to parse the error messages, but instead can depend on the value of the code.</td>
</tr>
<tr>
<td style="text-align: left"><code>session</code> <br><a href="#session">Session</a></td>
<td style="text-align: left">Session objects are session cookies and are invalidated on use. Query results will contain updated session values. Their content should be opaque to the user.</td>
</tr>
<tr>
<td style="text-align: left"><code>result</code> <br><a href="#query.queryresult">query.QueryResult</a></td>
<td style="text-align: left">QueryResult is returned by Execute and ExecuteStream.  As returned by Execute, len(fields) is always equal to len(row) (for each row in rows).  As returned by StreamExecute, the first QueryResult has the fields set, and subsequent QueryResult have rows set. And as Execute, len(QueryResult[0].fields) is always equal to len(row) (for each row in rows for each QueryResult in QueryResult[1:]).</td>
</tr>
</tbody></table>

<h3 id="streamexecuteshards">StreamExecuteShards</h3>

<p>StreamExecuteShards executes a streaming query based on shards. Use this method if the query returns a large number of rows.</p>

<h4 id="request">Request</h4>

<p>StreamExecuteShardsRequest is the payload to StreamExecuteShards.</p>

<h5 id="parameters">Parameters</h5>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>caller_id</code> <br><a href="#vtrpc.callerid">vtrpc.CallerID</a></td>
<td style="text-align: left">CallerID is passed along RPCs to identify the originating client for a request. It is not meant to be secure, but only informational.  The client can put whatever info they want in these fields, and they will be trusted by the servers. The fields will just be used for logging purposes, and to easily find a client. VtGate propagates it to VtTablet, and VtTablet may use this information for monitoring purposes, to display on dashboards, or for blacklisting purposes.</td>
</tr>
<tr>
<td style="text-align: left"><code>query</code> <br><a href="#query.boundquery">query.BoundQuery</a></td>
<td style="text-align: left">BoundQuery is a query with its bind variables</td>
</tr>
<tr>
<td style="text-align: left"><code>keyspace</code> <br>string</td>
<td style="text-align: left">keyspace to target the query to.</td>
</tr>
<tr>
<td style="text-align: left"><code>shards</code> <br>list &lt;string&gt;</td>
<td style="text-align: left">shards to target the query to.</td>
</tr>
<tr>
<td style="text-align: left"><code>tablet_type</code> <br><a href="#topodata.tablettype">topodata.TabletType</a></td>
<td style="text-align: left">TabletType represents the type of a given tablet.</td>
</tr>
<tr>
<td style="text-align: left"><code>options</code> <br><a href="#query.executeoptions">query.ExecuteOptions</a></td>
<td style="text-align: left">ExecuteOptions is passed around for all Execute calls.</td>
</tr>
</tbody></table>

<h4 id="response">Response</h4>

<p>StreamExecuteShardsResponse is the returned value from StreamExecuteShards.</p>

<h5 id="properties">Properties</h5>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>result</code> <br><a href="#query.queryresult">query.QueryResult</a></td>
<td style="text-align: left">QueryResult is returned by Execute and ExecuteStream.  As returned by Execute, len(fields) is always equal to len(row) (for each row in rows).  As returned by StreamExecute, the first QueryResult has the fields set, and subsequent QueryResult have rows set. And as Execute, len(QueryResult[0].fields) is always equal to len(row) (for each row in rows for each QueryResult in QueryResult[1:]).</td>
</tr>
</tbody></table>

<h2 id="map-reduce">Map Reduce</h2>

<h3 id="splitquery">SplitQuery</h3>

<p>Split a query into non-overlapping sub queries</p>

<h4 id="request">Request</h4>

<p>SplitQueryRequest is the payload to SplitQuery.  SplitQuery takes a &quot;SELECT&quot; query and generates a list of queries called &quot;query-parts&quot;. Each query-part consists of the original query with an added WHERE clause that restricts the query-part to operate only on rows whose values in the the columns listed in the &quot;split_column&quot; field of the request (see below) are in a particular range.  It is guaranteed that the set of rows obtained from executing each query-part on a database snapshot and merging (without deduping) the results is equal to the set of rows obtained from executing the original query on the same snapshot with the rows containing NULL values in any of the split_column&#39;s excluded.  This is typically called by the MapReduce master when reading from Vitess. There it&#39;s desirable that the sets of rows returned by the query-parts have roughly the same size.</p>

<h5 id="parameters">Parameters</h5>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>caller_id</code> <br><a href="#vtrpc.callerid">vtrpc.CallerID</a></td>
<td style="text-align: left">CallerID is passed along RPCs to identify the originating client for a request. It is not meant to be secure, but only informational.  The client can put whatever info they want in these fields, and they will be trusted by the servers. The fields will just be used for logging purposes, and to easily find a client. VtGate propagates it to VtTablet, and VtTablet may use this information for monitoring purposes, to display on dashboards, or for blacklisting purposes.</td>
</tr>
<tr>
<td style="text-align: left"><code>keyspace</code> <br>string</td>
<td style="text-align: left">keyspace to target the query to.</td>
</tr>
<tr>
<td style="text-align: left"><code>query</code> <br><a href="#query.boundquery">query.BoundQuery</a></td>
<td style="text-align: left">BoundQuery is a query with its bind variables</td>
</tr>
<tr>
<td style="text-align: left"><code>split_column</code> <br>list &lt;string&gt;</td>
<td style="text-align: left">Each generated query-part will be restricted to rows whose values in the columns listed in this field are in a particular range. The list of columns named here must be a prefix of the list of columns defining some index or primary key of the table referenced in &#39;query&#39;. For many tables using the primary key columns (in order) is sufficient and this is the default if this field is omitted. See the comment on the &#39;algorithm&#39; field for more restrictions and information.</td>
</tr>
<tr>
<td style="text-align: left"><code>split_count</code> <br>int64</td>
<td style="text-align: left">You can specify either an estimate of the number of query-parts to generate or an estimate of the number of rows each query-part should return. Thus, exactly one of split_count or num_rows_per_query_part should be nonzero. The non-given parameter is calculated from the given parameter using the formula: split_count * num_rows_per_query_pary = table_size, where table_size is an approximation of the number of rows in the table. Note that if &quot;split_count&quot; is given it is regarded as an estimate. The number of query-parts returned may differ slightly (in particular, if it&#39;s not a whole multiple of the number of vitess shards).</td>
</tr>
<tr>
<td style="text-align: left"><code>num_rows_per_query_part</code> <br>int64</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left"><code>algorithm</code> <br>query.SplitQueryRequest.Algorithm</td>
<td style="text-align: left">The algorithm to use to split the query. The split algorithm is performed on each database shard in parallel. The lists of query-parts generated by the shards are merged and returned to the caller. Two algorithms are supported: EQUAL_SPLITS If this algorithm is selected then only the first &#39;split_column&#39; given is used (or the first primary key column if the &#39;split_column&#39; field is empty). In the rest of this algorithm&#39;s description, we refer to this column as &quot;the split column&quot;. The split column must have numeric type (integral or floating point). The algorithm works by taking the interval [min, max], where min and max are the minimum and maximum values of the split column in the table-shard, respectively, and partitioning it into &#39;split_count&#39; sub-intervals of equal size. The added WHERE clause of each query-part restricts that part to rows whose value in the split column belongs to a particular sub-interval. This is fast, but requires that the distribution of values of the split column be uniform in [min, max] for the number of rows returned by each query part to be roughly the same. FULL_SCAN If this algorithm is used then the split_column must be the primary key columns (in order). This algorithm performs a full-scan of the table-shard referenced in &#39;query&#39; to get &quot;boundary&quot; rows that are num_rows_per_query_part apart when the table is ordered by the columns listed in &#39;split_column&#39;. It then restricts each query-part to the rows located between two successive boundary rows. This algorithm supports multiple split_column&#39;s of any type, but is slower than EQUAL_SPLITS.</td>
</tr>
<tr>
<td style="text-align: left"><code>use_split_query_v2</code> <br>bool</td>
<td style="text-align: left">Remove this field after this new server code is released to prod. We must keep it for now, so that clients can still send it to the old server code currently in production.</td>
</tr>
</tbody></table>

<h4 id="response">Response</h4>

<p>SplitQueryResponse is the returned value from SplitQuery.</p>

<h5 id="properties">Properties</h5>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>splits</code> <br>list &lt;<a href="#splitqueryresponse.part">Part</a>&gt;</td>
<td style="text-align: left">splits contains the queries to run to fetch the entire data set.</td>
</tr>
</tbody></table>

<h4 id="messages">Messages</h4>

<h5 id="splitqueryresponse-keyrangepart">SplitQueryResponse.KeyRangePart</h5>

<p><em>Properties</em></p>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>keyspace</code> <br>string</td>
<td style="text-align: left">keyspace to target the query to.</td>
</tr>
<tr>
<td style="text-align: left"><code>key_ranges</code> <br>list &lt;<a href="#topodata.keyrange">topodata.KeyRange</a>&gt;</td>
<td style="text-align: left">KeyRange describes a range of sharding keys, when range-based sharding is used.</td>
</tr>
</tbody></table>

<h5 id="splitqueryresponse-part">SplitQueryResponse.Part</h5>

<p><em>Properties</em></p>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>query</code> <br><a href="#query.boundquery">query.BoundQuery</a></td>
<td style="text-align: left">BoundQuery is a query with its bind variables</td>
</tr>
<tr>
<td style="text-align: left"><code>key_range_part</code> <br><a href="#splitqueryresponse.keyrangepart">KeyRangePart</a></td>
<td style="text-align: left">key_range_part is set if the query should be executed by ExecuteKeyRanges.</td>
</tr>
<tr>
<td style="text-align: left"><code>shard_part</code> <br><a href="#splitqueryresponse.shardpart">ShardPart</a></td>
<td style="text-align: left">shard_part is set if the query should be executed by ExecuteShards.</td>
</tr>
<tr>
<td style="text-align: left"><code>size</code> <br>int64</td>
<td style="text-align: left">size is the approximate number of rows this query will return.</td>
</tr>
</tbody></table>

<h5 id="splitqueryresponse-shardpart">SplitQueryResponse.ShardPart</h5>

<p><em>Properties</em></p>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>keyspace</code> <br>string</td>
<td style="text-align: left">keyspace to target the query to.</td>
</tr>
<tr>
<td style="text-align: left"><code>shards</code> <br>list &lt;string&gt;</td>
<td style="text-align: left">shards to target the query to.</td>
</tr>
</tbody></table>

<h2 id="topology">Topology</h2>

<h3 id="getsrvkeyspace">GetSrvKeyspace</h3>

<p>GetSrvKeyspace returns a SrvKeyspace object (as seen by this vtgate). This method is provided as a convenient way for clients to take a look at the sharding configuration for a Keyspace. Looking at the sharding information should not be used for routing queries (as the information may change, use the Execute calls for that). It is convenient for monitoring applications for instance, or if using custom sharding.</p>

<h4 id="request">Request</h4>

<p>GetSrvKeyspaceRequest is the payload to GetSrvKeyspace.</p>

<h5 id="parameters">Parameters</h5>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>keyspace</code> <br>string</td>
<td style="text-align: left">keyspace name to fetch.</td>
</tr>
</tbody></table>

<h4 id="response">Response</h4>

<p>GetSrvKeyspaceResponse is the returned value from GetSrvKeyspace.</p>

<h5 id="properties">Properties</h5>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>srv_keyspace</code> <br><a href="#topodata.srvkeyspace">topodata.SrvKeyspace</a></td>
<td style="text-align: left">SrvKeyspace is a rollup node for the keyspace itself.</td>
</tr>
</tbody></table>

<h2 id="v3-api-alpha">v3 API (alpha)</h2>

<h3 id="execute">Execute</h3>

<p>Execute tries to route the query to the right shard. It depends on the query and bind variables to provide enough information in conjonction with the vindexes to route the query.</p>

<h4 id="request">Request</h4>

<p>ExecuteRequest is the payload to Execute.</p>

<h5 id="parameters">Parameters</h5>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>caller_id</code> <br><a href="#vtrpc.callerid">vtrpc.CallerID</a></td>
<td style="text-align: left">CallerID is passed along RPCs to identify the originating client for a request. It is not meant to be secure, but only informational.  The client can put whatever info they want in these fields, and they will be trusted by the servers. The fields will just be used for logging purposes, and to easily find a client. VtGate propagates it to VtTablet, and VtTablet may use this information for monitoring purposes, to display on dashboards, or for blacklisting purposes.</td>
</tr>
<tr>
<td style="text-align: left"><code>session</code> <br><a href="#session">Session</a></td>
<td style="text-align: left">Session objects are session cookies and are invalidated on use. Query results will contain updated session values. Their content should be opaque to the user.</td>
</tr>
<tr>
<td style="text-align: left"><code>query</code> <br><a href="#query.boundquery">query.BoundQuery</a></td>
<td style="text-align: left">BoundQuery is a query with its bind variables</td>
</tr>
<tr>
<td style="text-align: left"><code>tablet_type</code> <br><a href="#topodata.tablettype">topodata.TabletType</a></td>
<td style="text-align: left">TabletType represents the type of a given tablet.</td>
</tr>
<tr>
<td style="text-align: left"><code>not_in_transaction</code> <br>bool</td>
<td style="text-align: left">not_in_transaction is deprecated and should not be used.</td>
</tr>
<tr>
<td style="text-align: left"><code>keyspace</code> <br>string</td>
<td style="text-align: left">keyspace to target the query to.</td>
</tr>
<tr>
<td style="text-align: left"><code>options</code> <br><a href="#query.executeoptions">query.ExecuteOptions</a></td>
<td style="text-align: left">ExecuteOptions is passed around for all Execute calls.</td>
</tr>
</tbody></table>

<h4 id="response">Response</h4>

<p>ExecuteResponse is the returned value from Execute.</p>

<h5 id="properties">Properties</h5>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>error</code> <br><a href="#vtrpc.rpcerror">vtrpc.RPCError</a></td>
<td style="text-align: left">RPCError is an application-level error structure returned by VtTablet (and passed along by VtGate if appropriate). We use this so the clients don&#39;t have to parse the error messages, but instead can depend on the value of the code.</td>
</tr>
<tr>
<td style="text-align: left"><code>session</code> <br><a href="#session">Session</a></td>
<td style="text-align: left">Session objects are session cookies and are invalidated on use. Query results will contain updated session values. Their content should be opaque to the user.</td>
</tr>
<tr>
<td style="text-align: left"><code>result</code> <br><a href="#query.queryresult">query.QueryResult</a></td>
<td style="text-align: left">QueryResult is returned by Execute and ExecuteStream.  As returned by Execute, len(fields) is always equal to len(row) (for each row in rows).  As returned by StreamExecute, the first QueryResult has the fields set, and subsequent QueryResult have rows set. And as Execute, len(QueryResult[0].fields) is always equal to len(row) (for each row in rows for each QueryResult in QueryResult[1:]).</td>
</tr>
</tbody></table>

<h3 id="streamexecute">StreamExecute</h3>

<p>StreamExecute executes a streaming query based on shards. It depends on the query and bind variables to provide enough information in conjonction with the vindexes to route the query. Use this method if the query returns a large number of rows.</p>

<h4 id="request">Request</h4>

<p>StreamExecuteRequest is the payload to StreamExecute.</p>

<h5 id="parameters">Parameters</h5>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>caller_id</code> <br><a href="#vtrpc.callerid">vtrpc.CallerID</a></td>
<td style="text-align: left">CallerID is passed along RPCs to identify the originating client for a request. It is not meant to be secure, but only informational.  The client can put whatever info they want in these fields, and they will be trusted by the servers. The fields will just be used for logging purposes, and to easily find a client. VtGate propagates it to VtTablet, and VtTablet may use this information for monitoring purposes, to display on dashboards, or for blacklisting purposes.</td>
</tr>
<tr>
<td style="text-align: left"><code>query</code> <br><a href="#query.boundquery">query.BoundQuery</a></td>
<td style="text-align: left">BoundQuery is a query with its bind variables</td>
</tr>
<tr>
<td style="text-align: left"><code>tablet_type</code> <br><a href="#topodata.tablettype">topodata.TabletType</a></td>
<td style="text-align: left">TabletType represents the type of a given tablet.</td>
</tr>
<tr>
<td style="text-align: left"><code>keyspace</code> <br>string</td>
<td style="text-align: left">keyspace to target the query to.</td>
</tr>
<tr>
<td style="text-align: left"><code>options</code> <br><a href="#query.executeoptions">query.ExecuteOptions</a></td>
<td style="text-align: left">ExecuteOptions is passed around for all Execute calls.</td>
</tr>
</tbody></table>

<h4 id="response">Response</h4>

<p>StreamExecuteResponse is the returned value from StreamExecute.</p>

<h5 id="properties">Properties</h5>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>result</code> <br><a href="#query.queryresult">query.QueryResult</a></td>
<td style="text-align: left">QueryResult is returned by Execute and ExecuteStream.  As returned by Execute, len(fields) is always equal to len(row) (for each row in rows).  As returned by StreamExecute, the first QueryResult has the fields set, and subsequent QueryResult have rows set. And as Execute, len(QueryResult[0].fields) is always equal to len(row) (for each row in rows for each QueryResult in QueryResult[1:]).</td>
</tr>
</tbody></table>

<h2 id="enums">Enums</h2>

<h3 id="query-type">query.Type</h3>

<p>Type defines the various supported data types in bind vars and query results.</p>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Value</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>NULL_TYPE</code></td>
<td style="text-align: left"><code>0</code></td>
<td style="text-align: left">NULL_TYPE specifies a NULL type.</td>
</tr>
<tr>
<td style="text-align: left"><code>INT8</code></td>
<td style="text-align: left"><code>257</code></td>
<td style="text-align: left">INT8 specifies a TINYINT type. Properties: 1, IsNumber.</td>
</tr>
<tr>
<td style="text-align: left"><code>UINT8</code></td>
<td style="text-align: left"><code>770</code></td>
<td style="text-align: left">UINT8 specifies a TINYINT UNSIGNED type. Properties: 2, IsNumber, IsUnsigned.</td>
</tr>
<tr>
<td style="text-align: left"><code>INT16</code></td>
<td style="text-align: left"><code>259</code></td>
<td style="text-align: left">INT16 specifies a SMALLINT type. Properties: 3, IsNumber.</td>
</tr>
<tr>
<td style="text-align: left"><code>UINT16</code></td>
<td style="text-align: left"><code>772</code></td>
<td style="text-align: left">UINT16 specifies a SMALLINT UNSIGNED type. Properties: 4, IsNumber, IsUnsigned.</td>
</tr>
<tr>
<td style="text-align: left"><code>INT24</code></td>
<td style="text-align: left"><code>261</code></td>
<td style="text-align: left">INT24 specifies a MEDIUMINT type. Properties: 5, IsNumber.</td>
</tr>
<tr>
<td style="text-align: left"><code>UINT24</code></td>
<td style="text-align: left"><code>774</code></td>
<td style="text-align: left">UINT24 specifies a MEDIUMINT UNSIGNED type. Properties: 6, IsNumber, IsUnsigned.</td>
</tr>
<tr>
<td style="text-align: left"><code>INT32</code></td>
<td style="text-align: left"><code>263</code></td>
<td style="text-align: left">INT32 specifies a INTEGER type. Properties: 7, IsNumber.</td>
</tr>
<tr>
<td style="text-align: left"><code>UINT32</code></td>
<td style="text-align: left"><code>776</code></td>
<td style="text-align: left">UINT32 specifies a INTEGER UNSIGNED type. Properties: 8, IsNumber, IsUnsigned.</td>
</tr>
<tr>
<td style="text-align: left"><code>INT64</code></td>
<td style="text-align: left"><code>265</code></td>
<td style="text-align: left">INT64 specifies a BIGINT type. Properties: 9, IsNumber.</td>
</tr>
<tr>
<td style="text-align: left"><code>UINT64</code></td>
<td style="text-align: left"><code>778</code></td>
<td style="text-align: left">UINT64 specifies a BIGINT UNSIGNED type. Properties: 10, IsNumber, IsUnsigned.</td>
</tr>
<tr>
<td style="text-align: left"><code>FLOAT32</code></td>
<td style="text-align: left"><code>1035</code></td>
<td style="text-align: left">FLOAT32 specifies a FLOAT type. Properties: 11, IsFloat.</td>
</tr>
<tr>
<td style="text-align: left"><code>FLOAT64</code></td>
<td style="text-align: left"><code>1036</code></td>
<td style="text-align: left">FLOAT64 specifies a DOUBLE or REAL type. Properties: 12, IsFloat.</td>
</tr>
<tr>
<td style="text-align: left"><code>TIMESTAMP</code></td>
<td style="text-align: left"><code>2061</code></td>
<td style="text-align: left">TIMESTAMP specifies a TIMESTAMP type. Properties: 13, IsQuoted.</td>
</tr>
<tr>
<td style="text-align: left"><code>DATE</code></td>
<td style="text-align: left"><code>2062</code></td>
<td style="text-align: left">DATE specifies a DATE type. Properties: 14, IsQuoted.</td>
</tr>
<tr>
<td style="text-align: left"><code>TIME</code></td>
<td style="text-align: left"><code>2063</code></td>
<td style="text-align: left">TIME specifies a TIME type. Properties: 15, IsQuoted.</td>
</tr>
<tr>
<td style="text-align: left"><code>DATETIME</code></td>
<td style="text-align: left"><code>2064</code></td>
<td style="text-align: left">DATETIME specifies a DATETIME type. Properties: 16, IsQuoted.</td>
</tr>
<tr>
<td style="text-align: left"><code>YEAR</code></td>
<td style="text-align: left"><code>785</code></td>
<td style="text-align: left">YEAR specifies a YEAR type. Properties: 17, IsNumber, IsUnsigned.</td>
</tr>
<tr>
<td style="text-align: left"><code>DECIMAL</code></td>
<td style="text-align: left"><code>18</code></td>
<td style="text-align: left">DECIMAL specifies a DECIMAL or NUMERIC type. Properties: 18, None.</td>
</tr>
<tr>
<td style="text-align: left"><code>TEXT</code></td>
<td style="text-align: left"><code>6163</code></td>
<td style="text-align: left">TEXT specifies a TEXT type. Properties: 19, IsQuoted, IsText.</td>
</tr>
<tr>
<td style="text-align: left"><code>BLOB</code></td>
<td style="text-align: left"><code>10260</code></td>
<td style="text-align: left">BLOB specifies a BLOB type. Properties: 20, IsQuoted, IsBinary.</td>
</tr>
<tr>
<td style="text-align: left"><code>VARCHAR</code></td>
<td style="text-align: left"><code>6165</code></td>
<td style="text-align: left">VARCHAR specifies a VARCHAR type. Properties: 21, IsQuoted, IsText.</td>
</tr>
<tr>
<td style="text-align: left"><code>VARBINARY</code></td>
<td style="text-align: left"><code>10262</code></td>
<td style="text-align: left">VARBINARY specifies a VARBINARY type. Properties: 22, IsQuoted, IsBinary.</td>
</tr>
<tr>
<td style="text-align: left"><code>CHAR</code></td>
<td style="text-align: left"><code>6167</code></td>
<td style="text-align: left">CHAR specifies a CHAR type. Properties: 23, IsQuoted, IsText.</td>
</tr>
<tr>
<td style="text-align: left"><code>BINARY</code></td>
<td style="text-align: left"><code>10264</code></td>
<td style="text-align: left">BINARY specifies a BINARY type. Properties: 24, IsQuoted, IsBinary.</td>
</tr>
<tr>
<td style="text-align: left"><code>BIT</code></td>
<td style="text-align: left"><code>2073</code></td>
<td style="text-align: left">BIT specifies a BIT type. Properties: 25, IsQuoted.</td>
</tr>
<tr>
<td style="text-align: left"><code>ENUM</code></td>
<td style="text-align: left"><code>2074</code></td>
<td style="text-align: left">ENUM specifies an ENUM type. Properties: 26, IsQuoted.</td>
</tr>
<tr>
<td style="text-align: left"><code>SET</code></td>
<td style="text-align: left"><code>2075</code></td>
<td style="text-align: left">SET specifies a SET type. Properties: 27, IsQuoted.</td>
</tr>
<tr>
<td style="text-align: left"><code>TUPLE</code></td>
<td style="text-align: left"><code>28</code></td>
<td style="text-align: left">TUPLE specifies a a tuple. This cannot be returned in a QueryResult, but it can be sent as a bind var. Properties: 28, None.</td>
</tr>
<tr>
<td style="text-align: left"><code>GEOMETRY</code></td>
<td style="text-align: left"><code>2077</code></td>
<td style="text-align: left">GEOMETRY specifies a GEOMETRY type. Properties: 29, IsQuoted.</td>
</tr>
<tr>
<td style="text-align: left"><code>JSON</code></td>
<td style="text-align: left"><code>2078</code></td>
<td style="text-align: left">JSON specified a JSON type. Properties: 30, IsQuoted.</td>
</tr>
</tbody></table>

<h3 id="topodata-keyspaceidtype">topodata.KeyspaceIdType</h3>

<p>KeyspaceIdType describes the type of the sharding key for a range-based sharded keyspace.</p>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Value</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>UNSET</code></td>
<td style="text-align: left"><code>0</code></td>
<td style="text-align: left">UNSET is the default value, when range-based sharding is not used.</td>
</tr>
<tr>
<td style="text-align: left"><code>UINT64</code></td>
<td style="text-align: left"><code>1</code></td>
<td style="text-align: left">UINT64 is when uint64 value is used. This is represented as &#39;unsigned bigint&#39; in mysql</td>
</tr>
<tr>
<td style="text-align: left"><code>BYTES</code></td>
<td style="text-align: left"><code>2</code></td>
<td style="text-align: left">BYTES is when an array of bytes is used. This is represented as &#39;varbinary&#39; in mysql</td>
</tr>
</tbody></table>

<h3 id="topodata-tablettype">topodata.TabletType</h3>

<p>TabletType represents the type of a given tablet.</p>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Value</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>UNKNOWN</code></td>
<td style="text-align: left"><code>0</code></td>
<td style="text-align: left">UNKNOWN is not a valid value.</td>
</tr>
<tr>
<td style="text-align: left"><code>MASTER</code></td>
<td style="text-align: left"><code>1</code></td>
<td style="text-align: left">MASTER is the master server for the shard. Only MASTER allows DMLs.</td>
</tr>
<tr>
<td style="text-align: left"><code>REPLICA</code></td>
<td style="text-align: left"><code>2</code></td>
<td style="text-align: left">REPLICA is a slave type. It is used to serve live traffic. A REPLICA can be promoted to MASTER. A demoted MASTER will go to REPLICA.</td>
</tr>
<tr>
<td style="text-align: left"><code>RDONLY</code></td>
<td style="text-align: left"><code>3</code></td>
<td style="text-align: left">RDONLY (old name) / BATCH (new name) is used to serve traffic for long-running jobs. It is a separate type from REPLICA so long-running queries don&#39;t affect web-like traffic.</td>
</tr>
<tr>
<td style="text-align: left"><code>BATCH</code></td>
<td style="text-align: left"><code>3</code></td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left"><code>SPARE</code></td>
<td style="text-align: left"><code>4</code></td>
<td style="text-align: left">SPARE is a type of servers that cannot serve queries, but is available in case an extra server is needed.</td>
</tr>
<tr>
<td style="text-align: left"><code>EXPERIMENTAL</code></td>
<td style="text-align: left"><code>5</code></td>
<td style="text-align: left">EXPERIMENTAL is like SPARE, except it can serve queries. This type can be used for usages not planned by Vitess, like online export to another storage engine.</td>
</tr>
<tr>
<td style="text-align: left"><code>BACKUP</code></td>
<td style="text-align: left"><code>6</code></td>
<td style="text-align: left">BACKUP is the type a server goes to when taking a backup. No queries can be served in BACKUP mode.</td>
</tr>
<tr>
<td style="text-align: left"><code>RESTORE</code></td>
<td style="text-align: left"><code>7</code></td>
<td style="text-align: left">RESTORE is the type a server uses when restoring a backup, at startup time.  No queries can be served in RESTORE mode.</td>
</tr>
<tr>
<td style="text-align: left"><code>DRAINED</code></td>
<td style="text-align: left"><code>8</code></td>
<td style="text-align: left">DRAINED is the type a server goes into when used by Vitess tools to perform an offline action. It is a serving type (as the tools processes may need to run queries), but it&#39;s not used to route queries from Vitess users. In this state, this tablet is dedicated to the process that uses it.</td>
</tr>
</tbody></table>

<h3 id="vtrpc-errorcode">vtrpc.ErrorCode</h3>

<p>ErrorCode is the enum values for Errors. Internally, errors should be created with one of these codes. These will then be translated over the wire by various RPC frameworks.</p>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Value</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>SUCCESS</code></td>
<td style="text-align: left"><code>0</code></td>
<td style="text-align: left">SUCCESS is returned from a successful call.</td>
</tr>
<tr>
<td style="text-align: left"><code>CANCELLED</code></td>
<td style="text-align: left"><code>1</code></td>
<td style="text-align: left">CANCELLED means that the context was cancelled (and noticed in the app layer, as opposed to the RPC layer).</td>
</tr>
<tr>
<td style="text-align: left"><code>UNKNOWN_ERROR</code></td>
<td style="text-align: left"><code>2</code></td>
<td style="text-align: left">UNKNOWN_ERROR includes: 1. MySQL error codes that we don&#39;t explicitly handle. 2. MySQL response that wasn&#39;t as expected. For example, we might expect a MySQL timestamp to be returned in a particular way, but it wasn&#39;t. 3. Anything else that doesn&#39;t fall into a different bucket.</td>
</tr>
<tr>
<td style="text-align: left"><code>BAD_INPUT</code></td>
<td style="text-align: left"><code>3</code></td>
<td style="text-align: left">BAD_INPUT is returned when an end-user either sends SQL that couldn&#39;t be parsed correctly, or tries a query that isn&#39;t supported by Vitess.</td>
</tr>
<tr>
<td style="text-align: left"><code>DEADLINE_EXCEEDED</code></td>
<td style="text-align: left"><code>4</code></td>
<td style="text-align: left">DEADLINE_EXCEEDED is returned when an action is taking longer than a given timeout.</td>
</tr>
<tr>
<td style="text-align: left"><code>INTEGRITY_ERROR</code></td>
<td style="text-align: left"><code>5</code></td>
<td style="text-align: left">INTEGRITY_ERROR is returned on integrity error from MySQL, usually due to duplicate primary keys.</td>
</tr>
<tr>
<td style="text-align: left"><code>PERMISSION_DENIED</code></td>
<td style="text-align: left"><code>6</code></td>
<td style="text-align: left">PERMISSION_DENIED errors are returned when a user requests access to something that they don&#39;t have permissions for.</td>
</tr>
<tr>
<td style="text-align: left"><code>RESOURCE_EXHAUSTED</code></td>
<td style="text-align: left"><code>7</code></td>
<td style="text-align: left">RESOURCE_EXHAUSTED is returned when a query exceeds its quota in some dimension and can&#39;t be completed due to that. Queries that return RESOURCE_EXHAUSTED should not be retried, as it could be detrimental to the server&#39;s health. Examples of errors that will cause the RESOURCE_EXHAUSTED code: 1. TxPoolFull: this is retried server-side, and is only returned as an error if the server-side retries failed. 2. Query is killed due to it taking too long.</td>
</tr>
<tr>
<td style="text-align: left"><code>QUERY_NOT_SERVED</code></td>
<td style="text-align: left"><code>8</code></td>
<td style="text-align: left">QUERY_NOT_SERVED means that a query could not be served right now. Client can interpret it as: &quot;the tablet that you sent this query to cannot serve the query right now, try a different tablet or try again later.&quot; This could be due to various reasons: QueryService is not serving, should not be serving, wrong shard, wrong tablet type, blacklisted table, etc. Clients that receive this error should usually retry the query, but after taking the appropriate steps to make sure that the query will get sent to the correct tablet.</td>
</tr>
<tr>
<td style="text-align: left"><code>NOT_IN_TX</code></td>
<td style="text-align: left"><code>9</code></td>
<td style="text-align: left">NOT_IN_TX means that we&#39;re not currently in a transaction, but we should be.</td>
</tr>
<tr>
<td style="text-align: left"><code>INTERNAL_ERROR</code></td>
<td style="text-align: left"><code>10</code></td>
<td style="text-align: left">INTERNAL_ERRORs are problems that only the server can fix, not the client. These errors are not due to a query itself, but rather due to the state of the system. Generally, we don&#39;t expect the errors to go away by themselves, but they may go away after human intervention. Examples of scenarios where INTERNAL_ERROR is returned: 1. Something is not configured correctly internally. 2. A necessary resource is not available, and we don&#39;t expect it to become available by itself. 3. A sanity check fails. 4. Some other internal error occurs. Clients should not retry immediately, as there is little chance of success. However, it&#39;s acceptable for retries to happen internally, for example to multiple backends, in case only a subset of backend are not functional.</td>
</tr>
<tr>
<td style="text-align: left"><code>TRANSIENT_ERROR</code></td>
<td style="text-align: left"><code>11</code></td>
<td style="text-align: left">TRANSIENT_ERROR is used for when there is some error that we expect we can recover from automatically - often due to a resource limit temporarily being reached. Retrying this error, with an exponential backoff, should succeed. Clients should be able to successfully retry the query on the same backends. Examples of things that can trigger this error: 1. Query has been throttled 2. VtGate could have request backlog</td>
</tr>
<tr>
<td style="text-align: left"><code>UNAUTHENTICATED</code></td>
<td style="text-align: left"><code>12</code></td>
<td style="text-align: left">UNAUTHENTICATED errors are returned when a user requests access to something, and we&#39;re unable to verify the user&#39;s authentication.</td>
</tr>
</tbody></table>

<h2 id="messages">Messages</h2>

<h3 id="boundkeyspaceidquery">BoundKeyspaceIdQuery</h3>

<p>BoundKeyspaceIdQuery represents a single query request for the specified list of keyspace ids. This is used in a list for ExecuteBatchKeyspaceIdsRequest.</p>

<h4 id="properties">Properties</h4>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>query</code> <br><a href="#query.boundquery">query.BoundQuery</a></td>
<td style="text-align: left">BoundQuery is a query with its bind variables</td>
</tr>
<tr>
<td style="text-align: left"><code>keyspace</code> <br>string</td>
<td style="text-align: left">keyspace to target the query to.</td>
</tr>
<tr>
<td style="text-align: left"><code>keyspace_ids</code> <br>list &lt;bytes&gt;</td>
<td style="text-align: left">keyspace_ids contains the list of keyspace_ids affected by this query. Will be used to find the shards to send the query to.</td>
</tr>
</tbody></table>

<h3 id="boundshardquery">BoundShardQuery</h3>

<p>BoundShardQuery represents a single query request for the specified list of shards. This is used in a list for ExecuteBatchShardsRequest.</p>

<h4 id="properties">Properties</h4>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>query</code> <br><a href="#query.boundquery">query.BoundQuery</a></td>
<td style="text-align: left">BoundQuery is a query with its bind variables</td>
</tr>
<tr>
<td style="text-align: left"><code>keyspace</code> <br>string</td>
<td style="text-align: left">keyspace to target the query to.</td>
</tr>
<tr>
<td style="text-align: left"><code>shards</code> <br>list &lt;string&gt;</td>
<td style="text-align: left">shards to target the query to. A DML can only target one shard.</td>
</tr>
</tbody></table>

<h3 id="session">Session</h3>

<p>Session objects are session cookies and are invalidated on use. Query results will contain updated session values. Their content should be opaque to the user.</p>

<h4 id="properties">Properties</h4>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>in_transaction</code> <br>bool</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left"><code>shard_sessions</code> <br>list &lt;<a href="#session.shardsession">ShardSession</a>&gt;</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left"><code>single_db</code> <br>bool</td>
<td style="text-align: left">single_db specifies if the transaction should be restricted to a single database.</td>
</tr>
</tbody></table>

<h4 id="messages">Messages</h4>

<h5 id="session-shardsession">Session.ShardSession</h5>

<p><em>Properties</em></p>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>target</code> <br><a href="#query.target">query.Target</a></td>
<td style="text-align: left">Target describes what the client expects the tablet is. If the tablet does not match, an error is returned.</td>
</tr>
<tr>
<td style="text-align: left"><code>transaction_id</code> <br>int64</td>
<td style="text-align: left"></td>
</tr>
</tbody></table>

<h3 id="query-bindvariable">query.BindVariable</h3>

<p>BindVariable represents a single bind variable in a Query.</p>

<h4 id="properties">Properties</h4>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>type</code> <br><a href="#query.type">Type</a></td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left"><code>value</code> <br>bytes</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left"><code>values</code> <br>list &lt;<a href="#query.value">Value</a>&gt;</td>
<td style="text-align: left">Value represents a typed value.</td>
</tr>
</tbody></table>

<h3 id="query-boundquery">query.BoundQuery</h3>

<p>BoundQuery is a query with its bind variables</p>

<h4 id="properties">Properties</h4>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>sql</code> <br>string</td>
<td style="text-align: left">sql is the SQL query to execute</td>
</tr>
<tr>
<td style="text-align: left"><code>bind_variables</code> <br>map &lt;string, <a href="#query.bindvariable">BindVariable</a>&gt;</td>
<td style="text-align: left">bind_variables is a map of all bind variables to expand in the query</td>
</tr>
</tbody></table>

<h3 id="query-eventtoken">query.EventToken</h3>

<p>EventToken is a structure that describes a point in time in a replication stream on one shard. The most recent known replication position can be retrieved from vttablet when executing a query. It is also sent with the replication streams from the binlog service.</p>

<h4 id="properties">Properties</h4>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>timestamp</code> <br>int64</td>
<td style="text-align: left">timestamp is the MySQL timestamp of the statements. Seconds since Epoch.</td>
</tr>
<tr>
<td style="text-align: left"><code>shard</code> <br>string</td>
<td style="text-align: left">The shard name that applied the statements. Note this is not set when streaming from a vttablet. It is only used on the client -&gt; vtgate link.</td>
</tr>
<tr>
<td style="text-align: left"><code>position</code> <br>string</td>
<td style="text-align: left">The position on the replication stream after this statement was applied. It is not the transaction ID / GTID, but the position / GTIDSet.</td>
</tr>
</tbody></table>

<h3 id="query-executeoptions">query.ExecuteOptions</h3>

<p>ExecuteOptions is passed around for all Execute calls.</p>

<h4 id="properties">Properties</h4>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>include_event_token</code> <br>bool</td>
<td style="text-align: left">This used to be exclude_field_names, which was replaced by IncludedFields enum below If set, we will try to include an EventToken with the responses.</td>
</tr>
<tr>
<td style="text-align: left"><code>compare_event_token</code> <br><a href="#query.eventtoken">EventToken</a></td>
<td style="text-align: left">EventToken is a structure that describes a point in time in a replication stream on one shard. The most recent known replication position can be retrieved from vttablet when executing a query. It is also sent with the replication streams from the binlog service.</td>
</tr>
<tr>
<td style="text-align: left"><code>included_fields</code> <br><a href="#executeoptions.includedfields">IncludedFields</a></td>
<td style="text-align: left">Controls what fields are returned in Field message responses from mysql, i.e. field name, table name, etc. This is an optimization for high-QPS queries where the client knows what it&#39;s getting</td>
</tr>
</tbody></table>

<h4 id="enums">Enums</h4>

<h5 id="executeoptions-includedfields">ExecuteOptions.IncludedFields</h5>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Value</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>TYPE_AND_NAME</code></td>
<td style="text-align: left"><code>0</code></td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left"><code>TYPE_ONLY</code></td>
<td style="text-align: left"><code>1</code></td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left"><code>ALL</code></td>
<td style="text-align: left"><code>2</code></td>
<td style="text-align: left"></td>
</tr>
</tbody></table>

<h3 id="query-field">query.Field</h3>

<p>Field describes a single column returned by a query</p>

<h4 id="properties">Properties</h4>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>name</code> <br>string</td>
<td style="text-align: left">name of the field as returned by mysql C API</td>
</tr>
<tr>
<td style="text-align: left"><code>type</code> <br><a href="#query.type">Type</a></td>
<td style="text-align: left">vitess-defined type. Conversion function is in sqltypes package.</td>
</tr>
<tr>
<td style="text-align: left"><code>table</code> <br>string</td>
<td style="text-align: left">Remaining fields from mysql C API. These fields are only populated when ExecuteOptions.included_fields is set to IncludedFields.ALL.</td>
</tr>
<tr>
<td style="text-align: left"><code>org_table</code> <br>string</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left"><code>database</code> <br>string</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left"><code>org_name</code> <br>string</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left"><code>column_length</code> <br>uint32</td>
<td style="text-align: left">column_length is really a uint32. All 32 bits can be used.</td>
</tr>
<tr>
<td style="text-align: left"><code>charset</code> <br>uint32</td>
<td style="text-align: left">charset is actually a uint16. Only the lower 16 bits are used.</td>
</tr>
<tr>
<td style="text-align: left"><code>decimals</code> <br>uint32</td>
<td style="text-align: left">decimals is actualy a uint8. Only the lower 8 bits are used.</td>
</tr>
<tr>
<td style="text-align: left"><code>flags</code> <br>uint32</td>
<td style="text-align: left">flags is actually a uint16. Only the lower 16 bits are used.</td>
</tr>
</tbody></table>

<h3 id="query-queryresult">query.QueryResult</h3>

<p>QueryResult is returned by Execute and ExecuteStream.  As returned by Execute, len(fields) is always equal to len(row) (for each row in rows).  As returned by StreamExecute, the first QueryResult has the fields set, and subsequent QueryResult have rows set. And as Execute, len(QueryResult[0].fields) is always equal to len(row) (for each row in rows for each QueryResult in QueryResult[1:]).</p>

<h4 id="properties">Properties</h4>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>fields</code> <br>list &lt;<a href="#query.field">Field</a>&gt;</td>
<td style="text-align: left">Field describes a single column returned by a query</td>
</tr>
<tr>
<td style="text-align: left"><code>rows_affected</code> <br>uint64</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left"><code>insert_id</code> <br>uint64</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left"><code>rows</code> <br>list &lt;<a href="#query.row">Row</a>&gt;</td>
<td style="text-align: left">Row is a database row.</td>
</tr>
<tr>
<td style="text-align: left"><code>extras</code> <br><a href="#query.resultextras">ResultExtras</a></td>
<td style="text-align: left">ResultExtras contains optional out-of-band information. Usually the extras are requested by adding ExecuteOptions flags.</td>
</tr>
</tbody></table>

<h3 id="query-resultextras">query.ResultExtras</h3>

<p>ResultExtras contains optional out-of-band information. Usually the extras are requested by adding ExecuteOptions flags.</p>

<h4 id="properties">Properties</h4>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>event_token</code> <br><a href="#query.eventtoken">EventToken</a></td>
<td style="text-align: left">EventToken is a structure that describes a point in time in a replication stream on one shard. The most recent known replication position can be retrieved from vttablet when executing a query. It is also sent with the replication streams from the binlog service.</td>
</tr>
<tr>
<td style="text-align: left"><code>fresher</code> <br>bool</td>
<td style="text-align: left">If set, it means the data returned with this result is fresher than the compare_token passed in the ExecuteOptions.</td>
</tr>
</tbody></table>

<h3 id="query-resultwitherror">query.ResultWithError</h3>

<p>ResultWithError represents a query response in the form of result or error but not both.</p>

<h4 id="properties">Properties</h4>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>error</code> <br><a href="#vtrpc.rpcerror">vtrpc.RPCError</a></td>
<td style="text-align: left">RPCError is an application-level error structure returned by VtTablet (and passed along by VtGate if appropriate). We use this so the clients don&#39;t have to parse the error messages, but instead can depend on the value of the code.</td>
</tr>
<tr>
<td style="text-align: left"><code>result</code> <br><a href="#query.queryresult">query.QueryResult</a></td>
<td style="text-align: left">QueryResult is returned by Execute and ExecuteStream.  As returned by Execute, len(fields) is always equal to len(row) (for each row in rows).  As returned by StreamExecute, the first QueryResult has the fields set, and subsequent QueryResult have rows set. And as Execute, len(QueryResult[0].fields) is always equal to len(row) (for each row in rows for each QueryResult in QueryResult[1:]).</td>
</tr>
</tbody></table>

<h3 id="query-row">query.Row</h3>

<p>Row is a database row.</p>

<h4 id="properties">Properties</h4>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>lengths</code> <br>list &lt;sint64&gt;</td>
<td style="text-align: left">lengths contains the length of each value in values. A length of -1 means that the field is NULL. While reading values, you have to accummulate the length to know the offset where the next value begins in values.</td>
</tr>
<tr>
<td style="text-align: left"><code>values</code> <br>bytes</td>
<td style="text-align: left">values contains a concatenation of all values in the row.</td>
</tr>
</tbody></table>

<h3 id="query-streamevent">query.StreamEvent</h3>

<p>StreamEvent describes a set of transformations that happened as a single transactional unit on a server. It is streamed back by the Update Stream calls.</p>

<h4 id="properties">Properties</h4>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>statements</code> <br>list &lt;<a href="#streamevent.statement">Statement</a>&gt;</td>
<td style="text-align: left">The statements in this transaction.</td>
</tr>
<tr>
<td style="text-align: left"><code>event_token</code> <br><a href="#query.eventtoken">EventToken</a></td>
<td style="text-align: left">EventToken is a structure that describes a point in time in a replication stream on one shard. The most recent known replication position can be retrieved from vttablet when executing a query. It is also sent with the replication streams from the binlog service.</td>
</tr>
</tbody></table>

<h4 id="messages">Messages</h4>

<h5 id="streamevent-statement">StreamEvent.Statement</h5>

<p>One individual Statement in a transaction.</p>

<p><em>Properties</em></p>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>category</code> <br><a href="#streamevent.statement.category">Category</a></td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left"><code>table_name</code> <br>string</td>
<td style="text-align: left">table_name, primary_key_fields and primary_key_values are set for DML.</td>
</tr>
<tr>
<td style="text-align: left"><code>primary_key_fields</code> <br>list &lt;<a href="#query.field">Field</a>&gt;</td>
<td style="text-align: left">Field describes a single column returned by a query</td>
</tr>
<tr>
<td style="text-align: left"><code>primary_key_values</code> <br>list &lt;<a href="#query.row">Row</a>&gt;</td>
<td style="text-align: left">Row is a database row.</td>
</tr>
<tr>
<td style="text-align: left"><code>sql</code> <br>bytes</td>
<td style="text-align: left">sql is set for all queries. FIXME(alainjobart) we may not need it for DMLs.</td>
</tr>
</tbody></table>

<h4 id="enums">Enums</h4>

<h5 id="streamevent-statement-category">StreamEvent.Statement.Category</h5>

<p>One individual Statement in a transaction. The category of one statement.</p>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Value</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>Error</code></td>
<td style="text-align: left"><code>0</code></td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left"><code>DML</code></td>
<td style="text-align: left"><code>1</code></td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left"><code>DDL</code></td>
<td style="text-align: left"><code>2</code></td>
<td style="text-align: left"></td>
</tr>
</tbody></table>

<h3 id="query-target">query.Target</h3>

<p>Target describes what the client expects the tablet is. If the tablet does not match, an error is returned.</p>

<h4 id="properties">Properties</h4>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>keyspace</code> <br>string</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left"><code>shard</code> <br>string</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left"><code>tablet_type</code> <br><a href="#topodata.tablettype">topodata.TabletType</a></td>
<td style="text-align: left">TabletType represents the type of a given tablet.</td>
</tr>
</tbody></table>

<h3 id="query-value">query.Value</h3>

<p>Value represents a typed value.</p>

<h4 id="properties">Properties</h4>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>type</code> <br><a href="#query.type">Type</a></td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left"><code>value</code> <br>bytes</td>
<td style="text-align: left"></td>
</tr>
</tbody></table>

<h3 id="topodata-keyrange">topodata.KeyRange</h3>

<p>KeyRange describes a range of sharding keys, when range-based sharding is used.</p>

<h4 id="properties">Properties</h4>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>start</code> <br>bytes</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left"><code>end</code> <br>bytes</td>
<td style="text-align: left"></td>
</tr>
</tbody></table>

<h3 id="topodata-shardreference">topodata.ShardReference</h3>

<p>ShardReference is used as a pointer from a SrvKeyspace to a Shard</p>

<h4 id="properties">Properties</h4>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>name</code> <br>string</td>
<td style="text-align: left">Copied from Shard.</td>
</tr>
<tr>
<td style="text-align: left"><code>key_range</code> <br><a href="#topodata.keyrange">KeyRange</a></td>
<td style="text-align: left">KeyRange describes a range of sharding keys, when range-based sharding is used.</td>
</tr>
</tbody></table>

<h3 id="topodata-srvkeyspace">topodata.SrvKeyspace</h3>

<p>SrvKeyspace is a rollup node for the keyspace itself.</p>

<h4 id="properties">Properties</h4>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>partitions</code> <br>list &lt;<a href="#srvkeyspace.keyspacepartition">KeyspacePartition</a>&gt;</td>
<td style="text-align: left">The partitions this keyspace is serving, per tablet type.</td>
</tr>
<tr>
<td style="text-align: left"><code>sharding_column_name</code> <br>string</td>
<td style="text-align: left">copied from Keyspace</td>
</tr>
<tr>
<td style="text-align: left"><code>sharding_column_type</code> <br><a href="#topodata.keyspaceidtype">KeyspaceIdType</a></td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left"><code>served_from</code> <br>list &lt;<a href="#srvkeyspace.servedfrom">ServedFrom</a>&gt;</td>
<td style="text-align: left"></td>
</tr>
</tbody></table>

<h4 id="messages">Messages</h4>

<h5 id="srvkeyspace-keyspacepartition">SrvKeyspace.KeyspacePartition</h5>

<p><em>Properties</em></p>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>served_type</code> <br><a href="#topodata.tablettype">TabletType</a></td>
<td style="text-align: left">The type this partition applies to.</td>
</tr>
<tr>
<td style="text-align: left"><code>shard_references</code> <br>list &lt;<a href="#topodata.shardreference">ShardReference</a>&gt;</td>
<td style="text-align: left">ShardReference is used as a pointer from a SrvKeyspace to a Shard</td>
</tr>
</tbody></table>

<h5 id="srvkeyspace-servedfrom">SrvKeyspace.ServedFrom</h5>

<p>ServedFrom indicates a relationship between a TabletType and the keyspace name that&#39;s serving it.</p>

<p><em>Properties</em></p>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>tablet_type</code> <br><a href="#topodata.tablettype">TabletType</a></td>
<td style="text-align: left">ServedFrom indicates a relationship between a TabletType and the keyspace name that&#39;s serving it. the tablet type</td>
</tr>
<tr>
<td style="text-align: left"><code>keyspace</code> <br>string</td>
<td style="text-align: left">the keyspace name that&#39;s serving it</td>
</tr>
</tbody></table>

<h3 id="vtrpc-callerid">vtrpc.CallerID</h3>

<p>CallerID is passed along RPCs to identify the originating client for a request. It is not meant to be secure, but only informational.  The client can put whatever info they want in these fields, and they will be trusted by the servers. The fields will just be used for logging purposes, and to easily find a client. VtGate propagates it to VtTablet, and VtTablet may use this information for monitoring purposes, to display on dashboards, or for blacklisting purposes.</p>

<h4 id="properties">Properties</h4>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>principal</code> <br>string</td>
<td style="text-align: left">principal is the effective user identifier. It is usually filled in with whoever made the request to the appserver, if the request came from an automated job or another system component. If the request comes directly from the Internet, or if the Vitess client takes action on its own accord, it is okay for this field to be absent.</td>
</tr>
<tr>
<td style="text-align: left"><code>component</code> <br>string</td>
<td style="text-align: left">component describes the running process of the effective caller. It can for instance be the hostname:port of the servlet initiating the database call, or the container engine ID used by the servlet.</td>
</tr>
<tr>
<td style="text-align: left"><code>subcomponent</code> <br>string</td>
<td style="text-align: left">subcomponent describes a component inisde the immediate caller which is responsible for generating is request. Suggested values are a servlet name or an API endpoint name.</td>
</tr>
</tbody></table>

<h3 id="vtrpc-rpcerror">vtrpc.RPCError</h3>

<p>RPCError is an application-level error structure returned by VtTablet (and passed along by VtGate if appropriate). We use this so the clients don&#39;t have to parse the error messages, but instead can depend on the value of the code.</p>

<h4 id="properties">Properties</h4>

<table><thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>code</code> <br><a href="#vtrpc.errorcode">ErrorCode</a></td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left"><code>message</code> <br>string</td>
<td style="text-align: left"></td>
</tr>
</tbody></table>

      </div>
    </div>
  </div>

</div>

    <div class="page-spacer"></div>
    <footer role="contentinfo" id="site-footer">
  <nav role="navigation" class="menu bottom-menu">
    
    <a href="https://groups.google.com/forum/#!forum/vitess" target="_blank">Contact: vitess@googlegroups.com</a>&nbsp;&nbsp;<b>·</b>&nbsp;&nbsp;
    <a href="https://groups.google.com/forum/#!forum/vitess-announce" target="_blank">Announcements</a>&nbsp;&nbsp;<b>·</b>&nbsp;&nbsp;
    &#169; 2017 <a href="/">Vitess</a> powered by <a href="https://developers.google.com/open-source/">Google Inc</a>
  </nav>
</footer>


        <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
<!--    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>   -->
    <!-- Include all compiled plugins (below), or include individual files as needed -->
<!--
    <script src="/libs/bootstrap/js/bootstrap.min.js"></script>
-->
    <!-- Include the common site javascript -->
    <script src="/js/common.js" type="text/javascript" charset="utf-8"></script>


  </body>
</html>
