<!DOCTYPE html>
<html lang="en" itemscope itemtype="https://schema.org/WebPage">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Vitess / VSchema User Guide</title>

        <!-- Webfont -->
    <link href='http://fonts.googleapis.com/css?family=Roboto:400,100,100italic,300,300italic,400italic,500,500italic,700,700italic,900,900italic' rel='stylesheet' type='text/css'>
    
    <!--<link rel="shortcut icon" type="image/png" href="/favicon.png">-->

    <!-- Bootstrap -->
    <link href="/libs/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Styles -->
    <link rel="stylesheet" type="text/css" href="/css/site.css" />
    <!-- Font Awesome icons -->
    <link href="/libs/font-awesome-4.4.0/css/font-awesome.min.css"
          rel="stylesheet"
          type="text/css">
    
    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="/libs/bootstrap/js/bootstrap.min.js"></script>


    <!-- metadata -->
    <meta name="og:title" content="Vitess / VSchema User Guide"/>
    <meta name="og:image" content="/images/vitess_logo_with_border.svg"/>
    <meta name="og:description" content="Vitess is a database clustering system for horizontal scaling of MySQL."/>

    <link rel="icon" href="/images/vitess_logo_icon_size.png" type="image/png">

    
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-60219601-1', 'auto');
  ga('send', 'pageview');
</script>

    
  </head>
  <body class="docs" id="top_of_page">

    <span id="toc-depth" data-toc-depth="h2,h3"></span>


    <nav id="common-nav" class="navbar navbar-fixed-top inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse-1">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/">
        <img class="logo" src="/images/vitess_logo_with_border.svg" alt="Vitess">
      </a>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="navbar-collapse-1">
      <ul class="nav navbar-nav navbar-right" id="standard-menu-links">
        <li><a href="/overview/">Overview</a></li>
        <li><a href="/user-guide/introduction.html">Guides</a></li>
        <li><a href="/reference/vitess-api.html">Reference</a></li>
        <li><a href="http://blog.vitess.io">Blog</a></li>
        <li><a href="https://github.com/youtube/vitess"><i class="fa fa-github"></i> GitHub</a></li>
        <!-- Hide link to blog unless we have actual posts -->
        <!-- <li><a href="/blog/" title="">Blog</a></li> -->
      </ul>
      <ul class="nav nav-stacked mobile-left-nav-menu" id="collapsed-left-menu">
                <li class="submenu">
          <h4 class="arrow-r no-top-margin">Overview</h4>
          <ul style="display: none">
            <li><a href="/overview/">What is Vitess</a></li>
            <li><a href="/overview/scaling-mysql.html">Scaling MySQL with Vitess</a></li>
            <li><a href="/overview/concepts.html">Key Concepts</a></li>
          </ul>
        </li>
        <li class="submenu">
          <h4 class="arrow-r">Getting Started</h4>
          <ul style="display: none">
            <li style="padding-bottom: 0"><a href="/getting-started/">Run Vitess on Kubernetes</a>
              <ul style="display: block">
                <li style="padding-bottom: 0"><a href="/getting-started/docker-build.html">Custom Docker Build</a></li>
              </ul>
            </li>
            <li><a href="/getting-started/local-instance.html">Run Vitess Locally</a></li>
          </ul>
        </li>
        <li class="submenu">
          <h4 class="arrow-r">User Guide</h4>
          <ul style="display: none">
            <li><a href="/user-guide/introduction.html">Introduction</a>
            <li><a href="/user-guide/client-libraries.html">Client Libraries</a>
            <li><a href="/user-guide/backup-and-restore.html">Backing Up Data</a>
            <li><a href="/user-guide/reparenting.html">Reparenting</a></li>
            <li style="padding-bottom: 0"><a href="/user-guide/schema-management.html">Schema Management</a></li>
              <ul style="display: block">
                <li style="padding-bottom: 0"><a href="/user-guide/vschema.html">VSchema Guide</a></li>
                <li style="padding-bottom: 0"><a href="/user-guide/schema-swap.html">Schema Swap (Tutorial)</a></li>
              </ul>
            <li style="padding-bottom: 0"><a href="/user-guide/sharding.html">Sharding</a>
              <ul style="display: block">
                <li><a href="/user-guide/horizontal-sharding-workflow.html">Horizontal Sharding (Tutorial, automated)</a></li>
                <li><a href="/user-guide/horizontal-sharding.html">Horizontal Sharding (Tutorial, manual)</a></li>
                <li><a href="/user-guide/sharding-kubernetes-workflow.html">Sharding in Kubernetes (Tutorial, automated)</a></li>
                <li style="padding-bottom: 0"><a href="/user-guide/sharding-kubernetes.html">Sharding in Kubernetes (Tutorial, manual)</a></li>
              </ul>
            </li>
            <li><a href="/user-guide/vitess-sequences.html">Vitess Sequences</a></li>
            <li><a href="/user-guide/mysql-server-protocol.html">MySQL Server Protocol</a></li>
            <li><a href="/user-guide/vitess-replication.html">Vitess and Replication</a></li>
            <li><a href="/user-guide/update-stream.html">Update Stream</a></li>
            <li><a href="/user-guide/row-based-replication.html">Row Based Replication</a></li>
            <li><a href="/user-guide/topology-service.html">Topology Service</a></li>
            <li><a href="/user-guide/transport-security-model.html">Transport Security Model</a></li>
            <li style="padding-bottom: 0"><a href="/user-guide/launching.html">Launching</a>
              <ul style="display: block">
                <li><a href="/user-guide/scalability-philosophy.html">Scalability Philosophy</a></li>
                <li><a href="/user-guide/production-planning.html">Production Planning</a></li>
                <li><a href="/user-guide/server-configuration.html">Server Configuration</a></li>
                <li><a href="/user-guide/twopc.html">2PC Guide</a></li>
                <li style="padding-bottom: 0"><a href="/user-guide/troubleshooting.html">Troubleshooting</a></li>
              </ul>
            </li>
            <li><a href="/user-guide/upgrading.html">Upgrading</a></li>
          </ul>
        </li>
        <li class="submenu">
          <h4 class="arrow-r">Reference Guides</h4>
          <ul style="display: none">
            <li><a href="/reference/vitess-api.html">Vitess API</a>
            <li><a href="/reference/vtctl.html">vtctl Commands</a>
          </ul>
        </li>
        <li class="submenu">
          <h4 class="arrow-r">Other Resources</h4>
          <ul style="display: none">
            <li><a href="/resources/presentations.html">Presentations</a>
            <li><a href="http://blog.vitess.io/">Blog</a>
            <li><a href="/resources/roadmap.html">Roadmap</a>
          </ul>
        </li>
        <li class="submenu">
          <h4 class="arrow-r">Contributing</h4>
          <ul style="display: none">
            <li><a href="/contributing/">Contributing to Vitess</a>
            <li><a href="/contributing/github-workflow.html">GitHub Workflow</a>
            <li><a href="/contributing/code-reviews.html">Code Reviews</a>
          </ul>
        </li>

        <div>
          <form method="get" action="/search/">
            <input id="search-form" name="q" type="text" placeholder="Search">
          </form>
        </div>

        <li><a href="https://github.com/youtube/vitess" id="collapsed-left-menu-repo-link"><i class="fa fa-github"></i> GitHub</a></li>
      </ul>
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

    
<div id="masthead">
  <div class="container">
    <div class="row">
      <div class="col-md-9">
        <h1>VSchema User Guide</h1>
      </div>
    </div>
  </div>
</div>


<div class="container">
    <div class="row scroll-margin" id="toc-content-row">
    <div class="col-md-2" id="leftCol">
      <ul class="nav nav-stacked mobile-left-nav-menu" id="sidebar">
                <li class="submenu">
          <h4 class="arrow-r no-top-margin">Overview</h4>
          <ul style="display: none">
            <li><a href="/overview/">What is Vitess</a></li>
            <li><a href="/overview/scaling-mysql.html">Scaling MySQL with Vitess</a></li>
            <li><a href="/overview/concepts.html">Key Concepts</a></li>
          </ul>
        </li>
        <li class="submenu">
          <h4 class="arrow-r">Getting Started</h4>
          <ul style="display: none">
            <li style="padding-bottom: 0"><a href="/getting-started/">Run Vitess on Kubernetes</a>
              <ul style="display: block">
                <li style="padding-bottom: 0"><a href="/getting-started/docker-build.html">Custom Docker Build</a></li>
              </ul>
            </li>
            <li><a href="/getting-started/local-instance.html">Run Vitess Locally</a></li>
          </ul>
        </li>
        <li class="submenu">
          <h4 class="arrow-r">User Guide</h4>
          <ul style="display: none">
            <li><a href="/user-guide/introduction.html">Introduction</a>
            <li><a href="/user-guide/client-libraries.html">Client Libraries</a>
            <li><a href="/user-guide/backup-and-restore.html">Backing Up Data</a>
            <li><a href="/user-guide/reparenting.html">Reparenting</a></li>
            <li style="padding-bottom: 0"><a href="/user-guide/schema-management.html">Schema Management</a></li>
              <ul style="display: block">
                <li style="padding-bottom: 0"><a href="/user-guide/vschema.html">VSchema Guide</a></li>
                <li style="padding-bottom: 0"><a href="/user-guide/schema-swap.html">Schema Swap (Tutorial)</a></li>
              </ul>
            <li style="padding-bottom: 0"><a href="/user-guide/sharding.html">Sharding</a>
              <ul style="display: block">
                <li><a href="/user-guide/horizontal-sharding-workflow.html">Horizontal Sharding (Tutorial, automated)</a></li>
                <li><a href="/user-guide/horizontal-sharding.html">Horizontal Sharding (Tutorial, manual)</a></li>
                <li><a href="/user-guide/sharding-kubernetes-workflow.html">Sharding in Kubernetes (Tutorial, automated)</a></li>
                <li style="padding-bottom: 0"><a href="/user-guide/sharding-kubernetes.html">Sharding in Kubernetes (Tutorial, manual)</a></li>
              </ul>
            </li>
            <li><a href="/user-guide/vitess-sequences.html">Vitess Sequences</a></li>
            <li><a href="/user-guide/mysql-server-protocol.html">MySQL Server Protocol</a></li>
            <li><a href="/user-guide/vitess-replication.html">Vitess and Replication</a></li>
            <li><a href="/user-guide/update-stream.html">Update Stream</a></li>
            <li><a href="/user-guide/row-based-replication.html">Row Based Replication</a></li>
            <li><a href="/user-guide/topology-service.html">Topology Service</a></li>
            <li><a href="/user-guide/transport-security-model.html">Transport Security Model</a></li>
            <li style="padding-bottom: 0"><a href="/user-guide/launching.html">Launching</a>
              <ul style="display: block">
                <li><a href="/user-guide/scalability-philosophy.html">Scalability Philosophy</a></li>
                <li><a href="/user-guide/production-planning.html">Production Planning</a></li>
                <li><a href="/user-guide/server-configuration.html">Server Configuration</a></li>
                <li><a href="/user-guide/twopc.html">2PC Guide</a></li>
                <li style="padding-bottom: 0"><a href="/user-guide/troubleshooting.html">Troubleshooting</a></li>
              </ul>
            </li>
            <li><a href="/user-guide/upgrading.html">Upgrading</a></li>
          </ul>
        </li>
        <li class="submenu">
          <h4 class="arrow-r">Reference Guides</h4>
          <ul style="display: none">
            <li><a href="/reference/vitess-api.html">Vitess API</a>
            <li><a href="/reference/vtctl.html">vtctl Commands</a>
          </ul>
        </li>
        <li class="submenu">
          <h4 class="arrow-r">Other Resources</h4>
          <ul style="display: none">
            <li><a href="/resources/presentations.html">Presentations</a>
            <li><a href="http://blog.vitess.io/">Blog</a>
            <li><a href="/resources/roadmap.html">Roadmap</a>
          </ul>
        </li>
        <li class="submenu">
          <h4 class="arrow-r">Contributing</h4>
          <ul style="display: none">
            <li><a href="/contributing/">Contributing to Vitess</a>
            <li><a href="/contributing/github-workflow.html">GitHub Workflow</a>
            <li><a href="/contributing/code-reviews.html">Code Reviews</a>
          </ul>
        </li>

        <div>
          <form method="get" action="/search/">
            <input id="search-form" name="q" type="text" placeholder="Search">
          </form>
        </div>

      </ul>
    </div>
    <div class="col-md-3" id="rightCol">
      <div class="nav nav-stacked" id="tocSidebar">
        <div id="toc"></div>
      </div>
    </div>
    <div class="col-md-7" id="centerCol">
      <div id="centerTextCol">
        <h1 id="vschema-user-guide">VSchema User Guide</h1>

<p>VSchema stands for Vitess Schema. In contrast to a traditional database schema that contains metadata about tables, a VSchema contains metadata about how tables are organized across keyspaces and shards. Simply put, it contains the information needed to make Vitess look like a single database server.</p>

<p>For example, the VSchema will contain the information about the sharding key for a sharded table. When the application issues a query with a WHERE clause that references the key, the VSchema information will be used to route the query to the appropriate shard.</p>

<h2 id="sharding-model">Sharding Model</h2>

<p>In Vitess, a <code class="prettyprint">keyspace</code> is sharded by <code class="prettyprint">keyspace ID</code> ranges. Each row is assigned a keyspace ID, which acts like a street address, and it determines the shard where the row lives. In some respect, one could say that the <code class="prettyprint">keyspace ID</code> is the equivalent of a NoSQL sharding key. However, there are some differences:</p>

<ol>
<li>The <code class="prettyprint">keyspace ID</code> is a concept that is internal to Vitess. The application does not need to know anything about it.</li>
<li>There is no physical column that stores the actual <code class="prettyprint">keyspace ID</code>. This value is computed as needed.</li>
</ol>

<p>This difference is significant enough that we do not refer to the keyspace ID as the sharding key. we will later introduce the concept of a Primary Vindex which more closely ressembles the NoSQL sharding key.</p>

<p>Mapping to a <code class="prettyprint">keyspace ID</code>, and then to a shard, gives us the flexibility to reshard the data with minimal disruption because the <code class="prettyprint">keyspace ID</code> of each row remains unchanged through the process.</p>

<h2 id="vindex">Vindex</h2>

<p>The Sharding Key is a concept that was introduced by NoSQL datastores. It is based on the fact that there is only one access path to the data, which is the Key. However, relational databases are more versatile about the data and their relationships. So, sharding a database by only designating a sharding key is often insufficient.</p>

<p>If one were to draw an analogy, the indexes in a database would be the equivalent of the key in a NoSQL datastore, except that databases allow you to define multiple indexes per table, and there are many types of indexes. Extending this analogy to a sharded database results in different types of cross-shard indexes. In Vitess, these are called Vindexes.</p>

<p>Simplistically stated, a Vindex provides a way to map a column value to a <code class="prettyprint">keyspace ID</code>. This mapping can be used to identify the location of a row. A variety of vindexes are available to choose from with different trade-offs, and you can choose one that best suits your needs.</p>

<p>Vindexes offer many flexibilities:</p>

<ul>
<li>A table can have multiple Vindexes.</li>
<li>Vindexes could be NonUnique, which allows a column value to yield multiple keyspace IDs.</li>
<li>They could be a simple function or be based on a lookup table.</li>
<li>They could be shared across multiple tables.</li>
<li>Custom Vindexes can be plugged in, and Vitess will still know how to reshard using such Vindexes.</li>
</ul>

<h3 id="the-primary-vindex">The Primary Vindex</h3>

<p>The Primary Vindex is analogous to a database primary key. Every sharded table must have one defined. A Primary Vindex must be unique: given an input value, it must produce a single keyspace ID. This unique mapping will be used at the time of insert to decide the target shard for a row. Conceptually, this is also equivalent to the NoSQL Sharding Key, and we often refer to the Primary Vindex as the Sharding Key.</p>

<p>However, there is a subtle difference: NoSQL datastores let you choose the Sharding Key, but the Sharding Scheme is generally hardcoded in the engine. In Vitess, the choice of Vindex lets you control how a column value maps to a keyspace ID. In other words, a Primary Vindex in Vitess not only defines the Sharding Key, it also decides the Sharding Scheme.</p>

<p>Vindexes come in many varieties. Some of them can be used as Primary Vindex, and others have different purposes. The following sections will describe their properties.</p>

<h3 id="secondary-vindexes">Secondary Vindexes</h3>

<p>Secondary Vindexes are additional vindexes you can define against other columns of a table offering you optimizations for WHERE clauses that do not use the Primary Vindex. Secondary Vindexes return a single or a limited set of <code class="prettyprint">keyspace IDs</code> which will allow VTGate to only target shards where the relevant data is present. In the absence of a Secondary Vindex, VTGate would have to send the query to all shards.</p>

<p>Secondary Vindexes are also commonly known as cross-shard indexes. It is important to note that Secondary Vindexes are only for making routing decisions. The underlying database shards will most likely need traditional indexes on those same columns.</p>

<h3 id="unique-and-nonunique-vindex">Unique and NonUnique Vindex</h3>

<p>A Unique Vindex is one that yields at most one keyspace ID for a given input. Knowing that a Vindex is Unique is useful because VTGate can push down some complex queries into VTTablet if it knows that the scope of that query cannot exceed a shard. Uniqueness is also a prerequisite for a Vindex to be used as Primary Vindex.</p>

<p>A NonUnique Vindex is analogous to a database non-unique index. It is a secondary index for searching by an alternate WHERE clause. An input value could yield multiple keyspace IDs, and rows could be matched from multiple shards. For example, if a table has a <code class="prettyprint">name</code> column that allows duplicates, you can define a cross-shard NonUnique Vindex for it, and this will let you efficiently search for users that match a certain <code class="prettyprint">name</code>.</p>

<h3 id="functional-and-lookup-vindex">Functional and Lookup Vindex</h3>

<p>A Functional Vindex is one where the column value to keyspace ID mapping is pre-established, typically through an algorithmic function. In contrast, a Lookup Vindex is one that gives you the ability to create an association between a value and a keyspace ID, and recall it later when needed.</p>

<p>Typically, the Primary Vindex is Functional. In some cases, it is the identity function where the input value yields itself as the kesypace id. However, one could also choose other algorithms like hashing or mod functions.</p>

<p>A Lookup Vindex is usually backed by a lookup table. This is analogous to the traditional database index, except that it is cross-shard. At the time of insert, the computed keyspace ID of the row is stored in the lookup table against the column value.</p>

<h3 id="shared-vindexes">Shared Vindexes</h3>

<p>Relational databases encourage normalization, which lets you split data into different tables to avoid duplication in the case of one-to-many relationships. In such cases, a key is shared between the two tables to indicate that the rows are related, aka <code class="prettyprint">Foreign Key</code>.</p>

<p>In a sharded environment, it is often beneficial to keep those rows in the same shard. If a Lookup Vindex was created on the foreign key column of each of those tables, you would find that the backing tables would actually be identical. In such cases, Vitess lets you share a single Lookup Vindex for multiple tables. Of these, one of them is designated as the owner, which is responsible for creating and deleting these associations. The other tables just reuse these associations.</p>

<p>Caveat: If you delete a row from the owner table, Vitess will not perform cascading deletes. This is mainly for efficiency reasons; The application is likely capable of doing this more efficiently.</p>

<p>Functional Vindexes can be also be shared. However, there is no concept of ownership because the column to keyspace ID mapping is pre-established.</p>

<h3 id="orthogonality">Orthogonality</h3>

<p>The previously described properties are mostly orthogonal. Combining them gives rise to the following valid categories:</p>

<ul>
<li><strong>Functional Unique</strong>: This is the most popular category because it is the one best suited to be a Primary Vindex.</li>
<li><strong>Functional NonUnique</strong>: There are currently no use cases that need this category.</li>
<li><strong>Lookup Unique Owned</strong>: This gets used for optimizing high QPS queries that do not use the Primary Vindex columns in their WHERE clause. There is a price to pay: You incur an extra write to the lookup table for insert and delete operations, and an extra lookup for read operations. However, it is worth it if you do not want these high QPS queries to be sent to all shards.</li>
<li><strong>Lookup Unique Unowned</strong>: This category is used as an optimization as described in the Shared Vindexes section.</li>
<li><strong>Lookup NonUnique Owned</strong>: This gets used for high QPS queries on columns that are non-unique.</li>
<li><strong>Lookup NonUnique Unowned</strong>: You would rarely have to use this category because it is unlikely that you will be using a column as foreign key that is not unique within a shard. But it is theoretically possible.</li>
</ul>

<p>Of the above categories, <code class="prettyprint">Functional Unique</code> and <code class="prettyprint">Lookup Unique Unowned</code> Vindexes can be Primary. This is because those are the only ones that are unique and have the column to keyspace ID mapping pre-established. This is required because the Primary Vindex is responsible for assigning the keyspace ID for a row when it is created.</p>

<p>However, it is generally not recommended to use a Lookup vindex as Primary because it is too slow for resharding. If absolutely unavoidable, you can use a Lookup Vindex as Primary. In such cases, it is recommended that you add a <code class="prettyprint">keyspace ID</code> column to such tables. While resharding, Vitess can use that column to efficiently compute the target shard. You can even configure Vitess to auto-populate that column on inserts. This is done using the reverse map feature explained below.</p>

<h3 id="how-vindexes-are-used">How vindexes are used</h3>

<h4 id="cost">Cost</h4>

<p>Vindexes have costs. For routing a query, the Vindex with the lowest cost is chosen. The current costs are:</p>

<table><thead>
<tr>
<th>Vindex Type</th>
<th>Cost</th>
</tr>
</thead><tbody>
<tr>
<td>Indentity</td>
<td>0</td>
</tr>
<tr>
<td>Functional</td>
<td>1</td>
</tr>
<tr>
<td>Lookup Unique</td>
<td>10</td>
</tr>
<tr>
<td>Lookup NonUnique</td>
<td>20</td>
</tr>
</tbody></table>

<h4 id="select">Select</h4>

<p>In the case of a simple select, Vitess scans the WHERE clause to match references to Vindex columns and chooses the best one to use. If there is no match and the query is simple without complex constructs like aggreates, etc, it is sent to all shards.</p>

<p>Vitess can handle more complex queries. For now, you can refer to the <a href="https://github.com/youtube/vitess/blob/master/doc/V3HighLevelDesign.md">design doc</a> on how it handles them.</p>

<h4 id="insert">Insert</h4>

<ul>
<li>The Primary Vindex is used to generate a keyspace ID.</li>
<li>The keyspace ID is validated against the rest of the Vindexes on the table. There must exist a mapping from the column value to the keyspace ID.</li>
<li>If a column value was not provided for a Vindex and the Vindex is capable of reverse mapping a keyspace ID to an input value, that function is used to auto-fill the column. If there is no reverse map, it is an error.</li>
</ul>

<h4 id="update">Update</h4>

<p>The WHERE clause is used to route the update. Changing the value of a Vindex column is unsupported because this may result in a row being migrated from one shard to another.</p>

<h4 id="delete">Delete</h4>

<p>If the table owns lookup vindexes, then the rows to be deleted are first read and the associated Vindex entries are deleted. Following this, the query is routed according to the WHERE clause.</p>

<h3 id="predefined-vindexes">Predefined Vindexes</h3>

<p>Vitess provides the following predefined Vindexes:</p>

<table><thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Primary</th>
<th>Reversible</th>
<th>Cost</th>
</tr>
</thead><tbody>
<tr>
<td>binary</td>
<td>Functional Unique</td>
<td>Identity</td>
<td>Yes</td>
<td>Yes</td>
<td>0</td>
</tr>
<tr>
<td>binary_md5</td>
<td>Functional Unique</td>
<td>md5 hash</td>
<td>Yes</td>
<td>No</td>
<td>1</td>
</tr>
<tr>
<td>hash</td>
<td>Functional Unique</td>
<td>3DES null-key hash</td>
<td>Yes</td>
<td>Yes</td>
<td>1</td>
</tr>
<tr>
<td>lookup</td>
<td>Lookup NonUnique</td>
<td>Lookup table non-unique values</td>
<td>No</td>
<td>Yes</td>
<td>20</td>
</tr>
<tr>
<td>lookup_unique</td>
<td>Lookup Unique</td>
<td>Lookup table unique values</td>
<td>If unowned</td>
<td>Yes</td>
<td>10</td>
</tr>
<tr>
<td>numeric</td>
<td>Functional Unique</td>
<td>Identity</td>
<td>Yes</td>
<td>Yes</td>
<td>0</td>
</tr>
<tr>
<td>numeric_static_map</td>
<td>Functional Unique</td>
<td>A JSON file that maps input values to keyspace IDs</td>
<td>Yes</td>
<td>No</td>
<td>1</td>
</tr>
<tr>
<td>unicode_loose_md5</td>
<td>Functional Unique</td>
<td>Case-insensitive (UCA level 1) md5 hash</td>
<td>Yes</td>
<td>No</td>
<td>1</td>
</tr>
</tbody></table>

<p>Custom vindexes can also be plugged in as needed.</p>

<h2 id="sequences">Sequences</h2>

<p>Auto-increment columns do not work very well for sharded tables. <a href="/user-guide/vitess-sequences.html">Vitess sequences</a> solve this problem. Sequence tables must be specified in the VSchema, and then tied to table columns. At the time of insert, if no value is specified for such a column, VTGate will generate a number for it using the sequence table.</p>

<h2 id="vschema">VSchema</h2>

<p>As mentioned in the beginning of the document, a VSchema is needed to tie together all the databases that Vitess manages. For a very trivial setup where there is only one unsharded keyspace, there is no need to specify a VSchema because Vitess will know that there is no other place to route a query.</p>

<p>If you have multiple unsharded keyspaces, you can still avoid defining a VSchema in one of two ways:</p>

<ol>
<li>Connect to a keyspace and all queries are sent to it.</li>
<li>Connect to Vitess without specifying a keyspace, but use qualifed names for tables, like <code class="prettyprint">keyspace.table</code> in your queries.</li>
</ol>

<p>However, once the setup exceeds the above complexity, VSchemas become a necessity. Vitess has a <a href="https://github.com/youtube/vitess/tree/master/examples/demo">working demo</a> of VSchemas. This section documents the various features highlighted with snippets pulled from the demo.</p>

<h3 id="unsharded-table">Unsharded Table</h3>

<p>The following snippets show the necessary configs for creating a table in an unsharded keyspace:</p>

<p>Schema:</p>
<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="o">#</span> <span class="n">lookup</span> <span class="n">keyspace</span>
<span class="k">create</span> <span class="k">table</span> <span class="n">name_user_idx</span><span class="p">(</span><span class="n">name</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">128</span><span class="p">),</span> <span class="n">user_id</span> <span class="nb">bigint</span><span class="p">,</span> <span class="k">primary</span> <span class="k">key</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">user_id</span><span class="p">));</span>
</code></pre></div>
<p>VSchema:</p>
<div class="highlight"><pre><code class="language-json" data-lang="json"><span class="err">//</span> <span class="err">lookup</span> <span class="err">keyspace</span>
<span class="p">{</span>
  <span class="nt">&quot;sharded&quot;</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
  <span class="nt">&quot;tables&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;name_user_idx&quot;</span><span class="p">:</span> <span class="p">{}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>For a normal unsharded table, the VSchema only needs to know the table name.  No additional metadata is needed.</p>

<h3 id="sharded-table-with-simple-primary-vindex">Sharded Table With Simple Primary Vindex</h3>

<p>To create a sharded table with a simple Primary Vindex, the VSchema requires more information:</p>

<p>Schema:</p>
<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="o">#</span> <span class="k">user</span> <span class="n">keyspace</span>
<span class="k">create</span> <span class="k">table</span> <span class="k">user</span><span class="p">(</span><span class="n">user_id</span> <span class="nb">bigint</span><span class="p">,</span> <span class="n">name</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">128</span><span class="p">),</span> <span class="k">primary</span> <span class="k">key</span><span class="p">(</span><span class="n">user_id</span><span class="p">));</span>
</code></pre></div>
<p>VSchema:</p>
<div class="highlight"><pre><code class="language-json" data-lang="json"><span class="err">//</span> <span class="err">user</span> <span class="err">keyspace</span>
<span class="p">{</span>
  <span class="nt">&quot;sharded&quot;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="nt">&quot;vindexes&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;hash&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;hash&quot;</span>
    <span class="p">},</span>
  <span class="nt">&quot;tables&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;user&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&quot;column_vindexes&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
          <span class="nt">&quot;column&quot;</span><span class="p">:</span> <span class="s2">&quot;user_id&quot;</span><span class="p">,</span>
          <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;hash&quot;</span>
        <span class="p">}</span>
      <span class="p">]</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Because Vindexes can be shared, the JSON requires them to be specified in a separate <code class="prettyprint">vindexes</code> section, and then referenced by name from the <code class="prettyprint">tables</code> section. The VSchema above simply states that <code class="prettyprint">user_id</code> uses <code class="prettyprint">hash</code> as Primary Vindex. The first Vindex of every table must be the Primary Vindex.</p>

<h3 id="specifying-a-sequence">Specifying A Sequence</h3>

<p>Since user is a sharded table, it will be beneficial to tie it to a Sequence. However, the sequence must be defined in the lookup (unsharded) keyspace. It is then referred from the user (sharded) keyspace. In this example, we are designating the user_id (Primary Vindex) column as the auto-increment.</p>

<p>Schema:</p>
<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="o">#</span> <span class="n">lookup</span> <span class="n">keyspace</span>
<span class="k">create</span> <span class="k">table</span> <span class="n">user_seq</span><span class="p">(</span><span class="n">id</span> <span class="nb">int</span><span class="p">,</span> <span class="n">next_id</span> <span class="nb">bigint</span><span class="p">,</span> <span class="k">cache</span> <span class="nb">bigint</span><span class="p">,</span> <span class="k">primary</span> <span class="k">key</span><span class="p">(</span><span class="n">id</span><span class="p">))</span> <span class="k">comment</span> <span class="s1">&#39;vitess_sequence&#39;</span><span class="p">;</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">user_seq</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">next_id</span><span class="p">,</span> <span class="k">cache</span><span class="p">)</span> <span class="k">values</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</code></pre></div>
<p>For the sequence table, <code class="prettyprint">id</code> is always 0. <code class="prettyprint">next_id</code> starts off as 1, and the cache is usually a medium-sized number like 1000. In our example, we are using a small number to showcase how it works.</p>

<p>VSchema:</p>
<div class="highlight"><pre><code class="language-json" data-lang="json"><span class="err">//</span> <span class="err">lookup</span> <span class="err">keyspace</span>
<span class="p">{</span>
  <span class="nt">&quot;sharded&quot;</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
  <span class="nt">&quot;tables&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;user_seq&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;sequence&quot;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="err">//</span> <span class="err">user</span> <span class="err">keyspace</span>
<span class="p">{</span>
  <span class="nt">&quot;sharded&quot;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="nt">&quot;vindexes&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;hash&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;hash&quot;</span>
    <span class="p">},</span>
  <span class="nt">&quot;tables&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;user&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&quot;column_vindexes&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
          <span class="nt">&quot;column&quot;</span><span class="p">:</span> <span class="s2">&quot;user_id&quot;</span><span class="p">,</span>
          <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;hash&quot;</span>
        <span class="p">}</span>
      <span class="p">],</span>
      <span class="nt">&quot;auto_increment&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&quot;column&quot;</span><span class="p">:</span> <span class="s2">&quot;user_id&quot;</span><span class="p">,</span>
        <span class="nt">&quot;sequence&quot;</span><span class="p">:</span> <span class="s2">&quot;user_seq&quot;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="specifying-a-secondary-vindex">Specifying A Secondary Vindex</h3>

<p>The following snippet shows how to configure a Secondary Vindex that is backed by a lookup table. In this case, the lookup table is configured to be in the unsharded lookup keyspace:</p>

<p>Schema:</p>
<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="o">#</span> <span class="n">lookup</span> <span class="n">keyspace</span>
<span class="k">create</span> <span class="k">table</span> <span class="n">name_user_idx</span><span class="p">(</span><span class="n">name</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">128</span><span class="p">),</span> <span class="n">user_id</span> <span class="nb">bigint</span><span class="p">,</span> <span class="k">primary</span> <span class="k">key</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">user_id</span><span class="p">));</span>
</code></pre></div>
<p>VSchema:</p>
<div class="highlight"><pre><code class="language-json" data-lang="json"><span class="err">//</span> <span class="err">lookup</span> <span class="err">keyspace</span>
<span class="p">{</span>
  <span class="nt">&quot;sharded&quot;</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
  <span class="nt">&quot;tables&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;name_user_idx&quot;</span><span class="p">:</span> <span class="p">{}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="err">//</span> <span class="err">user</span> <span class="err">keyspace</span>
<span class="p">{</span>
  <span class="nt">&quot;sharded&quot;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="nt">&quot;vindexes&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;name_user_idx&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;lookup_hash&quot;</span><span class="p">,</span>
      <span class="nt">&quot;params&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&quot;table&quot;</span><span class="p">:</span> <span class="s2">&quot;name_user_idx&quot;</span><span class="p">,</span>
        <span class="nt">&quot;from&quot;</span><span class="p">:</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span>
        <span class="nt">&quot;to&quot;</span><span class="p">:</span> <span class="s2">&quot;user_id&quot;</span>
      <span class="p">},</span>
      <span class="nt">&quot;owner&quot;</span><span class="p">:</span> <span class="s2">&quot;user&quot;</span>
    <span class="p">},</span>
  <span class="nt">&quot;tables&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;user&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&quot;column_vindexes&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
          <span class="nt">&quot;column&quot;</span><span class="p">:</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span>
          <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;name_user_idx&quot;</span>
        <span class="p">}</span>
      <span class="p">]</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>To recap, a checklist for creating the shared Secondary Vindex is:</p>

<ul>
<li>Create physical <code class="prettyprint">name_user_idx</code> table in lookup database.</li>
<li>Define a routing for it in the lookup VSchema.</li>
<li>Define a Vindex as type <code class="prettyprint">lookup_hash</code> that points to it. Ensure that the <code class="prettyprint">params</code> match the table name and columns.</li>
<li>Define the owner for the Vindex as the <code class="prettyprint">user</code> table.</li>
<li>Specify that <code class="prettyprint">name</code> uses the Vindex.</li>
</ul>

<p>Currently, these steps have to be currently performed manually. However, extended DDLs backed by improved automation will simplify these tasks in the future.</p>

<h3 id="advanced-usage">Advanced usage</h3>

<p>The examples/demo also shows more tricks you can perform:</p>

<ul>
<li>The <code class="prettyprint">music</code> table uses a secondary lookup vindex <code class="prettyprint">music_user_idx</code>. However, this lookup vindex is itself a sharded table.</li>
<li><code class="prettyprint">music_extra</code> shares <code class="prettyprint">music_user_idx</code> with <code class="prettyprint">music</code>, and uses it as Primary Vindex.</li>
<li><code class="prettyprint">music_extra</code> defines an additional Functional Vindex called <code class="prettyprint">keyspace_id</code> which the demo auto-populates using the reverse mapping capability.</li>
<li>There is also a <code class="prettyprint">name_info</code> table that showcases a case-insensitive Vindex <code class="prettyprint">unicode_loose_md5</code>.</li>
</ul>

<h2 id="roadmap">Roadmap</h2>

<p>VSchema is still evolving. Features are mostly added on demand. The following features are currently on our roadmap:</p>

<ul>
<li>DDL support</li>
<li>Lookup Vindex backfill</li>
<li>Pinned tables: This feature will allow unsharded tables to be pinned to a keypsace id. This avoids the need for a separate unsharded keyspace to contain them.</li>
</ul>

      </div>
    </div>
  </div>

</div>

    <div class="page-spacer"></div>
    <footer role="contentinfo" id="site-footer">
  <nav role="navigation" class="menu bottom-menu">
    
    <a href="https://groups.google.com/forum/#!forum/vitess" target="_blank">Contact: vitess@googlegroups.com</a>&nbsp;&nbsp;<b>·</b>&nbsp;&nbsp;
    <a href="https://groups.google.com/forum/#!forum/vitess-announce" target="_blank">Announcements</a>&nbsp;&nbsp;<b>·</b>&nbsp;&nbsp;
    &#169; 2017 <a href="/">Vitess</a> powered by <a href="https://developers.google.com/open-source/">Google Inc</a>
  </nav>
</footer>


        <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
<!--    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>   -->
    <!-- Include all compiled plugins (below), or include individual files as needed -->
<!--
    <script src="/libs/bootstrap/js/bootstrap.min.js"></script>
-->
    <!-- Include the common site javascript -->
    <script src="/js/common.js" type="text/javascript" charset="utf-8"></script>


  </body>
</html>
