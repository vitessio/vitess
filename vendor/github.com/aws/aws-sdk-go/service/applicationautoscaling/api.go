// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.

// Package applicationautoscaling provides a client for Application Auto Scaling.
package applicationautoscaling

import (
	"fmt"
	"time"

	"github.com/aws/aws-sdk-go/aws/awsutil"
	"github.com/aws/aws-sdk-go/aws/request"
)

const opDeleteScalingPolicy = "DeleteScalingPolicy"

// DeleteScalingPolicyRequest generates a request for the DeleteScalingPolicy operation.
func (c *ApplicationAutoScaling) DeleteScalingPolicyRequest(input *DeleteScalingPolicyInput) (req *request.Request, output *DeleteScalingPolicyOutput) {
	op := &request.Operation{
		Name:       opDeleteScalingPolicy,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DeleteScalingPolicyInput{}
	}

	req = c.newRequest(op, input, output)
	output = &DeleteScalingPolicyOutput{}
	req.Data = output
	return
}

// Deletes an Application Auto Scaling scaling policy that was previously created.
// If you are no longer using a scaling policy, you can delete it with this
// operation.
//
// Deleting a policy deletes the underlying alarm action, but does not delete
// the CloudWatch alarm, even if it no longer has an associated action.
//
// To create a new scaling policy or update an existing one, see PutScalingPolicy.
func (c *ApplicationAutoScaling) DeleteScalingPolicy(input *DeleteScalingPolicyInput) (*DeleteScalingPolicyOutput, error) {
	req, out := c.DeleteScalingPolicyRequest(input)
	err := req.Send()
	return out, err
}

const opDeregisterScalableTarget = "DeregisterScalableTarget"

// DeregisterScalableTargetRequest generates a request for the DeregisterScalableTarget operation.
func (c *ApplicationAutoScaling) DeregisterScalableTargetRequest(input *DeregisterScalableTargetInput) (req *request.Request, output *DeregisterScalableTargetOutput) {
	op := &request.Operation{
		Name:       opDeregisterScalableTarget,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DeregisterScalableTargetInput{}
	}

	req = c.newRequest(op, input, output)
	output = &DeregisterScalableTargetOutput{}
	req.Data = output
	return
}

// Deregisters a scalable target that was previously registered. If you are
// no longer using a scalable target, you can delete it with this operation.
// When you deregister a scalable target, all of the scaling policies that are
// associated with that scalable target are deleted.
//
// To create a new scalable target or update an existing one, see RegisterScalableTarget.
func (c *ApplicationAutoScaling) DeregisterScalableTarget(input *DeregisterScalableTargetInput) (*DeregisterScalableTargetOutput, error) {
	req, out := c.DeregisterScalableTargetRequest(input)
	err := req.Send()
	return out, err
}

const opDescribeScalableTargets = "DescribeScalableTargets"

// DescribeScalableTargetsRequest generates a request for the DescribeScalableTargets operation.
func (c *ApplicationAutoScaling) DescribeScalableTargetsRequest(input *DescribeScalableTargetsInput) (req *request.Request, output *DescribeScalableTargetsOutput) {
	op := &request.Operation{
		Name:       opDescribeScalableTargets,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &request.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "MaxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &DescribeScalableTargetsInput{}
	}

	req = c.newRequest(op, input, output)
	output = &DescribeScalableTargetsOutput{}
	req.Data = output
	return
}

// Provides descriptive information for scalable targets with a specified service
// namespace.
//
// You can filter the results in a service namespace with the ResourceIds and
// ScalableDimension parameters.
//
// To create a new scalable target or update an existing one, see RegisterScalableTarget.
// If you are no longer using a scalable target, you can deregister it with
// DeregisterScalableTarget.
func (c *ApplicationAutoScaling) DescribeScalableTargets(input *DescribeScalableTargetsInput) (*DescribeScalableTargetsOutput, error) {
	req, out := c.DescribeScalableTargetsRequest(input)
	err := req.Send()
	return out, err
}

func (c *ApplicationAutoScaling) DescribeScalableTargetsPages(input *DescribeScalableTargetsInput, fn func(p *DescribeScalableTargetsOutput, lastPage bool) (shouldContinue bool)) error {
	page, _ := c.DescribeScalableTargetsRequest(input)
	page.Handlers.Build.PushBack(request.MakeAddToUserAgentFreeFormHandler("Paginator"))
	return page.EachPage(func(p interface{}, lastPage bool) bool {
		return fn(p.(*DescribeScalableTargetsOutput), lastPage)
	})
}

const opDescribeScalingActivities = "DescribeScalingActivities"

// DescribeScalingActivitiesRequest generates a request for the DescribeScalingActivities operation.
func (c *ApplicationAutoScaling) DescribeScalingActivitiesRequest(input *DescribeScalingActivitiesInput) (req *request.Request, output *DescribeScalingActivitiesOutput) {
	op := &request.Operation{
		Name:       opDescribeScalingActivities,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &request.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "MaxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &DescribeScalingActivitiesInput{}
	}

	req = c.newRequest(op, input, output)
	output = &DescribeScalingActivitiesOutput{}
	req.Data = output
	return
}

// Provides descriptive information for scaling activities with a specified
// service namespace.
//
// You can filter the results in a service namespace with the ResourceId and
// ScalableDimension parameters.
//
// Scaling activities are triggered by CloudWatch alarms that are associated
// with scaling policies. To view the existing scaling policies for a service
// namespace, see DescribeScalingPolicies. To create a new scaling policy or
// update an existing one, see PutScalingPolicy.
func (c *ApplicationAutoScaling) DescribeScalingActivities(input *DescribeScalingActivitiesInput) (*DescribeScalingActivitiesOutput, error) {
	req, out := c.DescribeScalingActivitiesRequest(input)
	err := req.Send()
	return out, err
}

func (c *ApplicationAutoScaling) DescribeScalingActivitiesPages(input *DescribeScalingActivitiesInput, fn func(p *DescribeScalingActivitiesOutput, lastPage bool) (shouldContinue bool)) error {
	page, _ := c.DescribeScalingActivitiesRequest(input)
	page.Handlers.Build.PushBack(request.MakeAddToUserAgentFreeFormHandler("Paginator"))
	return page.EachPage(func(p interface{}, lastPage bool) bool {
		return fn(p.(*DescribeScalingActivitiesOutput), lastPage)
	})
}

const opDescribeScalingPolicies = "DescribeScalingPolicies"

// DescribeScalingPoliciesRequest generates a request for the DescribeScalingPolicies operation.
func (c *ApplicationAutoScaling) DescribeScalingPoliciesRequest(input *DescribeScalingPoliciesInput) (req *request.Request, output *DescribeScalingPoliciesOutput) {
	op := &request.Operation{
		Name:       opDescribeScalingPolicies,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &request.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "MaxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &DescribeScalingPoliciesInput{}
	}

	req = c.newRequest(op, input, output)
	output = &DescribeScalingPoliciesOutput{}
	req.Data = output
	return
}

// Provides descriptive information for scaling policies with a specified service
// namespace.
//
// You can filter the results in a service namespace with the ResourceId, ScalableDimension,
// and PolicyNames parameters.
//
// To create a new scaling policy or update an existing one, see PutScalingPolicy.
// If you are no longer using a scaling policy, you can delete it with DeleteScalingPolicy.
func (c *ApplicationAutoScaling) DescribeScalingPolicies(input *DescribeScalingPoliciesInput) (*DescribeScalingPoliciesOutput, error) {
	req, out := c.DescribeScalingPoliciesRequest(input)
	err := req.Send()
	return out, err
}

func (c *ApplicationAutoScaling) DescribeScalingPoliciesPages(input *DescribeScalingPoliciesInput, fn func(p *DescribeScalingPoliciesOutput, lastPage bool) (shouldContinue bool)) error {
	page, _ := c.DescribeScalingPoliciesRequest(input)
	page.Handlers.Build.PushBack(request.MakeAddToUserAgentFreeFormHandler("Paginator"))
	return page.EachPage(func(p interface{}, lastPage bool) bool {
		return fn(p.(*DescribeScalingPoliciesOutput), lastPage)
	})
}

const opPutScalingPolicy = "PutScalingPolicy"

// PutScalingPolicyRequest generates a request for the PutScalingPolicy operation.
func (c *ApplicationAutoScaling) PutScalingPolicyRequest(input *PutScalingPolicyInput) (req *request.Request, output *PutScalingPolicyOutput) {
	op := &request.Operation{
		Name:       opPutScalingPolicy,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &PutScalingPolicyInput{}
	}

	req = c.newRequest(op, input, output)
	output = &PutScalingPolicyOutput{}
	req.Data = output
	return
}

// Creates or updates a policy for an existing Application Auto Scaling scalable
// target. Each scalable target is identified by service namespace, a resource
// ID, and a scalable dimension, and a scaling policy applies to a scalable
// target that is identified by those three attributes. You cannot create a
// scaling policy without first registering a scalable target with RegisterScalableTarget.
//
// To update an existing policy, use the existing policy name and set the parameters
// you want to change. Any existing parameter not changed in an update to an
// existing policy is not changed in this update request.
//
// You can view the existing scaling policies for a service namespace with
// DescribeScalingPolicies. If you are no longer using a scaling policy, you
// can delete it with DeleteScalingPolicy.
func (c *ApplicationAutoScaling) PutScalingPolicy(input *PutScalingPolicyInput) (*PutScalingPolicyOutput, error) {
	req, out := c.PutScalingPolicyRequest(input)
	err := req.Send()
	return out, err
}

const opRegisterScalableTarget = "RegisterScalableTarget"

// RegisterScalableTargetRequest generates a request for the RegisterScalableTarget operation.
func (c *ApplicationAutoScaling) RegisterScalableTargetRequest(input *RegisterScalableTargetInput) (req *request.Request, output *RegisterScalableTargetOutput) {
	op := &request.Operation{
		Name:       opRegisterScalableTarget,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &RegisterScalableTargetInput{}
	}

	req = c.newRequest(op, input, output)
	output = &RegisterScalableTargetOutput{}
	req.Data = output
	return
}

// Registers or updates a scalable target. A scalable target is a resource that
// can be scaled up or down with Application Auto Scaling. After you have registered
// a scalable target, you can use this command to update the minimum and maximum
// values for your scalable dimension.
//
//  At this time, Application Auto Scaling only supports scaling Amazon ECS
// services.
//
//  After you register a scalable target with Application Auto Scaling, you
// can create and apply scaling policies to it with PutScalingPolicy. You can
// view the existing scaling policies for a service namespace with DescribeScalableTargets.
// If you are no longer using a scalable target, you can deregister it with
// DeregisterScalableTarget.
func (c *ApplicationAutoScaling) RegisterScalableTarget(input *RegisterScalableTargetInput) (*RegisterScalableTargetOutput, error) {
	req, out := c.RegisterScalableTargetRequest(input)
	err := req.Send()
	return out, err
}

// An object representing a CloudWatch alarm associated with a scaling policy.
type Alarm struct {
	_ struct{} `type:"structure"`

	// The Amazon Resource Name (ARN) of the alarm.
	AlarmARN *string `type:"string" required:"true"`

	// The name of the alarm.
	AlarmName *string `type:"string" required:"true"`
}

// String returns the string representation
func (s Alarm) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Alarm) GoString() string {
	return s.String()
}

type DeleteScalingPolicyInput struct {
	_ struct{} `type:"structure"`

	// The name of the scaling policy to delete.
	PolicyName *string `min:"1" type:"string" required:"true"`

	// The unique identifier string for the resource associated with the scaling
	// policy. For Amazon ECS services, this value is the resource type, followed
	// by the cluster name and service name, such as service/default/sample-webapp.
	ResourceId *string `min:"1" type:"string" required:"true"`

	// The scalable dimension associated with the scaling policy. The scalable dimension
	// contains the service namespace, resource type, and scaling property, such
	// as ecs:service:DesiredCount for the desired task count of an Amazon ECS service.
	ScalableDimension *string `type:"string" required:"true" enum:"ScalableDimension"`

	// The namespace for the AWS service that the scaling policy is associated with.
	// For more information, see AWS Service Namespaces (http://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces)
	// in the Amazon Web Services General Reference.
	ServiceNamespace *string `type:"string" required:"true" enum:"ServiceNamespace"`
}

// String returns the string representation
func (s DeleteScalingPolicyInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteScalingPolicyInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteScalingPolicyInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "DeleteScalingPolicyInput"}
	if s.PolicyName == nil {
		invalidParams.Add(request.NewErrParamRequired("PolicyName"))
	}
	if s.PolicyName != nil && len(*s.PolicyName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("PolicyName", 1))
	}
	if s.ResourceId == nil {
		invalidParams.Add(request.NewErrParamRequired("ResourceId"))
	}
	if s.ResourceId != nil && len(*s.ResourceId) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("ResourceId", 1))
	}
	if s.ScalableDimension == nil {
		invalidParams.Add(request.NewErrParamRequired("ScalableDimension"))
	}
	if s.ServiceNamespace == nil {
		invalidParams.Add(request.NewErrParamRequired("ServiceNamespace"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

type DeleteScalingPolicyOutput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s DeleteScalingPolicyOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteScalingPolicyOutput) GoString() string {
	return s.String()
}

type DeregisterScalableTargetInput struct {
	_ struct{} `type:"structure"`

	// The unique identifier string for the resource associated with the scalable
	// target. For Amazon ECS services, this value is the resource type, followed
	// by the cluster name and service name, such as service/default/sample-webapp.
	ResourceId *string `min:"1" type:"string" required:"true"`

	// The scalable dimension associated with the scalable target. The scalable
	// dimension contains the service namespace, resource type, and scaling property,
	// such as ecs:service:DesiredCount for the desired task count of an Amazon
	// ECS service.
	ScalableDimension *string `type:"string" required:"true" enum:"ScalableDimension"`

	// The namespace for the AWS service that the scalable target is associated
	// with. For more information, see AWS Service Namespaces (http://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces)
	// in the Amazon Web Services General Reference.
	ServiceNamespace *string `type:"string" required:"true" enum:"ServiceNamespace"`
}

// String returns the string representation
func (s DeregisterScalableTargetInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeregisterScalableTargetInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeregisterScalableTargetInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "DeregisterScalableTargetInput"}
	if s.ResourceId == nil {
		invalidParams.Add(request.NewErrParamRequired("ResourceId"))
	}
	if s.ResourceId != nil && len(*s.ResourceId) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("ResourceId", 1))
	}
	if s.ScalableDimension == nil {
		invalidParams.Add(request.NewErrParamRequired("ScalableDimension"))
	}
	if s.ServiceNamespace == nil {
		invalidParams.Add(request.NewErrParamRequired("ServiceNamespace"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

type DeregisterScalableTargetOutput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s DeregisterScalableTargetOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeregisterScalableTargetOutput) GoString() string {
	return s.String()
}

type DescribeScalableTargetsInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of scalable target results returned by DescribeScalableTargets
	// in paginated output. When this parameter is used, DescribeScalableTargets
	// returns up to MaxResults results in a single page along with a NextToken
	// response element. The remaining results of the initial request can be seen
	// by sending another DescribeScalableTargets request with the returned NextToken
	// value. This value can be between 1 and 50. If this parameter is not used,
	// then DescribeScalableTargets returns up to 50 results and a NextToken value,
	// if applicable.
	MaxResults *int64 `type:"integer"`

	// The NextToken value returned from a previous paginated DescribeScalableTargets
	// request. Pagination continues from the end of the previous results that returned
	// the NextToken value. This value is null when there are no more results to
	// return.
	NextToken *string `type:"string"`

	// The unique identifier string for the resource associated with the scalable
	// target. For Amazon ECS services, this value is the resource type, followed
	// by the cluster name and service name, such as service/default/sample-webapp.
	// If you specify a scalable dimension, you must also specify a resource ID.
	ResourceIds []*string `type:"list"`

	// The scalable dimension associated with the scalable target. The scalable
	// dimension contains the service namespace, resource type, and scaling property,
	// such as ecs:service:DesiredCount for the desired task count of an Amazon
	// ECS service. If you specify a scalable dimension, you must also specify a
	// resource ID.
	ScalableDimension *string `type:"string" enum:"ScalableDimension"`

	// The namespace for the AWS service that the scalable target is associated
	// with. For more information, see AWS Service Namespaces (http://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces)
	// in the Amazon Web Services General Reference.
	ServiceNamespace *string `type:"string" required:"true" enum:"ServiceNamespace"`
}

// String returns the string representation
func (s DescribeScalableTargetsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeScalableTargetsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeScalableTargetsInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "DescribeScalableTargetsInput"}
	if s.ServiceNamespace == nil {
		invalidParams.Add(request.NewErrParamRequired("ServiceNamespace"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

type DescribeScalableTargetsOutput struct {
	_ struct{} `type:"structure"`

	// The NextToken value to include in a future DescribeScalableTargets request.
	// When the results of a DescribeScalableTargets request exceed MaxResults,
	// this value can be used to retrieve the next page of results. This value is
	// null when there are no more results to return.
	NextToken *string `type:"string"`

	// The list of scalable targets that matches the request parameters.
	ScalableTargets []*ScalableTarget `type:"list"`
}

// String returns the string representation
func (s DescribeScalableTargetsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeScalableTargetsOutput) GoString() string {
	return s.String()
}

type DescribeScalingActivitiesInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of scaling activity results returned by DescribeScalingActivities
	// in paginated output. When this parameter is used, DescribeScalingActivities
	// returns up to MaxResults results in a single page along with a NextToken
	// response element. The remaining results of the initial request can be seen
	// by sending another DescribeScalingActivities request with the returned NextToken
	// value. This value can be between 1 and 50. If this parameter is not used,
	// then DescribeScalingActivities returns up to 50 results and a NextToken value,
	// if applicable.
	MaxResults *int64 `type:"integer"`

	// The NextToken value returned from a previous paginated DescribeScalingActivities
	// request. Pagination continues from the end of the previous results that returned
	// the NextToken value. This value is null when there are no more results to
	// return.
	NextToken *string `type:"string"`

	// The unique identifier string for the resource associated with the scaling
	// activity. For Amazon ECS services, this value is the resource type, followed
	// by the cluster name and service name, such as service/default/sample-webapp.
	// If you specify a scalable dimension, you must also specify a resource ID.
	ResourceId *string `min:"1" type:"string"`

	// The scalable dimension associated with the scaling activity. The scalable
	// dimension contains the service namespace, resource type, and scaling property,
	// such as ecs:service:DesiredCount for the desired task count of an Amazon
	// ECS service. If you specify a scalable dimension, you must also specify a
	// resource ID.
	ScalableDimension *string `type:"string" enum:"ScalableDimension"`

	// The namespace for the AWS service that the scaling activity is associated
	// with. For more information, see AWS Service Namespaces (http://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces)
	// in the Amazon Web Services General Reference.
	ServiceNamespace *string `type:"string" required:"true" enum:"ServiceNamespace"`
}

// String returns the string representation
func (s DescribeScalingActivitiesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeScalingActivitiesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeScalingActivitiesInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "DescribeScalingActivitiesInput"}
	if s.ResourceId != nil && len(*s.ResourceId) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("ResourceId", 1))
	}
	if s.ServiceNamespace == nil {
		invalidParams.Add(request.NewErrParamRequired("ServiceNamespace"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

type DescribeScalingActivitiesOutput struct {
	_ struct{} `type:"structure"`

	// The NextToken value to include in a future DescribeScalingActivities request.
	// When the results of a DescribeScalingActivities request exceed MaxResults,
	// this value can be used to retrieve the next page of results. This value is
	// null when there are no more results to return.
	NextToken *string `type:"string"`

	// A list of scaling activity objects.
	ScalingActivities []*ScalingActivity `type:"list"`
}

// String returns the string representation
func (s DescribeScalingActivitiesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeScalingActivitiesOutput) GoString() string {
	return s.String()
}

type DescribeScalingPoliciesInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of scaling policy results returned by DescribeScalingPolicies
	// in paginated output. When this parameter is used, DescribeScalingPolicies
	// returns up to MaxResults results in a single page along with a NextToken
	// response element. The remaining results of the initial request can be seen
	// by sending another DescribeScalingPolicies request with the returned NextToken
	// value. This value can be between 1 and 50. If this parameter is not used,
	// then DescribeScalingPolicies returns up to 50 results and a NextToken value,
	// if applicable.
	MaxResults *int64 `type:"integer"`

	// The NextToken value returned from a previous paginated DescribeScalingPolicies
	// request. Pagination continues from the end of the previous results that returned
	// the NextToken value. This value is null when there are no more results to
	// return.
	NextToken *string `type:"string"`

	// The names of the scaling policies to describe.
	PolicyNames []*string `type:"list"`

	// The unique resource identifier string of the scalable target that the scaling
	// policy is associated with. For Amazon ECS services, this value is the resource
	// type, followed by the cluster name and service name, such as service/default/sample-webapp.
	// If you specify a scalable dimension, you must also specify a resource ID.
	ResourceId *string `min:"1" type:"string"`

	// The scalable dimension of the scalable target that the scaling policy is
	// associated with. The scalable dimension contains the service namespace, resource
	// type, and scaling property, such as ecs:service:DesiredCount for the desired
	// task count of an Amazon ECS service. If you specify a scalable dimension,
	// you must also specify a resource ID.
	ScalableDimension *string `type:"string" enum:"ScalableDimension"`

	// The AWS service namespace of the scalable target that the scaling policy
	// is associated with. For more information, see AWS Service Namespaces (http://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces)
	// in the Amazon Web Services General Reference.
	ServiceNamespace *string `type:"string" required:"true" enum:"ServiceNamespace"`
}

// String returns the string representation
func (s DescribeScalingPoliciesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeScalingPoliciesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeScalingPoliciesInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "DescribeScalingPoliciesInput"}
	if s.ResourceId != nil && len(*s.ResourceId) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("ResourceId", 1))
	}
	if s.ServiceNamespace == nil {
		invalidParams.Add(request.NewErrParamRequired("ServiceNamespace"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

type DescribeScalingPoliciesOutput struct {
	_ struct{} `type:"structure"`

	// The NextToken value to include in a future DescribeScalingPolicies request.
	// When the results of a DescribeScalingPolicies request exceed MaxResults,
	// this value can be used to retrieve the next page of results. This value is
	// null when there are no more results to return.
	NextToken *string `type:"string"`

	// A list of scaling policy objects.
	ScalingPolicies []*ScalingPolicy `type:"list"`
}

// String returns the string representation
func (s DescribeScalingPoliciesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeScalingPoliciesOutput) GoString() string {
	return s.String()
}

type PutScalingPolicyInput struct {
	_ struct{} `type:"structure"`

	// The name of the scaling policy.
	PolicyName *string `min:"1" type:"string" required:"true"`

	// The policy type. This parameter is required if you are creating a new policy.
	PolicyType *string `type:"string" enum:"PolicyType"`

	// The unique resource identifier string for the scalable target that this scaling
	// policy applies to. For Amazon ECS services, this value is the resource type,
	// followed by the cluster name and service name, such as service/default/sample-webapp.
	ResourceId *string `min:"1" type:"string" required:"true"`

	// The scalable dimension of the scalable target that this scaling policy applies
	// to. The scalable dimension contains the service namespace, resource type,
	// and scaling property, such as ecs:service:DesiredCount for the desired task
	// count of an Amazon ECS service.
	ScalableDimension *string `type:"string" required:"true" enum:"ScalableDimension"`

	// The AWS service namespace of the scalable target that this scaling policy
	// applies to. For more information, see AWS Service Namespaces (http://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces)
	// in the Amazon Web Services General Reference.
	ServiceNamespace *string `type:"string" required:"true" enum:"ServiceNamespace"`

	// The configuration for the step scaling policy. This parameter is required
	// if you are creating a new policy. For more information, see StepScalingPolicyConfiguration
	// and StepAdjustment.
	StepScalingPolicyConfiguration *StepScalingPolicyConfiguration `type:"structure"`
}

// String returns the string representation
func (s PutScalingPolicyInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutScalingPolicyInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *PutScalingPolicyInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "PutScalingPolicyInput"}
	if s.PolicyName == nil {
		invalidParams.Add(request.NewErrParamRequired("PolicyName"))
	}
	if s.PolicyName != nil && len(*s.PolicyName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("PolicyName", 1))
	}
	if s.ResourceId == nil {
		invalidParams.Add(request.NewErrParamRequired("ResourceId"))
	}
	if s.ResourceId != nil && len(*s.ResourceId) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("ResourceId", 1))
	}
	if s.ScalableDimension == nil {
		invalidParams.Add(request.NewErrParamRequired("ScalableDimension"))
	}
	if s.ServiceNamespace == nil {
		invalidParams.Add(request.NewErrParamRequired("ServiceNamespace"))
	}
	if s.StepScalingPolicyConfiguration != nil {
		if err := s.StepScalingPolicyConfiguration.Validate(); err != nil {
			invalidParams.AddNested("StepScalingPolicyConfiguration", err.(request.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

type PutScalingPolicyOutput struct {
	_ struct{} `type:"structure"`

	// The Amazon Resource Name (ARN) of the resulting scaling policy.
	PolicyARN *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s PutScalingPolicyOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutScalingPolicyOutput) GoString() string {
	return s.String()
}

type RegisterScalableTargetInput struct {
	_ struct{} `type:"structure"`

	// The maximum value for this scalable target to scale out to in response to
	// scaling activities. This parameter is required if you are registering a new
	// scalable target, and it is optional if you are updating an existing one.
	MaxCapacity *int64 `type:"integer"`

	// The minimum value for this scalable target to scale in to in response to
	// scaling activities. This parameter is required if you are registering a new
	// scalable target, and it is optional if you are updating an existing one.
	MinCapacity *int64 `type:"integer"`

	// The unique identifier string for the resource to associate with the scalable
	// target. For Amazon ECS services, this value is the resource type, followed
	// by the cluster name and service name, such as service/default/sample-webapp.
	ResourceId *string `min:"1" type:"string" required:"true"`

	// The ARN of the IAM role that allows Application Auto Scaling to modify your
	// scalable target on your behalf. This parameter is required if you are registering
	// a new scalable target, and it is optional if you are updating an existing
	// one.
	RoleARN *string `min:"1" type:"string"`

	// The scalable dimension associated with the scalable target. The scalable
	// dimension contains the service namespace, resource type, and scaling property,
	// such as ecs:service:DesiredCount for the desired task count of an Amazon
	// ECS service.
	ScalableDimension *string `type:"string" required:"true" enum:"ScalableDimension"`

	// The namespace for the AWS service that the scalable target is associated
	// with. For Amazon ECS services, the namespace value is ecs. For more information,
	// see AWS Service Namespaces (http://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces)
	// in the Amazon Web Services General Reference.
	ServiceNamespace *string `type:"string" required:"true" enum:"ServiceNamespace"`
}

// String returns the string representation
func (s RegisterScalableTargetInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RegisterScalableTargetInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *RegisterScalableTargetInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "RegisterScalableTargetInput"}
	if s.ResourceId == nil {
		invalidParams.Add(request.NewErrParamRequired("ResourceId"))
	}
	if s.ResourceId != nil && len(*s.ResourceId) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("ResourceId", 1))
	}
	if s.RoleARN != nil && len(*s.RoleARN) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RoleARN", 1))
	}
	if s.ScalableDimension == nil {
		invalidParams.Add(request.NewErrParamRequired("ScalableDimension"))
	}
	if s.ServiceNamespace == nil {
		invalidParams.Add(request.NewErrParamRequired("ServiceNamespace"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

type RegisterScalableTargetOutput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s RegisterScalableTargetOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RegisterScalableTargetOutput) GoString() string {
	return s.String()
}

// An object representing a scalable target.
type ScalableTarget struct {
	_ struct{} `type:"structure"`

	// The Unix timestamp for when the scalable target was created.
	CreationTime *time.Time `type:"timestamp" timestampFormat:"unix" required:"true"`

	// The maximum value for this scalable target to scale out to in response to
	// scaling activities.
	MaxCapacity *int64 `type:"integer" required:"true"`

	// The minimum value for this scalable target to scale in to in response to
	// scaling activities.
	MinCapacity *int64 `type:"integer" required:"true"`

	// The unique identifier string for the resource associated with the scalable
	// target. For Amazon ECS services, this value is the resource type, followed
	// by the cluster name and service name, such as service/default/sample-webapp.
	ResourceId *string `min:"1" type:"string" required:"true"`

	// The ARN of the IAM role that allows Application Auto Scaling to modify your
	// scalable target on your behalf.
	RoleARN *string `min:"1" type:"string" required:"true"`

	// The scalable dimension associated with the scalable target. The scalable
	// dimension contains the service namespace, resource type, and scaling property,
	// such as ecs:service:DesiredCount for the desired task count of an Amazon
	// ECS service.
	ScalableDimension *string `type:"string" required:"true" enum:"ScalableDimension"`

	// The namespace for the AWS service that the scalable target is associated
	// with. For more information, see AWS Service Namespaces (http://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces)
	// in the Amazon Web Services General Reference.
	ServiceNamespace *string `type:"string" required:"true" enum:"ServiceNamespace"`
}

// String returns the string representation
func (s ScalableTarget) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ScalableTarget) GoString() string {
	return s.String()
}

// An object representing a scaling activity.
type ScalingActivity struct {
	_ struct{} `type:"structure"`

	// The unique identifier string for the scaling activity.
	ActivityId *string `type:"string" required:"true"`

	// A simple description of what caused the scaling activity to happen.
	Cause *string `type:"string" required:"true"`

	// A simple description of what action the scaling activity intends to accomplish.
	Description *string `type:"string" required:"true"`

	// The details about the scaling activity.
	Details *string `type:"string"`

	// The Unix timestamp for when the scaling activity ended.
	EndTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The unique identifier string for the resource associated with the scaling
	// activity. For Amazon ECS services, this value is the resource type, followed
	// by the cluster name and service name, such as service/default/sample-webapp.
	ResourceId *string `min:"1" type:"string" required:"true"`

	// The scalable dimension associated with the scaling activity. The scalable
	// dimension contains the service namespace, resource type, and scaling property,
	// such as ecs:service:DesiredCount for the desired task count of an Amazon
	// ECS service.
	ScalableDimension *string `type:"string" required:"true" enum:"ScalableDimension"`

	// The namespace for the AWS service that the scaling activity is associated
	// with. For more information, see AWS Service Namespaces (http://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces)
	// in the Amazon Web Services General Reference.
	ServiceNamespace *string `type:"string" required:"true" enum:"ServiceNamespace"`

	// The Unix timestamp for when the scaling activity began.
	StartTime *time.Time `type:"timestamp" timestampFormat:"unix" required:"true"`

	// Indicates the status of the scaling activity.
	StatusCode *string `type:"string" required:"true" enum:"ScalingActivityStatusCode"`

	// A simple message about the current status of the scaling activity.
	StatusMessage *string `type:"string"`
}

// String returns the string representation
func (s ScalingActivity) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ScalingActivity) GoString() string {
	return s.String()
}

// An object representing a scaling policy.
type ScalingPolicy struct {
	_ struct{} `type:"structure"`

	// The CloudWatch alarms that are associated with the scaling policy.
	Alarms []*Alarm `type:"list"`

	// The Unix timestamp for when the scaling policy was created.
	CreationTime *time.Time `type:"timestamp" timestampFormat:"unix" required:"true"`

	// The Amazon Resource Name (ARN) of the scaling policy.
	PolicyARN *string `min:"1" type:"string" required:"true"`

	// The name of the scaling policy.
	PolicyName *string `min:"1" type:"string" required:"true"`

	// The scaling policy type.
	PolicyType *string `type:"string" required:"true" enum:"PolicyType"`

	// The unique identifier string for the resource associated with the scaling
	// policy. For Amazon ECS services, this value is the resource type, followed
	// by the cluster name and service name, such as service/default/sample-webapp.
	ResourceId *string `min:"1" type:"string" required:"true"`

	// The scalable dimension associated with the scaling policy. The scalable dimension
	// contains the service namespace, resource type, and scaling property, such
	// as ecs:service:DesiredCount for the desired task count of an Amazon ECS service.
	ScalableDimension *string `type:"string" required:"true" enum:"ScalableDimension"`

	// The namespace for the AWS service that the scaling policy is associated with.
	// For more information, see AWS Service Namespaces (http://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#genref-aws-service-namespaces)
	// in the Amazon Web Services General Reference.
	ServiceNamespace *string `type:"string" required:"true" enum:"ServiceNamespace"`

	// The configuration for the step scaling policy.
	StepScalingPolicyConfiguration *StepScalingPolicyConfiguration `type:"structure"`
}

// String returns the string representation
func (s ScalingPolicy) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ScalingPolicy) GoString() string {
	return s.String()
}

// An object representing a step adjustment for a StepScalingPolicyConfiguration.
// Describes an adjustment based on the difference between the value of the
// aggregated CloudWatch metric and the breach threshold that you've defined
// for the alarm.
//
// For the following examples, suppose that you have an alarm with a breach
// threshold of 50:
//
//   If you want the adjustment to be triggered when the metric is greater
// than or equal to 50 and less than 60, specify a lower bound of 0 and an upper
// bound of 10.
//
//   If you want the adjustment to be triggered when the metric is greater
// than 40 and less than or equal to 50, specify a lower bound of -10 and an
// upper bound of 0.
//
//   There are a few rules for the step adjustments for your step policy:
//
//   The ranges of your step adjustments can't overlap or have a gap.
//
//   At most one step adjustment can have a null lower bound. If one step adjustment
// has a negative lower bound, then there must be a step adjustment with a null
// lower bound.
//
//   At most one step adjustment can have a null upper bound. If one step adjustment
// has a positive upper bound, then there must be a step adjustment with a null
// upper bound.
//
//   The upper and lower bound can't be null in the same step adjustment.
type StepAdjustment struct {
	_ struct{} `type:"structure"`

	// The lower bound for the difference between the alarm threshold and the CloudWatch
	// metric. If the metric value is above the breach threshold, the lower bound
	// is inclusive (the metric must be greater than or equal to the threshold plus
	// the lower bound). Otherwise, it is exclusive (the metric must be greater
	// than the threshold plus the lower bound). A null value indicates negative
	// infinity.
	MetricIntervalLowerBound *float64 `type:"double"`

	// The upper bound for the difference between the alarm threshold and the CloudWatch
	// metric. If the metric value is above the breach threshold, the upper bound
	// is exclusive (the metric must be less than the threshold plus the upper bound).
	// Otherwise, it is inclusive (the metric must be less than or equal to the
	// threshold plus the upper bound). A null value indicates positive infinity.
	//
	// The upper bound must be greater than the lower bound.
	MetricIntervalUpperBound *float64 `type:"double"`

	// The amount by which to scale, based on the specified adjustment type. A positive
	// value adds to the current scalable dimension while a negative number removes
	// from the current scalable dimension.
	ScalingAdjustment *int64 `type:"integer" required:"true"`
}

// String returns the string representation
func (s StepAdjustment) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StepAdjustment) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *StepAdjustment) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "StepAdjustment"}
	if s.ScalingAdjustment == nil {
		invalidParams.Add(request.NewErrParamRequired("ScalingAdjustment"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// An object representing a step scaling policy configuration.
type StepScalingPolicyConfiguration struct {
	_ struct{} `type:"structure"`

	// The adjustment type, which specifies how the ScalingAdjustment parameter
	// in a StepAdjustment is interpreted.
	AdjustmentType *string `type:"string" enum:"AdjustmentType"`

	// The amount of time, in seconds, after a scaling activity completes where
	// previous trigger-related scaling activities can influence future scaling
	// events.
	//
	// For scale out policies, while Cooldown is in effect, the capacity that has
	// been added by the previous scale out event that initiated the Cooldown is
	// calculated as part of the desired capacity for the next scale out. The intention
	// is to continuously (but not excessively) scale out. For example, an alarm
	// triggers a step scaling policy to scale out an Amazon ECS service by 2 tasks,
	// the scaling activity completes successfully, and a Cooldown period of 5 minutes
	// starts. During the Cooldown period, if the alarm triggers the same policy
	// again but at a more aggressive step adjustment to scale out the service by
	// 3 tasks, the 2 tasks that were added in the previous scale out event are
	// considered part of that capacity and only 1 additional task is added to the
	// desired count.
	//
	// For scale in policies, the Cooldown period is used to block subsequent scale
	// in requests until it has expired. The intention is to scale in conservatively
	// to protect your application's availability. However, if another alarm triggers
	// a scale out policy during the Cooldown period after a scale-in, Application
	// Auto Scaling scales out your scalable target immediately.
	Cooldown *int64 `type:"integer"`

	// The aggregation type for the CloudWatch metrics. Valid values are Minimum,
	// Maximum, and Average.
	MetricAggregationType *string `type:"string" enum:"MetricAggregationType"`

	// The minimum number to adjust your scalable dimension as a result of a scaling
	// activity. If the adjustment type is PercentChangeInCapacity, the scaling
	// policy changes the scalable dimension of the scalable target by this amount.
	MinAdjustmentMagnitude *int64 `type:"integer"`

	// A set of adjustments that enable you to scale based on the size of the alarm
	// breach.
	StepAdjustments []*StepAdjustment `type:"list"`
}

// String returns the string representation
func (s StepScalingPolicyConfiguration) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StepScalingPolicyConfiguration) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *StepScalingPolicyConfiguration) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "StepScalingPolicyConfiguration"}
	if s.StepAdjustments != nil {
		for i, v := range s.StepAdjustments {
			if v == nil {
				continue
			}
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "StepAdjustments", i), err.(request.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

const (
	// @enum AdjustmentType
	AdjustmentTypeChangeInCapacity = "ChangeInCapacity"
	// @enum AdjustmentType
	AdjustmentTypePercentChangeInCapacity = "PercentChangeInCapacity"
	// @enum AdjustmentType
	AdjustmentTypeExactCapacity = "ExactCapacity"
)

const (
	// @enum MetricAggregationType
	MetricAggregationTypeAverage = "Average"
	// @enum MetricAggregationType
	MetricAggregationTypeMinimum = "Minimum"
	// @enum MetricAggregationType
	MetricAggregationTypeMaximum = "Maximum"
)

const (
	// @enum PolicyType
	PolicyTypeStepScaling = "StepScaling"
)

const (
	// @enum ScalableDimension
	ScalableDimensionEcsServiceDesiredCount = "ecs:service:DesiredCount"
)

const (
	// @enum ScalingActivityStatusCode
	ScalingActivityStatusCodePending = "Pending"
	// @enum ScalingActivityStatusCode
	ScalingActivityStatusCodeInProgress = "InProgress"
	// @enum ScalingActivityStatusCode
	ScalingActivityStatusCodeSuccessful = "Successful"
	// @enum ScalingActivityStatusCode
	ScalingActivityStatusCodeOverridden = "Overridden"
	// @enum ScalingActivityStatusCode
	ScalingActivityStatusCodeUnfulfilled = "Unfulfilled"
	// @enum ScalingActivityStatusCode
	ScalingActivityStatusCodeFailed = "Failed"
)

const (
	// @enum ServiceNamespace
	ServiceNamespaceEcs = "ecs"
)
