// Code generated by protoc-gen-go. DO NOT EDIT.
// source: google/watcher/v1/watch.proto

/*
Package watcher is a generated protocol buffer package.

It is generated from these files:
	google/watcher/v1/watch.proto

It has these top-level messages:
	Request
	ChangeBatch
	Change
*/
package watcher

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import google_protobuf1 "github.com/golang/protobuf/ptypes/any"
import _ "github.com/golang/protobuf/ptypes/empty"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// A reported value can be in one of the following states:
type Change_State int32

const (
	// The element exists and its full value is included in data.
	Change_EXISTS Change_State = 0
	// The element does not exist.
	Change_DOES_NOT_EXIST Change_State = 1
	// Element may or may not exist. Used only for initial state delivery when
	// the client is not interested in fetching the initial state. See the
	// "Initial State" section above.
	Change_INITIAL_STATE_SKIPPED Change_State = 2
	// The element may exist, but some error has occurred. More information is
	// available in the data field - the value is a serialized Status
	// proto (from [google.rpc.Status][])
	Change_ERROR Change_State = 3
)

var Change_State_name = map[int32]string{
	0: "EXISTS",
	1: "DOES_NOT_EXIST",
	2: "INITIAL_STATE_SKIPPED",
	3: "ERROR",
}
var Change_State_value = map[string]int32{
	"EXISTS":                0,
	"DOES_NOT_EXIST":        1,
	"INITIAL_STATE_SKIPPED": 2,
	"ERROR":                 3,
}

func (x Change_State) String() string {
	return proto.EnumName(Change_State_name, int32(x))
}
func (Change_State) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 0} }

// The message used by the client to register interest in an entity.
type Request struct {
	// The `target` value **must** be a valid URL path pointing to an entity
	// to watch. Note that the service name **must** be
	// removed from the target field (e.g., the target field must say
	// "/foo/bar", not "myservice.googleapis.com/foo/bar"). A client is
	// also allowed to pass system-specific parameters in the URL that
	// are only obeyed by some implementations. Some parameters will be
	// implementation-specific. However, some have predefined meaning
	// and are listed here:
	//
	//  * recursive = true|false [default=false]
	//    If set to true, indicates that the client wants to watch all elements
	//    of entities in the subtree rooted at the entity's name in `target`. For
	//    descendants that are not the immediate children of the target, the
	//    `Change.element` will contain slashes.
	//
	//    Note that some namespaces and entities will not support recursive
	//    watching. When watching such an entity, a client must not set recursive
	//    to true. Otherwise, it will receive an `UNIMPLEMENTED` error.
	//
	// Normal URL encoding must be used inside `target`.  For example, if a query
	// parameter name or value, or the non-query parameter portion of `target`
	// contains a special character, it must be %-encoded.  We recommend that
	// clients and servers use their runtime's URL library to produce and consume
	// target values.
	Target string `protobuf:"bytes,1,opt,name=target" json:"target,omitempty"`
	// The `resume_marker` specifies how much of the existing underlying state is
	// delivered to the client when the watch request is received by the
	// system. The client can set this marker in one of the following ways to get
	// different semantics:
	//
	// *   Parameter is not specified or has the value "".
	//     Semantics: Fetch initial state.
	//     The client wants the entity's initial state to be delivered. See the
	//     description in "Initial State".
	//
	// *   Parameter is set to the string "now" (UTF-8 encoding).
	//     Semantics: Fetch new changes only.
	//     The client just wants to get the changes received by the system after
	//     the watch point. The system may deliver changes from before the watch
	//     point as well.
	//
	// *   Parameter is set to a value received in an earlier
	//     `Change.resume_marker` field while watching the same entity.
	//     Semantics: Resume from a specific point.
	//     The client wants to receive the changes from a specific point; this
	//     value must correspond to a value received in the `Change.resume_marker`
	//     field. The system may deliver changes from before the `resume_marker`
	//     as well. If the system cannot resume the stream from this point (e.g.,
	//     if it is too far behind in the stream), it can raise the
	//     `FAILED_PRECONDITION` error.
	//
	// An implementation MUST support an unspecified parameter and the
	// empty string "" marker (initial state fetching) and the "now" marker.
	// It need not support resuming from a specific point.
	ResumeMarker []byte `protobuf:"bytes,2,opt,name=resume_marker,json=resumeMarker,proto3" json:"resume_marker,omitempty"`
}

func (m *Request) Reset()                    { *m = Request{} }
func (m *Request) String() string            { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()               {}
func (*Request) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Request) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *Request) GetResumeMarker() []byte {
	if m != nil {
		return m.ResumeMarker
	}
	return nil
}

// A batch of Change messages.
type ChangeBatch struct {
	// A list of Change messages.
	Changes []*Change `protobuf:"bytes,1,rep,name=changes" json:"changes,omitempty"`
}

func (m *ChangeBatch) Reset()                    { *m = ChangeBatch{} }
func (m *ChangeBatch) String() string            { return proto.CompactTextString(m) }
func (*ChangeBatch) ProtoMessage()               {}
func (*ChangeBatch) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ChangeBatch) GetChanges() []*Change {
	if m != nil {
		return m.Changes
	}
	return nil
}

// A Change indicates the most recent state of an element.
type Change struct {
	// Name of the element, interpreted relative to the entity's actual
	// name. "" refers to the entity itself. The element name is a valid
	// UTF-8 string.
	Element string `protobuf:"bytes,1,opt,name=element" json:"element,omitempty"`
	// The state of the `element`.
	State Change_State `protobuf:"varint,2,opt,name=state,enum=google.watcher.v1.Change_State" json:"state,omitempty"`
	// The actual change data. This field is present only when `state() == EXISTS`
	// or `state() == ERROR`. Please see [google.protobuf.Any][google.protobuf.Any] about how to use
	// the Any type.
	Data *google_protobuf1.Any `protobuf:"bytes,6,opt,name=data" json:"data,omitempty"`
	// If present, provides a compact representation of all the messages that have
	// been received by the caller for the given entity, e.g., it could be a
	// sequence number or a multi-part timestamp/version vector. This marker can
	// be provided in the Request message, allowing the caller to resume the stream
	// watching at a specific point without fetching the initial state.
	ResumeMarker []byte `protobuf:"bytes,4,opt,name=resume_marker,json=resumeMarker,proto3" json:"resume_marker,omitempty"`
	// If true, this Change is followed by more Changes that are in the same group
	// as this Change.
	Continued bool `protobuf:"varint,5,opt,name=continued" json:"continued,omitempty"`
}

func (m *Change) Reset()                    { *m = Change{} }
func (m *Change) String() string            { return proto.CompactTextString(m) }
func (*Change) ProtoMessage()               {}
func (*Change) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Change) GetElement() string {
	if m != nil {
		return m.Element
	}
	return ""
}

func (m *Change) GetState() Change_State {
	if m != nil {
		return m.State
	}
	return Change_EXISTS
}

func (m *Change) GetData() *google_protobuf1.Any {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Change) GetResumeMarker() []byte {
	if m != nil {
		return m.ResumeMarker
	}
	return nil
}

func (m *Change) GetContinued() bool {
	if m != nil {
		return m.Continued
	}
	return false
}

func init() {
	proto.RegisterType((*Request)(nil), "google.watcher.v1.Request")
	proto.RegisterType((*ChangeBatch)(nil), "google.watcher.v1.ChangeBatch")
	proto.RegisterType((*Change)(nil), "google.watcher.v1.Change")
	proto.RegisterEnum("google.watcher.v1.Change_State", Change_State_name, Change_State_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Watcher service

type WatcherClient interface {
	// Start a streaming RPC to get watch information from the server.
	Watch(ctx context.Context, in *Request, opts ...grpc.CallOption) (Watcher_WatchClient, error)
}

type watcherClient struct {
	cc *grpc.ClientConn
}

func NewWatcherClient(cc *grpc.ClientConn) WatcherClient {
	return &watcherClient{cc}
}

func (c *watcherClient) Watch(ctx context.Context, in *Request, opts ...grpc.CallOption) (Watcher_WatchClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Watcher_serviceDesc.Streams[0], c.cc, "/google.watcher.v1.Watcher/Watch", opts...)
	if err != nil {
		return nil, err
	}
	x := &watcherWatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Watcher_WatchClient interface {
	Recv() (*ChangeBatch, error)
	grpc.ClientStream
}

type watcherWatchClient struct {
	grpc.ClientStream
}

func (x *watcherWatchClient) Recv() (*ChangeBatch, error) {
	m := new(ChangeBatch)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Watcher service

type WatcherServer interface {
	// Start a streaming RPC to get watch information from the server.
	Watch(*Request, Watcher_WatchServer) error
}

func RegisterWatcherServer(s *grpc.Server, srv WatcherServer) {
	s.RegisterService(&_Watcher_serviceDesc, srv)
}

func _Watcher_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Request)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(WatcherServer).Watch(m, &watcherWatchServer{stream})
}

type Watcher_WatchServer interface {
	Send(*ChangeBatch) error
	grpc.ServerStream
}

type watcherWatchServer struct {
	grpc.ServerStream
}

func (x *watcherWatchServer) Send(m *ChangeBatch) error {
	return x.ServerStream.SendMsg(m)
}

var _Watcher_serviceDesc = grpc.ServiceDesc{
	ServiceName: "google.watcher.v1.Watcher",
	HandlerType: (*WatcherServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Watch",
			Handler:       _Watcher_Watch_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "google/watcher/v1/watch.proto",
}

func init() { proto.RegisterFile("google/watcher/v1/watch.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 445 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x52, 0x51, 0x6f, 0xd3, 0x30,
	0x10, 0xc6, 0xdd, 0x92, 0xd2, 0xeb, 0x98, 0x3a, 0x0b, 0x50, 0x5a, 0x06, 0x44, 0xe1, 0x25, 0x4f,
	0x09, 0xeb, 0x84, 0x84, 0xc4, 0x53, 0xcb, 0x82, 0x88, 0x60, 0x6b, 0xe5, 0x44, 0x62, 0xe2, 0x25,
	0xf2, 0x3a, 0xe3, 0x55, 0xb4, 0x76, 0x49, 0x9c, 0xa1, 0xbd, 0xf2, 0x17, 0x10, 0xbf, 0x8c, 0xbf,
	0xc0, 0x0f, 0x41, 0xb5, 0x1d, 0x40, 0x74, 0x7d, 0xbb, 0xfb, 0xbe, 0xef, 0xce, 0xf7, 0x9d, 0x0f,
	0x1e, 0x73, 0x29, 0xf9, 0x82, 0xc5, 0x5f, 0xa9, 0x9a, 0x5d, 0xb1, 0x32, 0xbe, 0x3e, 0x32, 0x61,
	0xb4, 0x2a, 0xa5, 0x92, 0xf8, 0xc0, 0xd0, 0x91, 0xa5, 0xa3, 0xeb, 0xa3, 0xc1, 0xa1, 0xad, 0xa0,
	0xab, 0x79, 0x4c, 0x85, 0x90, 0x8a, 0xaa, 0xb9, 0x14, 0x95, 0x29, 0x18, 0xf4, 0x2d, 0xab, 0xb3,
	0x8b, 0xfa, 0x53, 0x4c, 0xc5, 0x8d, 0xa5, 0x1e, 0xfd, 0x4f, 0xb1, 0xe5, 0x4a, 0x59, 0x32, 0x78,
	0x03, 0x6d, 0xc2, 0xbe, 0xd4, 0xac, 0x52, 0xf8, 0x21, 0xb8, 0x8a, 0x96, 0x9c, 0x29, 0x0f, 0xf9,
	0x28, 0xec, 0x10, 0x9b, 0xe1, 0x67, 0x70, 0xaf, 0x64, 0x55, 0xbd, 0x64, 0xc5, 0x92, 0x96, 0x9f,
	0x59, 0xe9, 0xb5, 0x7c, 0x14, 0xee, 0x91, 0x3d, 0x03, 0x9e, 0x6a, 0x2c, 0x18, 0x43, 0xf7, 0xf5,
	0x15, 0x15, 0x9c, 0x8d, 0xd7, 0x13, 0xe3, 0x63, 0x68, 0xcf, 0x74, 0x5a, 0x79, 0xc8, 0xdf, 0x09,
	0xbb, 0xc3, 0x7e, 0xb4, 0xe1, 0x28, 0x32, 0x05, 0xa4, 0x51, 0x06, 0x3f, 0x5a, 0xe0, 0x1a, 0x0c,
	0x7b, 0xd0, 0x66, 0x0b, 0xb6, 0x64, 0xa2, 0x19, 0xa6, 0x49, 0xf1, 0x0b, 0x70, 0x2a, 0x45, 0x15,
	0xd3, 0x53, 0xec, 0x0f, 0x9f, 0x6e, 0xed, 0x1b, 0x65, 0x6b, 0x19, 0x31, 0x6a, 0x1c, 0xc2, 0xee,
	0x25, 0x55, 0xd4, 0x73, 0x7d, 0x14, 0x76, 0x87, 0xf7, 0x9b, 0xaa, 0x66, 0x27, 0xd1, 0x48, 0xdc,
	0x10, 0xad, 0xd8, 0xb4, 0xbb, 0xbb, 0x69, 0x17, 0x1f, 0x42, 0x67, 0x26, 0x85, 0x9a, 0x8b, 0x9a,
	0x5d, 0x7a, 0x8e, 0x8f, 0xc2, 0xbb, 0xe4, 0x2f, 0x10, 0x9c, 0x82, 0xa3, 0x1f, 0xc7, 0x00, 0x6e,
	0x72, 0x9e, 0x66, 0x79, 0xd6, 0xbb, 0x83, 0x31, 0xec, 0x9f, 0x4c, 0x92, 0xac, 0x38, 0x9b, 0xe4,
	0x85, 0x06, 0x7b, 0x08, 0xf7, 0xe1, 0x41, 0x7a, 0x96, 0xe6, 0xe9, 0xe8, 0x7d, 0x91, 0xe5, 0xa3,
	0x3c, 0x29, 0xb2, 0x77, 0xe9, 0x74, 0x9a, 0x9c, 0xf4, 0x5a, 0xb8, 0x03, 0x4e, 0x42, 0xc8, 0x84,
	0xf4, 0x76, 0x86, 0x33, 0x68, 0x7f, 0x30, 0xee, 0xf0, 0x39, 0x38, 0x3a, 0xc4, 0x83, 0x5b, 0x7c,
	0xdb, 0x8f, 0x1c, 0x3c, 0xd9, 0xba, 0x13, 0xfd, 0x39, 0xc1, 0xc1, 0xb7, 0x9f, 0xbf, 0xbe, 0xb7,
	0xba, 0xb8, 0xf3, 0xe7, 0xea, 0x9e, 0xa3, 0xf1, 0xdb, 0x31, 0xe8, 0xce, 0xd3, 0xf5, 0x46, 0xa6,
	0xe8, 0xe3, 0x4b, 0xdb, 0x83, 0xcb, 0x05, 0x15, 0x3c, 0x92, 0x25, 0x8f, 0x39, 0x13, 0x7a, 0x5f,
	0xb1, 0xa1, 0xe8, 0x6a, 0x5e, 0xfd, 0x73, 0xbf, 0xaf, 0x6c, 0x78, 0xe1, 0x6a, 0xd1, 0xf1, 0xef,
	0x00, 0x00, 0x00, 0xff, 0xff, 0x4f, 0x60, 0xe9, 0x84, 0xe3, 0x02, 0x00, 0x00,
}
