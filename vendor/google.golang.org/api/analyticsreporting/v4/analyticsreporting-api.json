{
  "id": "analyticsreporting:v4",
  "auth": {
    "oauth2": {
      "scopes": {
        "https://www.googleapis.com/auth/analytics.readonly": {
          "description": "View your Google Analytics data"
        },
        "https://www.googleapis.com/auth/analytics": {
          "description": "View and manage your Google Analytics data"
        }
      }
    }
  },
  "description": "Accesses Analytics report data.",
  "protocol": "rest",
  "title": "Google Analytics Reporting API",
  "resources": {
    "reports": {
      "methods": {
        "batchGet": {
          "id": "analyticsreporting.reports.batchGet",
          "response": {
            "$ref": "GetReportsResponse"
          },
          "parameterOrder": [],
          "description": "Returns the Analytics data.",
          "request": {
            "$ref": "GetReportsRequest"
          },
          "flatPath": "v4/reports:batchGet",
          "httpMethod": "POST",
          "parameters": {},
          "path": "v4/reports:batchGet",
          "scopes": [
            "https://www.googleapis.com/auth/analytics",
            "https://www.googleapis.com/auth/analytics.readonly"
          ]
        }
      }
    }
  },
  "schemas": {
    "PivotHeader": {
      "description": "The headers for each of the pivot sections defined in the request.",
      "type": "object",
      "properties": {
        "totalPivotGroupsCount": {
          "description": "The total number of groups for this pivot.",
          "type": "integer",
          "format": "int32"
        },
        "pivotHeaderEntries": {
          "description": "A single pivot section header.",
          "type": "array",
          "items": {
            "$ref": "PivotHeaderEntry"
          }
        }
      },
      "id": "PivotHeader"
    },
    "Metric": {
      "description": "[Metrics](https://support.google.com/analytics/answer/1033861)\nare the quantitative measurements. For example, the metric `ga:users`\nindicates the total number of users for the requested time period.",
      "type": "object",
      "properties": {
        "alias": {
          "description": "An alias for the metric expression is an alternate name for the\nexpression. The alias can be used for filtering and sorting. This field\nis optional and is useful if the expression is not a single metric but\na complex expression which cannot be used in filtering and sorting.\nThe alias is also used in the response column header.",
          "type": "string"
        },
        "formattingType": {
          "description": "Specifies how the metric expression should be formatted, for example\n`INTEGER`.",
          "enum": [
            "METRIC_TYPE_UNSPECIFIED",
            "INTEGER",
            "FLOAT",
            "CURRENCY",
            "PERCENT",
            "TIME"
          ],
          "enumDescriptions": [
            "Metric type is unspecified.",
            "Integer metric.",
            "Float metric.",
            "Currency metric.",
            "Percentage metric.",
            "Time metric in `HH:MM:SS` format."
          ],
          "type": "string"
        },
        "expression": {
          "description": "A metric expression in the request. An expression is constructed from one\nor more metrics and numbers. Accepted operators include: Plus (+), Minus\n(-), Negation (Unary -), Divided by (/), Multiplied by (*), Parenthesis,\nPositive cardinal numbers (0-9), can include decimals and is limited to\n1024 characters. Example `ga:totalRefunds/ga:users`, in most cases the\nmetric expression is just a single metric name like `ga:users`.\nAdding mixed `MetricType` (E.g., `CURRENCY` + `PERCENTAGE`) metrics\nwill result in unexpected results.",
          "type": "string"
        }
      },
      "id": "Metric"
    },
    "ColumnHeader": {
      "description": "Column headers.",
      "type": "object",
      "properties": {
        "dimensions": {
          "description": "The dimension names in the response.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "metricHeader": {
          "description": "Metric headers for the metrics in the response.",
          "$ref": "MetricHeader"
        }
      },
      "id": "ColumnHeader"
    },
    "DynamicSegment": {
      "description": "Dynamic segment definition for defining the segment within the request.\nA segment can select users, sessions or both.",
      "type": "object",
      "properties": {
        "sessionSegment": {
          "description": "Session Segment to select sessions to include in the segment.",
          "$ref": "SegmentDefinition"
        },
        "name": {
          "description": "The name of the dynamic segment.",
          "type": "string"
        },
        "userSegment": {
          "description": "User Segment to select users to include in the segment.",
          "$ref": "SegmentDefinition"
        }
      },
      "id": "DynamicSegment"
    },
    "MetricHeader": {
      "description": "The headers for the metrics.",
      "type": "object",
      "properties": {
        "metricHeaderEntries": {
          "description": "Headers for the metrics in the response.",
          "type": "array",
          "items": {
            "$ref": "MetricHeaderEntry"
          }
        },
        "pivotHeaders": {
          "description": "Headers for the pivots in the response.",
          "type": "array",
          "items": {
            "$ref": "PivotHeader"
          }
        }
      },
      "id": "MetricHeader"
    },
    "Report": {
      "description": "The data response corresponding to the request.",
      "type": "object",
      "properties": {
        "columnHeader": {
          "description": "The column headers.",
          "$ref": "ColumnHeader"
        },
        "data": {
          "description": "Response data.",
          "$ref": "ReportData"
        },
        "nextPageToken": {
          "description": "Page token to retrieve the next page of results in the list.",
          "type": "string"
        }
      },
      "id": "Report"
    },
    "SegmentFilterClause": {
      "description": "Filter Clause to be used in a segment definition, can be wither a metric or\na dimension filter.",
      "type": "object",
      "properties": {
        "dimensionFilter": {
          "description": "Dimension Filter for the segment definition.",
          "$ref": "SegmentDimensionFilter"
        },
        "metricFilter": {
          "description": "Metric Filter for the segment definition.",
          "$ref": "SegmentMetricFilter"
        },
        "not": {
          "description": "Matches the complement (`!`) of the filter.",
          "type": "boolean"
        }
      },
      "id": "SegmentFilterClause"
    },
    "DimensionFilter": {
      "description": "Dimension filter specifies the filtering options on a dimension.",
      "type": "object",
      "properties": {
        "dimensionName": {
          "description": "The dimension to filter on. A DimensionFilter must contain a dimension.",
          "type": "string"
        },
        "operator": {
          "description": "How to match the dimension to the expression. The default is REGEXP.",
          "enum": [
            "OPERATOR_UNSPECIFIED",
            "REGEXP",
            "BEGINS_WITH",
            "ENDS_WITH",
            "PARTIAL",
            "EXACT",
            "NUMERIC_EQUAL",
            "NUMERIC_GREATER_THAN",
            "NUMERIC_LESS_THAN",
            "IN_LIST"
          ],
          "enumDescriptions": [
            "If the match type is unspecified, it is treated as a `REGEXP`.",
            "The match expression is treated as a regular expression. All match types\nare not treated as regular expressions.",
            "Matches the value which begin with the match expression provided.",
            "Matches the values which end with the match expression provided.",
            "Substring match.",
            "The value should match the match expression entirely.",
            "Integer comparison filters.\ncase sensitivity is ignored for these and the expression\nis assumed to be a string representing an integer.\nFailure conditions:\n\n- If expression is not a valid int64, the client should expect\n  an error.\n- Input dimensions that are not valid int64 values will never match the\n  filter.",
            "Checks if the dimension is numerically greater than the match\nexpression. Read the description for `NUMERIC_EQUALS` for restrictions.",
            "Checks if the dimension is numerically less than the match expression.\nRead the description for `NUMERIC_EQUALS` for restrictions.",
            "This option is used to specify a dimension filter whose expression can\ntake any value from a selected list of values. This helps avoiding\nevaluating multiple exact match dimension filters which are OR'ed for\nevery single response row. For example:\n\n    expressions: [\"A\", \"B\", \"C\"]\n\nAny response row whose dimension has it is value as A, B or C, matches\nthis DimensionFilter."
          ],
          "type": "string"
        },
        "caseSensitive": {
          "description": "Should the match be case sensitive? Default is false.",
          "type": "boolean"
        },
        "expressions": {
          "description": "Strings or regular expression to match against. Only the first value of\nthe list is used for comparison unless the operator is `IN_LIST`.\nIf `IN_LIST` operator, then the entire list is used to filter the\ndimensions as explained in the description of the `IN_LIST` operator.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "not": {
          "description": "Logical `NOT` operator. If this boolean is set to true, then the matching\ndimension values will be excluded in the report. The default is false.",
          "type": "boolean"
        }
      },
      "id": "DimensionFilter"
    },
    "SegmentDimensionFilter": {
      "description": "Dimension filter specifies the filtering options on a dimension.",
      "type": "object",
      "properties": {
        "maxComparisonValue": {
          "description": "Maximum comparison values for `BETWEEN` match type.",
          "type": "string"
        },
        "dimensionName": {
          "description": "Name of the dimension for which the filter is being applied.",
          "type": "string"
        },
        "caseSensitive": {
          "description": "Should the match be case sensitive, ignored for `IN_LIST` operator.",
          "type": "boolean"
        },
        "operator": {
          "description": "The operator to use to match the dimension with the expressions.",
          "enum": [
            "OPERATOR_UNSPECIFIED",
            "REGEXP",
            "BEGINS_WITH",
            "ENDS_WITH",
            "PARTIAL",
            "EXACT",
            "IN_LIST",
            "NUMERIC_LESS_THAN",
            "NUMERIC_GREATER_THAN",
            "NUMERIC_BETWEEN"
          ],
          "enumDescriptions": [
            "If the match type is unspecified, it is treated as a REGEXP.",
            "The match expression is treated as a regular expression. All other match\ntypes are not treated as regular expressions.",
            "Matches the values which begin with the match expression provided.",
            "Matches the values which end with the match expression provided.",
            "Substring match.",
            "The value should match the match expression entirely.",
            "This option is used to specify a dimension filter whose expression can\ntake any value from a selected list of values. This helps avoiding\nevaluating multiple exact match dimension filters which are OR'ed for\nevery single response row. For example:\n\n    expressions: [\"A\", \"B\", \"C\"]\n\nAny response row whose dimension has it is value as A, B or C, matches\nthis DimensionFilter.",
            "Integer comparison filters.\ncase sensitivity is ignored for these and the expression\nis assumed to be a string representing an integer.\nFailure conditions:\n\n- if expression is not a valid int64, the client should expect\n  an error.\n- input dimensions that are not valid int64 values will never match the\n  filter.\n\nChecks if the dimension is numerically less than the match expression.",
            "Checks if the dimension is numerically greater than the match\nexpression.",
            "Checks if the dimension is numerically between the minimum and maximum\nof the match expression, boundaries excluded."
          ],
          "type": "string"
        },
        "expressions": {
          "description": "The list of expressions, only the first element is used for all operators",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "minComparisonValue": {
          "description": "Minimum comparison values for `BETWEEN` match type.",
          "type": "string"
        }
      },
      "id": "SegmentDimensionFilter"
    },
    "ReportRequest": {
      "description": "The main request class which specifies the Reporting API request.",
      "type": "object",
      "properties": {
        "cohortGroup": {
          "description": "Cohort group associated with this request. If there is a cohort group\nin the request the `ga:cohort` dimension must be present.\nEvery [ReportRequest](#ReportRequest) within a `batchGet` method must\ncontain the same `cohortGroup` definition.",
          "$ref": "CohortGroup"
        },
        "dimensions": {
          "description": "The dimensions requested.\nRequests can have a total of 7 dimensions.",
          "type": "array",
          "items": {
            "$ref": "Dimension"
          }
        },
        "metricFilterClauses": {
          "description": "The metric filter clauses. They are logically combined with the `AND`\noperator.  Metric filters look at only the first date range and not the\ncomparing date range. Note that filtering on metrics occurs after the\nmetrics are aggregated.",
          "type": "array",
          "items": {
            "$ref": "MetricFilterClause"
          }
        },
        "hideTotals": {
          "description": "If set to true, hides the total of all metrics for all the matching rows,\nfor every date range. The default false and will return the totals.",
          "type": "boolean"
        },
        "includeEmptyRows": {
          "description": "If set to false, the response does not include rows if all the retrieved\nmetrics are equal to zero. The default is false which will exclude these\nrows.",
          "type": "boolean"
        },
        "dimensionFilterClauses": {
          "description": "The dimension filter clauses for filtering Dimension Values. They are\nlogically combined with the `AND` operator. Note that filtering occurs\nbefore any dimensions are aggregated, so that the returned metrics\nrepresent the total for only the relevant dimensions.",
          "type": "array",
          "items": {
            "$ref": "DimensionFilterClause"
          }
        },
        "pivots": {
          "description": "The pivot definitions. Requests can have a maximum of 2 pivots.",
          "type": "array",
          "items": {
            "$ref": "Pivot"
          }
        },
        "dateRanges": {
          "description": "Date ranges in the request. The request can have a maximum of 2 date\nranges. The response will contain a set of metric values for each\ncombination of the dimensions for each date range in the request. So, if\nthere are two date ranges, there will be two set of metric values, one for\nthe original date range and one for the second date range.\nThe `reportRequest.dateRanges` field should not be specified for cohorts\nor Lifetime value requests.\nIf a date range is not provided, the default date range is (startDate:\ncurrent date - 7 days, endDate: current date - 1 day). Every\n[ReportRequest](#ReportRequest) within a `batchGet` method must\ncontain the same `dateRanges` definition.",
          "type": "array",
          "items": {
            "$ref": "DateRange"
          }
        },
        "segments": {
          "description": "Segment the data returned for the request. A segment definition helps look\nat a subset of the segment request. A request can contain up to four\nsegments. Every [ReportRequest](#ReportRequest) within a\n`batchGet` method must contain the same `segments` definition. Requests\nwith segments must have the `ga:segment` dimension.",
          "type": "array",
          "items": {
            "$ref": "Segment"
          }
        },
        "samplingLevel": {
          "description": "The desired report\n[sample](https://support.google.com/analytics/answer/2637192) size.\nIf the the `samplingLevel` field is unspecified the `DEFAULT` sampling\nlevel is used. Every [ReportRequest](#ReportRequest) within a\n`batchGet` method must contain the same `samplingLevel` definition. See\n[developer guide](/analytics/devguides/reporting/core/v4/basics#sampling)\n for details.",
          "enum": [
            "SAMPLING_UNSPECIFIED",
            "DEFAULT",
            "SMALL",
            "LARGE"
          ],
          "enumDescriptions": [
            "If the `samplingLevel` field is unspecified the `DEFAULT` sampling level\nis used.",
            "Returns response with a sample size that balances speed and\naccuracy.",
            "It returns a fast response with a smaller sampling size.",
            "Returns a more accurate response using a large sampling size. But this\nmay result in response being slower."
          ],
          "type": "string"
        },
        "metrics": {
          "description": "The metrics requested.\nRequests must specify at least one metric. Requests can have a\ntotal of 10 metrics.",
          "type": "array",
          "items": {
            "$ref": "Metric"
          }
        },
        "pageSize": {
          "description": "Page size is for paging and specifies the maximum number of returned rows.\nPage size should be \u003e= 0. A query returns the default of 1,000 rows.\nThe Analytics Core Reporting API returns a maximum of 10,000 rows per\nrequest, no matter how many you ask for. It can also return fewer rows\nthan requested, if there aren't as many dimension segments as you expect.\nFor instance, there are fewer than 300 possible values for `ga:country`,\nso when segmenting only by country, you can't get more than 300 rows,\neven if you set `pageSize` to a higher value.",
          "type": "integer",
          "format": "int32"
        },
        "orderBys": {
          "description": "Sort order on output rows. To compare two rows, the elements of the\nfollowing are applied in order until a difference is found.  All date\nranges in the output get the same row order.",
          "type": "array",
          "items": {
            "$ref": "OrderBy"
          }
        },
        "filtersExpression": {
          "description": "Dimension or metric filters that restrict the data returned for your\nrequest. To use the `filtersExpression`, supply a dimension or metric on\nwhich to filter, followed by the filter expression. For example, the\nfollowing expression selects `ga:browser` dimension which starts with\nFirefox; `ga:browser=~^Firefox`. For more information on dimensions\nand metric filters, see\n[Filters reference](https://developers.google.com/analytics/devguides/reporting/core/v3/reference#filters).",
          "type": "string"
        },
        "hideValueRanges": {
          "description": "If set to true, hides the minimum and maximum across all matching rows.\nThe default is false and the value ranges are returned.",
          "type": "boolean"
        },
        "viewId": {
          "description": "The Analytics\n[view ID](https://support.google.com/analytics/answer/1009618)\nfrom which to retrieve data. Every [ReportRequest](#ReportRequest)\nwithin a `batchGet` method must contain the same `viewId`.",
          "type": "string"
        },
        "pageToken": {
          "description": "A continuation token to get the next page of the results. Adding this to\nthe request will return the rows after the pageToken. The pageToken should\nbe the value returned in the nextPageToken parameter in the response to\nthe GetReports request.",
          "type": "string"
        }
      },
      "id": "ReportRequest"
    },
    "SimpleSegment": {
      "description": "A Simple segment conditions consist of one or more dimension/metric\nconditions that can be combined.",
      "type": "object",
      "properties": {
        "orFiltersForSegment": {
          "description": "A list of segment filters groups which are combined with logical `AND`\noperator.",
          "type": "array",
          "items": {
            "$ref": "OrFiltersForSegment"
          }
        }
      },
      "id": "SimpleSegment"
    },
    "SegmentDefinition": {
      "description": "SegmentDefinition defines the segment to be a set of SegmentFilters which\nare combined together with a logical `AND` operation.",
      "type": "object",
      "properties": {
        "segmentFilters": {
          "description": "A segment is defined by a set of segment filters which are combined\ntogether with a logical `AND` operation.",
          "type": "array",
          "items": {
            "$ref": "SegmentFilter"
          }
        }
      },
      "id": "SegmentDefinition"
    },
    "SegmentMetricFilter": {
      "description": "Metric filter to be used in a segment filter clause.",
      "type": "object",
      "properties": {
        "metricName": {
          "description": "The metric that will be filtered on. A `metricFilter` must contain a\nmetric name.",
          "type": "string"
        },
        "operator": {
          "description": "Specifies is the operation to perform to compare the metric. The default\nis `EQUAL`.",
          "enum": [
            "UNSPECIFIED_OPERATOR",
            "LESS_THAN",
            "GREATER_THAN",
            "EQUAL",
            "BETWEEN"
          ],
          "enumDescriptions": [
            "Unspecified operator is treated as `LESS_THAN` operator.",
            "Checks if the metric value is less than comparison value.",
            "Checks if the metric value is greater than comparison value.",
            "Equals operator.",
            "For between operator, both the minimum and maximum are exclusive.\nWe will use `LT` and `GT` for comparison."
          ],
          "type": "string"
        },
        "comparisonValue": {
          "description": "The value to compare against. If the operator is `BETWEEN`, this value is\ntreated as minimum comparison value.",
          "type": "string"
        },
        "scope": {
          "description": "Scope for a metric defines the level at which that metric is defined.  The\nspecified metric scope must be equal to or greater than its primary scope\nas defined in the data model. The primary scope is defined by if the\nsegment is selecting users or sessions.",
          "enum": [
            "UNSPECIFIED_SCOPE",
            "PRODUCT",
            "HIT",
            "SESSION",
            "USER"
          ],
          "enumDescriptions": [
            "If the scope is unspecified, it defaults to the condition scope,\n`USER` or `SESSION` depending on if the segment is trying to choose\nusers or sessions.",
            "Product scope.",
            "Hit scope.",
            "Session scope.",
            "User scope."
          ],
          "type": "string"
        },
        "maxComparisonValue": {
          "description": "Max comparison value is only used for `BETWEEN` operator.",
          "type": "string"
        }
      },
      "id": "SegmentMetricFilter"
    },
    "ReportData": {
      "description": "The data part of the report.",
      "type": "object",
      "properties": {
        "rowCount": {
          "description": "Total number of matching rows for this query.",
          "type": "integer",
          "format": "int32"
        },
        "samplingSpaceSizes": {
          "description": "If the results are\n[sampled](https://support.google.com/analytics/answer/2637192),\nthis returns the total number of\nsamples present, one entry per date range. If the results are not sampled\nthis field will not be defined. See\n[developer guide](/analytics/devguides/reporting/core/v4/basics#sampling)\nfor details.",
          "type": "array",
          "items": {
            "type": "string",
            "format": "int64"
          }
        },
        "maximums": {
          "description": "Minimum and maximum values seen over all matching rows. These are both\nempty when `hideValueRanges` in the request is false, or when\nrowCount is zero.",
          "type": "array",
          "items": {
            "$ref": "DateRangeValues"
          }
        },
        "samplesReadCounts": {
          "description": "If the results are\n[sampled](https://support.google.com/analytics/answer/2637192),\nthis returns the total number of samples read, one entry per date range.\nIf the results are not sampled this field will not be defined. See\n[developer guide](/analytics/devguides/reporting/core/v4/basics#sampling)\nfor details.",
          "type": "array",
          "items": {
            "type": "string",
            "format": "int64"
          }
        },
        "minimums": {
          "description": "Minimum and maximum values seen over all matching rows. These are both\nempty when `hideValueRanges` in the request is false, or when\nrowCount is zero.",
          "type": "array",
          "items": {
            "$ref": "DateRangeValues"
          }
        },
        "rows": {
          "description": "There's one ReportRow for every unique combination of dimensions.",
          "type": "array",
          "items": {
            "$ref": "ReportRow"
          }
        },
        "totals": {
          "description": "For each requested date range, for the set of all rows that match\nthe query, every requested value format gets a total. The total\nfor a value format is computed by first totaling the metrics\nmentioned in the value format and then evaluating the value\nformat as a scalar expression.  E.g., The \"totals\" for\n`3 / (ga:sessions + 2)` we compute\n`3 / ((sum of all relevant ga:sessions) + 2)`.\nTotals are computed before pagination.",
          "type": "array",
          "items": {
            "$ref": "DateRangeValues"
          }
        },
        "isDataGolden": {
          "description": "Indicates if response to this request is golden or not. Data is\ngolden when the exact same request will not produce any new results if\nasked at a later point in time.",
          "type": "boolean"
        }
      },
      "id": "ReportData"
    },
    "GetReportsRequest": {
      "description": "The batch request containing multiple report request.",
      "type": "object",
      "properties": {
        "reportRequests": {
          "description": "Requests, each request will have a separate response.\nThere can be a maximum of 5 requests. All requests should have the same\n`dateRanges`, `viewId`, `segments`, `samplingLevel`, and `cohortGroup`.",
          "type": "array",
          "items": {
            "$ref": "ReportRequest"
          }
        }
      },
      "id": "GetReportsRequest"
    },
    "OrderBy": {
      "description": "Specifies the sorting options.",
      "type": "object",
      "properties": {
        "sortOrder": {
          "description": "The sorting order for the field.",
          "enum": [
            "SORT_ORDER_UNSPECIFIED",
            "ASCENDING",
            "DESCENDING"
          ],
          "enumDescriptions": [
            "If the sort order is unspecified, the default is ascending.",
            "Ascending sort. The field will be sorted in an ascending manner.",
            "Descending sort. The field will be sorted in a descending manner."
          ],
          "type": "string"
        },
        "orderType": {
          "description": "The order type. The default orderType is `VALUE`.",
          "enum": [
            "ORDER_TYPE_UNSPECIFIED",
            "VALUE",
            "DELTA",
            "SMART",
            "HISTOGRAM_BUCKET",
            "DIMENSION_AS_INTEGER"
          ],
          "enumDescriptions": [
            "Unspecified order type will be treated as sort based on value.",
            "The sort order is based on the value of the chosen column; looks only at\nthe first date range.",
            "The sort order is based on the difference of the values of the chosen\ncolumn between the first two date ranges.  Usable only if there are\nexactly two date ranges.",
            "The sort order is based on weighted value of the chosen column.  If\ncolumn has n/d format, then weighted value of this ratio will\nbe `(n + totals.n)/(d + totals.d)` Usable only for metrics that\nrepresent ratios.",
            "Histogram order type is applicable only to dimension columns with\nnon-empty histogram-buckets.",
            "If the dimensions are fixed length numbers, ordinary sort would just\nwork fine. `DIMENSION_AS_INTEGER` can be used if the dimensions are\nvariable length numbers."
          ],
          "type": "string"
        },
        "fieldName": {
          "description": "The field which to sort by. The default sort order is ascending. Example:\n`ga:browser`.\nNote, that you can only specify one field for sort here. For example,\n`ga:browser, ga:city` is not valid.",
          "type": "string"
        }
      },
      "id": "OrderBy"
    },
    "Cohort": {
      "description": "Defines a cohort. A cohort is a group of users who share a common\ncharacteristic. For example, all users with the same acquisition date\nbelong to the same cohort.",
      "type": "object",
      "properties": {
        "type": {
          "description": "Type of the cohort. The only supported type as of now is\n`FIRST_VISIT_DATE`. If this field is unspecified the cohort is treated\nas `FIRST_VISIT_DATE` type cohort.",
          "enum": [
            "UNSPECIFIED_COHORT_TYPE",
            "FIRST_VISIT_DATE"
          ],
          "enumDescriptions": [
            "If unspecified it's treated as `FIRST_VISIT_DATE`.",
            "Cohorts that are selected based on first visit date."
          ],
          "type": "string"
        },
        "dateRange": {
          "description": "This is used for `FIRST_VISIT_DATE` cohort, the cohort selects users\nwhose first visit date is between start date and end date defined in the\nDateRange. The date ranges should be aligned for cohort requests. If the\nrequest contains `ga:cohortNthDay` it should be exactly one day long,\nif `ga:cohortNthWeek` it should be aligned to the week boundary (starting\nat Sunday and ending Saturday), and for `ga:cohortNthMonth` the date range\nshould be aligned to the month (starting at the first and ending on the\nlast day of the month).\nFor LTV requests there are no such restrictions.\nYou do not need to supply a date range for the\n`reportsRequest.dateRanges` field.",
          "$ref": "DateRange"
        },
        "name": {
          "description": "A unique name for the cohort. If not defined name will be auto-generated\nwith values cohort_[1234...].",
          "type": "string"
        }
      },
      "id": "Cohort"
    },
    "OrFiltersForSegment": {
      "description": "A list of segment filters in the `OR` group are combined with the logical OR\noperator.",
      "type": "object",
      "properties": {
        "segmentFilterClauses": {
          "description": "List of segment filters to be combined with a `OR` operator.",
          "type": "array",
          "items": {
            "$ref": "SegmentFilterClause"
          }
        }
      },
      "id": "OrFiltersForSegment"
    },
    "SequenceSegment": {
      "description": "Sequence conditions consist of one or more steps, where each step is defined\nby one or more dimension/metric conditions. Multiple steps can be combined\nwith special sequence operators.",
      "type": "object",
      "properties": {
        "firstStepShouldMatchFirstHit": {
          "description": "If set, first step condition must match the first hit of the visitor (in\nthe date range).",
          "type": "boolean"
        },
        "segmentSequenceSteps": {
          "description": "The list of steps in the sequence.",
          "type": "array",
          "items": {
            "$ref": "SegmentSequenceStep"
          }
        }
      },
      "id": "SequenceSegment"
    },
    "SegmentFilter": {
      "description": "SegmentFilter defines the segment to be either a simple or a sequence\nsegment. A simple segment condition contains dimension and metric conditions\nto select the sessions or users. A sequence segment condition can be used to\nselect users or sessions based on sequential conditions.",
      "type": "object",
      "properties": {
        "sequenceSegment": {
          "description": "Sequence conditions consist of one or more steps, where each step is\ndefined by one or more dimension/metric conditions. Multiple steps can\nbe combined with special sequence operators.",
          "$ref": "SequenceSegment"
        },
        "not": {
          "description": "If true, match the complement of simple or sequence segment.\nFor example, to match all visits not from \"New York\", we can define the\nsegment as follows:\n\n      \"sessionSegment\": {\n        \"segmentFilters\": [{\n          \"simpleSegment\" :{\n            \"orFiltersForSegment\": [{\n              \"segmentFilterClauses\":[{\n                \"dimensionFilter\": {\n                  \"dimensionName\": \"ga:city\",\n                  \"expressions\": [\"New York\"]\n                }\n              }]\n            }]\n          },\n          \"not\": \"True\"\n        }]\n      },",
          "type": "boolean"
        },
        "simpleSegment": {
          "description": "A Simple segment conditions consist of one or more dimension/metric\nconditions that can be combined",
          "$ref": "SimpleSegment"
        }
      },
      "id": "SegmentFilter"
    },
    "PivotHeaderEntry": {
      "description": "The headers for the each of the metric column corresponding to the metrics\nrequested in the pivots section of the response.",
      "type": "object",
      "properties": {
        "dimensionNames": {
          "description": "The name of the dimensions in the pivot response.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "dimensionValues": {
          "description": "The values for the dimensions in the pivot.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "metric": {
          "description": "The metric header for the metric in the pivot.",
          "$ref": "MetricHeaderEntry"
        }
      },
      "id": "PivotHeaderEntry"
    },
    "DimensionFilterClause": {
      "description": "A group of dimension filters. Set the operator value to specify how\nthe filters are logically combined.",
      "type": "object",
      "properties": {
        "operator": {
          "description": "The operator for combining multiple dimension filters. If unspecified, it\nis treated as an `OR`.",
          "enum": [
            "OPERATOR_UNSPECIFIED",
            "OR",
            "AND"
          ],
          "enumDescriptions": [
            "Unspecified operator. It is treated as an `OR`.",
            "The logical `OR` operator.",
            "The logical `AND` operator."
          ],
          "type": "string"
        },
        "filters": {
          "description": "The repeated set of filters. They are logically combined based on the\noperator specified.",
          "type": "array",
          "items": {
            "$ref": "DimensionFilter"
          }
        }
      },
      "id": "DimensionFilterClause"
    },
    "SegmentSequenceStep": {
      "description": "A segment sequence definition.",
      "type": "object",
      "properties": {
        "matchType": {
          "description": "Specifies if the step immediately precedes or can be any time before the\nnext step.",
          "enum": [
            "UNSPECIFIED_MATCH_TYPE",
            "PRECEDES",
            "IMMEDIATELY_PRECEDES"
          ],
          "enumDescriptions": [
            "Unspecified match type is treated as precedes.",
            "Operator indicates that the previous step precedes the next step.",
            "Operator indicates that the previous step immediately precedes the next\nstep."
          ],
          "type": "string"
        },
        "orFiltersForSegment": {
          "description": "A sequence is specified with a list of Or grouped filters which are\ncombined with `AND` operator.",
          "type": "array",
          "items": {
            "$ref": "OrFiltersForSegment"
          }
        }
      },
      "id": "SegmentSequenceStep"
    },
    "Pivot": {
      "description": "The Pivot describes the pivot section in the request.\nThe Pivot helps rearrange the information in the table for certain reports\nby pivoting your data on a second dimension.",
      "type": "object",
      "properties": {
        "dimensions": {
          "description": "A list of dimensions to show as pivot columns. A Pivot can have a maximum\nof 4 dimensions. Pivot dimensions are part of the restriction on the\ntotal number of dimensions allowed in the request.",
          "type": "array",
          "items": {
            "$ref": "Dimension"
          }
        },
        "metrics": {
          "description": "The pivot metrics. Pivot metrics are part of the\nrestriction on total number of metrics allowed in the request.",
          "type": "array",
          "items": {
            "$ref": "Metric"
          }
        },
        "maxGroupCount": {
          "description": "Specifies the maximum number of groups to return.\nThe default value is 10, also the maximum value is 1,000.",
          "type": "integer",
          "format": "int32"
        },
        "dimensionFilterClauses": {
          "description": "DimensionFilterClauses are logically combined with an `AND` operator: only\ndata that is included by all these DimensionFilterClauses contributes to\nthe values in this pivot region. Dimension filters can be used to restrict\nthe columns shown in the pivot region. For example if you have\n`ga:browser` as the requested dimension in the pivot region, and you\nspecify key filters to restrict `ga:browser` to only \"IE\" or \"Firefox\",\nthen only those two browsers would show up as columns.",
          "type": "array",
          "items": {
            "$ref": "DimensionFilterClause"
          }
        },
        "startGroup": {
          "description": "If k metrics were requested, then the response will contain some\ndata-dependent multiple of k columns in the report.  E.g., if you pivoted\non the dimension `ga:browser` then you'd get k columns for \"Firefox\", k\ncolumns for \"IE\", k columns for \"Chrome\", etc. The ordering of the groups\nof columns is determined by descending order of \"total\" for the first of\nthe k values.  Ties are broken by lexicographic ordering of the first\npivot dimension, then lexicographic ordering of the second pivot\ndimension, and so on.  E.g., if the totals for the first value for\nFirefox, IE, and Chrome were 8, 2, 8, respectively, the order of columns\nwould be Chrome, Firefox, IE.\n\nThe following let you choose which of the groups of k columns are\nincluded in the response.",
          "type": "integer",
          "format": "int32"
        }
      },
      "id": "Pivot"
    },
    "DateRangeValues": {
      "description": "Used to return a list of metrics for a single DateRange / dimension\ncombination",
      "type": "object",
      "properties": {
        "values": {
          "description": "Each value corresponds to each Metric in the request.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "pivotValueRegions": {
          "description": "The values of each pivot region.",
          "type": "array",
          "items": {
            "$ref": "PivotValueRegion"
          }
        }
      },
      "id": "DateRangeValues"
    },
    "MetricFilterClause": {
      "description": "Represents a group of metric filters.\nSet the operator value to specify how the filters are logically combined.",
      "type": "object",
      "properties": {
        "operator": {
          "description": "The operator for combining multiple metric filters. If unspecified, it is\ntreated as an `OR`.",
          "enum": [
            "OPERATOR_UNSPECIFIED",
            "OR",
            "AND"
          ],
          "enumDescriptions": [
            "Unspecified operator. It is treated as an `OR`.",
            "The logical `OR` operator.",
            "The logical `AND` operator."
          ],
          "type": "string"
        },
        "filters": {
          "description": "The repeated set of filters. They are logically combined based on the\noperator specified.",
          "type": "array",
          "items": {
            "$ref": "MetricFilter"
          }
        }
      },
      "id": "MetricFilterClause"
    },
    "Segment": {
      "description": "The segment definition, if the report needs to be segmented.\nA Segment is a subset of the Analytics data. For example, of the entire\nset of users, one Segment might be users from a particular country or city.",
      "type": "object",
      "properties": {
        "dynamicSegment": {
          "description": "A dynamic segment definition in the request.",
          "$ref": "DynamicSegment"
        },
        "segmentId": {
          "description": "The segment ID of a built-in or custom segment, for example `gaid::-3`.",
          "type": "string"
        }
      },
      "id": "Segment"
    },
    "DateRange": {
      "description": "A contiguous set of days: startDate, startDate + 1 day, ..., endDate.\nThe start and end dates are specified in\n[ISO8601](https://en.wikipedia.org/wiki/ISO_8601) date format `YYYY-MM-DD`.",
      "type": "object",
      "properties": {
        "startDate": {
          "description": "The start date for the query in the format `YYYY-MM-DD`.",
          "type": "string"
        },
        "endDate": {
          "description": "The end date for the query in the format `YYYY-MM-DD`.",
          "type": "string"
        }
      },
      "id": "DateRange"
    },
    "ReportRow": {
      "description": "A row in the report.",
      "type": "object",
      "properties": {
        "dimensions": {
          "description": "List of requested dimensions.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "metrics": {
          "description": "List of metrics for each requested DateRange.",
          "type": "array",
          "items": {
            "$ref": "DateRangeValues"
          }
        }
      },
      "id": "ReportRow"
    },
    "CohortGroup": {
      "description": "Defines a cohort group.\nFor example:\n\n    \"cohortGroup\": {\n      \"cohorts\": [{\n        \"name\": \"cohort 1\",\n        \"type\": \"FIRST_VISIT_DATE\",\n        \"dateRange\": { \"startDate\": \"2015-08-01\", \"endDate\": \"2015-08-01\" }\n      },{\n        \"name\": \"cohort 2\"\n         \"type\": \"FIRST_VISIT_DATE\"\n         \"dateRange\": { \"startDate\": \"2015-07-01\", \"endDate\": \"2015-07-01\" }\n      }]\n    }",
      "type": "object",
      "properties": {
        "lifetimeValue": {
          "description": "Enable Life Time Value (LTV).  LTV measures lifetime value for users\nacquired through different channels.\nPlease see:\n[Cohort Analysis](https://support.google.com/analytics/answer/6074676) and\n[Lifetime Value](https://support.google.com/analytics/answer/6182550)\nIf the value of lifetimeValue is false:\n\n- The metric values are similar to the values in the web interface cohort\n  report.\n- The cohort definition date ranges must be aligned to the calendar week\n  and month. i.e. while requesting `ga:cohortNthWeek` the `startDate` in\n  the cohort definition should be a Sunday and the `endDate` should be the\n  following Saturday, and for `ga:cohortNthMonth`, the `startDate`\n  should be the 1st of the month and `endDate` should be the last day\n  of the month.\n\nWhen the lifetimeValue is true:\n\n- The metric values will correspond to the values in the web interface\n  LifeTime value report.\n- The Lifetime Value report shows you how user value (Revenue) and\n  engagement (Appviews, Goal Completions, Sessions, and Session Duration)\n  grow during the 90 days after a user is acquired.\n- The metrics are calculated as a cumulative average per user per the time\n  increment.\n- The cohort definition date ranges need not be aligned to the calendar\n  week and month boundaries.\n- The `viewId` must be an\n  [app view ID](https://support.google.com/analytics/answer/2649553#WebVersusAppViews)",
          "type": "boolean"
        },
        "cohorts": {
          "description": "The definition for the cohort.",
          "type": "array",
          "items": {
            "$ref": "Cohort"
          }
        }
      },
      "id": "CohortGroup"
    },
    "GetReportsResponse": {
      "description": "The main response class which holds the reports from the Reporting API\n`batchGet` call.",
      "type": "object",
      "properties": {
        "reports": {
          "description": "Responses corresponding to each of the request.",
          "type": "array",
          "items": {
            "$ref": "Report"
          }
        }
      },
      "id": "GetReportsResponse"
    },
    "MetricHeaderEntry": {
      "description": "Header for the metrics.",
      "type": "object",
      "properties": {
        "type": {
          "description": "The type of the metric, for example `INTEGER`.",
          "enum": [
            "METRIC_TYPE_UNSPECIFIED",
            "INTEGER",
            "FLOAT",
            "CURRENCY",
            "PERCENT",
            "TIME"
          ],
          "enumDescriptions": [
            "Metric type is unspecified.",
            "Integer metric.",
            "Float metric.",
            "Currency metric.",
            "Percentage metric.",
            "Time metric in `HH:MM:SS` format."
          ],
          "type": "string"
        },
        "name": {
          "description": "The name of the header.",
          "type": "string"
        }
      },
      "id": "MetricHeaderEntry"
    },
    "MetricFilter": {
      "description": "MetricFilter specifies the filter on a metric.",
      "type": "object",
      "properties": {
        "metricName": {
          "description": "The metric that will be filtered on. A metricFilter must contain a metric\nname. A metric name can be an alias earlier defined as a metric or it can\nalso be a metric expression.",
          "type": "string"
        },
        "operator": {
          "description": "Is the metric `EQUAL`, `LESS_THAN` or `GREATER_THAN` the\ncomparisonValue, the default is `EQUAL`. If the operator is\n`IS_MISSING`, checks if the metric is missing and would ignore the\ncomparisonValue.",
          "enum": [
            "OPERATOR_UNSPECIFIED",
            "EQUAL",
            "LESS_THAN",
            "GREATER_THAN",
            "IS_MISSING"
          ],
          "enumDescriptions": [
            "If the operator is not specified, it is treated as `EQUAL`.",
            "Should the value of the metric be exactly equal to the comparison value.",
            "Should the value of the metric be less than to the comparison value.",
            "Should the value of the metric be greater than to the comparison value.",
            "Validates if the metric is missing.\nDoesn't take comparisonValue into account."
          ],
          "type": "string"
        },
        "comparisonValue": {
          "description": "The value to compare against.",
          "type": "string"
        },
        "not": {
          "description": "Logical `NOT` operator. If this boolean is set to true, then the matching\nmetric values will be excluded in the report. The default is false.",
          "type": "boolean"
        }
      },
      "id": "MetricFilter"
    },
    "Dimension": {
      "description": "[Dimensions](https://support.google.com/analytics/answer/1033861)\nare attributes of your data. For example, the dimension `ga:city`\nindicates the city, for example, \"Paris\" or \"New York\", from which\na session originates.",
      "type": "object",
      "properties": {
        "histogramBuckets": {
          "description": "If non-empty, we place dimension values into buckets after string to\nint64. Dimension values that are not the string representation of an\nintegral value will be converted to zero.  The bucket values have to be in\nincreasing order.  Each bucket is closed on the lower end, and open on the\nupper end. The \"first\" bucket includes all values less than the first\nboundary, the \"last\" bucket includes all values up to infinity. Dimension\nvalues that fall in a bucket get transformed to a new dimension value. For\nexample, if one gives a list of \"0, 1, 3, 4, 7\", then we return the\nfollowing buckets:\n\n- bucket #1: values \u003c 0, dimension value \"\u003c0\"\n- bucket #2: values in [0,1), dimension value \"0\"\n- bucket #3: values in [1,3), dimension value \"1-2\"\n- bucket #4: values in [3,4), dimension value \"3\"\n- bucket #5: values in [4,7), dimension value \"4-6\"\n- bucket #6: values \u003e= 7, dimension value \"7+\"\n\nNOTE: If you are applying histogram mutation on any dimension, and using\nthat dimension in sort, you will want to use the sort type\n`HISTOGRAM_BUCKET` for that purpose. Without that the dimension values\nwill be sorted according to dictionary\n(lexicographic) order. For example the ascending dictionary order is:\n\n   \"\u003c50\", \"1001+\", \"121-1000\", \"50-120\"\n\nAnd the ascending `HISTOGRAM_BUCKET` order is:\n\n   \"\u003c50\", \"50-120\", \"121-1000\", \"1001+\"\n\nThe client has to explicitly request `\"orderType\": \"HISTOGRAM_BUCKET\"`\nfor a histogram-mutated dimension.",
          "type": "array",
          "items": {
            "type": "string",
            "format": "int64"
          }
        },
        "name": {
          "description": "Name of the dimension to fetch, for example `ga:browser`.",
          "type": "string"
        }
      },
      "id": "Dimension"
    },
    "PivotValueRegion": {
      "description": "The metric values in the pivot region.",
      "type": "object",
      "properties": {
        "values": {
          "description": "The values of the metrics in each of the pivot regions.",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "id": "PivotValueRegion"
    }
  },
  "revision": "20160809",
  "basePath": "",
  "icons": {
    "x32": "http://www.google.com/images/icons/product/search-32.gif",
    "x16": "http://www.google.com/images/icons/product/search-16.gif"
  },
  "version_module": "True",
  "canonicalName": "AnalyticsReporting",
  "discoveryVersion": "v1",
  "baseUrl": "https://analyticsreporting.googleapis.com/",
  "name": "analyticsreporting",
  "parameters": {
    "access_token": {
      "description": "OAuth access token.",
      "type": "string",
      "location": "query"
    },
    "prettyPrint": {
      "description": "Returns response with indentations and line breaks.",
      "default": "true",
      "type": "boolean",
      "location": "query"
    },
    "key": {
      "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.",
      "type": "string",
      "location": "query"
    },
    "quotaUser": {
      "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.",
      "type": "string",
      "location": "query"
    },
    "pp": {
      "description": "Pretty-print response.",
      "default": "true",
      "type": "boolean",
      "location": "query"
    },
    "fields": {
      "description": "Selector specifying which fields to include in a partial response.",
      "type": "string",
      "location": "query"
    },
    "alt": {
      "description": "Data format for response.",
      "location": "query",
      "enum": [
        "json",
        "media",
        "proto"
      ],
      "default": "json",
      "enumDescriptions": [
        "Responses with Content-Type of application/json",
        "Media download with context-dependent Content-Type",
        "Responses with Content-Type of application/x-protobuf"
      ],
      "type": "string"
    },
    "$.xgafv": {
      "description": "V1 error format.",
      "enum": [
        "1",
        "2"
      ],
      "enumDescriptions": [
        "v1 error format",
        "v2 error format"
      ],
      "type": "string",
      "location": "query"
    },
    "callback": {
      "description": "JSONP",
      "type": "string",
      "location": "query"
    },
    "oauth_token": {
      "description": "OAuth 2.0 token for the current user.",
      "type": "string",
      "location": "query"
    },
    "uploadType": {
      "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\").",
      "type": "string",
      "location": "query"
    },
    "bearer_token": {
      "description": "OAuth bearer token.",
      "type": "string",
      "location": "query"
    },
    "upload_protocol": {
      "description": "Upload protocol for media (e.g. \"raw\", \"multipart\").",
      "type": "string",
      "location": "query"
    }
  },
  "documentationLink": "https://developers.google.com/analytics/devguides/reporting/core/v4/",
  "ownerDomain": "google.com",
  "batchPath": "batch",
  "servicePath": "",
  "ownerName": "Google",
  "version": "v4",
  "rootUrl": "https://analyticsreporting.googleapis.com/",
  "kind": "discovery#restDescription"
}
