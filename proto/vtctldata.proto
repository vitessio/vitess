/*
Copyright 2019 The Vitess Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// This package contains the data structures for a service allowing
// you to use vtctld as a server for vt commands.

syntax = "proto3";
option go_package = "vitess.io/vitess/go/vt/proto/vtctldata";

package vtctldata;

import "binlogdata.proto";
import "logutil.proto";
import "mysqlctl.proto";
import "query.proto";
import "replicationdata.proto";
import "tabletmanagerdata.proto";
import "topodata.proto";
import "vschema.proto";
import "vtrpc.proto";
import "vttime.proto";

// ExecuteVtctlCommandRequest is the payload for ExecuteVtctlCommand.
// timeouts are in nanoseconds.
message ExecuteVtctlCommandRequest {
  repeated string args = 1;
  int64 action_timeout = 2;
}

// ExecuteVtctlCommandResponse is streamed back by ExecuteVtctlCommand.
message ExecuteVtctlCommandResponse {
  logutil.Event event = 1;
}

// MaterializationIntent describes the reason for creating the Materialize flow
enum MaterializationIntent {
  // CUSTOM is the default value
  CUSTOM = 0;

  // MOVETABLES is when we are creating a MoveTables flow
  MOVETABLES = 1;

  // CREATELOOKUPINDEX is when we are creating a CreateLookupIndex flow
  CREATELOOKUPINDEX = 2;
}

// TableMaterializeSttings contains the settings for one table.
message TableMaterializeSettings {
  string target_table = 1;
  // source_expression is a select statement.
  string source_expression = 2;
  // create_ddl contains the DDL to create the target table.
  // If empty, the target table must already exist.
  // if "copy", the target table DDL is the same as the source table.
  string create_ddl = 3;
}

// MaterializeSettings contains the settings for the Materialize command.
message MaterializeSettings {
  // workflow is the name of the workflow.
  string workflow = 1;
  string source_keyspace = 2;
  string target_keyspace = 3;
  // stop_after_copy specifies if vreplication should be stopped after copying.
  bool stop_after_copy = 4;
  repeated TableMaterializeSettings table_settings = 5;
  // optional parameters.
  string cell = 6;
  string tablet_types = 7;
  // ExternalCluster is the name of the mounted cluster which has the source keyspace/db for this workflow
  // it is of the type <cluster_type.cluster_name>
  string external_cluster = 8;
  // MaterializationIntent is used to identify the reason behind the materialization workflow: eg. MoveTables, CreateLookupVindex
  MaterializationIntent materialization_intent = 9;
  // SourceTimeZone is the time zone in which datetimes on the source were stored, provided as an option in MoveTable
  string source_time_zone = 10;
  // TargetTimeZone is not currently specifiable by the user, defaults to UTC for the forward workflows
  // and to the SourceTimeZone in reverse workflows
  string target_time_zone = 11;
  repeated string source_shards = 12;
  // OnDdl specifies the action to be taken when a DDL is encountered.
  string on_ddl = 13;
  // DeferSecondaryKeys specifies if secondary keys should be created in one shot after table copy finishes.
  bool defer_secondary_keys = 14;
  tabletmanagerdata.TabletSelectionPreference tablet_selection_preference = 15;
  bool atomic_copy = 16;
}

/* Data types for VtctldServer */

message Keyspace {
  string name = 1;
  topodata.Keyspace keyspace = 2;
}

enum QueryOrdering {
  NONE = 0;
  ASCENDING = 1;
  DESCENDING = 2;
}

// SchemaMigration represents a row in the schema_migrations sidecar table.
message SchemaMigration {
  string uuid = 1;
  string keyspace = 2;
  string shard = 3;
  string schema = 4;
  string table = 5;
  string migration_statement = 6;
  Strategy strategy = 7;
  string options = 8;
  vttime.Time added_at = 9;
  vttime.Time requested_at = 10;
  vttime.Time ready_at = 11;
  vttime.Time started_at = 12;
  vttime.Time liveness_timestamp = 13;
  vttime.Time completed_at = 14;
  vttime.Time cleaned_up_at = 15;
  Status status = 16;
  string log_path = 17;
  string artifacts = 18;
  uint64 retries = 19;
  topodata.TabletAlias tablet = 20;
  bool tablet_failure = 21;
  float progress = 22;
  string migration_context = 23;
  string ddl_action = 24;
  string message = 25;
  int64 eta_seconds = 26;
  uint64 rows_copied = 27;
  int64 table_rows = 28;
  uint32 added_unique_keys = 29;
  uint32 removed_unique_keys = 30;
  string log_file = 31;
  vttime.Duration artifact_retention = 32;
  bool postpone_completion = 33;
  string removed_unique_key_names = 34;
  string dropped_no_default_column_names = 35;
  string expanded_column_names = 36;
  string revertible_notes = 37;
  bool allow_concurrent = 38;
  string reverted_uuid = 39;
  bool is_view = 40;
  bool ready_to_complete = 41;
  int64 vitess_liveness_indicator = 42;
  float user_throttle_ratio = 43;
  string special_plan = 44;
  vttime.Time last_throttled_at = 45;
  string component_throttled = 46;
  vttime.Time cancelled_at = 47;
  bool postpone_launch = 48;
  string stage = 49; // enum?
  uint32 cutover_attempts = 50;
  bool is_immediate_operation = 51;
  vttime.Time reviewed_at = 52;
  vttime.Time ready_to_complete_at = 53;
  string removed_foreign_key_names = 54;

  enum Strategy {
    option allow_alias = true;
    // SchemaMigration_VITESS uses vreplication to run the schema migration. It is
    // the default strategy for OnlineDDL requests.
    //
    // SchemaMigration_VITESS was also formerly called "ONLINE".
    VITESS = 0;
    ONLINE = 0;
    GHOST = 1;
    PTOSC = 2;
    // SchemaMigration_DIRECT runs the migration directly against MySQL (e.g. `ALTER TABLE ...`),
    // meaning it is not actually an "online" DDL migration.
    DIRECT = 3;
    // SchemaMigration_MYSQL is a managed migration (queued and executed by the
    // scheduler) but runs through a MySQL `ALTER TABLE`.
    MYSQL = 4;
  }

  enum Status {
    UNKNOWN = 0;
    REQUESTED = 1;
    CANCELLED = 2;
    QUEUED = 3;
    READY = 4;
    RUNNING = 5;
    COMPLETE = 6;
    FAILED = 7;
  }
}

message Shard {
  string keyspace = 1;
  string name = 2;
  topodata.Shard shard = 3;
}

// TODO: comment the hell out of this.
message Workflow {
  string name = 1;
  ReplicationLocation source = 2;
  ReplicationLocation target = 3;
  // This represents how long it's been since we processed any event in the
  // stream.
  int64 max_v_replication_lag = 4;
  map<string, ShardStream> shard_streams = 5;
  string workflow_type = 6;
  string workflow_sub_type = 7;
  // This represents the lag across all shards, between the current time and
  // the timestamp of the last transaction OR heartbeat timestamp (if there
  // have been no writes to replicate from the source).
  int64 max_v_replication_transaction_lag = 8;
  // This specifies whether to defer the creation of secondary keys.
  bool defer_secondary_keys = 9;

  message ReplicationLocation {
    string keyspace = 1;
    repeated string shards = 2;
  }

  message ShardStream {
    repeated Stream streams = 1;
    repeated topodata.Shard.TabletControl tablet_controls = 2;
    bool is_primary_serving = 3;
  }

  message Stream {
    int64 id = 1;
    string shard = 2;
    topodata.TabletAlias tablet = 3;
    binlogdata.BinlogSource binlog_source = 4;
    string position = 5;
    string stop_position = 6;
    string state = 7;
    string db_name = 8;
    vttime.Time transaction_timestamp = 9;
    vttime.Time time_updated = 10;
    string message = 11;
    repeated CopyState copy_states = 12;
    repeated Log logs = 13;
    // LogFetchError is set if we fail to fetch some logs for this stream. We
    // will never fail to fetch workflows because we cannot fetch the logs, but
    // we will still forward log-fetch errors to the caller, should that be
    // relevant to the context in which they are fetching workflows.
    //
    // Note that this field being set does not necessarily mean that Logs is nil;
    // if there are N logs that exist for the stream, and we fail to fetch the
    // ith log, we will still return logs in [0, i) + (i, N].
    string log_fetch_error = 14;
    repeated string tags = 15;
    int64 rows_copied = 16;
    ThrottlerStatus throttler_status = 17;
    repeated topodata.TabletType tablet_types = 18;
    tabletmanagerdata.TabletSelectionPreference tablet_selection_preference = 19;
    repeated string cells = 20;

    message CopyState {
      string table = 1;
      string last_pk = 2;
      int64 stream_id = 3;
    }

    message Log {
      int64 id = 1;
      int64 stream_id = 2;
      string type = 3;
      string state = 4;
      vttime.Time created_at = 5;
      vttime.Time updated_at = 6;
      string message = 7;
      int64 count = 8;
    }

    message ThrottlerStatus {
      string component_throttled = 1;
      vttime.Time time_throttled = 2;
    }
  }
}

/* Request/response types for VtctldServer */


message AddCellInfoRequest {
  string name = 1;
  topodata.CellInfo cell_info = 2;
}

message AddCellInfoResponse {
}

message AddCellsAliasRequest {
  string name = 1;
  repeated string cells = 2;
}

message AddCellsAliasResponse {
}

message ApplyRoutingRulesRequest {
  vschema.RoutingRules routing_rules = 1;
  // SkipRebuild, if set, will cause ApplyRoutingRules to skip rebuilding the
  // SrvVSchema objects in each cell in RebuildCells.
  bool skip_rebuild = 2;
  // RebuildCells limits the SrvVSchema rebuild to the specified cells. If not
  // provided the SrvVSchema will be rebuilt in every cell in the topology.
  //
  // Ignored if SkipRebuild is set.
  repeated string rebuild_cells = 3;
}

message ApplyRoutingRulesResponse {
}

message ApplyShardRoutingRulesRequest {
  vschema.ShardRoutingRules shard_routing_rules = 1;
  // SkipRebuild, if set, will cause ApplyShardRoutingRules to skip rebuilding the
  // SrvVSchema objects in each cell in RebuildCells.
  bool skip_rebuild = 2;
  // RebuildCells limits the SrvVSchema rebuild to the specified cells. If not
  // provided the SrvVSchema will be rebuilt in every cell in the topology.
  //
  // Ignored if SkipRebuild is set.
  repeated string rebuild_cells = 3;
}

message ApplyShardRoutingRulesResponse {
}

message ApplySchemaRequest {
  string keyspace = 1;
  reserved 2;
  // SQL commands to run.
  repeated string sql = 3;
  // Online DDL strategy, compatible with @@ddl_strategy session variable (examples: 'gh-ost', 'pt-osc', 'gh-ost --max-load=Threads_running=100'")
  string ddl_strategy = 4;
  // Optional: explicit UUIDs for migration.
  // If given, must match number of DDL changes
  repeated string uuid_list = 5;
  // For Online DDL, optionally supply a custom unique string used as context for the migration(s) in this command.
  // By default a unique context is auto-generated by Vitess
  string migration_context = 6;
  // WaitReplicasTimeout is the duration of time to wait for replicas to catch
  // up in reparenting.
  vttime.Duration wait_replicas_timeout = 7;

  reserved 8;
  // caller_id identifies the caller. This is the effective caller ID,
  // set by the application to further identify the caller.
  vtrpc.CallerID caller_id = 9;
  // BatchSize indicates how many queries to apply together
  int64 batch_size = 10;
}

message ApplySchemaResponse {
  repeated string uuid_list = 1;
  map<string, uint64> rows_affected_by_shard = 2;
}

message ApplyVSchemaRequest {
  string keyspace = 1;
  bool skip_rebuild = 2;
  bool dry_run = 3;
  repeated string cells = 4;
  vschema.Keyspace v_schema = 5;
  string sql = 6;
  // Strict returns an error if there are unknown vindex params.
  bool strict = 7;
}

message ApplyVSchemaResponse {
  vschema.Keyspace v_schema = 1;
  // UnknownVindexParams is a map of vindex name to params that were not recognized by the vindex
  // type. E.g.:
  //
  // {
  //   "lookup_vdx": {
  //     "params": ["raed_lock", "not_verify"]
  //   }
  // }
  map<string, ParamList> unknown_vindex_params = 2;

  message ParamList {
    repeated string params = 1;
  }
}

message BackupRequest {
  topodata.TabletAlias tablet_alias = 1;
  // AllowPrimary allows the backup to proceed if TabletAlias is a PRIMARY.
  //
  // WARNING: If using the builtin backup engine, this will shutdown mysqld on
  // the primary for the duration of the backup, and no writes will be possible.
  bool allow_primary = 2;
  // Concurrency specifies the number of compression/checksum jobs to run
  // simultaneously.
  int32 concurrency = 3;
  // IncrementalFromPos indicates a position of a previous backup. When this value is non-empty
  // then the backup becomes incremental and applies as of given position.
  string incremental_from_pos = 4;
  // UpgradeSafe indicates if the backup should be taken with innodb_fast_shutdown=0
  // so that it's a backup that can be used for an upgrade.
  bool upgrade_safe = 5;
}

message BackupResponse {
  // TabletAlias is the alias being used for the backup.
  topodata.TabletAlias tablet_alias = 1;
  string keyspace = 2;
  string shard = 3;
  logutil.Event event = 4;
}

message BackupShardRequest {
  string keyspace = 1;
  string shard = 2;
  // AllowPrimary allows the backup to occur on a PRIMARY tablet. See
  // BackupRequest.AllowPrimary for warnings and caveats.
  bool allow_primary = 3;
  // Concurrency specifies the number of compression/checksum jobs to run
  // simultaneously.
  int32 concurrency = 4;
  // UpgradeSafe indicates if the backup should be taken with innodb_fast_shutdown=0
  // so that it's a backup that can be used for an upgrade.
  bool upgrade_safe = 5;
  // IncrementalFromPos indicates a position of a previous backup. When this value is non-empty
  // then the backup becomes incremental and applies as of given position.
  string incremental_from_pos = 6;
}

message CancelSchemaMigrationRequest {
  string keyspace = 1;
  string uuid = 2;
}

message CancelSchemaMigrationResponse {
  map<string, uint64> rows_affected_by_shard = 1;
}

message ChangeTabletTypeRequest {
  topodata.TabletAlias tablet_alias = 1;
  topodata.TabletType db_type = 2;
  bool dry_run = 3;
}

message ChangeTabletTypeResponse {
  topodata.Tablet before_tablet = 1;
  topodata.Tablet after_tablet = 2;
  bool was_dry_run = 3;
}

message CleanupSchemaMigrationRequest {
  string keyspace = 1;
  string uuid = 2;
}

message CleanupSchemaMigrationResponse {
  map<string, uint64> rows_affected_by_shard = 1;
}

message CompleteSchemaMigrationRequest {
  string keyspace = 1;
  string uuid = 2;
}

message CompleteSchemaMigrationResponse {
  map<string, uint64> rows_affected_by_shard = 1;
}

message CreateKeyspaceRequest {
  // Name is the name of the keyspace.
  string name = 1;
  // Force proceeds with the request even if the keyspace already exists.
  bool force = 2;
  // AllowEmptyVSchema allows a keyspace to be created with no vschema.
  bool allow_empty_v_schema = 3;

  // OBSOLETE string sharding_column_name = 4;
  reserved 4;

  // OBSOLETE topodata.KeyspaceIdType sharding_column_type = 5;
  reserved 5;

  // OBSOLETE: repeated topodata.Keyspace.ServedFrom served_froms = 6;
  reserved 6;

  // Type is the type of the keyspace to create.
  topodata.KeyspaceType type = 7;
  // BaseKeyspace specifies the base keyspace for SNAPSHOT keyspaces. It is
  // required to create a SNAPSHOT keyspace.
  string base_keyspace = 8;
  // SnapshotTime specifies the snapshot time for this keyspace. It is required
  // to create a SNAPSHOT keyspace.
  vttime.Time snapshot_time = 9;
  // DurabilityPolicy is the durability policy to be
  // used for this keyspace.
  string durability_policy = 10;
  // SidecarDBName is the name of the sidecar database that
  // each vttablet in the keyspace will use.
  string sidecar_db_name = 11;
}

message CreateKeyspaceResponse {
  // Keyspace is the newly-created keyspace.
  Keyspace keyspace = 1;
}

message CreateShardRequest {
  // Keyspace is the name of the keyspace to create the shard in.
  string keyspace = 1;
  // ShardName is the name of the shard to create. E.g. "-" or "-80".
  string shard_name = 2;
  // Force treats an attempt to create a shard that already exists as a
  // non-error.
  bool force = 3;
  // IncludeParent creates the parent keyspace as an empty BASE keyspace, if it
  // doesn't already exist.
  bool include_parent = 4;
}

message CreateShardResponse {
  // Keyspace is the created keyspace. It is set only if IncludeParent was
  // specified in the request and the parent keyspace needed to be created.
  Keyspace keyspace = 1;
  // Shard is the newly-created shard object.
  Shard shard = 2;
  // ShardAlreadyExists is set if Force was specified in the request and the
  // shard already existed.
  bool shard_already_exists = 3;
}

message DeleteCellInfoRequest {
  string name = 1;
  bool force = 2;
}

message DeleteCellInfoResponse {
}

message DeleteCellsAliasRequest {
  string name = 1;
}

message DeleteCellsAliasResponse {
}

message DeleteKeyspaceRequest {
  // Keyspace is the name of the keyspace to delete.
  string keyspace = 1;
  // Recursive causes all shards in the keyspace to be recursively deleted
  // before deleting the keyspace. It is an error to call DeleteKeyspace on a
  // non-empty keyspace without also specifying Recursive.
  bool recursive = 2;
  // Force allows a keyspace to be deleted even if the keyspace lock cannot be
  // obtained. This should only be used to force-clean a keyspace.
  bool force = 3;
}

message DeleteKeyspaceResponse {
}

message DeleteShardsRequest {
  // Shards is the list of shards to delete. The nested topodatapb.Shard field
  // is not required for DeleteShard, but the Keyspace and Shard fields are.
  repeated Shard shards = 1;
  // Recursive also deletes all tablets belonging to the shard(s). It is an
  // error to call DeleteShard on a non-empty shard without also specificying
  // Recursive.
  bool recursive = 2;
  // EvenIfServing allows a shard to be deleted even if it is serving, which is
  // normally an error. Use with caution.
  bool even_if_serving = 4;
  // Force allows a shard to be deleted even if the shard lock cannot be
  // obtained. This should only be used to force-clean a shard.
  bool force = 5;
}

message DeleteShardsResponse {
}

message DeleteSrvVSchemaRequest {
  string cell = 1;
}

message DeleteSrvVSchemaResponse {
}

message DeleteTabletsRequest {
  // TabletAliases is the list of tablets to delete.
  repeated topodata.TabletAlias tablet_aliases = 1;
  // AllowPrimary allows for the primary tablet of a shard to be deleted.
  // Use with caution.
  bool allow_primary = 2;
}

message DeleteTabletsResponse {
}

message EmergencyReparentShardRequest {
  // Keyspace is the name of the keyspace to perform the Emergency Reparent in.
  string keyspace = 1;
  // Shard is the name of the shard to perform the Emergency Reparent in.
  string shard = 2;
  // Optional alias of a tablet that should become the new shard primary. If not
  // not specified, the vtctld will select the most up-to-date canditate to
  // promote.
  topodata.TabletAlias new_primary = 3;
  // List of replica aliases to ignore during the Emergency Reparent. The vtctld
  // will not attempt to stop replication on these tablets, nor attempt to
  // demote any that may think they are the shard primary.
  repeated topodata.TabletAlias ignore_replicas = 4;
  // WaitReplicasTimeout is the duration of time to wait for replicas to catch
  // up in reparenting.
  vttime.Duration wait_replicas_timeout = 5;
  // PreventCrossCellPromotion is used to only promote the new primary from the same cell
  // as the failed primary.
  bool prevent_cross_cell_promotion = 6;
  // WaitForAllTablets makes ERS wait for a response from all the tablets before proceeding.
  // Useful when all the tablets are up and reachable.
  bool wait_for_all_tablets = 7;
}

message EmergencyReparentShardResponse {
  // Keyspace is the name of the keyspace the Emergency Reparent took place in.
  string keyspace = 1;
  // Shard is the name of the shard the Emergency Reparent took place in.
  string shard = 2;
  // PromotedPrimary is the alias of the tablet that was promoted to shard
  // primary. If NewPrimary was set in the request, then this will be the same
  // alias. Otherwise, it will be the alias of the tablet found to be most
  // up-to-date.
  topodata.TabletAlias promoted_primary = 3;
  repeated logutil.Event events = 4;
}

message ExecuteFetchAsAppRequest {
  topodata.TabletAlias tablet_alias = 1;
  string query = 2;
  // MaxRows is an optional parameter to limit the number of rows read into the
  // QueryResult. Note that this does not apply a LIMIT to the query, just how
  // many rows are read from the MySQL server on the tablet side.
  //
  // This field is optional. Specifying a non-positive value will use whatever
  // default is configured in the VtctldService.
  int64 max_rows = 3;
  // UsePool causes the query to be run with a pooled connection to the tablet.
  bool use_pool = 4;
}

message ExecuteFetchAsAppResponse {
  query.QueryResult result = 1;
}

message ExecuteFetchAsDBARequest {
  topodata.TabletAlias tablet_alias = 1;
  string query = 2;
  // MaxRows is an optional parameter to limit the number of rows read into the
  // QueryResult. Note that this does not apply a LIMIT to the query, just how
  // many rows are read from the MySQL server on the tablet side.
  //
  // This field is optional. Specifying a non-positive value will use whatever
  // default is configured in the VtctldService.
  int64 max_rows = 3;
  // DisableBinlogs instructs the tablet not to use binary logging when
  // executing the query.
  bool disable_binlogs = 4;
  // ReloadSchema instructs the tablet to reload its schema after executing the
  // query.
  bool reload_schema = 5;
}

message ExecuteFetchAsDBAResponse {
  query.QueryResult result = 1;
}

message ExecuteHookRequest {
  topodata.TabletAlias tablet_alias = 1;
  tabletmanagerdata.ExecuteHookRequest tablet_hook_request = 2;
}

message ExecuteHookResponse {
  tabletmanagerdata.ExecuteHookResponse hook_result = 1;
}

message FindAllShardsInKeyspaceRequest {
  string keyspace = 1;
}

message FindAllShardsInKeyspaceResponse {
  map<string, Shard> shards = 1;
}

message ForceCutOverSchemaMigrationRequest {
  string keyspace = 1;
  string uuid = 2;
}

message ForceCutOverSchemaMigrationResponse {
  map<string, uint64> rows_affected_by_shard = 1;
}

message GetBackupsRequest {
  string keyspace = 1;
  string shard = 2;
  // Limit, if nonzero, will return only the most N recent backups.
  uint32 limit = 3;
  // Detailed indicates whether to use the backupengine, if supported, to
  // populate additional fields, such as Engine and Status, on BackupInfo
  // objects in the response. If not set, or if the backupengine does not
  // support populating these fields, Engine will always be empty, and Status
  // will always be UNKNOWN.
  bool detailed = 4;
  // DetailedLimit, if nonzero, will only populate additional fields (see Detailed)
  // on the N most recent backups. The Limit field still dictates the total
  // number of backup info objects returned, so, in reality, min(Limit, DetailedLimit)
  // backup infos will have additional fields set, and any remaining backups
  // will not.
  uint32 detailed_limit = 5;
}

message GetBackupsResponse {
  repeated mysqlctl.BackupInfo backups = 1;
}

message GetCellInfoRequest {
  string cell = 1;
}

message GetCellInfoResponse {
  topodata.CellInfo cell_info = 1;
}

message GetCellInfoNamesRequest {
}

message GetCellInfoNamesResponse {
  repeated string names = 1;
}

message GetCellsAliasesRequest {
}

message GetCellsAliasesResponse {
  map<string, topodata.CellsAlias> aliases = 1;
}

message GetFullStatusRequest {
  topodata.TabletAlias tablet_alias = 1;
}

message GetFullStatusResponse {
  replicationdata.FullStatus status = 1;
}

message GetKeyspacesRequest {
}

message GetKeyspacesResponse {
  repeated Keyspace keyspaces = 1;
}

message GetKeyspaceRequest {
  string keyspace = 1;
}

message GetKeyspaceResponse {
  Keyspace keyspace = 1;
}

message GetPermissionsRequest {
  topodata.TabletAlias tablet_alias = 1;
}

message GetPermissionsResponse {
  tabletmanagerdata.Permissions permissions = 1;
}

message GetRoutingRulesRequest {
}

message GetRoutingRulesResponse {
  vschema.RoutingRules routing_rules = 1;
}

message GetSchemaRequest {
  topodata.TabletAlias tablet_alias = 1;
  // Tables is a list of tables for which we should gather information. Each is
  // either an exact match, or a regular expression of the form /regexp/.
  repeated string tables = 2;
  // ExcludeTables is a list of tables to exclude from the result. Each is
  // either an exact match, or a regular expression of the form /regexp/.
  repeated string exclude_tables = 3;
  // IncludeViews specifies whether to include views in the result.
  bool include_views = 4;
  // TableNamesOnly specifies whether to limit the results to just table names,
  // rather than full schema information for each table.
  bool table_names_only = 5;
  // TableSizesOnly specifies whether to limit the results to just table sizes,
  // rather than full schema information for each table. It is ignored if
  // TableNamesOnly is set to true.
  bool table_sizes_only = 6;
  // TableSchemaOnly specifies whether to limit the results to just table/view
  // schema definition (CREATE TABLE/VIEW statements) and skip column/field information
  bool table_schema_only = 7;
}

message GetSchemaResponse {
  tabletmanagerdata.SchemaDefinition schema = 1;
}

// GetSchemaMigrationsRequest controls the behavior of the GetSchemaMigrations
// rpc.
//
// Keyspace is a required field, while all other fields are optional.
//
// If UUID is set, other optional fields will be ignored, since there will be at
// most one migration with that UUID. Furthermore, if no migration with that
// UUID exists, an empty response, not an error, is returned.
//
// MigrationContext, Status, and Recent are mutually exclusive.
message GetSchemaMigrationsRequest {
  string keyspace = 1;
  // Uuid, if set, will cause GetSchemaMigrations to return exactly 1 migration,
  // namely the one with that UUID. If no migration exists, the response will
  // be an empty slice, not an error.
  //
  // If this field is set, other fields (status filters, limit, skip, order) are
  // ignored.
  string uuid = 2;

  string migration_context = 3;
  SchemaMigration.Status status = 4;
  // Recent, if set, returns migrations requested between now and the provided
  // value.
  vttime.Duration recent = 5;

  QueryOrdering order = 6;
  uint64 limit = 7;
  uint64 skip = 8;
}

message GetSchemaMigrationsResponse {
  repeated SchemaMigration migrations = 1;
}

message GetShardRequest {
  string keyspace = 1;
  string shard_name = 2;
}

message GetShardResponse {
  Shard shard = 1;
}

message GetShardRoutingRulesRequest {
}

message GetShardRoutingRulesResponse {
  vschema.ShardRoutingRules shard_routing_rules = 1;
}

message GetSrvKeyspaceNamesRequest {
  repeated string cells = 1;
}

message GetSrvKeyspaceNamesResponse {
  // Names is a mapping of cell name to a list of SrvKeyspace names.
  map<string, NameList> names = 1;

  message NameList {
    repeated string names = 1;
  }
}

message GetSrvKeyspacesRequest {
  string keyspace = 1;
  // Cells is a list of cells to lookup a SrvKeyspace for. Leaving this empty is
  // equivalent to specifying all cells in the topo.
  repeated string cells = 2;
}

message GetSrvKeyspacesResponse {
  // SrvKeyspaces is a mapping of cell name to SrvKeyspace.
  map<string, topodata.SrvKeyspace> srv_keyspaces = 1;
}

message UpdateThrottlerConfigRequest {
  string keyspace = 1;
  // Enable instructs to enable the throttler
  bool enable = 2;
  // Disable instructs to disable the throttler
  bool disable = 3;
  // Threshold for throttler (with no custom query, ie using default query, only positive values are considered)
  double threshold = 4;
  // CustomQuery replaces the default replication lag query
  string custom_query = 5;
  // CustomQuerySet indicates that the value of CustomQuery has changed
  bool custom_query_set = 6;
  // CheckAsCheckSelf instructs the throttler to respond to /check requests by checking the tablet's own health
  bool check_as_check_self = 7;
  // CheckAsCheckShard instructs the throttler to respond to /check requests by checking the shard's health (this is the default behavior)
  bool check_as_check_shard = 8;
  // ThrottledApp indicates a single throttled app rule (ignored if name is empty)
  topodata.ThrottledAppRule throttled_app = 9;
}

message UpdateThrottlerConfigResponse {
}

message GetSrvVSchemaRequest {
  string cell = 1;
}

message GetSrvVSchemaResponse {
  vschema.SrvVSchema srv_v_schema = 1;
}

message GetSrvVSchemasRequest {
  repeated string cells = 2;
}

message GetSrvVSchemasResponse {
  // SrvVSchemas is a mapping of cell name to SrvVSchema
  map<string, vschema.SrvVSchema> srv_v_schemas = 1;
}

message GetTabletRequest {
  topodata.TabletAlias tablet_alias = 1;
}

message GetTabletResponse {
  topodata.Tablet tablet = 1;
}

message GetTabletsRequest {
  // Keyspace is the name of the keyspace to return tablets for. Omit to return
  // tablets from all keyspaces.
  string keyspace = 1;
  // Shard is the name of the shard to return tablets for. This field is ignored
  // if Keyspace is not set.
  string shard = 2;
  // Cells is an optional set of cells to return tablets for.
  repeated string cells = 3;
  // Strict specifies how the server should treat failures from individual
  // cells.
  //
  // When false (the default), GetTablets will return data from any cells that
  // return successfully, but will fail the request if all cells fail. When
  // true, any individual cell can fail the full request.
  bool strict = 4;
  // TabletAliases is an optional list of tablet aliases to fetch Tablet objects
  // for. If specified, Keyspace, Shard, and Cells are ignored, and tablets are
  // looked up by their respective aliases' Cells directly.
  repeated topodata.TabletAlias tablet_aliases = 5;
  // tablet_type specifies the type of tablets to return. Omit to return all
  // tablet types.
  topodata.TabletType tablet_type = 6;
}

message GetTabletsResponse {
  repeated topodata.Tablet tablets = 1;
}

message GetTopologyPathRequest {
  string path = 1;
}

message GetTopologyPathResponse {
  TopologyCell cell = 1;
}

message TopologyCell {
  string name = 1;
  string path = 2;
  // Data is the file contents of the cell located at path.
  // It is only populated if the cell is a terminal node.
  string data = 3;
  repeated string children = 4;
}

message GetVSchemaRequest {
  string keyspace = 1;
}

message GetVersionRequest {
  topodata.TabletAlias tablet_alias = 1;
}

message GetVersionResponse {
  string version = 1;
}

message GetVSchemaResponse {
  vschema.Keyspace v_schema = 1;
}

message GetWorkflowsRequest {
  string keyspace = 1;
  bool active_only = 2;
  bool name_only = 3;
  // If you only want a specific workflow then set this field.
  string workflow = 4;
  bool include_logs = 5;
  repeated string shards = 6;
}

message GetWorkflowsResponse {
  repeated Workflow workflows = 1;
}

message InitShardPrimaryRequest {
  string keyspace = 1;
  string shard = 2;
  topodata.TabletAlias primary_elect_tablet_alias = 3;
  bool force = 4;
  vttime.Duration wait_replicas_timeout = 5;
}

message InitShardPrimaryResponse {
  repeated logutil.Event events = 1;
}

message LaunchSchemaMigrationRequest {
  string keyspace = 1;
  string uuid = 2;
}

message LaunchSchemaMigrationResponse {
  map<string, uint64> rows_affected_by_shard = 1;
}

message LookupVindexCreateRequest {
  string keyspace = 1;
  string workflow = 2;
  repeated string cells = 3;
  vschema.Keyspace vindex = 4;
  bool continue_after_copy_with_owner = 5;
  repeated topodata.TabletType tablet_types = 6;
  tabletmanagerdata.TabletSelectionPreference tablet_selection_preference = 7;
}

message LookupVindexCreateResponse {
}

message LookupVindexExternalizeRequest {
  // Where the lookup vindex lives.
  string keyspace = 1;
  // This is the name of the lookup vindex and the vreplication workflow.
  string name = 2;
  // Where the vreplication workflow lives.
  string table_keyspace = 3;
}

message LookupVindexExternalizeResponse {
  // Was the workflow also deleted.
  bool workflow_deleted = 1;
}

message MaterializeCreateRequest {
  MaterializeSettings settings = 1;
}

message MaterializeCreateResponse {
}

message MigrateCreateRequest {
  // The necessary info gets passed on to each primary tablet involved
  // in the workflow via the CreateVReplicationWorkflow tabletmanager RPC.
  string workflow = 1;
  string source_keyspace = 2;
  string target_keyspace = 3;
  string mount_name = 4;
  repeated string cells = 5;
  repeated topodata.TabletType tablet_types = 6;
  tabletmanagerdata.TabletSelectionPreference tablet_selection_preference = 7;
  bool all_tables = 8;
  repeated string include_tables = 9;
  repeated string exclude_tables = 10;
  // SourceTimeZone is the time zone in which datetimes on the source were stored, provided as an option in MoveTables
  string source_time_zone = 11;
  // OnDdl specifies the action to be taken when a DDL is encountered.
  string on_ddl = 12;
  // StopAfterCopy specifies if vreplication should be stopped after copying.
  bool stop_after_copy = 13;
  // DropForeignKeys specifies if foreign key constraints should be elided on the target.
  bool drop_foreign_keys = 14;
  // DeferSecondaryKeys specifies if secondary keys should be created in one shot after table copy finishes.
  bool defer_secondary_keys = 15;
  // Start the workflow after creating it.
  bool auto_start = 16;
  // NoRoutingRules is set to true if routing rules should not be created on the target when the workflow is created.
  bool no_routing_rules = 17;
}

message MigrateCompleteRequest {
  string workflow = 1;
  string target_keyspace = 3;
  bool keep_data = 4;
  bool keep_routing_rules = 5;
  bool rename_tables = 6;
  bool dry_run = 7;
}

message MigrateCompleteResponse {
  string summary = 1;
  repeated string dry_run_results = 2;
}

message MountRegisterRequest {
  string topo_type = 1;
  string topo_server = 2;
  string topo_root = 3;
  string name = 4;
}

message MountRegisterResponse {
}

message MountUnregisterRequest {
  string name = 4;
}

message MountUnregisterResponse {
}

message MountShowRequest {
  string name = 4;
}

message MountShowResponse {
  string topo_type = 1;
  string topo_server = 2;
  string topo_root = 3;
  string name = 4;
}

message MountListRequest {
}

message MountListResponse {
  repeated string names = 1;
}

message MoveTablesCreateRequest {
  // The necessary info gets passed on to each primary tablet involved
  // in the workflow via the CreateVReplicationWorkflow tabletmanager RPC.
  string workflow = 1;
  string source_keyspace = 2;
  string target_keyspace = 3;
  repeated string cells = 4;
  repeated topodata.TabletType tablet_types = 5;
  tabletmanagerdata.TabletSelectionPreference tablet_selection_preference = 6;
  repeated string source_shards = 7;
  bool all_tables = 8;
  repeated string include_tables = 9;
  repeated string exclude_tables = 10;
  // The name of the external cluster mounted in topo server.
  string external_cluster_name = 11;
  // SourceTimeZone is the time zone in which datetimes on the source were stored, provided as an option in MoveTables
  string source_time_zone = 12;
  // OnDdl specifies the action to be taken when a DDL is encountered.
  string on_ddl = 13;
  // StopAfterCopy specifies if vreplication should be stopped after copying.
  bool stop_after_copy = 14;
  // DropForeignKeys specifies if foreign key constraints should be elided on the target.
  bool drop_foreign_keys = 15;
  // DeferSecondaryKeys specifies if secondary keys should be created in one shot after table copy finishes.
  bool defer_secondary_keys = 16;
  // Start the workflow after creating it.
  bool auto_start = 17;
  // NoRoutingRules is set to true if routing rules should not be created on the target when the workflow is created.
  bool no_routing_rules = 18;
  // Run a single copy phase for the entire database.
  bool atomic_copy = 19;
}

message MoveTablesCreateResponse {
  message TabletInfo {
    topodata.TabletAlias tablet = 1;
    // Created is set if the workflow was created on this tablet or not.
    bool created = 2;
  }
  string summary = 1;
  repeated TabletInfo details = 2;
}

message MoveTablesCompleteRequest {
  string workflow = 1;
  string target_keyspace = 3;
  bool keep_data = 4;
  bool keep_routing_rules = 5;
  bool rename_tables = 6;
  bool dry_run = 7;
  repeated string shards = 8;
}

message MoveTablesCompleteResponse {
  string summary = 1;
  repeated string dry_run_results = 2;
}

message PingTabletRequest {
  topodata.TabletAlias tablet_alias = 1;
}

message PingTabletResponse {
}

message PlannedReparentShardRequest {
  // Keyspace is the name of the keyspace to perform the Planned Reparent in.
  string keyspace = 1;
  // Shard is the name of the shard to perform teh Planned Reparent in.
  string shard = 2;
  // NewPrimary is the alias of the tablet to promote to shard primary. If not
  // specified, the vtctld will select the most up-to-date candidate to promote.
  //
  // It is an error to set NewPrimary and AvoidPrimary to the same alias.
  topodata.TabletAlias new_primary = 3;
  // AvoidPrimary is the alias of the tablet to demote. In other words,
  // specifying an AvoidPrimary alias tells the vtctld to promote any replica
  // other than this one. A shard whose current primary is not this one is then
  // a no-op.
  //
  // It is an error to set NewPrimary and AvoidPrimary to the same alias.
  topodata.TabletAlias avoid_primary = 4;
  // WaitReplicasTimeout is the duration of time to wait for replicas to catch
  // up in replication both before and after the reparent. The timeout is not
  // cumulative across both wait periods, meaning that the replicas have
  // WaitReplicasTimeout time to catch up before the reparent, and an additional
  // WaitReplicasTimeout time to catch up after the reparent.
  vttime.Duration wait_replicas_timeout = 5;
  // TolerableReplicationLag is the amount of replication lag that is considered
  // acceptable for a tablet to be eligible for promotion when Vitess makes the choice of a new primary.
  // A value of 0 indicates that Vitess shouldn't consider the replication lag at all.
  vttime.Duration tolerable_replication_lag = 6;
}

message PlannedReparentShardResponse {
  // Keyspace is the name of the keyspace the Planned Reparent took place in.
  string keyspace = 1;
  // Shard is the name of the shard the Planned Reparent took place in.
  string shard = 2;
  // PromotedPrimary is the alias of the tablet that was promoted to shard
  // primary. If NewPrimary was set in the request, then this will be the same
  // alias. Otherwise, it will be the alias of the tablet found to be most
  // up-to-date.
  topodata.TabletAlias promoted_primary = 3;
  repeated logutil.Event events = 4;
}

message RebuildKeyspaceGraphRequest {
  string keyspace = 1;
  repeated string cells = 2;
  // AllowPartial, when set, allows a SNAPSHOT keyspace to serve with an
  // incomplete set of shards. It is ignored for all other keyspace types.
  bool allow_partial = 3;
}

message RebuildKeyspaceGraphResponse {
}

message RebuildVSchemaGraphRequest {
  // Cells specifies the cells to rebuild the SrvVSchema objects for. If empty,
  // RebuildVSchemaGraph rebuilds the SrvVSchema for every cell in the topo.
  repeated string cells = 1;
}

message RebuildVSchemaGraphResponse {
}

message RefreshStateRequest {
  topodata.TabletAlias tablet_alias = 1;
}

message RefreshStateResponse {
}

message RefreshStateByShardRequest {
  string keyspace = 1;
  string shard = 2;
  repeated string cells = 3;
}

message RefreshStateByShardResponse {
  bool is_partial_refresh = 1;
  // This explains why we had a partial refresh (if we did)
  string partial_refresh_details = 2;
}

message ReloadSchemaRequest {
  topodata.TabletAlias tablet_alias = 1;
}

message ReloadSchemaResponse {
}

message ReloadSchemaKeyspaceRequest {
  string keyspace = 1;
  string wait_position = 2;
  bool include_primary = 3;
  // Concurrency is the global concurrency across all shards in the keyspace
  // (so, at most this many tablets will be reloaded across the keyspace at any
  // given point).
  int32 concurrency = 4;
}

message ReloadSchemaKeyspaceResponse {
  repeated logutil.Event events = 1;
}

message ReloadSchemaShardRequest {
  string keyspace = 1;
  string shard = 2;
  string wait_position = 3;
  bool include_primary = 4;
  // Concurrency is the maximum number of tablets to reload at one time.
  int32 concurrency = 5;
}

message ReloadSchemaShardResponse {
  repeated logutil.Event events = 2;
}

message RemoveBackupRequest {
  string keyspace = 1;
  string shard = 2;
  string name = 3;
}

message RemoveBackupResponse {
}

message RemoveKeyspaceCellRequest {
  string keyspace = 1;
  string cell = 2;
  // Force proceeds even if the cell's topology server cannot be reached. This
  // should only be set if a cell has been shut down entirely, and the global
  // topology data just needs to be updated.
  bool force = 3;
  // Recursive also deletes all tablets in that cell belonging to the specified
  // keyspace.
  bool recursive = 4;
}

message RemoveKeyspaceCellResponse {
  // (TODO:@amason) Consider including the deleted SrvKeyspace object and any
  // deleted Tablet objects here.
}

message RemoveShardCellRequest {
  string keyspace = 1;
  string shard_name = 2;
  string cell = 3;
  // Force proceeds even if the cell's topology server cannot be reached. This
  // should only be set if a cell has been shut down entirely, and the global
  // topology data just needs to be updated.
  bool force = 4;
  // Recursive also deletes all tablets in that cell belonging to the specified
  // keyspace and shard.
  bool recursive = 5;
}

message RemoveShardCellResponse {
  // (TODO:@amason) Consider including the deleted SrvKeyspacePartitions objects
  // and any deleted Tablet objects here.
}

message ReparentTabletRequest {
  // Tablet is the alias of the tablet that should be reparented under the
  // current shard primary.
  topodata.TabletAlias tablet = 1;
}

message ReparentTabletResponse {
  // Keyspace is the name of the keyspace the tablet was reparented in.
  string keyspace = 1;
  // Shard is the name of the shard the tablet was reparented in.
  string shard = 2;
  // Primary is the alias of the tablet that the tablet was reparented under.
  topodata.TabletAlias primary = 3;
}

message ReshardCreateRequest {
  string workflow = 1;
  string keyspace = 2;
  repeated string source_shards = 3;
  repeated string target_shards = 4;
  repeated string cells = 5;
  repeated topodata.TabletType tablet_types = 6;
  tabletmanagerdata.TabletSelectionPreference tablet_selection_preference = 7;
  // SkipSchemaCopy specifies if the schema should be copied from the source shard, set false if
  // schema is already created on the target shard before Reshard is invoked.
  bool skip_schema_copy = 8;
  // OnDdl specifies the action to be taken when a DDL is encountered.
  string on_ddl = 9;
  // StopAfterCopy specifies if vreplication should be stopped after copying.
  bool stop_after_copy = 10;
  // DeferSecondaryKeys specifies if secondary keys should be created in one shot after table copy finishes.
  bool defer_secondary_keys = 11;
  // Start the workflow after creating it.
  bool auto_start = 12;
}

message RestoreFromBackupRequest {
  topodata.TabletAlias tablet_alias = 1;
  // BackupTime, if set, will use the backup taken most closely at or before
  // this time. If nil, the latest backup will be restored on the tablet.
  vttime.Time backup_time = 2;
  // RestoreToPos indicates a position for a point-in-time recovery. The recovery
  // is expected to utilize one full backup, followed by zero or more incremental backups,
  // that reach the precise desired position
  string restore_to_pos = 3;
  // Dry run does not actually performs the restore, but validates the steps and availability of backups
  bool dry_run = 4;
  // RestoreToTimestamp, if given, requested an inremental restore up to (and excluding) the given timestamp.
  // RestoreToTimestamp and RestoreToPos are mutually exclusive.
  vttime.Time restore_to_timestamp = 5;
}

message RestoreFromBackupResponse {
  // TabletAlias is the alias of the tablet doing the restore.
  topodata.TabletAlias tablet_alias = 1;
  string keyspace = 2;
  string shard = 3;
  logutil.Event event = 4;
}

message RetrySchemaMigrationRequest {
  string keyspace = 1;
  string uuid = 2;
}

message RetrySchemaMigrationResponse {
  map<string, uint64> rows_affected_by_shard = 1;
}

message RunHealthCheckRequest {
  topodata.TabletAlias tablet_alias = 1;
}

message RunHealthCheckResponse {
}

message SetKeyspaceDurabilityPolicyRequest {
  string keyspace = 1;
  string durability_policy = 2;
}

message SetKeyspaceDurabilityPolicyResponse {
  // Keyspace is the updated keyspace record.
  topodata.Keyspace keyspace = 1;
}

message SetKeyspaceShardingInfoRequest {
  string keyspace = 1;
  // OBSOLETE string column_name = 2;
  reserved 2;
  // OBSOLETE topodata.KeyspaceIdType column_type = 3;
  reserved 3;
  bool force = 4;
}

message SetKeyspaceShardingInfoResponse {
  // Keyspace is the updated keyspace record.
  topodata.Keyspace keyspace = 1;
}

message SetShardIsPrimaryServingRequest {
  string keyspace = 1;
  string shard = 2;
  bool is_serving = 3;
}

message SetShardIsPrimaryServingResponse {
  // Shard is the updated shard record.
  topodata.Shard shard = 1;
}

message SetShardTabletControlRequest {
  string keyspace = 1;
  string shard = 2;
  topodata.TabletType tablet_type = 3;
  repeated string cells = 4;
  // DeniedTables updates the list of denied tables the shard will serve for
  // the given tablet type. This is useful to fix tables that are being blocked
  // after a MoveTables operation.
  //
  // NOTE: Setting this field will cause DisableQueryService to be ignored.
  repeated string denied_tables = 5;
  // DisableQueryService instructs whether to enable the query service on
  // tablets of the given type in the shard. This is useful to fix Reshard
  // operations gone awry.
  //
  // NOTE: this is ignored if DeniedTables is not empty.
  bool disable_query_service = 6;
  // Remove removes the ShardTabletControl record entirely. If set, this takes
  // precedence over DeniedTables and DisableQueryService fields, and is useful
  // to manually remove serving restrictions after a completed MoveTables
  // operation.
  bool remove = 7;
}

message SetShardTabletControlResponse {
  // Shard is the updated shard record.
  topodata.Shard shard = 1;
}

message SetWritableRequest {
  topodata.TabletAlias tablet_alias = 1;
  bool writable = 2;
}

message SetWritableResponse {
}

message ShardReplicationAddRequest {
  string keyspace = 1;
  string shard = 2;
  topodata.TabletAlias tablet_alias = 3;
}

message ShardReplicationAddResponse {
}

message ShardReplicationFixRequest {
  string keyspace = 1;
  string shard = 2;
  string cell = 3;
}

message ShardReplicationFixResponse {
  // Error contains information about the error fixed by a
  // ShardReplicationFix RPC. If there were no errors to fix (i.e. all nodes
  // in the replication graph are valid), this field is nil.
  topodata.ShardReplicationError error = 1;
}

message ShardReplicationPositionsRequest {
  string keyspace = 1;
  string shard = 2;
}

message ShardReplicationPositionsResponse {
  // ReplicationStatuses is a mapping of tablet alias string to replication
  // status for that tablet.
  map<string, replicationdata.Status> replication_statuses = 1;
  // TabletMap is the set of tablets whose replication statuses were queried,
  // keyed by tablet alias.
  map<string, topodata.Tablet> tablet_map = 2;
}

message ShardReplicationRemoveRequest {
  string keyspace = 1;
  string shard = 2;
  topodata.TabletAlias tablet_alias = 3;
}

message ShardReplicationRemoveResponse {
}

message SleepTabletRequest {
  topodata.TabletAlias tablet_alias = 1;
  vttime.Duration duration = 2;
}

message SleepTabletResponse {
}

message SourceShardAddRequest {
  string keyspace = 1;
  string shard = 2;
  int32 uid = 3;
  string source_keyspace = 4;
  string source_shard = 5;
  // KeyRange identifies the key range to use for the SourceShard. This field is
  // optional.
  topodata.KeyRange key_range = 6;
  // Tables is a list of tables replicate (for MoveTables). Each "table" can be
  // either an exact match or a regular expression of the form "/regexp/".
  repeated string tables = 7;
}

message SourceShardAddResponse {
  // Shard is the updated shard record.
  topodata.Shard shard = 1;
}

message SourceShardDeleteRequest {
  string keyspace = 1;
  string shard = 2;
  int32 uid = 3;
}

message SourceShardDeleteResponse {
  // Shard is the updated shard record.
  topodata.Shard shard = 1;
}

message StartReplicationRequest {
  topodata.TabletAlias tablet_alias = 1;
}

message StartReplicationResponse {
}

message StopReplicationRequest {
  topodata.TabletAlias tablet_alias = 1;
}

message StopReplicationResponse {
}

message TabletExternallyReparentedRequest {
  // Tablet is the alias of the tablet that was promoted externally and should
  // be updated to the shard primary in the topo.
  topodata.TabletAlias tablet = 1;
}

message TabletExternallyReparentedResponse {
  string keyspace = 1;
  string shard = 2;
  topodata.TabletAlias new_primary = 3;
  topodata.TabletAlias old_primary = 4;
}

message UpdateCellInfoRequest {
  string name = 1;
  topodata.CellInfo cell_info = 2;
}

message UpdateCellInfoResponse {
  string name = 1;
  topodata.CellInfo cell_info = 2;
}

message UpdateCellsAliasRequest {
  string name = 1;
  topodata.CellsAlias cells_alias = 2;
}

message UpdateCellsAliasResponse {
  string name = 1;
  topodata.CellsAlias cells_alias = 2;
}

message ValidateRequest {
  bool ping_tablets = 1;
}

message ValidateResponse {
  repeated string results = 1;
  map<string, ValidateKeyspaceResponse> results_by_keyspace = 2;
}

message ValidateKeyspaceRequest {
  string keyspace = 1;
  bool ping_tablets = 2;
}

message ValidateKeyspaceResponse {
  repeated string results = 1;
  map<string, ValidateShardResponse> results_by_shard = 2;
}

message ValidateSchemaKeyspaceRequest {
  string keyspace = 1;
  repeated string exclude_tables = 2;
  bool include_views = 3;
  bool skip_no_primary = 4;
  bool include_vschema = 5;
}

message ValidateSchemaKeyspaceResponse {
  repeated string results = 1;
  map<string, ValidateShardResponse> results_by_shard = 2;
}

message ValidateShardRequest {
  string keyspace = 1;
  string shard = 2;
  bool ping_tablets = 3;
}

message ValidateShardResponse {
  repeated string results = 1;
}

message ValidateVersionKeyspaceRequest {
  string keyspace = 1;
}

message ValidateVersionKeyspaceResponse {
  repeated string results = 1;
  map<string, ValidateShardResponse> results_by_shard = 2;
}

message ValidateVersionShardRequest {
  string keyspace = 1;
  string shard = 2;
}

message ValidateVersionShardResponse {
  repeated string results = 1;
}

message ValidateVSchemaRequest {
  string keyspace = 1;
  repeated string shards = 2;
  repeated string exclude_tables = 3;
  bool include_views = 4;
}

message ValidateVSchemaResponse {
  repeated string results = 1;
  map<string, ValidateShardResponse> results_by_shard = 2;
}

message VDiffCreateRequest {
  string workflow = 1;
  string target_keyspace = 2;
  string uuid = 3;
  repeated string source_cells = 4;
  repeated string target_cells = 5;
  repeated topodata.TabletType tablet_types = 6;
  tabletmanagerdata.TabletSelectionPreference tablet_selection_preference = 7;
  repeated string tables = 8;
  int64 limit = 9;
  vttime.Duration filtered_replication_wait_time = 10;
  bool debug_query = 11;
  bool only_p_ks = 12;
  bool update_table_stats = 13;
  int64 max_extra_rows_to_compare = 14;
  bool wait = 15;
  vttime.Duration wait_update_interval = 16;
  bool auto_retry = 17;
  bool verbose = 18;
  int64 max_report_sample_rows = 19;
  vttime.Duration max_diff_duration = 20;
}

message VDiffCreateResponse {
  // Intentionally upper case to maintain compatibility with
  // vtctlclient and other VDiff client command output.
  string UUID = 1;
}

message VDiffDeleteRequest {
  string workflow = 1;
  string target_keyspace = 2;
  // This will be 'all' or a UUID.
  string arg = 3;
}

message VDiffDeleteResponse {
}

message VDiffResumeRequest {
  string workflow = 1;
  string target_keyspace = 2;
  string uuid = 3;
}

message VDiffResumeResponse {
}

message VDiffShowRequest {
  string workflow = 1;
  string target_keyspace = 2;
  // This will be 'all', 'last', or a UUID.
  string arg = 3;
}

message VDiffShowResponse {
  // The key is keyspace/shard.
  map<string, tabletmanagerdata.VDiffResponse> tablet_responses = 1;
}

message VDiffStopRequest {
  string workflow = 1;
  string target_keyspace = 2;
  string uuid = 3;
}

message VDiffStopResponse {
}

message WorkflowDeleteRequest {
  string keyspace = 1;
  string workflow = 2;
  bool keep_data = 3;
  bool keep_routing_rules = 4;
  repeated string shards = 5;
}

message WorkflowDeleteResponse {
  message TabletInfo {
    topodata.TabletAlias tablet = 1;
    // Delete is set if the workflow was deleted on this tablet.
    bool deleted = 2;
  }
  string summary = 1;
  repeated TabletInfo details = 2;
}

message WorkflowStatusRequest {
  string keyspace = 1;
  string workflow = 2;
  repeated string shards = 3;
}

message WorkflowStatusResponse {
  message TableCopyState {
    int64 rows_copied = 1;
    int64 rows_total = 2;
    float rows_percentage = 3;
    int64 bytes_copied = 4;
    int64 bytes_total = 5;
    float bytes_percentage = 6;
  }
  message ShardStreamState {
    int32 id = 1;
    topodata.TabletAlias tablet = 2;
    string source_shard = 3;
    string position = 4;
    string status = 5;
    string info = 6;
  }
  message ShardStreams {
    repeated ShardStreamState streams = 2;
  }
  // The key is keyspace/shard.
  map<string, TableCopyState> table_copy_state = 1;
  map<string, ShardStreams> shard_streams = 2;
  string traffic_state = 3;
}

message WorkflowSwitchTrafficRequest {
  string keyspace = 1;
  string workflow = 2;
  repeated string cells = 3;
  repeated topodata.TabletType tablet_types = 4;
  vttime.Duration max_replication_lag_allowed = 5;
  bool enable_reverse_replication = 6;
  int32 direction = 7;
  vttime.Duration timeout = 8;
  bool dry_run = 9;
  bool initialize_target_sequences = 10;
  repeated string shards = 11;
}

message WorkflowSwitchTrafficResponse {
  string summary = 1;
  string start_state = 2;
  string current_state = 3;
  repeated string dry_run_results = 4;
}

message WorkflowUpdateRequest {
  string keyspace = 1;
  // TabletRequest gets passed on to each primary tablet involved
  // in the workflow via the UpdateVReplicationWorkflow tabletmanager RPC.
  tabletmanagerdata.UpdateVReplicationWorkflowRequest tablet_request = 2;
}

message WorkflowUpdateResponse {
  message TabletInfo {
    topodata.TabletAlias tablet = 1;
    // Changed is true if any of the provided values were different
    // than what was already stored on this tablet.
    bool changed = 2;
  }
  string summary = 1;
  repeated TabletInfo details = 2;
}
