/*
Copyright 2023 The Vitess Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
// Code generated by ASTHelperGen. DO NOT EDIT.

package integration

// AST does deep equals between the two objects.
func (cmp *Comparator) AST(inA, inB AST) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case BasicType:
		b, ok := inB.(BasicType)
		if !ok {
			return false
		}
		return a == b
	case Bytes:
		b, ok := inB.(Bytes)
		if !ok {
			return false
		}
		return cmp.Bytes(a, b)
	case InterfaceContainer:
		b, ok := inB.(InterfaceContainer)
		if !ok {
			return false
		}
		return cmp.InterfaceContainer(a, b)
	case InterfaceSlice:
		b, ok := inB.(InterfaceSlice)
		if !ok {
			return false
		}
		return cmp.InterfaceSlice(a, b)
	case *Leaf:
		b, ok := inB.(*Leaf)
		if !ok {
			return false
		}
		return cmp.RefOfLeaf(a, b)
	case LeafSlice:
		b, ok := inB.(LeafSlice)
		if !ok {
			return false
		}
		return cmp.LeafSlice(a, b)
	case *NoCloneType:
		b, ok := inB.(*NoCloneType)
		if !ok {
			return false
		}
		return cmp.RefOfNoCloneType(a, b)
	case *RefContainer:
		b, ok := inB.(*RefContainer)
		if !ok {
			return false
		}
		return cmp.RefOfRefContainer(a, b)
	case *RefSliceContainer:
		b, ok := inB.(*RefSliceContainer)
		if !ok {
			return false
		}
		return cmp.RefOfRefSliceContainer(a, b)
	case *SubImpl:
		b, ok := inB.(*SubImpl)
		if !ok {
			return false
		}
		return cmp.RefOfSubImpl(a, b)
	case ValueContainer:
		b, ok := inB.(ValueContainer)
		if !ok {
			return false
		}
		return cmp.ValueContainer(a, b)
	case ValueSliceContainer:
		b, ok := inB.(ValueSliceContainer)
		if !ok {
			return false
		}
		return cmp.ValueSliceContainer(a, b)
	default:
		// this should never happen
		return false
	}
}

// Bytes does deep equals between the two objects.
func (cmp *Comparator) Bytes(a, b Bytes) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}

// InterfaceContainer does deep equals between the two objects.
func (cmp *Comparator) InterfaceContainer(a, b InterfaceContainer) bool {
	return true
}

// InterfaceSlice does deep equals between the two objects.
func (cmp *Comparator) InterfaceSlice(a, b InterfaceSlice) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !cmp.AST(a[i], b[i]) {
			return false
		}
	}
	return true
}

// RefOfLeaf does deep equals between the two objects.
func (cmp *Comparator) RefOfLeaf(a, b *Leaf) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.v == b.v
}

// LeafSlice does deep equals between the two objects.
func (cmp *Comparator) LeafSlice(a, b LeafSlice) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !cmp.RefOfLeaf(a[i], b[i]) {
			return false
		}
	}
	return true
}

// RefOfNoCloneType does deep equals between the two objects.
func (cmp *Comparator) RefOfNoCloneType(a, b *NoCloneType) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.v == b.v
}

// RefOfRefContainer does deep equals between the two objects.
func (cmp *Comparator) RefOfRefContainer(a, b *RefContainer) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.NotASTType == b.NotASTType &&
		cmp.AST(a.ASTType, b.ASTType) &&
		cmp.RefOfLeaf(a.ASTImplementationType, b.ASTImplementationType)
}

// RefOfRefSliceContainer does deep equals between the two objects.
func (cmp *Comparator) RefOfRefSliceContainer(a, b *RefSliceContainer) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.SliceOfAST(a.ASTElements, b.ASTElements) &&
		cmp.SliceOfInt(a.NotASTElements, b.NotASTElements) &&
		cmp.SliceOfRefOfLeaf(a.ASTImplementationElements, b.ASTImplementationElements)
}

// RefOfSubImpl does deep equals between the two objects.
func (cmp *Comparator) RefOfSubImpl(a, b *SubImpl) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.SubIface(a.inner, b.inner) &&
		cmp.RefOfBool(a.field, b.field)
}

// ValueContainer does deep equals between the two objects.
func (cmp *Comparator) ValueContainer(a, b ValueContainer) bool {
	return a.NotASTType == b.NotASTType &&
		cmp.AST(a.ASTType, b.ASTType) &&
		cmp.RefOfLeaf(a.ASTImplementationType, b.ASTImplementationType)
}

// ValueSliceContainer does deep equals between the two objects.
func (cmp *Comparator) ValueSliceContainer(a, b ValueSliceContainer) bool {
	return cmp.SliceOfAST(a.ASTElements, b.ASTElements) &&
		cmp.SliceOfInt(a.NotASTElements, b.NotASTElements) &&
		cmp.SliceOfRefOfLeaf(a.ASTImplementationElements, b.ASTImplementationElements)
}

// SubIface does deep equals between the two objects.
func (cmp *Comparator) SubIface(inA, inB SubIface) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *SubImpl:
		b, ok := inB.(*SubImpl)
		if !ok {
			return false
		}
		return cmp.RefOfSubImpl(a, b)
	default:
		// this should never happen
		return false
	}
}

// RefOfInterfaceContainer does deep equals between the two objects.
func (cmp *Comparator) RefOfInterfaceContainer(a, b *InterfaceContainer) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return true
}

// SliceOfAST does deep equals between the two objects.
func (cmp *Comparator) SliceOfAST(a, b []AST) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !cmp.AST(a[i], b[i]) {
			return false
		}
	}
	return true
}

// SliceOfInt does deep equals between the two objects.
func (cmp *Comparator) SliceOfInt(a, b []int) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}

// SliceOfRefOfLeaf does deep equals between the two objects.
func (cmp *Comparator) SliceOfRefOfLeaf(a, b []*Leaf) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !cmp.RefOfLeaf(a[i], b[i]) {
			return false
		}
	}
	return true
}

// RefOfBool does deep equals between the two objects.
func (cmp *Comparator) RefOfBool(a, b *bool) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return *a == *b
}

// RefOfValueContainer does deep equals between the two objects.
func (cmp *Comparator) RefOfValueContainer(a, b *ValueContainer) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.NotASTType == b.NotASTType &&
		cmp.AST(a.ASTType, b.ASTType) &&
		cmp.RefOfLeaf(a.ASTImplementationType, b.ASTImplementationType)
}

// RefOfValueSliceContainer does deep equals between the two objects.
func (cmp *Comparator) RefOfValueSliceContainer(a, b *ValueSliceContainer) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.SliceOfAST(a.ASTElements, b.ASTElements) &&
		cmp.SliceOfInt(a.NotASTElements, b.NotASTElements) &&
		cmp.SliceOfRefOfLeaf(a.ASTImplementationElements, b.ASTImplementationElements)
}

type Comparator struct{}
