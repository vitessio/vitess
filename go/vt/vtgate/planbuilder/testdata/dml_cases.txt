# update table not found
"update nouser set val = 1"
"table nouser not found"
Gen4 plan same as above

# delete table not found
"delete from nouser"
"table nouser not found"
Gen4 plan same as above

# explicit keyspace reference
"update main.m1 set val = 1"
{
  "QueryType": "UPDATE",
  "Original": "update main.m1 set val = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Unsharded",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update m1 set val = 1"
  }
}
Gen4 plan same as above

# update unsharded
"update unsharded set val = 1"
{
  "QueryType": "UPDATE",
  "Original": "update unsharded set val = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Unsharded",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update unsharded set val = 1"
  }
}
Gen4 plan same as above

# subqueries in unsharded update
"update unsharded set col = (select col from unsharded limit 1)"
{
  "QueryType": "UPDATE",
  "Original": "update unsharded set col = (select col from unsharded limit 1)",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Unsharded",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update unsharded set col = (select col from unsharded limit 1)"
  }
}
Gen4 plan same as above

# unsharded union in subquery of unsharded update
"update unsharded set col = (select id from unsharded union select id from unsharded)"
{
  "QueryType": "UPDATE",
  "Original": "update unsharded set col = (select id from unsharded union select id from unsharded)",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Unsharded",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update unsharded set col = (select id from unsharded union select id from unsharded)"
  }
}
Gen4 plan same as above

# unsharded join in subquery of unsharded update
"update unsharded set col = (select id from unsharded a join unsharded b on a.id = b.id)"
{
  "QueryType": "UPDATE",
  "Original": "update unsharded set col = (select id from unsharded a join unsharded b on a.id = b.id)",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Unsharded",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update unsharded set col = (select id from unsharded as a join unsharded as b on a.id = b.id)"
  }
}
Gen4 plan same as above

# update with join subquery
"update unsharded as foo left join (select id from unsharded where col is not null order by col desc limit 10) as keepers on foo.id = keepers.id set col1 = 'asdf' where keepers.id is null and foo.col is not null and foo.col < 1000"
{
  "QueryType": "UPDATE",
  "Original": "update unsharded as foo left join (select id from unsharded where col is not null order by col desc limit 10) as keepers on foo.id = keepers.id set col1 = 'asdf' where keepers.id is null and foo.col is not null and foo.col \u003c 1000",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Unsharded",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update unsharded as foo left join (select id from unsharded where col is not null order by col desc limit 10) as keepers on foo.id = keepers.id set col1 = 'asdf' where keepers.id is null and foo.col is not null and foo.col \u003c 1000"
  }
}
Gen4 plan same as above

# routing rules: updated of a routed table
"update route1 set a=1 where id=1"
{
  "QueryType": "UPDATE",
  "Original": "update route1 set a=1 where id=1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Equal",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update `user` as route1 set a = 1 where id = 1",
    "Table": "user",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "user_index"
  }
}
{
  "QueryType": "UPDATE",
  "Original": "update route1 set a=1 where id=1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "EqualUnique",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update `user` as route1 set a = 1 where id = 1",
    "Table": "user",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "user_index"
  }
}

# update: routing rules for subquery.
"update unsharded_a set a=(select a from route2)"
{
  "QueryType": "UPDATE",
  "Original": "update unsharded_a set a=(select a from route2)",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Unsharded",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update unsharded_a set a = (select a from unsharded as route2)"
  }
}
Gen4 plan same as above

# delete unsharded
"delete from unsharded"
{
  "QueryType": "DELETE",
  "Original": "delete from unsharded",
  "Instructions": {
    "OperatorType": "Delete",
    "Variant": "Unsharded",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "delete from unsharded"
  }
}
Gen4 plan same as above

# update by primary keyspace id
"update user set val = 1 where id = 1"
{
  "QueryType": "UPDATE",
  "Original": "update user set val = 1 where id = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Equal",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update `user` set val = 1 where id = 1",
    "Table": "user",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "user_index"
  }
}
{
  "QueryType": "UPDATE",
  "Original": "update user set val = 1 where id = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "EqualUnique",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update `user` set val = 1 where id = 1",
    "Table": "user",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "user_index"
  }
}

# update by primary keyspace id with alias
"update user as user_alias set val = 1 where user_alias.id = 1"
{
  "QueryType": "UPDATE",
  "Original": "update user as user_alias set val = 1 where user_alias.id = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Equal",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update `user` as user_alias set val = 1 where user_alias.id = 1",
    "Table": "user",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "user_index"
  }
}
{
  "QueryType": "UPDATE",
  "Original": "update user as user_alias set val = 1 where user_alias.id = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "EqualUnique",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update `user` as user_alias set val = 1 where user_alias.id = 1",
    "Table": "user",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "user_index"
  }
}

# update by primary keyspace id with parenthesized expression
"update user set val = 1 where (id = 1)"
{
  "QueryType": "UPDATE",
  "Original": "update user set val = 1 where (id = 1)",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Equal",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update `user` set val = 1 where id = 1",
    "Table": "user",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "user_index"
  }
}
{
  "QueryType": "UPDATE",
  "Original": "update user set val = 1 where (id = 1)",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "EqualUnique",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update `user` set val = 1 where id = 1",
    "Table": "user",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "user_index"
  }
}

# update by primary keyspace id with multi-part where clause with parens
"update user set val = 1 where (name = 'foo' and id = 1)"
{
  "QueryType": "UPDATE",
  "Original": "update user set val = 1 where (name = 'foo' and id = 1)",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Equal",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update `user` set val = 1 where `name` = 'foo' and id = 1",
    "Table": "user",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "user_index"
  }
}
{
  "QueryType": "UPDATE",
  "Original": "update user set val = 1 where (name = 'foo' and id = 1)",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "EqualUnique",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update `user` set val = 1 where `name` = 'foo' and id = 1",
    "Table": "user",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "user_index"
  }
}

# update by primary keyspace id, changing one vindex column
"update user_metadata set email = 'juan@vitess.io' where user_id = 1"
{
  "QueryType": "UPDATE",
  "Original": "update user_metadata set email = 'juan@vitess.io' where user_id = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Equal",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "ChangedVindexValues": [
      "email_user_map:3"
    ],
    "KsidLength": 1,
    "KsidVindex": "user_index",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select user_id, email, address, email = 'juan@vitess.io' from user_metadata where user_id = 1 for update",
    "Query": "update user_metadata set email = 'juan@vitess.io' where user_id = 1",
    "Table": "user_metadata",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "user_index"
  }
}
{
  "QueryType": "UPDATE",
  "Original": "update user_metadata set email = 'juan@vitess.io' where user_id = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "EqualUnique",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "ChangedVindexValues": [
      "email_user_map:3"
    ],
    "KsidLength": 1,
    "KsidVindex": "user_index",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select user_id, email, address, email = 'juan@vitess.io' from user_metadata where user_id = 1 for update",
    "Query": "update user_metadata set email = 'juan@vitess.io' where user_id = 1",
    "Table": "user_metadata",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "user_index"
  }
}

# update by primary keyspace id, changing same vindex twice
"update user_metadata set email = 'a', email = 'b' where user_id = 1"
"column has duplicate set values: 'email'"
Gen4 plan same as above

# update by primary keyspace id, changing multiple vindex columns
"update user_metadata set email = 'juan@vitess.io', address = '155 5th street' where user_id = 1"
{
  "QueryType": "UPDATE",
  "Original": "update user_metadata set email = 'juan@vitess.io', address = '155 5th street' where user_id = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Equal",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "ChangedVindexValues": [
      "address_user_map:4",
      "email_user_map:3"
    ],
    "KsidLength": 1,
    "KsidVindex": "user_index",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select user_id, email, address, email = 'juan@vitess.io', address = '155 5th street' from user_metadata where user_id = 1 for update",
    "Query": "update user_metadata set email = 'juan@vitess.io', address = '155 5th street' where user_id = 1",
    "Table": "user_metadata",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "user_index"
  }
}
{
  "QueryType": "UPDATE",
  "Original": "update user_metadata set email = 'juan@vitess.io', address = '155 5th street' where user_id = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "EqualUnique",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "ChangedVindexValues": [
      "address_user_map:4",
      "email_user_map:3"
    ],
    "KsidLength": 1,
    "KsidVindex": "user_index",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select user_id, email, address, email = 'juan@vitess.io', address = '155 5th street' from user_metadata where user_id = 1 for update",
    "Query": "update user_metadata set email = 'juan@vitess.io', address = '155 5th street' where user_id = 1",
    "Table": "user_metadata",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "user_index"
  }
}

# update by primary keyspace id, changing one vindex column, using order by and limit
"update user_metadata set email = 'juan@vitess.io' where user_id = 1 order by user_id asc limit 10"
{
  "QueryType": "UPDATE",
  "Original": "update user_metadata set email = 'juan@vitess.io' where user_id = 1 order by user_id asc limit 10",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Equal",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "ChangedVindexValues": [
      "email_user_map:3"
    ],
    "KsidLength": 1,
    "KsidVindex": "user_index",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select user_id, email, address, email = 'juan@vitess.io' from user_metadata where user_id = 1 order by user_id asc limit 10 for update",
    "Query": "update user_metadata set email = 'juan@vitess.io' where user_id = 1 order by user_id asc limit 10",
    "Table": "user_metadata",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "user_index"
  }
}
{
  "QueryType": "UPDATE",
  "Original": "update user_metadata set email = 'juan@vitess.io' where user_id = 1 order by user_id asc limit 10",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "EqualUnique",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "ChangedVindexValues": [
      "email_user_map:3"
    ],
    "KsidLength": 1,
    "KsidVindex": "user_index",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select user_id, email, address, email = 'juan@vitess.io' from user_metadata where user_id = 1 order by user_id asc limit 10 for update",
    "Query": "update user_metadata set email = 'juan@vitess.io' where user_id = 1 order by user_id asc limit 10",
    "Table": "user_metadata",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "user_index"
  }
}

# update changes non owned vindex column
"update music_extra set music_id = 1 where user_id = 1"
{
  "QueryType": "UPDATE",
  "Original": "update music_extra set music_id = 1 where user_id = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Equal",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "ChangedVindexValues": [
      "music_user_map:1"
    ],
    "KsidLength": 1,
    "KsidVindex": "user_index",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select user_id, music_id = 1 from music_extra where user_id = 1 for update",
    "Query": "update music_extra set music_id = 1 where user_id = 1",
    "Table": "music_extra",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "user_index"
  }
}
{
  "QueryType": "UPDATE",
  "Original": "update music_extra set music_id = 1 where user_id = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "EqualUnique",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "ChangedVindexValues": [
      "music_user_map:1"
    ],
    "KsidLength": 1,
    "KsidVindex": "user_index",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select user_id, music_id = 1 from music_extra where user_id = 1 for update",
    "Query": "update music_extra set music_id = 1 where user_id = 1",
    "Table": "music_extra",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "user_index"
  }
}

# update by primary keyspace id, stray where clause
"update user set val = 1 where id = id2 and id = 1"
{
  "QueryType": "UPDATE",
  "Original": "update user set val = 1 where id = id2 and id = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Equal",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update `user` set val = 1 where id = id2 and id = 1",
    "Table": "user",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "user_index"
  }
}
{
  "QueryType": "UPDATE",
  "Original": "update user set val = 1 where id = id2 and id = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "EqualUnique",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update `user` set val = 1 where id = id2 and id = 1",
    "Table": "user",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "user_index"
  }
}

# update by primary keyspace id, stray where clause with conversion error
"update user set val = 1 where id = 18446744073709551616 and id = 1"
{
  "QueryType": "UPDATE",
  "Original": "update user set val = 1 where id = 18446744073709551616 and id = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Equal",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update `user` set val = 1 where id = 18446744073709551616 and id = 1",
    "Table": "user",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "user_index"
  }
}
{
  "QueryType": "UPDATE",
  "Original": "update user set val = 1 where id = 18446744073709551616 and id = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "EqualUnique",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update `user` set val = 1 where id = 18446744073709551616 and id = 1",
    "Table": "user",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "user_index"
  }
}

# delete from by primary keyspace id
"delete from user where id = 1"
{
  "QueryType": "DELETE",
  "Original": "delete from user where id = 1",
  "Instructions": {
    "OperatorType": "Delete",
    "Variant": "Equal",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "KsidLength": 1,
    "KsidVindex": "user_index",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select Id, `Name`, Costly from `user` where id = 1 for update",
    "Query": "delete from `user` where id = 1",
    "Table": "user",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "user_index"
  }
}
Gen4 plan same as above

# multi-table delete with comma join
"delete a from unsharded_a a, unsharded_b b where a.id = b.id and b.val = 1"
{
  "QueryType": "DELETE",
  "Original": "delete a from unsharded_a a, unsharded_b b where a.id = b.id and b.val = 1",
  "Instructions": {
    "OperatorType": "Delete",
    "Variant": "Unsharded",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "delete a from unsharded_a as a, unsharded_b as b where a.id = b.id and b.val = 1"
  }
}
Gen4 plan same as above

# multi-table delete with ansi join
"delete a from unsharded_a a join unsharded_b b on a.id = b.id where b.val = 1"
{
  "QueryType": "DELETE",
  "Original": "delete a from unsharded_a a join unsharded_b b on a.id = b.id where b.val = 1",
  "Instructions": {
    "OperatorType": "Delete",
    "Variant": "Unsharded",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "delete a from unsharded_a as a join unsharded_b as b on a.id = b.id where b.val = 1"
  }
}
Gen4 plan same as above

#delete with join from subquery
"delete foo from unsharded as foo left join (select id from unsharded where col is not null order by col desc limit 10) as keepers on foo.id = keepers.id where keepers.id is null and foo.col is not null and foo.col < 1000"
{
  "QueryType": "DELETE",
  "Original": "delete foo from unsharded as foo left join (select id from unsharded where col is not null order by col desc limit 10) as keepers on foo.id = keepers.id where keepers.id is null and foo.col is not null and foo.col \u003c 1000",
  "Instructions": {
    "OperatorType": "Delete",
    "Variant": "Unsharded",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "delete foo from unsharded as foo left join (select id from unsharded where col is not null order by col desc limit 10) as keepers on foo.id = keepers.id where keepers.id is null and foo.col is not null and foo.col \u003c 1000"
  }
}
Gen4 plan same as above

# routing rules: deleted from a routed table
"delete from route1 where id = 1"
{
  "QueryType": "DELETE",
  "Original": "delete from route1 where id = 1",
  "Instructions": {
    "OperatorType": "Delete",
    "Variant": "Equal",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "KsidLength": 1,
    "KsidVindex": "user_index",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select Id, `Name`, Costly from `user` as route1 where id = 1 for update",
    "Query": "delete from `user` as route1 where id = 1",
    "Table": "user",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "user_index"
  }
}
Gen4 plan same as above

# delete: routing rules for subquery
"delete from  unsharded_a where a=(select a from route2)"
{
  "QueryType": "DELETE",
  "Original": "delete from  unsharded_a where a=(select a from route2)",
  "Instructions": {
    "OperatorType": "Delete",
    "Variant": "Unsharded",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "delete from unsharded_a where a = (select a from unsharded as route2)"
  }
}
Gen4 plan same as above

# update by lookup
"update music set val = 1 where id = 1"
{
  "QueryType": "UPDATE",
  "Original": "update music set val = 1 where id = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Equal",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update music set val = 1 where id = 1",
    "Table": "music",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "music_user_map"
  }
}
{
  "QueryType": "UPDATE",
  "Original": "update music set val = 1 where id = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "EqualUnique",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update music set val = 1 where id = 1",
    "Table": "music",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "music_user_map"
  }
}

# update multi-table ansi join
"update unsharded_a a join unsharded_b b on a.id = b.id set a.val = 'foo' where b.val = 1"
{
  "QueryType": "UPDATE",
  "Original": "update unsharded_a a join unsharded_b b on a.id = b.id set a.val = 'foo' where b.val = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Unsharded",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update unsharded_a as a join unsharded_b as b on a.id = b.id set a.val = 'foo' where b.val = 1"
  }
}
Gen4 plan same as above

# update multi-table comma join
"update unsharded_a a, unsharded_b b set a.val = 'foo' where a.id = b.id and b.val = 1"
{
  "QueryType": "UPDATE",
  "Original": "update unsharded_a a, unsharded_b b set a.val = 'foo' where a.id = b.id and b.val = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Unsharded",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update unsharded_a as a, unsharded_b as b set a.val = 'foo' where a.id = b.id and b.val = 1"
  }
}
Gen4 plan same as above

# delete from by lookup
"delete from music where id = 1"
{
  "QueryType": "DELETE",
  "Original": "delete from music where id = 1",
  "Instructions": {
    "OperatorType": "Delete",
    "Variant": "Equal",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "KsidLength": 1,
    "KsidVindex": "user_index",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select user_id, id from music where id = 1 for update",
    "Query": "delete from music where id = 1",
    "Table": "music",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "music_user_map"
  }
}
Gen4 plan same as above

# delete from, no owned vindexes
"delete from music_extra where user_id = 1"
{
  "QueryType": "DELETE",
  "Original": "delete from music_extra where user_id = 1",
  "Instructions": {
    "OperatorType": "Delete",
    "Variant": "Equal",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "delete from music_extra where user_id = 1",
    "Table": "music_extra",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "user_index"
  }
}
Gen4 plan same as above

# simple insert, no values
"insert into unsharded values()"
{
  "QueryType": "INSERT",
  "Original": "insert into unsharded values()",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Unsharded",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "insert into unsharded values ()",
    "TableName": "unsharded"
  }
}
Gen4 plan same as above

# simple insert unsharded
"insert into unsharded values(1, 2)"
{
  "QueryType": "INSERT",
  "Original": "insert into unsharded values(1, 2)",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Unsharded",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "insert into unsharded values (1, 2)",
    "TableName": "unsharded"
  }
}
Gen4 plan same as above

# simple upsert unsharded
"insert into unsharded values(1, 2) on duplicate key update x = 3"
{
  "QueryType": "INSERT",
  "Original": "insert into unsharded values(1, 2) on duplicate key update x = 3",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Unsharded",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "insert into unsharded values (1, 2) on duplicate key update x = 3",
    "TableName": "unsharded"
  }
}
Gen4 plan same as above

# unsharded insert, no col list with auto-inc and authoritative column list
"insert into unsharded_authoritative values(1,1)"
{
  "QueryType": "INSERT",
  "Original": "insert into unsharded_authoritative values(1,1)",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Unsharded",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "insert into unsharded_authoritative(col1, col2) values (:__seq0, 1)",
    "TableName": "unsharded_authoritative"
  }
}
Gen4 plan same as above

# sharded upsert with sharding key set to vindex column
"insert into music(user_id, id) values(1, 2) on duplicate key update user_id = values(user_id)"
{
  "QueryType": "INSERT",
  "Original": "insert into music(user_id, id) values(1, 2) on duplicate key update user_id = values(user_id)",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Sharded",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "InsertIgnore": true,
    "MultiShardAutocommit": false,
    "Query": "insert into music(user_id, id) values (:_user_id_0, :_id_0) on duplicate key update user_id = values(user_id)",
    "TableName": "music",
    "VindexValues": {
      "music_user_map": "INT64(2)",
      "user_index": "INT64(1)"
    }
  }
}
Gen4 plan same as above

# sharded bulk upsert with sharding key set to vindex column
"insert into music(user_id, id) values (1, 2), (3,4) on duplicate key update user_id = values(user_id)"
{
  "QueryType": "INSERT",
  "Original": "insert into music(user_id, id) values (1, 2), (3,4) on duplicate key update user_id = values(user_id)",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Sharded",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "InsertIgnore": true,
    "MultiShardAutocommit": false,
    "Query": "insert into music(user_id, id) values (:_user_id_0, :_id_0), (:_user_id_1, :_id_1) on duplicate key update user_id = values(user_id)",
    "TableName": "music",
    "VindexValues": {
      "music_user_map": "INT64(2), INT64(4)",
      "user_index": "INT64(1), INT64(3)"
    }
  }
}
Gen4 plan same as above

# insert unsharded with select
"insert into unsharded select id from unsharded_auto"
{
  "QueryType": "INSERT",
  "Original": "insert into unsharded select id from unsharded_auto",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Unsharded",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "insert into unsharded select id from unsharded_auto for update",
    "TableName": "unsharded"
  }
}
Gen4 plan same as above

# insert unsharded with select with join
"insert into unsharded select id from unsharded join unsharded_auto"
{
  "QueryType": "INSERT",
  "Original": "insert into unsharded select id from unsharded join unsharded_auto",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Unsharded",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "insert into unsharded select id from unsharded join unsharded_auto for update",
    "TableName": "unsharded"
  }
}
Gen4 plan same as above

# insert unsharded, invalid value for auto-inc
"insert into unsharded_auto(id, val) values(18446744073709551616, 'aa')"
{
  "QueryType": "INSERT",
  "Original": "insert into unsharded_auto(id, val) values(18446744073709551616, 'aa')",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Unsharded",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "insert into unsharded_auto(id, val) values (:__seq0, 'aa')",
    "TableName": "unsharded_auto"
  }
}
Gen4 plan same as above

# insert unsharded, column present
"insert into unsharded_auto(id, val) values(1, 'aa')"
{
  "QueryType": "INSERT",
  "Original": "insert into unsharded_auto(id, val) values(1, 'aa')",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Unsharded",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "insert into unsharded_auto(id, val) values (:__seq0, 'aa')",
    "TableName": "unsharded_auto"
  }
}
Gen4 plan same as above

# insert unsharded, column absent
"insert into unsharded_auto(val) values('aa')"
{
  "QueryType": "INSERT",
  "Original": "insert into unsharded_auto(val) values('aa')",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Unsharded",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "insert into unsharded_auto(val, id) values ('aa', :__seq0)",
    "TableName": "unsharded_auto"
  }
}
Gen4 plan same as above

# insert unsharded, column absent
"insert into unsharded_auto(val) values(false)"
{
  "QueryType": "INSERT",
  "Original": "insert into unsharded_auto(val) values(false)",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Unsharded",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "insert into unsharded_auto(val, id) values (false, :__seq0)",
    "TableName": "unsharded_auto"
  }
}
Gen4 plan same as above

# insert unsharded, multi-val
"insert into unsharded_auto(id, val) values(1, 'aa'), (null, 'bb')"
{
  "QueryType": "INSERT",
  "Original": "insert into unsharded_auto(id, val) values(1, 'aa'), (null, 'bb')",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Unsharded",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "insert into unsharded_auto(id, val) values (:__seq0, 'aa'), (:__seq1, 'bb')",
    "TableName": "unsharded_auto"
  }
}
Gen4 plan same as above

# unsharded insert subquery in insert value
"insert into unsharded values((select 1 from dual), 1)"
{
  "QueryType": "INSERT",
  "Original": "insert into unsharded values((select 1 from dual), 1)",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Unsharded",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "insert into unsharded values (1, 1)",
    "TableName": "unsharded"
  }
}
Gen4 plan same as above

# sharded insert subquery in insert value
"insert into user(id, val) values((select 1), 1)"
{
  "QueryType": "INSERT",
  "Original": "insert into user(id, val) values((select 1), 1)",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Sharded",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "insert into `user`(id, val, `Name`, Costly) values (:_Id_0, 1, :_Name_0, :_Costly_0)",
    "TableName": "user",
    "VindexValues": {
      "costly_map": "NULL",
      "name_user_map": "NULL",
      "user_index": ":__seq0"
    }
  }
}
Gen4 plan same as above

# insert into a routed table
"insert into route1(id) values (1)"
{
  "QueryType": "INSERT",
  "Original": "insert into route1(id) values (1)",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Sharded",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "insert into `user`(id, `Name`, Costly) values (:_Id_0, :_Name_0, :_Costly_0)",
    "TableName": "user",
    "VindexValues": {
      "costly_map": "NULL",
      "name_user_map": "NULL",
      "user_index": ":__seq0"
    }
  }
}
Gen4 plan same as above

# insert with mimatched column list
"insert into user(id) values (1, 2)"
"column list doesn't match values"
Gen4 plan same as above

# insert no column list for sharded authoritative table
"insert into authoritative values(1, 2, 3)"
{
  "QueryType": "INSERT",
  "Original": "insert into authoritative values(1, 2, 3)",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Sharded",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "insert into authoritative(user_id, col1, col2) values (:_user_id_0, 2, 3)",
    "TableName": "authoritative",
    "VindexValues": {
      "user_index": "INT64(1)"
    }
  }
}
Gen4 plan same as above

# insert sharded, no values
"insert into user values()"
{
  "QueryType": "INSERT",
  "Original": "insert into user values()",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Sharded",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "insert into `user`(id, `Name`, Costly) values (:_Id_0, :_Name_0, :_Costly_0)",
    "TableName": "user",
    "VindexValues": {
      "costly_map": "NULL",
      "name_user_map": "NULL",
      "user_index": ":__seq0"
    }
  }
}
Gen4 plan same as above

# insert with one vindex
"insert into user(id) values (1)"
{
  "QueryType": "INSERT",
  "Original": "insert into user(id) values (1)",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Sharded",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "insert into `user`(id, `Name`, Costly) values (:_Id_0, :_Name_0, :_Costly_0)",
    "TableName": "user",
    "VindexValues": {
      "costly_map": "NULL",
      "name_user_map": "NULL",
      "user_index": ":__seq0"
    }
  }
}
Gen4 plan same as above

# insert ignore sharded
"insert ignore into user(id) values (1)"
{
  "QueryType": "INSERT",
  "Original": "insert ignore into user(id) values (1)",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Sharded",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "InsertIgnore": true,
    "MultiShardAutocommit": false,
    "Query": "insert ignore into `user`(id, `Name`, Costly) values (:_Id_0, :_Name_0, :_Costly_0)",
    "TableName": "user",
    "VindexValues": {
      "costly_map": "NULL",
      "name_user_map": "NULL",
      "user_index": ":__seq0"
    }
  }
}
Gen4 plan same as above

# insert on duplicate key
"insert into user(id) values(1) on duplicate key update col = 2"
{
  "QueryType": "INSERT",
  "Original": "insert into user(id) values(1) on duplicate key update col = 2",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Sharded",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "InsertIgnore": true,
    "MultiShardAutocommit": false,
    "Query": "insert into `user`(id, `Name`, Costly) values (:_Id_0, :_Name_0, :_Costly_0) on duplicate key update col = 2",
    "TableName": "user",
    "VindexValues": {
      "costly_map": "NULL",
      "name_user_map": "NULL",
      "user_index": ":__seq0"
    }
  }
}
Gen4 plan same as above

# insert with one vindex and bind var
"insert into user(id) values (:aa)"
{
  "QueryType": "INSERT",
  "Original": "insert into user(id) values (:aa)",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Sharded",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "insert into `user`(id, `Name`, Costly) values (:_Id_0, :_Name_0, :_Costly_0)",
    "TableName": "user",
    "VindexValues": {
      "costly_map": "NULL",
      "name_user_map": "NULL",
      "user_index": ":__seq0"
    }
  }
}
Gen4 plan same as above

# insert with non vindex
"insert into user(nonid) values (2)"
{
  "QueryType": "INSERT",
  "Original": "insert into user(nonid) values (2)",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Sharded",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "insert into `user`(nonid, id, `Name`, Costly) values (2, :_Id_0, :_Name_0, :_Costly_0)",
    "TableName": "user",
    "VindexValues": {
      "costly_map": "NULL",
      "name_user_map": "NULL",
      "user_index": ":__seq0"
    }
  }
}
Gen4 plan same as above

# insert with default seq
"insert into user(id, nonid) values (default, 2)"
{
  "QueryType": "INSERT",
  "Original": "insert into user(id, nonid) values (default, 2)",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Sharded",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "insert into `user`(id, nonid, `Name`, Costly) values (:_Id_0, 2, :_Name_0, :_Costly_0)",
    "TableName": "user",
    "VindexValues": {
      "costly_map": "NULL",
      "name_user_map": "NULL",
      "user_index": ":__seq0"
    }
  }
}
Gen4 plan same as above

# insert with non vindex bool value
"insert into user(nonid) values (true)"
{
  "QueryType": "INSERT",
  "Original": "insert into user(nonid) values (true)",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Sharded",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "insert into `user`(nonid, id, `Name`, Costly) values (true, :_Id_0, :_Name_0, :_Costly_0)",
    "TableName": "user",
    "VindexValues": {
      "costly_map": "NULL",
      "name_user_map": "NULL",
      "user_index": ":__seq0"
    }
  }
}
Gen4 plan same as above

# insert with all vindexes supplied
"insert into user(nonid, name, id) values (2, 'foo', 1)"
{
  "QueryType": "INSERT",
  "Original": "insert into user(nonid, name, id) values (2, 'foo', 1)",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Sharded",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "insert into `user`(nonid, `name`, id, Costly) values (2, :_Name_0, :_Id_0, :_Costly_0)",
    "TableName": "user",
    "VindexValues": {
      "costly_map": "NULL",
      "name_user_map": "VARCHAR(\"foo\")",
      "user_index": ":__seq0"
    }
  }
}
Gen4 plan same as above

# insert for non-vindex autoinc
"insert into user_extra(nonid) values (2)"
{
  "QueryType": "INSERT",
  "Original": "insert into user_extra(nonid) values (2)",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Sharded",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "insert into user_extra(nonid, extra_id, user_id) values (2, :__seq0, :_user_id_0)",
    "TableName": "user_extra",
    "VindexValues": {
      "user_index": "NULL"
    }
  }
}
Gen4 plan same as above

# insert for non-compliant names
"insert into `weird``name`(`a``b*c`, `b*c`) values(1, 2)"
{
  "QueryType": "INSERT",
  "Original": "insert into `weird``name`(`a``b*c`, `b*c`) values(1, 2)",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Sharded",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "insert into `weird``name`(`a``b*c`, `b*c`) values (:_a_b_c_0, 2)",
    "TableName": "weird`name",
    "VindexValues": {
      "user_index": "INT64(1)"
    }
  }
}
Gen4 plan same as above

# unsharded insert from union
"insert into unsharded select 1 from dual union select 1 from dual"
{
  "QueryType": "INSERT",
  "Original": "insert into unsharded select 1 from dual union select 1 from dual",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Unsharded",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "insert into unsharded select 1 from dual union select 1 from dual for update",
    "TableName": "unsharded"
  }
}
Gen4 plan same as above

# insert for non-vindex autoinc, invalid value
"insert into user_extra(nonid, extra_id) values (2, 18446744073709551616)"
{
  "QueryType": "INSERT",
  "Original": "insert into user_extra(nonid, extra_id) values (2, 18446744073709551616)",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Sharded",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "insert into user_extra(nonid, extra_id, user_id) values (2, :__seq0, :_user_id_0)",
    "TableName": "user_extra",
    "VindexValues": {
      "user_index": "NULL"
    }
  }
}
Gen4 plan same as above

# insert invalid index value
"insert into music_extra(music_id, user_id) values(1, 18446744073709551616)"
{
  "QueryType": "INSERT",
  "Original": "insert into music_extra(music_id, user_id) values(1, 18446744073709551616)",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Sharded",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "insert into music_extra(music_id, user_id) values (:_music_id_0, :_user_id_0)",
    "TableName": "music_extra",
    "VindexValues": {
      "music_user_map": "INT64(1)",
      "user_index": "DECIMAL(18446744073709551616)"
    }
  }
}
Gen4 plan same as above

# insert invalid index value
"insert into music_extra(music_id, user_id) values(1, id)"
"column access not supported here"
Gen4 plan same as above

# insert invalid table
"insert into noexist(music_id, user_id) values(1, 18446744073709551616)"
"table noexist not found"
Gen4 plan same as above

# insert with multiple rows
"insert into user(id) values (1), (2)"
{
  "QueryType": "INSERT",
  "Original": "insert into user(id) values (1), (2)",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Sharded",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "insert into `user`(id, `Name`, Costly) values (:_Id_0, :_Name_0, :_Costly_0), (:_Id_1, :_Name_1, :_Costly_1)",
    "TableName": "user",
    "VindexValues": {
      "costly_map": "NULL, NULL",
      "name_user_map": "NULL, NULL",
      "user_index": ":__seq0, :__seq1"
    }
  }
}
Gen4 plan same as above

# insert with query timeout
"insert /*vt+ QUERY_TIMEOUT_MS=1 */ into user(id) values (1), (2)"
{
  "QueryType": "INSERT",
  "Original": "insert /*vt+ QUERY_TIMEOUT_MS=1 */ into user(id) values (1), (2)",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Sharded",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "insert /*vt+ QUERY_TIMEOUT_MS=1 */ into `user`(id, `Name`, Costly) values (:_Id_0, :_Name_0, :_Costly_0), (:_Id_1, :_Name_1, :_Costly_1)",
    "QueryTimeout": 1,
    "TableName": "user",
    "VindexValues": {
      "costly_map": "NULL, NULL",
      "name_user_map": "NULL, NULL",
      "user_index": ":__seq0, :__seq1"
    }
  }
}
Gen4 plan same as above

# insert with multiple rows - multi-shard autocommit
"insert /*vt+ MULTI_SHARD_AUTOCOMMIT=1 */ into user(id) values (1), (2)"
{
  "QueryType": "INSERT",
  "Original": "insert /*vt+ MULTI_SHARD_AUTOCOMMIT=1 */ into user(id) values (1), (2)",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Sharded",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": true,
    "Query": "insert /*vt+ MULTI_SHARD_AUTOCOMMIT=1 */ into `user`(id, `Name`, Costly) values (:_Id_0, :_Name_0, :_Costly_0), (:_Id_1, :_Name_1, :_Costly_1)",
    "TableName": "user",
    "VindexValues": {
      "costly_map": "NULL, NULL",
      "name_user_map": "NULL, NULL",
      "user_index": ":__seq0, :__seq1"
    }
  }
}
Gen4 plan same as above

# insert into a vindex not allowed
"insert into user_index(id) values(1)"
"unsupported: multi-shard or vindex write statement"
Gen4 plan same as above

# simple replace unsharded
"replace into unsharded values(1, 2)"
{
  "QueryType": "INSERT",
  "Original": "replace into unsharded values(1, 2)",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Unsharded",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "replace into unsharded values (1, 2)",
    "TableName": "unsharded"
  }
}
Gen4 plan same as above

# replace unsharded with select
"replace into unsharded select id from unsharded_auto"
{
  "QueryType": "INSERT",
  "Original": "replace into unsharded select id from unsharded_auto",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Unsharded",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "replace into unsharded select id from unsharded_auto for update",
    "TableName": "unsharded"
  }
}
Gen4 plan same as above

# replace unsharded, invalid value for auto-inc
"replace into unsharded_auto(id, val) values(18446744073709551616, 'aa')"
{
  "QueryType": "INSERT",
  "Original": "replace into unsharded_auto(id, val) values(18446744073709551616, 'aa')",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Unsharded",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "replace into unsharded_auto(id, val) values (:__seq0, 'aa')",
    "TableName": "unsharded_auto"
  }
}
Gen4 plan same as above

# replace unsharded, column present
"replace into unsharded_auto(id, val) values(1, 'aa')"
{
  "QueryType": "INSERT",
  "Original": "replace into unsharded_auto(id, val) values(1, 'aa')",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Unsharded",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "replace into unsharded_auto(id, val) values (:__seq0, 'aa')",
    "TableName": "unsharded_auto"
  }
}
Gen4 plan same as above

# replace unsharded, column absent
"replace into unsharded_auto(val) values('aa')"
{
  "QueryType": "INSERT",
  "Original": "replace into unsharded_auto(val) values('aa')",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Unsharded",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "replace into unsharded_auto(val, id) values ('aa', :__seq0)",
    "TableName": "unsharded_auto"
  }
}
Gen4 plan same as above

# replace unsharded, multi-val
"replace into unsharded_auto(id, val) values(1, 'aa'), (null, 'bb')"
{
  "QueryType": "INSERT",
  "Original": "replace into unsharded_auto(id, val) values(1, 'aa'), (null, 'bb')",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Unsharded",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "replace into unsharded_auto(id, val) values (:__seq0, 'aa'), (:__seq1, 'bb')",
    "TableName": "unsharded_auto"
  }
}
Gen4 plan same as above

# replace invalid table
"replace into noexist(music_id, user_id) values(1, 18446744073709551616)"
"table noexist not found"
Gen4 plan same as above

# insert a row in a multi column vindex table
"insert multicolvin (column_a, column_b, column_c, kid) VALUES (1,2,3,4)"
{
  "QueryType": "INSERT",
  "Original": "insert multicolvin (column_a, column_b, column_c, kid) VALUES (1,2,3,4)",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Sharded",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "insert into multicolvin(column_a, column_b, column_c, kid) values (:_column_a_0, :_column_b_0, :_column_c_0, :_kid_0)",
    "TableName": "multicolvin",
    "VindexValues": {
      "cola_map": "INT64(1)",
      "colb_colc_map": "INT64(2), INT64(3)",
      "kid_index": "INT64(4)"
    }
  }
}
Gen4 plan same as above

# insert for overlapped vindex columns
"insert overlap_vindex (kid, column_a, column_b) VALUES (1,2,3)"
{
  "QueryType": "INSERT",
  "Original": "insert overlap_vindex (kid, column_a, column_b) VALUES (1,2,3)",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Sharded",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "insert into overlap_vindex(kid, column_a, column_b) values (:_kid_0, :_column_a_0, 3)",
    "TableName": "overlap_vindex",
    "VindexValues": {
      "cola_kid_map": "INT64(2), INT64(1)",
      "kid_index": "INT64(1)"
    }
  }
}
Gen4 plan same as above

# insert multiple rows in a multi column vindex table
"insert multicolvin (column_a, column_b, column_c, kid) VALUES (1,2,3,4), (5,6,7,8)"
{
  "QueryType": "INSERT",
  "Original": "insert multicolvin (column_a, column_b, column_c, kid) VALUES (1,2,3,4), (5,6,7,8)",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Sharded",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "insert into multicolvin(column_a, column_b, column_c, kid) values (:_column_a_0, :_column_b_0, :_column_c_0, :_kid_0), (:_column_a_1, :_column_b_1, :_column_c_1, :_kid_1)",
    "TableName": "multicolvin",
    "VindexValues": {
      "cola_map": "INT64(1), INT64(5)",
      "colb_colc_map": "INT64(2), INT64(6), INT64(3), INT64(7)",
      "kid_index": "INT64(4), INT64(8)"
    }
  }
}
Gen4 plan same as above

# delete row in a multi column vindex table
"delete from multicolvin where kid=1"
{
  "QueryType": "DELETE",
  "Original": "delete from multicolvin where kid=1",
  "Instructions": {
    "OperatorType": "Delete",
    "Variant": "Equal",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "KsidLength": 1,
    "KsidVindex": "kid_index",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select kid, column_a, column_b, column_c from multicolvin where kid = 1 for update",
    "Query": "delete from multicolvin where kid = 1",
    "Table": "multicolvin",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "kid_index"
  }
}
Gen4 plan same as above

# update columns of multi column vindex
"update multicolvin set column_b = 1, column_c = 2 where kid = 1"
{
  "QueryType": "UPDATE",
  "Original": "update multicolvin set column_b = 1, column_c = 2 where kid = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Equal",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "ChangedVindexValues": [
      "colb_colc_map:4"
    ],
    "KsidLength": 1,
    "KsidVindex": "kid_index",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select kid, column_a, column_b, column_c, column_b = 1 and column_c = 2 from multicolvin where kid = 1 for update",
    "Query": "update multicolvin set column_b = 1, column_c = 2 where kid = 1",
    "Table": "multicolvin",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "kid_index"
  }
}
{
  "QueryType": "UPDATE",
  "Original": "update multicolvin set column_b = 1, column_c = 2 where kid = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "EqualUnique",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "ChangedVindexValues": [
      "colb_colc_map:4"
    ],
    "KsidLength": 1,
    "KsidVindex": "kid_index",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select kid, column_a, column_b, column_c, column_b = 1 and column_c = 2 from multicolvin where kid = 1 for update",
    "Query": "update multicolvin set column_b = 1, column_c = 2 where kid = 1",
    "Table": "multicolvin",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "kid_index"
  }
}

# update multiple vindexes, with multi column vindex
"update multicolvin set column_a = 0, column_b = 1, column_c = 2 where kid = 1"
{
  "QueryType": "UPDATE",
  "Original": "update multicolvin set column_a = 0, column_b = 1, column_c = 2 where kid = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Equal",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "ChangedVindexValues": [
      "cola_map:4",
      "colb_colc_map:5"
    ],
    "KsidLength": 1,
    "KsidVindex": "kid_index",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select kid, column_a, column_b, column_c, column_a = 0, column_b = 1 and column_c = 2 from multicolvin where kid = 1 for update",
    "Query": "update multicolvin set column_a = 0, column_b = 1, column_c = 2 where kid = 1",
    "Table": "multicolvin",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "kid_index"
  }
}
{
  "QueryType": "UPDATE",
  "Original": "update multicolvin set column_a = 0, column_b = 1, column_c = 2 where kid = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "EqualUnique",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "ChangedVindexValues": [
      "cola_map:4",
      "colb_colc_map:5"
    ],
    "KsidLength": 1,
    "KsidVindex": "kid_index",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select kid, column_a, column_b, column_c, column_a = 0, column_b = 1 and column_c = 2 from multicolvin where kid = 1 for update",
    "Query": "update multicolvin set column_a = 0, column_b = 1, column_c = 2 where kid = 1",
    "Table": "multicolvin",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "kid_index"
  }
}

# update with no primary vindex on where clause (scatter update)
"update user_extra set val = 1"
{
  "QueryType": "UPDATE",
  "Original": "update user_extra set val = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Scatter",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update user_extra set val = 1",
    "Table": "user_extra"
  }
}
Gen4 plan same as above

# update with target destination
"update `user[-]`.user_extra set val = 1"
{
  "QueryType": "UPDATE",
  "Original": "update `user[-]`.user_extra set val = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "ByDestination",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update user_extra set val = 1",
    "Table": "user_extra"
  }
}
Gen4 plan same as above

# update with no primary vindex on where clause (scatter update)   - multi shard autocommit
"update /*vt+ MULTI_SHARD_AUTOCOMMIT=1 */  user_extra set val = 1"
{
  "QueryType": "UPDATE",
  "Original": "update /*vt+ MULTI_SHARD_AUTOCOMMIT=1 */  user_extra set val = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Scatter",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": true,
    "Query": "update /*vt+ MULTI_SHARD_AUTOCOMMIT=1 */ user_extra set val = 1",
    "Table": "user_extra"
  }
}
Gen4 plan same as above

# update with no primary vindex on where clause (scatter update)   - query timeout
"update /*vt+ QUERY_TIMEOUT_MS=1 */  user_extra set val = 1"
{
  "QueryType": "UPDATE",
  "Original": "update /*vt+ QUERY_TIMEOUT_MS=1 */  user_extra set val = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Scatter",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update /*vt+ QUERY_TIMEOUT_MS=1 */ user_extra set val = 1",
    "QueryTimeout": 1,
    "Table": "user_extra"
  }
}
Gen4 plan same as above

# update with non-comparison expr
"update user_extra set val = 1 where id between 1 and 2"
{
  "QueryType": "UPDATE",
  "Original": "update user_extra set val = 1 where id between 1 and 2",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Scatter",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update user_extra set val = 1 where id between 1 and 2",
    "Table": "user_extra"
  }
}
Gen4 plan same as above

# update with primary id through IN clause
"update user_extra set val = 1 where user_id in (1, 2)"
{
  "QueryType": "UPDATE",
  "Original": "update user_extra set val = 1 where user_id in (1, 2)",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "IN",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update user_extra set val = 1 where user_id in (1, 2)",
    "Table": "user_extra",
    "Values": [
      "(INT64(1), INT64(2))"
    ],
    "Vindex": "user_index"
  }
}
Gen4 plan same as above

# update with non-unique key
"update user_extra set val = 1 where name = 'foo'"
{
  "QueryType": "UPDATE",
  "Original": "update user_extra set val = 1 where name = 'foo'",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Scatter",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update user_extra set val = 1 where `name` = 'foo'",
    "Table": "user_extra"
  }
}
Gen4 plan same as above

# update by lookup with IN clause
"update user_extra set val = 1 where id in (1, 2)"
{
  "QueryType": "UPDATE",
  "Original": "update user_extra set val = 1 where id in (1, 2)",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Scatter",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update user_extra set val = 1 where id in (1, 2)",
    "Table": "user_extra"
  }
}
Gen4 plan same as above

# update with where clause with parens
"update user_extra set val = 1 where (name = 'foo' or id = 1)"
{
  "QueryType": "UPDATE",
  "Original": "update user_extra set val = 1 where (name = 'foo' or id = 1)",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Scatter",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update user_extra set val = 1 where `name` = 'foo' or id = 1",
    "Table": "user_extra"
  }
}
Gen4 plan same as above

# delete from with no where clause
"delete from user_extra"
{
  "QueryType": "DELETE",
  "Original": "delete from user_extra",
  "Instructions": {
    "OperatorType": "Delete",
    "Variant": "Scatter",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "delete from user_extra",
    "Table": "user_extra"
  }
}
Gen4 plan same as above

# delete with target destination
"delete from `user[-]`.user_extra"
{
  "QueryType": "DELETE",
  "Original": "delete from `user[-]`.user_extra",
  "Instructions": {
    "OperatorType": "Delete",
    "Variant": "ByDestination",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "delete from user_extra",
    "Table": "user_extra"
  }
}
Gen4 plan same as above

# delete with non-comparison expr
"delete from user_extra where user_id between 1 and 2"
{
  "QueryType": "DELETE",
  "Original": "delete from user_extra where user_id between 1 and 2",
  "Instructions": {
    "OperatorType": "Delete",
    "Variant": "Scatter",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "delete from user_extra where user_id between 1 and 2",
    "Table": "user_extra"
  }
}
Gen4 plan same as above

# delete from with no index match
"delete from user_extra where name = 'jose'"
{
  "QueryType": "DELETE",
  "Original": "delete from user_extra where name = 'jose'",
  "Instructions": {
    "OperatorType": "Delete",
    "Variant": "Scatter",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "delete from user_extra where `name` = 'jose'",
    "Table": "user_extra"
  }
}
Gen4 plan same as above

# delete from with no index match - multi shard autocommit
"delete /*vt+ MULTI_SHARD_AUTOCOMMIT=1 */ from user_extra where name = 'jose'"
{
  "QueryType": "DELETE",
  "Original": "delete /*vt+ MULTI_SHARD_AUTOCOMMIT=1 */ from user_extra where name = 'jose'",
  "Instructions": {
    "OperatorType": "Delete",
    "Variant": "Scatter",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": true,
    "Query": "delete /*vt+ MULTI_SHARD_AUTOCOMMIT=1 */ from user_extra where `name` = 'jose'",
    "Table": "user_extra"
  }
}
Gen4 plan same as above

# delete from with no index match - query timeout
"delete /*vt+ QUERY_TIMEOUT_MS=1 */ from user_extra where name = 'jose'"
{
  "QueryType": "DELETE",
  "Original": "delete /*vt+ QUERY_TIMEOUT_MS=1 */ from user_extra where name = 'jose'",
  "Instructions": {
    "OperatorType": "Delete",
    "Variant": "Scatter",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "delete /*vt+ QUERY_TIMEOUT_MS=1 */ from user_extra where `name` = 'jose'",
    "QueryTimeout": 1,
    "Table": "user_extra"
  }
}
Gen4 plan same as above

# delete from with primary id in through IN clause
"delete from user_extra where user_id in (1, 2)"
{
  "QueryType": "DELETE",
  "Original": "delete from user_extra where user_id in (1, 2)",
  "Instructions": {
    "OperatorType": "Delete",
    "Variant": "IN",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "delete from user_extra where user_id in (1, 2)",
    "Table": "user_extra",
    "Values": [
      "(INT64(1), INT64(2))"
    ],
    "Vindex": "user_index"
  }
}
Gen4 plan same as above

# unsharded update where inner query references outer query
"update unsharded set col = (select id from unsharded_a where id = unsharded.col) where col = (select id from unsharded_b)"
{
  "QueryType": "UPDATE",
  "Original": "update unsharded set col = (select id from unsharded_a where id = unsharded.col) where col = (select id from unsharded_b)",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Unsharded",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update unsharded set col = (select id from unsharded_a where id = unsharded.col) where col = (select id from unsharded_b)"
  }
}
Gen4 plan same as above

# unsharded delete where inner query references outer query
"delete from unsharded where col = (select id from unsharded_a where id = unsharded.col)"
{
  "QueryType": "DELETE",
  "Original": "delete from unsharded where col = (select id from unsharded_a where id = unsharded.col)",
  "Instructions": {
    "OperatorType": "Delete",
    "Variant": "Unsharded",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "delete from unsharded where col = (select id from unsharded_a where id = unsharded.col)"
  }
}
Gen4 plan same as above

# update vindex value to null
"update user set name = null where id = 1"
{
  "QueryType": "UPDATE",
  "Original": "update user set name = null where id = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Equal",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "ChangedVindexValues": [
      "name_user_map:3"
    ],
    "KsidLength": 1,
    "KsidVindex": "user_index",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select Id, `Name`, Costly, `name` = null from `user` where id = 1 for update",
    "Query": "update `user` set `name` = null where id = 1",
    "Table": "user",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "user_index"
  }
}
{
  "QueryType": "UPDATE",
  "Original": "update user set name = null where id = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "EqualUnique",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "ChangedVindexValues": [
      "name_user_map:3"
    ],
    "KsidLength": 1,
    "KsidVindex": "user_index",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select Id, `Name`, Costly, `name` = null from `user` where id = 1 for update",
    "Query": "update `user` set `name` = null where id = 1",
    "Table": "user",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "user_index"
  }
}

# insert using last_insert_id
"insert into unsharded values(last_insert_id(), 2)"
{
  "QueryType": "INSERT",
  "Original": "insert into unsharded values(last_insert_id(), 2)",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Unsharded",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "insert into unsharded values (:__lastInsertId, 2)",
    "TableName": "unsharded"
  }
}
Gen4 plan same as above

# update vindex value to null with multiple primary keyspace id
"update user set name = null where id in (1, 2, 3)"
{
  "QueryType": "UPDATE",
  "Original": "update user set name = null where id in (1, 2, 3)",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "IN",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "ChangedVindexValues": [
      "name_user_map:3"
    ],
    "KsidLength": 1,
    "KsidVindex": "user_index",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select Id, `Name`, Costly, `name` = null from `user` where id in (1, 2, 3) for update",
    "Query": "update `user` set `name` = null where id in (1, 2, 3)",
    "Table": "user",
    "Values": [
      "(INT64(1), INT64(2), INT64(3))"
    ],
    "Vindex": "user_index"
  }
}
Gen4 plan same as above

# update vindex value to null without a where clause
"update user set name = null"
{
  "QueryType": "UPDATE",
  "Original": "update user set name = null",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Scatter",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "ChangedVindexValues": [
      "name_user_map:3"
    ],
    "KsidLength": 1,
    "KsidVindex": "user_index",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select Id, `Name`, Costly, `name` = null from `user` for update",
    "Query": "update `user` set `name` = null",
    "Table": "user"
  }
}
Gen4 plan same as above

# update vindex value to null with complex where clause
"update user set name = null where id + 1 = 2"
{
  "QueryType": "UPDATE",
  "Original": "update user set name = null where id + 1 = 2",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Scatter",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "ChangedVindexValues": [
      "name_user_map:3"
    ],
    "KsidLength": 1,
    "KsidVindex": "user_index",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select Id, `Name`, Costly, `name` = null from `user` where id + 1 = 2 for update",
    "Query": "update `user` set `name` = null where id + 1 = 2",
    "Table": "user"
  }
}
Gen4 plan same as above

# delete from user by primary keyspace id with in clause
"delete from user where id in (1, 2, 3)"
{
  "QueryType": "DELETE",
  "Original": "delete from user where id in (1, 2, 3)",
  "Instructions": {
    "OperatorType": "Delete",
    "Variant": "IN",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "KsidLength": 1,
    "KsidVindex": "user_index",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select Id, `Name`, Costly from `user` where id in (1, 2, 3) for update",
    "Query": "delete from `user` where id in (1, 2, 3)",
    "Table": "user",
    "Values": [
      "(INT64(1), INT64(2), INT64(3))"
    ],
    "Vindex": "user_index"
  }
}
Gen4 plan same as above

# delete from user by complex expression
"delete from user where id + 1 = 2"
{
  "QueryType": "DELETE",
  "Original": "delete from user where id + 1 = 2",
  "Instructions": {
    "OperatorType": "Delete",
    "Variant": "Scatter",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "KsidLength": 1,
    "KsidVindex": "user_index",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select Id, `Name`, Costly from `user` where id + 1 = 2 for update",
    "Query": "delete from `user` where id + 1 = 2",
    "Table": "user"
  }
}
Gen4 plan same as above

# delete from user without a where clause
"delete from user"
{
  "QueryType": "DELETE",
  "Original": "delete from user",
  "Instructions": {
    "OperatorType": "Delete",
    "Variant": "Scatter",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "KsidLength": 1,
    "KsidVindex": "user_index",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select Id, `Name`, Costly from `user` for update",
    "Query": "delete from `user`",
    "Table": "user"
  }
}
Gen4 plan same as above

# delete with single table targets
"delete music from music where id = 1"
{
  "QueryType": "DELETE",
  "Original": "delete music from music where id = 1",
  "Instructions": {
    "OperatorType": "Delete",
    "Variant": "Equal",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "KsidLength": 1,
    "KsidVindex": "user_index",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select user_id, id from music where id = 1 for update",
    "Query": "delete from music where id = 1",
    "Table": "music",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "music_user_map"
  }
}
Gen4 plan same as above

# scatter update table with owned vindexes without changing lookup vindex
"update user set val = 1"
{
  "QueryType": "UPDATE",
  "Original": "update user set val = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Scatter",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update `user` set val = 1",
    "Table": "user"
  }
}
Gen4 plan same as above

# scatter delete with owned lookup vindex
"delete from user"
{
  "QueryType": "DELETE",
  "Original": "delete from user",
  "Instructions": {
    "OperatorType": "Delete",
    "Variant": "Scatter",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "KsidLength": 1,
    "KsidVindex": "user_index",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select Id, `Name`, Costly from `user` for update",
    "Query": "delete from `user`",
    "Table": "user"
  }
}
Gen4 plan same as above

# update multi column vindex, without values for all the vindex columns
"update multicolvin set column_c = 2 where kid = 1"
{
  "QueryType": "UPDATE",
  "Original": "update multicolvin set column_c = 2 where kid = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Equal",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "ChangedVindexValues": [
      "colb_colc_map:4"
    ],
    "KsidLength": 1,
    "KsidVindex": "kid_index",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select kid, column_a, column_b, column_c, column_c = 2 from multicolvin where kid = 1 for update",
    "Query": "update multicolvin set column_c = 2 where kid = 1",
    "Table": "multicolvin",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "kid_index"
  }
}
{
  "QueryType": "UPDATE",
  "Original": "update multicolvin set column_c = 2 where kid = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "EqualUnique",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "ChangedVindexValues": [
      "colb_colc_map:4"
    ],
    "KsidLength": 1,
    "KsidVindex": "kid_index",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select kid, column_a, column_b, column_c, column_c = 2 from multicolvin where kid = 1 for update",
    "Query": "update multicolvin set column_c = 2 where kid = 1",
    "Table": "multicolvin",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "kid_index"
  }
}

# update with binary value
"update user set name = _binary 'abc' where id = 1"
{
  "QueryType": "UPDATE",
  "Original": "update user set name = _binary 'abc' where id = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Equal",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "ChangedVindexValues": [
      "name_user_map:3"
    ],
    "KsidLength": 1,
    "KsidVindex": "user_index",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select Id, `Name`, Costly, `name` = _binary 'abc' from `user` where id = 1 for update",
    "Query": "update `user` set `name` = _binary 'abc' where id = 1",
    "Table": "user",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "user_index"
  }
}
{
  "QueryType": "UPDATE",
  "Original": "update user set name = _binary 'abc' where id = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "EqualUnique",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "ChangedVindexValues": [
      "name_user_map:3"
    ],
    "KsidLength": 1,
    "KsidVindex": "user_index",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select Id, `Name`, Costly, `name` = _binary 'abc' from `user` where id = 1 for update",
    "Query": "update `user` set `name` = _binary 'abc' where id = 1",
    "Table": "user",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "user_index"
  }
}

# delete with binary value
"delete from user where name = _binary 'abc'"
{
  "QueryType": "DELETE",
  "Original": "delete from user where name = _binary 'abc'",
  "Instructions": {
    "OperatorType": "Delete",
    "Variant": "Scatter",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "KsidLength": 1,
    "KsidVindex": "user_index",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select Id, `Name`, Costly from `user` where `name` = _binary 'abc' for update",
    "Query": "delete from `user` where `name` = _binary 'abc'",
    "Table": "user"
  }
}
Gen4 plan same as above

# delete with shard targeting
"delete from `user[-]`.user"
{
  "QueryType": "DELETE",
  "Original": "delete from `user[-]`.user",
  "Instructions": {
    "OperatorType": "Delete",
    "Variant": "ByDestination",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "KsidLength": 1,
    "KsidVindex": "user_index",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select Id, `Name`, Costly from `user` for update",
    "Query": "delete from `user`",
    "Table": "user"
  }
}
Gen4 plan same as above

# update with shard targeting
"update `user[-]`.user set name = 'myname'"
{
  "QueryType": "UPDATE",
  "Original": "update `user[-]`.user set name = 'myname'",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "ByDestination",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "ChangedVindexValues": [
      "name_user_map:3"
    ],
    "KsidLength": 1,
    "KsidVindex": "user_index",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select Id, `Name`, Costly, `name` = 'myname' from `user` for update",
    "Query": "update `user` set `name` = 'myname'",
    "Table": "user"
  }
}
Gen4 plan same as above

# update with shard targeting without vindex
"update `user[-]`.user_extra set val = 1"
{
  "QueryType": "UPDATE",
  "Original": "update `user[-]`.user_extra set val = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "ByDestination",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update user_extra set val = 1",
    "Table": "user_extra"
  }
}
Gen4 plan same as above

# multi-table delete with single table
"delete u.* from user u where u.id * u.col = u.foo"
{
  "QueryType": "DELETE",
  "Original": "delete u.* from user u where u.id * u.col = u.foo",
  "Instructions": {
    "OperatorType": "Delete",
    "Variant": "Scatter",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "KsidLength": 1,
    "KsidVindex": "user_index",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select Id, `Name`, Costly from `user` where `user`.id * `user`.col = `user`.foo for update",
    "Query": "delete from `user` where `user`.id * `user`.col = `user`.foo",
    "Table": "user"
  }
}
Gen4 plan same as above

# delete with unknown reference
"delete music from user where id = 1"
"Unknown table 'music' in MULTI DELETE"
Gen4 plan same as above

# delete with derived tables
"delete music from (select * from user) music where id = 1"
"The target table music of the DELETE is not updatable"
Gen4 plan same as above

# delete with derived tables with unknown table
"delete user from (select * from user) music where id = 1"
"Unknown table 'user' in MULTI DELETE"
Gen4 plan same as above

"INSERT INTO main.user_privacy_consents (user_id, accepted_at)  SELECT user_id, accepted_at FROM (SELECT 1 as user_id, 1629194864 as accepted_at) AS tmp WHERE NOT EXISTS (SELECT user_id FROM main.user_privacy_consents WHERE user_id = 1)"
{
  "QueryType": "INSERT",
  "Original": "INSERT INTO main.user_privacy_consents (user_id, accepted_at)  SELECT user_id, accepted_at FROM (SELECT 1 as user_id, 1629194864 as accepted_at) AS tmp WHERE NOT EXISTS (SELECT user_id FROM main.user_privacy_consents WHERE user_id = 1)",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Unsharded",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "insert into user_privacy_consents(user_id, accepted_at) select user_id, accepted_at from (select 1 as user_id, 1629194864 as accepted_at from dual) as tmp where not exists (select 1 from user_privacy_consents where user_id = 1 limit 1) for update",
    "TableName": "user_privacy_consents"
  }
}
Gen4 error: unsupported: unable to split predicates to derived table: not :__sq_has_values1

# Delete on backfilling unique lookup vindex should be a scatter
"delete from zlookup_unique.t1 where c2 = 20"
{
  "QueryType": "DELETE",
  "Original": "delete from zlookup_unique.t1 where c2 = 20",
  "Instructions": {
    "OperatorType": "Delete",
    "Variant": "Scatter",
    "Keyspace": {
      "Name": "zlookup_unique",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "KsidLength": 1,
    "KsidVindex": "xxhash",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select c1, c2, c3 from t1 where c2 = 20 for update",
    "Query": "delete from t1 where c2 = 20",
    "Table": "t1"
  }
}
Gen4 plan same as above

# Update on backfilling unique lookup vindex should be a scatter
"update zlookup_unique.t1 set c2 = 1 where c2 = 20"
{
  "QueryType": "UPDATE",
  "Original": "update zlookup_unique.t1 set c2 = 1 where c2 = 20",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Scatter",
    "Keyspace": {
      "Name": "zlookup_unique",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "ChangedVindexValues": [
      "lookup_t1:3"
    ],
    "KsidLength": 1,
    "KsidVindex": "xxhash",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select c1, c2, c3, c2 = 1 from t1 where c2 = 20 for update",
    "Query": "update t1 set c2 = 1 where c2 = 20",
    "Table": "t1"
  }
}
Gen4 plan same as above

# Delete on backfilling and non-backfilling unique lookup vindexes should be a delete equal
"delete from zlookup_unique.t1 where c2 = 10 and c3 = 20"
{
  "QueryType": "DELETE",
  "Original": "delete from zlookup_unique.t1 where c2 = 10 and c3 = 20",
  "Instructions": {
    "OperatorType": "Delete",
    "Variant": "Equal",
    "Keyspace": {
      "Name": "zlookup_unique",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "KsidLength": 1,
    "KsidVindex": "xxhash",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select c1, c2, c3 from t1 where c2 = 10 and c3 = 20 for update",
    "Query": "delete from t1 where c2 = 10 and c3 = 20",
    "Table": "t1",
    "Values": [
      "INT64(20)"
    ],
    "Vindex": "lookup_t1_2"
  }
}
Gen4 plan same as above

# Update on backfilling and non-backfilling unique lookup vindexes should be an equal
"update zlookup_unique.t1 set c2 = 1 where c2 = 10 and c3 = 20"
{
  "QueryType": "UPDATE",
  "Original": "update zlookup_unique.t1 set c2 = 1 where c2 = 10 and c3 = 20",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Equal",
    "Keyspace": {
      "Name": "zlookup_unique",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "ChangedVindexValues": [
      "lookup_t1:3"
    ],
    "KsidLength": 1,
    "KsidVindex": "xxhash",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select c1, c2, c3, c2 = 1 from t1 where c2 = 10 and c3 = 20 for update",
    "Query": "update t1 set c2 = 1 where c2 = 10 and c3 = 20",
    "Table": "t1",
    "Values": [
      "INT64(20)"
    ],
    "Vindex": "lookup_t1_2"
  }
}
{
  "QueryType": "UPDATE",
  "Original": "update zlookup_unique.t1 set c2 = 1 where c2 = 10 and c3 = 20",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "EqualUnique",
    "Keyspace": {
      "Name": "zlookup_unique",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "ChangedVindexValues": [
      "lookup_t1:3"
    ],
    "KsidLength": 1,
    "KsidVindex": "xxhash",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select c1, c2, c3, c2 = 1 from t1 where c2 = 10 and c3 = 20 for update",
    "Query": "update t1 set c2 = 1 where c2 = 10 and c3 = 20",
    "Table": "t1",
    "Values": [
      "INT64(20)"
    ],
    "Vindex": "lookup_t1_2"
  }
}

# Delete EQUAL and IN on backfilling and non-backfilling unique lookup vindexes should be a delete IN
"delete from zlookup_unique.t1 where c2 = 10 and c3 in (20, 21)"
{
  "QueryType": "DELETE",
  "Original": "delete from zlookup_unique.t1 where c2 = 10 and c3 in (20, 21)",
  "Instructions": {
    "OperatorType": "Delete",
    "Variant": "IN",
    "Keyspace": {
      "Name": "zlookup_unique",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "KsidLength": 1,
    "KsidVindex": "xxhash",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select c1, c2, c3 from t1 where c2 = 10 and c3 in (20, 21) for update",
    "Query": "delete from t1 where c2 = 10 and c3 in (20, 21)",
    "Table": "t1",
    "Values": [
      "(INT64(20), INT64(21))"
    ],
    "Vindex": "lookup_t1_2"
  }
}
Gen4 plan same as above

# Update EQUAL and IN on backfilling and non-backfilling unique lookup vindexes should be an update IN
"update zlookup_unique.t1 set c2 = 1 where c2 = 10 and c3 in (20, 21)"
{
  "QueryType": "UPDATE",
  "Original": "update zlookup_unique.t1 set c2 = 1 where c2 = 10 and c3 in (20, 21)",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "IN",
    "Keyspace": {
      "Name": "zlookup_unique",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "ChangedVindexValues": [
      "lookup_t1:3"
    ],
    "KsidLength": 1,
    "KsidVindex": "xxhash",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select c1, c2, c3, c2 = 1 from t1 where c2 = 10 and c3 in (20, 21) for update",
    "Query": "update t1 set c2 = 1 where c2 = 10 and c3 in (20, 21)",
    "Table": "t1",
    "Values": [
      "(INT64(20), INT64(21))"
    ],
    "Vindex": "lookup_t1_2"
  }
}
Gen4 plan same as above

#update with alias table
"update user u set u.name = 'john' where u.col > 20"
{
  "QueryType": "UPDATE",
  "Original": "update user u set u.name = 'john' where u.col \u003e 20",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Scatter",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "ChangedVindexValues": [
      "name_user_map:3"
    ],
    "KsidLength": 1,
    "KsidVindex": "user_index",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select Id, `Name`, Costly, u.`name` = 'john' from `user` as u where u.col \u003e 20 for update",
    "Query": "update `user` as u set u.`name` = 'john' where u.col \u003e 20",
    "Table": "user"
  }
}
Gen4 plan same as above

#delete with alias table
"delete from user u where u.col > 20"
{
  "QueryType": "DELETE",
  "Original": "delete from user u where u.col \u003e 20",
  "Instructions": {
    "OperatorType": "Delete",
    "Variant": "Scatter",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "KsidLength": 1,
    "KsidVindex": "user_index",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select Id, `Name`, Costly from `user` as u where u.col \u003e 20 for update",
    "Query": "delete from `user` as u where u.col \u003e 20",
    "Table": "user"
  }
}
Gen4 plan same as above

# update with a multicol vindex
"update multicol_tbl set x = 1 where cola = 1 and colb = 2"
{
  "QueryType": "UPDATE",
  "Original": "update multicol_tbl set x = 1 where cola = 1 and colb = 2",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Equal",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update multicol_tbl set x = 1 where cola = 1 and colb = 2",
    "Table": "multicol_tbl",
    "Values": [
      "INT64(1)",
      "INT64(2)"
    ],
    "Vindex": "multicolIdx"
  }
}
{
  "QueryType": "UPDATE",
  "Original": "update multicol_tbl set x = 1 where cola = 1 and colb = 2",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "EqualUnique",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update multicol_tbl set x = 1 where cola = 1 and colb = 2",
    "Table": "multicol_tbl",
    "Values": [
      "INT64(1)",
      "INT64(2)"
    ],
    "Vindex": "multicolIdx"
  }
}

# update with a multicol vindex - reverse order
"update multicol_tbl set x = 1 where colb = 2 and cola = 1"
{
  "QueryType": "UPDATE",
  "Original": "update multicol_tbl set x = 1 where colb = 2 and cola = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Equal",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update multicol_tbl set x = 1 where colb = 2 and cola = 1",
    "Table": "multicol_tbl",
    "Values": [
      "INT64(1)",
      "INT64(2)"
    ],
    "Vindex": "multicolIdx"
  }
}
{
  "QueryType": "UPDATE",
  "Original": "update multicol_tbl set x = 1 where colb = 2 and cola = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "EqualUnique",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update multicol_tbl set x = 1 where colb = 2 and cola = 1",
    "Table": "multicol_tbl",
    "Values": [
      "INT64(1)",
      "INT64(2)"
    ],
    "Vindex": "multicolIdx"
  }
}

# update with a multicol vindex using an IN clause
"update multicol_tbl set x = 1 where colb IN (1,2) and cola = 1"
{
  "QueryType": "UPDATE",
  "Original": "update multicol_tbl set x = 1 where colb IN (1,2) and cola = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "IN",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update multicol_tbl set x = 1 where colb in (1, 2) and cola = 1",
    "Table": "multicol_tbl",
    "Values": [
      "INT64(1)",
      "(INT64(1), INT64(2))"
    ],
    "Vindex": "multicolIdx"
  }
}
Gen4 plan same as above

# update with a multicol vindex using an IN clause
"update multicol_tbl set x = 1 where colb IN (1,2) and cola IN (3,4)"
{
  "QueryType": "UPDATE",
  "Original": "update multicol_tbl set x = 1 where colb IN (1,2) and cola IN (3,4)",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "IN",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update multicol_tbl set x = 1 where colb in (1, 2) and cola in (3, 4)",
    "Table": "multicol_tbl",
    "Values": [
      "(INT64(3), INT64(4))",
      "(INT64(1), INT64(2))"
    ],
    "Vindex": "multicolIdx"
  }
}
Gen4 plan same as above

# delete with a multicol vindex
"delete from multicol_tbl where cola = 1 and colb = 2"
{
  "QueryType": "DELETE",
  "Original": "delete from multicol_tbl where cola = 1 and colb = 2",
  "Instructions": {
    "OperatorType": "Delete",
    "Variant": "Equal",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "KsidLength": 2,
    "KsidVindex": "multicolIdx",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select cola, colb, colc, `name` from multicol_tbl where cola = 1 and colb = 2 for update",
    "Query": "delete from multicol_tbl where cola = 1 and colb = 2",
    "Table": "multicol_tbl",
    "Values": [
      "INT64(1)",
      "INT64(2)"
    ],
    "Vindex": "multicolIdx"
  }
}
Gen4 plan same as above

# delete with a multicol vindex - reverse order
"delete from multicol_tbl where colb = 2 and cola = 1"
{
  "QueryType": "DELETE",
  "Original": "delete from multicol_tbl where colb = 2 and cola = 1",
  "Instructions": {
    "OperatorType": "Delete",
    "Variant": "Equal",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "KsidLength": 2,
    "KsidVindex": "multicolIdx",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select cola, colb, colc, `name` from multicol_tbl where colb = 2 and cola = 1 for update",
    "Query": "delete from multicol_tbl where colb = 2 and cola = 1",
    "Table": "multicol_tbl",
    "Values": [
      "INT64(1)",
      "INT64(2)"
    ],
    "Vindex": "multicolIdx"
  }
}
Gen4 plan same as above

# delete with a multicol vindex using an IN clause
"delete from multicol_tbl where colb IN (1,2) and cola = 1"
{
  "QueryType": "DELETE",
  "Original": "delete from multicol_tbl where colb IN (1,2) and cola = 1",
  "Instructions": {
    "OperatorType": "Delete",
    "Variant": "IN",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "KsidLength": 2,
    "KsidVindex": "multicolIdx",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select cola, colb, colc, `name` from multicol_tbl where colb in (1, 2) and cola = 1 for update",
    "Query": "delete from multicol_tbl where colb in (1, 2) and cola = 1",
    "Table": "multicol_tbl",
    "Values": [
      "INT64(1)",
      "(INT64(1), INT64(2))"
    ],
    "Vindex": "multicolIdx"
  }
}
Gen4 plan same as above

# delete with a multicol vindex using an IN clause
"delete from multicol_tbl where colb IN (1,2) and cola IN (3,4)"
{
  "QueryType": "DELETE",
  "Original": "delete from multicol_tbl where colb IN (1,2) and cola IN (3,4)",
  "Instructions": {
    "OperatorType": "Delete",
    "Variant": "IN",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "KsidLength": 2,
    "KsidVindex": "multicolIdx",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select cola, colb, colc, `name` from multicol_tbl where colb in (1, 2) and cola in (3, 4) for update",
    "Query": "delete from multicol_tbl where colb in (1, 2) and cola in (3, 4)",
    "Table": "multicol_tbl",
    "Values": [
      "(INT64(3), INT64(4))",
      "(INT64(1), INT64(2))"
    ],
    "Vindex": "multicolIdx"
  }
}
Gen4 plan same as above

# update with multicol and an owned vindex which changes
"update multicol_tbl set colc = 1 where cola = 1 and colb = 2"
{
  "QueryType": "UPDATE",
  "Original": "update multicol_tbl set colc = 1 where cola = 1 and colb = 2",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Equal",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "ChangedVindexValues": [
      "colc_map:4"
    ],
    "KsidLength": 2,
    "KsidVindex": "multicolIdx",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select cola, colb, colc, `name`, colc = 1 from multicol_tbl where cola = 1 and colb = 2 for update",
    "Query": "update multicol_tbl set colc = 1 where cola = 1 and colb = 2",
    "Table": "multicol_tbl",
    "Values": [
      "INT64(1)",
      "INT64(2)"
    ],
    "Vindex": "multicolIdx"
  }
}
{
  "QueryType": "UPDATE",
  "Original": "update multicol_tbl set colc = 1 where cola = 1 and colb = 2",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "EqualUnique",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "ChangedVindexValues": [
      "colc_map:4"
    ],
    "KsidLength": 2,
    "KsidVindex": "multicolIdx",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select cola, colb, colc, `name`, colc = 1 from multicol_tbl where cola = 1 and colb = 2 for update",
    "Query": "update multicol_tbl set colc = 1 where cola = 1 and colb = 2",
    "Table": "multicol_tbl",
    "Values": [
      "INT64(1)",
      "INT64(2)"
    ],
    "Vindex": "multicolIdx"
  }
}

# update with routing using non-unique lookup vindex
"update multicol_tbl set x = 42 where name = 'foo'"
{
  "QueryType": "UPDATE",
  "Original": "update multicol_tbl set x = 42 where name = 'foo'",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Equal",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update multicol_tbl set x = 42 where `name` = 'foo'",
    "Table": "multicol_tbl",
    "Values": [
      "VARCHAR(\"foo\")"
    ],
    "Vindex": "name_muticoltbl_map"
  }
}
Gen4 plan same as above

# update with routing using subsharding column
"update multicol_tbl set x = 42 where cola = 1"
{
  "QueryType": "UPDATE",
  "Original": "update multicol_tbl set x = 42 where cola = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Equal",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update multicol_tbl set x = 42 where cola = 1",
    "Table": "multicol_tbl",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "multicolIdx"
  }
}
{
  "QueryType": "UPDATE",
  "Original": "update multicol_tbl set x = 42 where cola = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "SubShard",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update multicol_tbl set x = 42 where cola = 1",
    "Table": "multicol_tbl",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "multicolIdx"
  }
}

# update with routing using subsharding column on lookup vindex
"update multicol_tbl set name = 'bar' where cola = 1"
{
  "QueryType": "UPDATE",
  "Original": "update multicol_tbl set name = 'bar' where cola = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Equal",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "ChangedVindexValues": [
      "name_muticoltbl_map:4"
    ],
    "KsidLength": 2,
    "KsidVindex": "multicolIdx",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select cola, colb, colc, `name`, `name` = 'bar' from multicol_tbl where cola = 1 for update",
    "Query": "update multicol_tbl set `name` = 'bar' where cola = 1",
    "Table": "multicol_tbl",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "multicolIdx"
  }
}
{
  "QueryType": "UPDATE",
  "Original": "update multicol_tbl set name = 'bar' where cola = 1",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "SubShard",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "ChangedVindexValues": [
      "name_muticoltbl_map:4"
    ],
    "KsidLength": 2,
    "KsidVindex": "multicolIdx",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select cola, colb, colc, `name`, `name` = 'bar' from multicol_tbl where cola = 1 for update",
    "Query": "update multicol_tbl set `name` = 'bar' where cola = 1",
    "Table": "multicol_tbl",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "multicolIdx"
  }
}

# update with routing using subsharding column with in query
"update multicol_tbl set name = 'bar' where cola in (1,2)"
{
  "QueryType": "UPDATE",
  "Original": "update multicol_tbl set name = 'bar' where cola in (1,2)",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "IN",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "ChangedVindexValues": [
      "name_muticoltbl_map:4"
    ],
    "KsidLength": 2,
    "KsidVindex": "multicolIdx",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select cola, colb, colc, `name`, `name` = 'bar' from multicol_tbl where cola in (1, 2) for update",
    "Query": "update multicol_tbl set `name` = 'bar' where cola in (1, 2)",
    "Table": "multicol_tbl",
    "Values": [
      "(INT64(1), INT64(2))"
    ],
    "Vindex": "multicolIdx"
  }
}
Gen4 plan same as above

# update with routing using subsharding column with in query as lower cost over lookup vindex
"update multicol_tbl set x = 1 where name = 'foo' and cola = 2"
{
  "QueryType": "UPDATE",
  "Original": "update multicol_tbl set x = 1 where name = 'foo' and cola = 2",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Equal",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update multicol_tbl set x = 1 where `name` = 'foo' and cola = 2",
    "Table": "multicol_tbl",
    "Values": [
      "INT64(2)"
    ],
    "Vindex": "multicolIdx"
  }
}
{
  "QueryType": "UPDATE",
  "Original": "update multicol_tbl set x = 1 where name = 'foo' and cola = 2",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Equal",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update multicol_tbl set x = 1 where `name` = 'foo' and cola = 2",
    "Table": "multicol_tbl",
    "Values": [
      "VARCHAR(\"foo\")"
    ],
    "Vindex": "name_muticoltbl_map"
  }
}

# delete with routing using non-unique lookup vindex
"delete from multicol_tbl where name = 'foo'"
{
  "QueryType": "DELETE",
  "Original": "delete from multicol_tbl where name = 'foo'",
  "Instructions": {
    "OperatorType": "Delete",
    "Variant": "Equal",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "KsidLength": 2,
    "KsidVindex": "multicolIdx",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select cola, colb, colc, `name` from multicol_tbl where `name` = 'foo' for update",
    "Query": "delete from multicol_tbl where `name` = 'foo'",
    "Table": "multicol_tbl",
    "Values": [
      "VARCHAR(\"foo\")"
    ],
    "Vindex": "name_muticoltbl_map"
  }
}
Gen4 plan same as above

# delete with routing using subsharding column
"delete from multicol_tbl where cola = 1"
{
  "QueryType": "DELETE",
  "Original": "delete from multicol_tbl where cola = 1",
  "Instructions": {
    "OperatorType": "Delete",
    "Variant": "Equal",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "KsidLength": 2,
    "KsidVindex": "multicolIdx",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select cola, colb, colc, `name` from multicol_tbl where cola = 1 for update",
    "Query": "delete from multicol_tbl where cola = 1",
    "Table": "multicol_tbl",
    "Values": [
      "INT64(1)"
    ],
    "Vindex": "multicolIdx"
  }
}
Gen4 plan same as above

# delete with routing using subsharding column with in query
"delete from multicol_tbl where cola in (1,2)"
{
  "QueryType": "DELETE",
  "Original": "delete from multicol_tbl where cola in (1,2)",
  "Instructions": {
    "OperatorType": "Delete",
    "Variant": "IN",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "KsidLength": 2,
    "KsidVindex": "multicolIdx",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select cola, colb, colc, `name` from multicol_tbl where cola in (1, 2) for update",
    "Query": "delete from multicol_tbl where cola in (1, 2)",
    "Table": "multicol_tbl",
    "Values": [
      "(INT64(1), INT64(2))"
    ],
    "Vindex": "multicolIdx"
  }
}
Gen4 plan same as above

# delete with routing using subsharding column with in query as lower cost over lookup vindex
"delete from multicol_tbl where name = 'foo' and cola = 2"
{
  "QueryType": "DELETE",
  "Original": "delete from multicol_tbl where name = 'foo' and cola = 2",
  "Instructions": {
    "OperatorType": "Delete",
    "Variant": "Equal",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "KsidLength": 2,
    "KsidVindex": "multicolIdx",
    "MultiShardAutocommit": false,
    "OwnedVindexQuery": "select cola, colb, colc, `name` from multicol_tbl where `name` = 'foo' and cola = 2 for update",
    "Query": "delete from multicol_tbl where `name` = 'foo' and cola = 2",
    "Table": "multicol_tbl",
    "Values": [
      "INT64(2)"
    ],
    "Vindex": "multicolIdx"
  }
}
Gen4 plan same as above

# insert using select with simple table.
"insert into music(id, user_id) select * from user"
{
  "QueryType": "INSERT",
  "Original": "insert into music(id, user_id) select * from user",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Select",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "TableName": "music",
    "VindexOffsetFromSelect": {
      "music_user_map": "[0]",
      "user_index": "[1]"
    },
    "Inputs": [
      {
        "OperatorType": "Route",
        "Variant": "Scatter",
        "Keyspace": {
          "Name": "user",
          "Sharded": true
        },
        "FieldQuery": "select * from `user` where 1 != 1",
        "Query": "select * from `user` for update",
        "Table": "`user`"
      }
    ]
  }
}
Gen4 plan same as above

# insert using select with more columns in insert
"insert into music(id, user_id) select 1"
"Column count doesn't match value count at row 1"
Gen4 plan same as above

# insert using select with more columns in select
"insert into music(id, user_id) select id, count(user_id), sum(user_id) from user group by id"
"Column count doesn't match value count at row 1"
Gen4 plan same as above

# insert using select with more columns in select after accounting for star column
"insert into music(id, user_id) select id, *, 2 from user"
"Column count doesn't match value count at row 1"
Gen4 plan same as above

# insert using select with auto-inc column using vitess sequence, sequence column not present
"insert into user_extra(user_id) select id from user"
{
  "QueryType": "INSERT",
  "Original": "insert into user_extra(user_id) select id from user",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Select",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "AutoIncrement": "main:1",
    "MultiShardAutocommit": false,
    "TableName": "user_extra",
    "VindexOffsetFromSelect": {
      "user_index": "[0]"
    },
    "Inputs": [
      {
        "OperatorType": "Route",
        "Variant": "Scatter",
        "Keyspace": {
          "Name": "user",
          "Sharded": true
        },
        "FieldQuery": "select id from `user` where 1 != 1",
        "Query": "select id from `user` for update",
        "Table": "`user`"
      }
    ]
  }
}
Gen4 plan same as above

# insert using select with auto-inc column using vitess sequence, sequence column present
"insert into user_extra(id, user_id) select null, id from user"
{
  "QueryType": "INSERT",
  "Original": "insert into user_extra(id, user_id) select null, id from user",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Select",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "AutoIncrement": "main:2",
    "MultiShardAutocommit": false,
    "TableName": "user_extra",
    "VindexOffsetFromSelect": {
      "user_index": "[1]"
    },
    "Inputs": [
      {
        "OperatorType": "Route",
        "Variant": "Scatter",
        "Keyspace": {
          "Name": "user",
          "Sharded": true
        },
        "FieldQuery": "select null, id from `user` where 1 != 1",
        "Query": "select null, id from `user` for update",
        "Table": "`user`"
      }
    ]
  }
}
Gen4 plan same as above

# sharded insert from select
"insert into user(id) select 1 from dual"
{
  "QueryType": "INSERT",
  "Original": "insert into user(id) select 1 from dual",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Select",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "AutoIncrement": "main:0",
    "MultiShardAutocommit": false,
    "TableName": "user",
    "VindexOffsetFromSelect": {
      "costly_map": "[-1]",
      "name_user_map": "[-1]",
      "user_index": "[0]"
    },
    "Inputs": [
      {
        "OperatorType": "Projection",
        "Expressions": [
          "INT64(1) as 1"
        ],
        "Inputs": [
          {
            "OperatorType": "SingleRow"
          }
        ]
      }
    ]
  }
}
Gen4 plan same as above

# insert using select with sharding column is autoinc and not present in the insert column query
"insert into user(pattern) SELECT 1"
{
  "QueryType": "INSERT",
  "Original": "insert into user(pattern) SELECT 1",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Select",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "AutoIncrement": "main:1",
    "MultiShardAutocommit": false,
    "TableName": "user",
    "VindexOffsetFromSelect": {
      "costly_map": "[-1]",
      "name_user_map": "[-1]",
      "user_index": "[1]"
    },
    "Inputs": [
      {
        "OperatorType": "Projection",
        "Expressions": [
          "INT64(1) as 1"
        ],
        "Inputs": [
          {
            "OperatorType": "SingleRow"
          }
        ]
      }
    ]
  }
}
Gen4 plan same as above

# insert using select with sharding column is not an autoinc and not present in the insert column query
"insert into user_extra(pattern) SELECT 1"
"insert query does not have sharding column 'user_id' in the column list"
Gen4 plan same as above

# sharded same keyspace
"insert into user_extra(user_id, col) select col1, col2 from user"
{
  "QueryType": "INSERT",
  "Original": "insert into user_extra(user_id, col) select col1, col2 from user",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Select",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "AutoIncrement": "main:2",
    "MultiShardAutocommit": false,
    "TableName": "user_extra",
    "VindexOffsetFromSelect": {
      "user_index": "[0]"
    },
    "Inputs": [
      {
        "OperatorType": "Route",
        "Variant": "Scatter",
        "Keyspace": {
          "Name": "user",
          "Sharded": true
        },
        "FieldQuery": "select col1, col2 from `user` where 1 != 1",
        "Query": "select col1, col2 from `user` for update",
        "Table": "`user`"
      }
    ]
  }
}
Gen4 plan same as above

# unsharded same keyspace
"insert into unsharded(col) select col from unsharded_auto"
{
  "QueryType": "INSERT",
  "Original": "insert into unsharded(col) select col from unsharded_auto",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Unsharded",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "insert into unsharded(col) select col from unsharded_auto for update",
    "TableName": "unsharded"
  }
}
Gen4 plan same as above

# sharded different keyspace
"insert into user_extra(user_id, col) select col1, col2 from t1"
{
  "QueryType": "INSERT",
  "Original": "insert into user_extra(user_id, col) select col1, col2 from t1",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Select",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "AutoIncrement": "main:2",
    "MultiShardAutocommit": false,
    "TableName": "user_extra",
    "VindexOffsetFromSelect": {
      "user_index": "[0]"
    },
    "Inputs": [
      {
        "OperatorType": "Route",
        "Variant": "Scatter",
        "Keyspace": {
          "Name": "zlookup_unique",
          "Sharded": true
        },
        "FieldQuery": "select col1, col2 from t1 where 1 != 1",
        "Query": "select col1, col2 from t1 for update",
        "Table": "t1"
      }
    ]
  }
}
Gen4 plan same as above

# sharded insert table, unsharded select table
"insert into user_extra(user_id, col) select col1, col2 from unsharded_tab"
{
  "QueryType": "INSERT",
  "Original": "insert into user_extra(user_id, col) select col1, col2 from unsharded_tab",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Select",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "AutoIncrement": "main:2",
    "MultiShardAutocommit": false,
    "TableName": "user_extra",
    "VindexOffsetFromSelect": {
      "user_index": "[0]"
    },
    "Inputs": [
      {
        "OperatorType": "Route",
        "Variant": "Unsharded",
        "Keyspace": {
          "Name": "main_2",
          "Sharded": false
        },
        "FieldQuery": "select col1, col2 from unsharded_tab where 1 != 1",
        "Query": "select col1, col2 from unsharded_tab for update",
        "Table": "unsharded_tab"
      }
    ]
  }
}
Gen4 plan same as above

# unsharded different keyspace
"insert into unsharded(col) select col from unsharded_tab"
{
  "QueryType": "INSERT",
  "Original": "insert into unsharded(col) select col from unsharded_tab",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Unsharded",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "TableName": "unsharded",
    "Inputs": [
      {
        "OperatorType": "Route",
        "Variant": "Unsharded",
        "Keyspace": {
          "Name": "main_2",
          "Sharded": false
        },
        "FieldQuery": "select col from unsharded_tab where 1 != 1",
        "Query": "select col from unsharded_tab for update",
        "Table": "unsharded_tab"
      }
    ]
  }
}
Gen4 plan same as above

# unsharded insert table, sharded select table
"insert into unsharded(col) select col from t1"
{
  "QueryType": "INSERT",
  "Original": "insert into unsharded(col) select col from t1",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Unsharded",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "TableName": "unsharded",
    "Inputs": [
      {
        "OperatorType": "Route",
        "Variant": "Scatter",
        "Keyspace": {
          "Name": "zlookup_unique",
          "Sharded": true
        },
        "FieldQuery": "select col from t1 where 1 != 1",
        "Query": "select col from t1 for update",
        "Table": "t1"
      }
    ]
  }
}
Gen4 plan same as above

# unsharded subquery in sharded update, not the same keyspace between outer and inner
"update user set col = (select id from unsharded)"
"unsupported: subqueries in sharded DML"
{
  "QueryType": "UPDATE",
  "Original": "update user set col = (select id from unsharded)",
  "Instructions": {
    "OperatorType": "Subquery",
    "Variant": "PulloutValue",
    "PulloutVars": [
      "__sq1"
    ],
    "Inputs": [
      {
        "OperatorType": "Route",
        "Variant": "Unsharded",
        "Keyspace": {
          "Name": "main",
          "Sharded": false
        },
        "FieldQuery": "select id from unsharded where 1 != 1",
        "Query": "select id from unsharded lock in share mode",
        "Table": "unsharded"
      },
      {
        "OperatorType": "Update",
        "Variant": "Scatter",
        "Keyspace": {
          "Name": "user",
          "Sharded": true
        },
        "TargetTabletType": "PRIMARY",
        "MultiShardAutocommit": false,
        "Query": "update `user` set col = :__sq1",
        "Table": "user"
      }
    ]
  }
}

# sharded subquery in unsharded update, not the same keyspace
"update unsharded set col = (select id from user)"
"unsupported: sharded subqueries in DML"
{
  "QueryType": "UPDATE",
  "Original": "update unsharded set col = (select id from user)",
  "Instructions": {
    "OperatorType": "Subquery",
    "Variant": "PulloutValue",
    "PulloutVars": [
      "__sq1"
    ],
    "Inputs": [
      {
        "OperatorType": "Route",
        "Variant": "Scatter",
        "Keyspace": {
          "Name": "user",
          "Sharded": true
        },
        "FieldQuery": "select id from `user` where 1 != 1",
        "Query": "select id from `user` lock in share mode",
        "Table": "`user`"
      },
      {
        "OperatorType": "Update",
        "Variant": "Unsharded",
        "Keyspace": {
          "Name": "main",
          "Sharded": false
        },
        "TargetTabletType": "PRIMARY",
        "MultiShardAutocommit": false,
        "Query": "update unsharded set col = :__sq1",
        "Table": "unsharded"
      }
    ]
  }
}

# sharded join unsharded subqueries in unsharded update
"update unsharded set col = (select id from unsharded join user on unsharded.id = user.id)"
"unsupported: sharded subqueries in DML"
{
  "QueryType": "UPDATE",
  "Original": "update unsharded set col = (select id from unsharded join user on unsharded.id = user.id)",
  "Instructions": {
    "OperatorType": "Subquery",
    "Variant": "PulloutValue",
    "PulloutVars": [
      "__sq1"
    ],
    "Inputs": [
      {
        "OperatorType": "Join",
        "Variant": "Join",
        "JoinColumnIndexes": "R:0",
        "JoinVars": {
          "unsharded_id": 0
        },
        "TableName": "unsharded_`user`",
        "Inputs": [
          {
            "OperatorType": "Route",
            "Variant": "Unsharded",
            "Keyspace": {
              "Name": "main",
              "Sharded": false
            },
            "FieldQuery": "select unsharded.id from unsharded where 1 != 1",
            "Query": "select unsharded.id from unsharded lock in share mode",
            "Table": "unsharded"
          },
          {
            "OperatorType": "Route",
            "Variant": "EqualUnique",
            "Keyspace": {
              "Name": "user",
              "Sharded": true
            },
            "FieldQuery": "select id from `user` where 1 != 1",
            "Query": "select id from `user` where `user`.id = :unsharded_id lock in share mode",
            "Table": "`user`",
            "Values": [
              ":unsharded_id"
            ],
            "Vindex": "user_index"
          }
        ]
      },
      {
        "OperatorType": "Update",
        "Variant": "Unsharded",
        "Keyspace": {
          "Name": "main",
          "Sharded": false
        },
        "TargetTabletType": "PRIMARY",
        "MultiShardAutocommit": false,
        "Query": "update unsharded set col = :__sq1",
        "Table": "unsharded"
      }
    ]
  }
}

# sharded update with sub query where the sources can be merged into a single query
"update user set col = (select count(*) from user_extra where user_extra.user_id = 5) where id = 5"
"unsupported: subqueries in sharded DML"
{
  "QueryType": "UPDATE",
  "Original": "update user set col = (select count(*) from user_extra where user_extra.user_id = 5) where id = 5",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "EqualUnique",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update `user` set col = (select count(*) from user_extra where user_extra.user_id = 5) where id = 5",
    "Table": "user",
    "Values": [
      "INT64(5)"
    ],
    "Vindex": "user_index"
  }
}

# merge through correlated subquery
"update user set col = (select count(*) from user_extra where user_extra.user_id = user.id) where id = 5"
"unsupported: subqueries in sharded DML"
{
  "QueryType": "UPDATE",
  "Original": "update user set col = (select count(*) from user_extra where user_extra.user_id = user.id) where id = 5",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "EqualUnique",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update `user` set col = (select count(*) from user_extra where user_extra.user_id = `user`.id) where id = 5",
    "Table": "user",
    "Values": [
      "INT64(5)"
    ],
    "Vindex": "user_index"
  }
}

# merge through correlated subquery #2
"update user set col = (select count(*) from user_extra where user_extra.user_id = user.id) where id > 5"
"unsupported: subqueries in sharded DML"
{
  "QueryType": "UPDATE",
  "Original": "update user set col = (select count(*) from user_extra where user_extra.user_id = user.id) where id \u003e 5",
  "Instructions": {
    "OperatorType": "Update",
    "Variant": "Scatter",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "update `user` set col = (select count(*) from user_extra where user_extra.user_id = `user`.id) where id \u003e 5",
    "Table": "user"
  }
}

# all defaults empty column, empty values
"insert into authoritative () values ()"
{
  "QueryType": "INSERT",
  "Original": "insert into authoritative () values ()",
  "Instructions": {
    "OperatorType": "Insert",
    "Variant": "Sharded",
    "Keyspace": {
      "Name": "user",
      "Sharded": true
    },
    "TargetTabletType": "PRIMARY",
    "MultiShardAutocommit": false,
    "Query": "insert into authoritative(user_id) values (:_user_id_0)",
    "TableName": "authoritative",
    "VindexValues": {
      "user_index": "NULL"
    }
  }
}
Gen4 plan same as above
