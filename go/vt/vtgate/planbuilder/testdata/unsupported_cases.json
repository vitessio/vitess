[
  {
    "comment": "union operations in subqueries (expressions)",
    "query": "select * from user where id in (select * from user union select * from user_extra)",
    "plan": "unsupported: '*' expression in cross-shard query"
  },
  {
    "comment": "TODO: Implement support for select with a target destination",
    "query": "select * from `user[-]`.user_metadata",
    "plan": "unsupported: SELECT with a target destination"
  },
  {
    "comment": "Unsupported INSERT statement with a target destination",
    "query": "insert into `user[-]`.user_metadata (a, b) values (1,2)",
    "plan": "unsupported: INSERT with a target destination"
  },
  {
    "comment": "Unsupported delete statement with a replica target destination",
    "query": "DELETE FROM `user[-]@replica`.user_metadata limit 1",
    "plan": "unsupported: delete statement with a replica target"
  },
  {
    "comment": "Unsupported update statement with a replica target destination",
    "query": "update `user[-]@replica`.user_metadata set id=2",
    "plan": "unsupported: update statement with a replica target"
  },
  {
    "comment": "scatter order by with * expression",
    "query": "select * from user order by id",
    "v3-plan": "unsupported: in scatter query: order by must reference a column in the select list: id asc",
    "gen4-plan": "unsupported: '*' expression in cross-shard query"
  },
  {
    "comment": "order by rand on a cross-shard subquery",
    "query": "select id from (select user.id, user.col from user join user_extra) as t order by rand()",
    "v3-plan": "unsupported: memory sort: complex order by expression: rand()",
    "gen4-plan": "unsupported: in scatter query: complex order by expression: rand()"
  },
  {
    "comment": "natural join",
    "query": "select * from user natural join user_extra",
    "plan": "unsupported: natural join"
  },
  {
    "comment": "join with USING construct",
    "query": "select * from user join user_extra using(id)",
    "plan": "unsupported: join with USING(column_list) clause for complex queries"
  },
  {
    "comment": "join with USING construct with 3 tables",
    "query": "select user.id from user join user_extra using(id) join music using(id2)",
    "plan": "unsupported: join with USING(column_list) clause for complex queries"
  },
  {
    "comment": "natural left join",
    "query": "select * from user natural left join user_extra",
    "plan": "unsupported: natural left join"
  },
  {
    "comment": "natural right join",
    "query": "select * from user natural right join user_extra",
    "plan": "unsupported: natural right join"
  },
  {
    "comment": "left join with expressions",
    "query": "select user_extra.col+1 from user left join user_extra on user.col = user_extra.col",
    "plan": "unsupported: cross-shard left join and column expressions"
  },
  {
    "comment": "left join with expressions, with three-way join (different code path)",
    "query": "select user.id, user_extra.col+1 from user left join user_extra on user.col = user_extra.col join user_extra e",
    "plan": "unsupported: cross-shard left join and column expressions"
  },
  {
    "comment": "* expresson not allowed for cross-shard joins",
    "query": "select * from user join user_extra",
    "plan": "unsupported: '*' expression in cross-shard query"
  },
  {
    "comment": "Group by column number, used with non-aliased expression (duplicated code)",
    "query": "select * from user group by 1",
    "v3-plan": "unsupported: '*' expression in cross-shard query",
    "gen4-plan": "cannot use column offsets in group statement when using `*`"
  },
  {
    "comment": "group by must reference select list",
    "query": "select a from user group by b",
    "v3-plan": "unsupported: in scatter query: group by column must reference column in SELECT list",
    "gen4-plan": "Expression of SELECT list is not in GROUP BY clause and contains nonaggregated column 'a' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by"
  },
  {
    "comment": "complex group by expression",
    "query": "select a from user group by a+1",
    "v3-plan": "unsupported: in scatter query: only simple references allowed",
    "gen4-plan": "Expression of SELECT list is not in GROUP BY clause and contains nonaggregated column 'a' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by"
  },
  {
    "comment": "Complex aggregate expression on scatter",
    "query": "select 1+count(*) from user",
    "plan": "unsupported: in scatter query: complex aggregate expression"
  },
  {
    "comment": "Multi-value aggregates not supported",
    "query": "select count(a,b) from user",
    "v3-plan": "unsupported: only one expression allowed inside aggregates: count(a, b)",
    "gen4-plan": "aggregate functions take a single argument 'count(a, b)'"
  },
  {
    "comment": "scatter aggregate symtab lookup error",
    "query": "select id, b as id, count(*) from user order by id",
    "v3-plan": "ambiguous symbol reference: id",
    "gen4-plan": "In aggregated query without GROUP BY, expression of SELECT list contains nonaggregated column 'id'; this is incompatible with sql_mode=only_full_group_by"
  },
  {
    "comment": "scatter aggregate complex order by",
    "query": "select id from user group by id order by id+1",
    "plan": "unsupported: in scatter query: complex order by expression: id + 1"
  },
  {
    "comment": "Scatter order by is complex with aggregates in select",
    "query": "select col, count(*) from user group by col order by col+1",
    "v3-plan": "unsupported: in scatter query: complex order by expression: col + 1",
    "gen4-plan": "Expression of SELECT list is not in GROUP BY clause and contains nonaggregated column 'col + 1' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by"
  },
  {
    "comment": "Aggregate detection (group_concat)",
    "query": "select group_concat(user.a) from user join user_extra",
    "v3-plan": "unsupported: cross-shard query with aggregates",
    "gen4-plan": "unsupported: in scatter query: complex aggregate expression"
  },
  {
    "comment": "group by and ',' joins",
    "query": "select user.id from user, user_extra group by id",
    "v3-plan": "unsupported: cross-shard query with aggregates",
    "gen4-plan": "Expression of SELECT list is not in GROUP BY clause and contains nonaggregated column '`user`.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by"
  },
  {
    "comment": "group by and ',' joins with condition",
    "query": "select user.col from user join user_extra on user_extra.col = user.col group by user.id",
    "v3-plan": "unsupported: cross-shard query with aggregates",
    "gen4-plan": "Expression of SELECT list is not in GROUP BY clause and contains nonaggregated column '`user`.col' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by"
  },
  {
    "comment": "subqueries not supported in group by",
    "query": "select id from user group by id, (select id from user_extra)",
    "v3-plan": "unsupported: subqueries disallowed in GROUP or ORDER BY",
    "gen4-plan": "unsupported: subqueries disallowed in GROUP BY"
  },
  {
    "comment": "Order by uses cross-shard expression",
    "query": "select id from user order by id+1",
    "plan": "unsupported: in scatter query: complex order by expression: id + 1"
  },
  {
    "comment": "Order by column number with collate",
    "query": "select user.col1 as a from user order by 1 collate utf8_general_ci",
    "v3-plan": "unsupported: in scatter query: complex order by expression: 1 collate utf8_general_ci",
    "gen4-plan": "unsupported: in scatter query: complex order by expression: a collate utf8_general_ci"
  },
  {
    "comment": "subqueries in update",
    "query": "update user set col = (select id from unsharded)",
    "plan": "unsupported: subqueries in sharded DML"
  },
  {
    "comment": "sharded subqueries in unsharded update",
    "query": "update unsharded set col = (select id from user)",
    "plan": "unsupported: sharded subqueries in DML"
  },
  {
    "comment": "sharded join unsharded subqueries in unsharded update",
    "query": "update unsharded set col = (select id from unsharded join user on unsharded.id = user.id)",
    "plan": "unsupported: sharded subqueries in DML"
  },
  {
    "comment": "subqueries in delete",
    "query": "delete from user where col = (select id from unsharded)",
    "plan": "unsupported: subqueries in sharded DML"
  },
  {
    "comment": "sharded subqueries in unsharded delete",
    "query": "delete from unsharded where col = (select id from user)",
    "plan": "unsupported: sharded subqueries in DML"
  },
  {
    "comment": "sharded delete with limit clasue",
    "query": "delete from user_extra limit 10",
    "plan": "multi shard delete with limit is not supported"
  },
  {
    "comment": "sharded subquery in unsharded subquery in unsharded delete",
    "query": "delete from unsharded where col = (select id from unsharded where id = (select id from user))",
    "plan": "unsupported: sharded subqueries in DML"
  },
  {
    "comment": "sharded join unsharded subqueries in unsharded delete",
    "query": "delete from unsharded where col = (select id from unsharded join user on unsharded.id = user.id)",
    "plan": "unsupported: sharded subqueries in DML"
  },
  {
    "comment": "scatter update with limit clause",
    "query": "update user_extra set val = 1 where (name = 'foo' or id = 1) limit 1",
    "plan": "multi shard update with limit is not supported"
  },
  {
    "comment": "multi delete multi table",
    "query": "delete user from user join user_extra on user.id = user_extra.id where user.name = 'foo'",
    "plan": "unsupported: multi-shard or vindex write statement"
  },
  {
    "comment": "update changes primary vindex column",
    "query": "update user set id = 1 where id = 1",
    "plan": "unsupported: You can't update primary vindex columns. Invalid update on vindex: user_index"
  },
  {
    "comment": "update change in multicol vindex column",
    "query": "update multicol_tbl set colc = 5, colb = 4 where cola = 1 and colb = 2",
    "plan": "unsupported: You can't update primary vindex columns. Invalid update on vindex: multicolIdx"
  },
  {
    "comment": "update changes non owned vindex column",
    "query": "update music_extra set music_id = 1 where user_id = 1",
    "plan": "unsupported: You can only update owned vindexes. Invalid update on vindex: music_user_map"
  },
  {
    "comment": "update changes non lookup vindex column",
    "query": "update user_metadata set md5 = 1 where user_id = 1",
    "plan": "unsupported: You can only update lookup vindexes. Invalid update on vindex: user_md5_index"
  },
  {
    "comment": "update with complex set clause",
    "query": "update music set id = id + 1 where id = 1",
    "plan": "unsupported: Only values are supported. Invalid update on column: `id` with expr: [id + 1]"
  },
  {
    "comment": "update by primary keyspace id, changing one vindex column, limit without order clause",
    "query": "update user_metadata set email = 'juan@vitess.io' where user_id = 1 limit 10",
    "plan": "unsupported: Need to provide order by clause when using limit. Invalid update on vindex: email_user_map"
  },
  {
    "comment": "cross-shard update tables",
    "query": "update (select id from user) as u set id = 4",
    "plan": "unsupported: subqueries in sharded DML"
  },
  {
    "comment": "join in update tables",
    "query": "update user join user_extra on user.id = user_extra.id set user.name = 'foo'",
    "plan": "unsupported: multi-shard or vindex write statement"
  },
  {
    "comment": "multiple tables in update",
    "query": "update user as u, user_extra as ue set u.name = 'foo' where u.id = ue.id",
    "plan": "unsupported: multi-shard or vindex write statement"
  },
  {
    "comment": "unsharded insert with cross-shard join\"",
    "query": "insert into unsharded select u.col from user u join user u1",
    "plan": "unsupported: sharded subquery in insert values"
  },
  {
    "comment": "unsharded insert with mismatched keyspaces\"",
    "query": "insert into unsharded select col from user where id=1",
    "plan": "unsupported: sharded subquery in insert values"
  },
  {
    "comment": "unsharded insert, unqualified names and auto-inc combined",
    "query": "insert into unsharded_auto select col from unsharded",
    "plan": "unsupported: auto-inc and select in insert"
  },
  {
    "comment": "unsharded insert, with sharded subquery in insert value",
    "query": "insert into unsharded values((select 1 from user), 1)",
    "plan": "unsupported: sharded subquery in insert values"
  },
  {
    "comment": "unsharded insert, no col list with auto-inc",
    "query": "insert into unsharded_auto values(1,1)",
    "plan": "column list required for tables with auto-inc columns"
  },
  {
    "comment": "unsharded insert, col list does not match values",
    "query": "insert into unsharded_auto(id, val) values(1)",
    "plan": "column list doesn't match values"
  },
  {
    "comment": "sharded upsert can't change vindex",
    "query": "insert into user(id) values(1) on duplicate key update id = 3",
    "plan": "unsupported: DML cannot change vindex column"
  },
  {
    "comment": "sharded upsert can't change vindex using values function",
    "query": "insert into music(user_id, id) values(1, 2) on duplicate key update user_id = values(id)",
    "plan": "unsupported: DML cannot change vindex column"
  },
  {
    "comment": "sharded insert from select",
    "query": "insert into user(id) select 1 from dual",
    "plan": "unsupported: insert into select"
  },
  {
    "comment": "sharded replace no vindex",
    "query": "replace into user(val) values(1, 'foo')",
    "plan": "unsupported: REPLACE INTO with sharded schema"
  },
  {
    "comment": "sharded replace with vindex",
    "query": "replace into user(id, name) values(1, 'foo')",
    "plan": "unsupported: REPLACE INTO with sharded schema"
  },
  {
    "comment": "replace no column list",
    "query": "replace into user values(1, 2, 3)",
    "plan": "unsupported: REPLACE INTO with sharded schema"
  },
  {
    "comment": "replace with mimatched column list",
    "query": "replace into user(id) values (1, 2)",
    "plan": "unsupported: REPLACE INTO with sharded schema"
  },
  {
    "comment": "replace with one vindex",
    "query": "replace into user(id) values (1)",
    "plan": "unsupported: REPLACE INTO with sharded schema"
  },
  {
    "comment": "replace with non vindex on vindex-enabled table",
    "query": "replace into user(nonid) values (2)",
    "plan": "unsupported: REPLACE INTO with sharded schema"
  },
  {
    "comment": "replace with all vindexes supplied",
    "query": "replace into user(nonid, name, id) values (2, 'foo', 1)",
    "plan": "unsupported: REPLACE INTO with sharded schema"
  },
  {
    "comment": "replace for non-vindex autoinc",
    "query": "replace into user_extra(nonid) values (2)",
    "plan": "unsupported: REPLACE INTO with sharded schema"
  },
  {
    "comment": "replace with multiple rows",
    "query": "replace into user(id) values (1), (2)",
    "plan": "unsupported: REPLACE INTO with sharded schema"
  },
  {
    "query": "select keyspace_id from user_index where id = 1 and id = 2",
    "plan": "unsupported: where clause for vindex function must be of the form id = <val> or id in(<val>,...) (multiple filters)"
  },
  {
    "query": "select keyspace_id from user_index where func(id)",
    "plan": "unsupported: where clause for vindex function must be of the form id = <val> or id in(<val>,...) (not a comparison)"
  },
  {
    "query": "select keyspace_id from user_index where id > 1",
    "plan": "unsupported: where clause for vindex function must be of the form id = <val> or id in(<val>,...) (not equality)"
  },
  {
    "query": "select keyspace_id from user_index where 1 = id",
    "plan": "unsupported: where clause for vindex function must be of the form id = <val> or id in(<val>,...) (lhs is not a column)"
  },
  {
    "query": "select keyspace_id from user_index where keyspace_id = 1",
    "plan": "unsupported: where clause for vindex function must be of the form id = <val> or id in(<val>,...) (lhs is not id)"
  },
  {
    "query": "select keyspace_id from user_index where id = id+1",
    "plan": "unsupported: where clause for vindex function must be of the form id = <val> or id in(<val>,...) (rhs is not a value)"
  },
  {
    "comment": "vindex func without where condition",
    "query": "select keyspace_id from user_index",
    "plan": "unsupported: where clause for vindex function must be of the form id = <val> or id in(<val>,...) (where clause missing)"
  },
  {
    "comment": "vindex func in subquery without where",
    "query": "select id from user where exists(select keyspace_id from user_index)",
    "plan": "unsupported: where clause for vindex function must be of the form id = <val> or id in(<val>,...) (where clause missing)"
  },
  {
    "query": "select func(keyspace_id) from user_index where id = :id",
    "plan": "unsupported: expression on results of a vindex function"
  },
  {
    "comment": "delete with multi-table targets",
    "query": "delete music,user from music inner join user where music.id = user.id",
    "plan": "unsupported: multi-shard or vindex write statement"
  },
  {
    "comment": "select get_lock with non-dual table",
    "query": "select get_lock('xyz', 10) from user",
    "plan": "get_lock('xyz', 10) allowed only with dual"
  },
  {
    "comment": "select is_free_lock with non-dual table",
    "query": "select is_free_lock('xyz') from user",
    "plan": "is_free_lock('xyz') allowed only with dual"
  },
  {
    "comment": "insert using select get_lock from table",
    "query": "insert into user(pattern) SELECT GET_LOCK('xyz1', 10)",
    "plan": "unsupported: insert into select"
  },
  {
    "comment": "union with SQL_CALC_FOUND_ROWS",
    "query": "(select sql_calc_found_rows id from user where id = 1 limit 1) union select id from user where id = 1",
    "plan": "SQL_CALC_FOUND_ROWS not supported with union"
  },
  {
    "comment": "set with DEFAULT - vitess aware",
    "query": "set workload = default",
    "plan": "DEFAULT not supported for @@workload"
  },
  {
    "comment": "set with DEFAULT - reserved connection",
    "query": "set sql_mode = default",
    "plan": "DEFAULT not supported for @@sql_mode"
  },
  {
    "comment": "Multi shard query using into outfile s3",
    "query": "select * from user into outfile s3 'out_file_name'",
    "plan": "INTO is not supported on sharded keyspace"
  },
  {
    "comment": "create view with Cannot auto-resolve for cross-shard joins",
    "query": "create view user.view_a as select col from user join user_extra",
    "v3-plan": "symbol col not found",
    "gen4-plan": "Column 'col' in field list is ambiguous"
  },
  {
    "comment": "create view with join that cannot be served in each shard separately",
    "query": "create view user.view_a as select user_extra.id from user join user_extra",
    "plan": "Complex select queries are not supported in create or alter view statements"
  },
  {
    "comment": "create view with sharded limit",
    "query": "create view user.view_a as select id from user order by id limit 10",
    "plan": "Complex select queries are not supported in create or alter view statements"
  },
  {
    "comment": "create view with top level subquery in select",
    "query": "create view user.view_a as select a, (select col from user) from unsharded",
    "plan": "Complex select queries are not supported in create or alter view statements"
  },
  {
    "comment": "create view with sql_calc_found_rows with limit",
    "query": "create view user.view_a as select sql_calc_found_rows * from music limit 100",
    "plan": "Complex select queries are not supported in create or alter view statements"
  },
  {
    "comment": "create view with sql_calc_found_rows with group by and having",
    "query": "create view user.view_a as select sql_calc_found_rows user_id, count(id) from music group by user_id having count(user_id) = 1 order by user_id limit 2",
    "plan": "Complex select queries are not supported in create or alter view statements"
  },
  {
    "comment": "create view with incompatible keyspaces",
    "query": "create view main.view_a as select * from user.user_extra",
    "plan": "Select query does not belong to the same keyspace as the view statement"
  },
  {
    "comment": "table_schema OR predicate\n# It is unsupported because we do not route queries to multiple keyspaces right now",
    "query": "SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = 'ks' OR TABLE_SCHEMA = 'main'",
    "plan": {
      "QueryType": "SELECT",
      "Original": "SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = 'ks' OR TABLE_SCHEMA = 'main'",
      "Instructions": {
        "OperatorType": "Route",
        "Variant": "DBA",
        "Keyspace": {
          "Name": "main",
          "Sharded": false
        },
        "FieldQuery": "select * from INFORMATION_SCHEMA.`TABLES` where 1 != 1",
        "Query": "select * from INFORMATION_SCHEMA.`TABLES` where TABLE_SCHEMA = 'ks' or TABLE_SCHEMA = 'main'",
        "Table": "INFORMATION_SCHEMA.`TABLES`"
      }
    }
  },
  {
    "comment": "aggr and non-aggr without group by (with query does not give useful result out)",
    "query": "select id, count(*) from user",
    "v3-plan": {
      "QueryType": "SELECT",
      "Original": "select id, count(*) from user",
      "Instructions": {
        "OperatorType": "Aggregate",
        "Variant": "Ordered",
        "Aggregates": "count(1)",
        "Inputs": [
          {
            "OperatorType": "Route",
            "Variant": "Scatter",
            "Keyspace": {
              "Name": "user",
              "Sharded": true
            },
            "FieldQuery": "select id, count(*) from `user` where 1 != 1",
            "Query": "select id, count(*) from `user`",
            "Table": "`user`"
          }
        ]
      }
    },
    "gen4-plan": "In aggregated query without GROUP BY, expression of SELECT list contains nonaggregated column 'id'; this is incompatible with sql_mode=only_full_group_by"
  },
  {
    "comment": "avg function on scatter query",
    "query": "select avg(id) from user",
    "v3-plan": "unsupported: in scatter query: complex aggregate expression",
    "gen4-plan": "unsupported: in scatter query: aggregation function 'avg'"
  },
  {
    "comment": "scatter aggregate with ambiguous aliases",
    "query": "select distinct a, b as a from user",
    "plan": "generating order by clause: ambiguous symbol reference: a"
  },
  {
    "comment": "Aggregates and joins",
    "query": "select count(*) from user join user_extra",
    "plan": "unsupported: cross-shard query with aggregates"
  },
  {
    "comment": "TODO this should be planned without using OA and MS",
    "query": "select u.id from user u join user_extra ue on ue.id = u.id group by u.id having count(u.name) = 3",
    "v3-plan": "unsupported: cross-shard query with aggregates",
    "gen4-plan": "expr cannot be converted, not supported: count(u.`name`)"
  },
  {
    "query": "select (select 1 from user u having count(ue.col) > 10) from user_extra ue",
    "v3-plan": "symbol ue.col not found in subquery",
    "gen4-plan": "expr cannot be converted, not supported: count(ue.col)"
  },
  {
    "comment": "aggregation filtering by having on a route with no group by",
    "query": "select 1 from user having count(id) = 10",
    "v3-plan": {
      "QueryType": "SELECT",
      "Original": "select 1 from user having count(id) = 10",
      "Instructions": {
        "OperatorType": "Route",
        "Variant": "Scatter",
        "Keyspace": {
          "Name": "user",
          "Sharded": true
        },
        "FieldQuery": "select 1 from `user` where 1 != 1",
        "Query": "select 1 from `user` having count(id) = 10",
        "Table": "`user`"
      }
    },
    "gen4-plan": "expr cannot be converted, not supported: count(id)"
  },
  {
    "comment": "aggregation filtering by having on a route with no group by with non-unique vindex filter",
    "query": "select 1 from user having count(id) = 10 and name = 'a'",
    "v3-plan": {
      "QueryType": "SELECT",
      "Original": "select 1 from user having count(id) = 10 and name = 'a'",
      "Instructions": {
        "OperatorType": "Route",
        "Variant": "Equal",
        "Keyspace": {
          "Name": "user",
          "Sharded": true
        },
        "FieldQuery": "select 1 from `user` where 1 != 1",
        "Query": "select 1 from `user` having count(id) = 10 and `name` = 'a'",
        "Table": "`user`",
        "Values": [
          "VARCHAR(\"a\")"
        ],
        "Vindex": "name_user_map"
      }
    },
    "gen4-plan": "expr cannot be converted, not supported: count(id)"
  },
  {
    "comment": "subquery of information_schema with itself and star expression in outer select",
    "query": "select a.*, u.id from information_schema.a a, user u where a.id in (select * from information_schema.b)",
    "plan": "unsupported: '*' expression in cross-shard query"
  },
  {
    "comment": "outer and inner subquery route reference the same \"uu.id\" name\n# but they refer to different things. The first reference is to the outermost query,\n# and the second reference is to the innermost 'from' subquery.\n# This query will never work as the inner derived table is only selecting one of the column",
    "query": "select id2 from user uu where id in (select id from user where id = uu.id and user.col in (select col from (select id from user_extra where user_id = 5) uu where uu.user_id = uu.id))",
    "v3-plan": "unsupported: cross-shard correlated subquery",
    "gen4-plan": "unsupported: unable to split predicates to derived table: uu.user_id = uu.id"
  },
  {
    "comment": "outer and inner subquery route reference the same \"uu.id\" name\n# but they refer to different things. The first reference is to the outermost query,\n# and the second reference is to the innermost 'from' subquery.\n# changed to project all the columns from the derived tables.",
    "query": "select id2 from user uu where id in (select id from user where id = uu.id and user.col in (select col from (select col, id, user_id from user_extra where user_id = 5) uu where uu.user_id = uu.id))",
    "plan": "unsupported: cross-shard correlated subquery"
  },
  {
    "comment": "Gen4 does a rewrite of 'order by 2' that becomes 'order by id', leading to ambiguous binding.",
    "query": "select a.id, b.id from user as a, user_extra as b union select 1, 2 order by 2",
    "v3-plan": "can't do ORDER BY on top of UNION",
    "gen4-plan": "Column 'id' in field list is ambiguous"
  },
  {
    "comment": "Column aliases in Derived Table",
    "query": "select id2 from (select id from user) as x (id2)",
    "v3-plan": "unsupported: column aliases in derived table",
    "gen4-plan": {
      "QueryType": "SELECT",
      "Original": "select id2 from (select id from user) as x (id2)",
      "Instructions": {
        "OperatorType": "Route",
        "Variant": "Scatter",
        "Keyspace": {
          "Name": "user",
          "Sharded": true
        },
        "FieldQuery": "select id2 from (select id from `user` where 1 != 1) as x(id2) where 1 != 1",
        "Query": "select id2 from (select id from `user`) as x(id2)",
        "Table": "`user`"
      }
    }
  },
  {
    "comment": "unsupported with clause in delete statement",
    "query": "with x as (select * from user) delete from x",
    "plan": "unsupported: with expression in delete statement"
  },
  {
    "comment": "unsupported with clause in update statement",
    "query": "with x as (select * from user) update x set name = 'f'",
    "plan": "unsupported: with expression in update statement"
  },
  {
    "comment": "unsupported with clause in select statement",
    "query": "with x as (select * from user) select * from x",
    "plan": "unsupported: with expression in select statement"
  },
  {
    "comment": "unsupported with clause in union statement",
    "query": "with x as (select * from user) select * from x union select * from x",
    "plan": "unsupported: with expression in union statement"
  },
  {
    "comment": "Aggregate on join",
    "query": "select user.a, count(*) from user join user_extra group by user.a",
    "plan": "unsupported: cross-shard query with aggregates"
  },
  {
    "comment": "Aggregate on other table in join",
    "query": "select user.a, count(user_extra.a) from user join user_extra group by user.a",
    "plan": "unsupported: cross-shard query with aggregates"
  },
  {
    "comment": "scatter aggregate with complex select list (can't build order by)",
    "query": "select distinct a+1 from user",
    "v3-plan": "generating order by clause: cannot reference a complex expression",
    "gen4-plan": "unsupported: in scatter query: complex order by expression: a + 1"
  },
  {
    "comment": "aggregation on union",
    "query": "select sum(col) from (select col from user union all select col from unsharded) t",
    "v3-plan": "unsupported: cross-shard query with aggregates",
    "gen4-plan": "unsupported: aggregation on unions"
  },
  {
    "comment": "systable union query in derived table with constraint on outside (without star projection)",
    "query": "select id from (select id from `information_schema`.`key_column_usage` `kcu` where `kcu`.`table_schema` = 'user' and `kcu`.`table_name` = 'user_extra' union select id from `information_schema`.`key_column_usage` `kcu` where `kcu`.`table_schema` = 'user' and `kcu`.`table_name` = 'music') `kcu` where `id` = 'primary'",
    "v3-plan": "unsupported: filtering on results of cross-shard subquery",
    "gen4-plan": "can't push predicates on concatenate"
  }
]
