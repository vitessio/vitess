# Single information_schema query
"select col from information_schema.foo"
{
  "QueryType": "SELECT",
  "Original": "select col from information_schema.foo",
  "Instructions": {
    "OperatorType": "Route",
    "Variant": "SelectDBA",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "FieldQuery": "select col from information_schema.foo where 1 != 1",
    "Query": "select col from information_schema.foo",
    "Table": "information_schema.foo"
  }
}
Gen4 plan same as above

# ',' join information_schema
"select a.id,b.id from information_schema.a as a, information_schema.b as b"
{
  "QueryType": "SELECT",
  "Original": "select a.id,b.id from information_schema.a as a, information_schema.b as b",
  "Instructions": {
    "OperatorType": "Route",
    "Variant": "SelectDBA",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "FieldQuery": "select a.id, b.id from information_schema.a as a, information_schema.b as b where 1 != 1",
    "Query": "select a.id, b.id from information_schema.a as a, information_schema.b as b",
    "Table": "information_schema.a, information_schema.b"
  }
}
Gen4 plan same as above

# information schema query that uses table_schema
"select column_name from information_schema.columns where table_schema = (select schema())"
{
  "QueryType": "SELECT",
  "Original": "select column_name from information_schema.columns where table_schema = (select schema())",
  "Instructions": {
    "OperatorType": "Route",
    "Variant": "SelectDBA",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "FieldQuery": "select column_name from information_schema.`columns` where 1 != 1",
    "Query": "select column_name from information_schema.`columns` where table_schema = schema()",
    "Table": "information_schema.`columns`"
  }
}
Gen4 plan same as above

# information schema join
"select * from information_schema.a join information_schema.b"
{
  "QueryType": "SELECT",
  "Original": "select * from information_schema.a join information_schema.b",
  "Instructions": {
    "OperatorType": "Route",
    "Variant": "SelectDBA",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "FieldQuery": "select * from information_schema.a join information_schema.b where 1 != 1",
    "Query": "select * from information_schema.a join information_schema.b",
    "Table": "information_schema.a, information_schema.b"
  }
}
{
  "QueryType": "SELECT",
  "Original": "select * from information_schema.a join information_schema.b",
  "Instructions": {
    "OperatorType": "Route",
    "Variant": "SelectDBA",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "FieldQuery": "select * from information_schema.a, information_schema.b where 1 != 1",
    "Query": "select * from information_schema.a, information_schema.b",
    "Table": "information_schema.a, information_schema.b"
  }
}

# access to unqualified column names in information_schema
"select * from information_schema.a where b=10"
{
  "QueryType": "SELECT",
  "Original": "select * from information_schema.a where b=10",
  "Instructions": {
    "OperatorType": "Route",
    "Variant": "SelectDBA",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "FieldQuery": "select * from information_schema.a where 1 != 1",
    "Query": "select * from information_schema.a where b = 10",
    "Table": "information_schema.a"
  }
}
Gen4 plan same as above

# access to qualified column names in information_schema
"select * from information_schema.a where information_schema.a.b=10"
{
  "QueryType": "SELECT",
  "Original": "select * from information_schema.a where information_schema.a.b=10",
  "Instructions": {
    "OperatorType": "Route",
    "Variant": "SelectDBA",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "FieldQuery": "select * from information_schema.a where 1 != 1",
    "Query": "select * from information_schema.a where information_schema.a.b = 10",
    "Table": "information_schema.a"
  }
}
Gen4 plan same as above

# union of information_schema
"select * from information_schema.a union select * from information_schema.b"
{
  "QueryType": "SELECT",
  "Original": "select * from information_schema.a union select * from information_schema.b",
  "Instructions": {
    "OperatorType": "Route",
    "Variant": "SelectDBA",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "FieldQuery": "select * from information_schema.a where 1 != 1 union (select * from information_schema.b where 1 != 1)",
    "Query": "(select * from information_schema.a) union (select * from information_schema.b)",
    "Table": "information_schema.a"
  }
}
Gen4 plan same as above

# union between information_schema tables that should not be merged
"select * from information_schema.tables where table_schema = 'user' union select * from information_schema.tables where table_schema = 'main'"
{
  "QueryType": "SELECT",
  "Original": "select * from information_schema.tables where table_schema = 'user' union select * from information_schema.tables where table_schema = 'main'",
  "Instructions": {
    "OperatorType": "Distinct",
    "Inputs": [
      {
        "OperatorType": "Concatenate",
        "Inputs": [
          {
            "OperatorType": "Route",
            "Variant": "SelectDBA",
            "Keyspace": {
              "Name": "main",
              "Sharded": false
            },
            "FieldQuery": "select * from information_schema.`tables` where 1 != 1",
            "Query": "select * from information_schema.`tables` where table_schema = :__vtschemaname",
            "SysTableTableSchema": "[VARBINARY(\"user\")]",
            "Table": "information_schema.`tables`"
          },
          {
            "OperatorType": "Route",
            "Variant": "SelectDBA",
            "Keyspace": {
              "Name": "main",
              "Sharded": false
            },
            "FieldQuery": "select * from information_schema.`tables` where 1 != 1",
            "Query": "select * from information_schema.`tables` where table_schema = :__vtschemaname",
            "SysTableTableSchema": "[VARBINARY(\"main\")]",
            "Table": "information_schema.`tables`"
          }
        ]
      }
    ]
  }
}

# Select from information schema query with two tables that route should be merged
"SELECT DELETE_RULE, UPDATE_RULE FROM  INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS KCU INNER JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS AS RC ON KCU.CONSTRAINT_NAME = RC.CONSTRAINT_NAME WHERE KCU.TABLE_SCHEMA = 'test' AND KCU.TABLE_NAME = 'data_type_table' AND KCU.COLUMN_NAME = 'id' AND KCU.REFERENCED_TABLE_SCHEMA = 'test' AND KCU.CONSTRAINT_NAME = 'data_type_table_id_fkey' ORDER BY KCU.CONSTRAINT_NAME, KCU.COLUMN_NAME"
{
  "QueryType": "SELECT",
  "Original": "SELECT DELETE_RULE, UPDATE_RULE FROM  INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS KCU INNER JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS AS RC ON KCU.CONSTRAINT_NAME = RC.CONSTRAINT_NAME WHERE KCU.TABLE_SCHEMA = 'test' AND KCU.TABLE_NAME = 'data_type_table' AND KCU.COLUMN_NAME = 'id' AND KCU.REFERENCED_TABLE_SCHEMA = 'test' AND KCU.CONSTRAINT_NAME = 'data_type_table_id_fkey' ORDER BY KCU.CONSTRAINT_NAME, KCU.COLUMN_NAME",
  "Instructions": {
    "OperatorType": "Route",
    "Variant": "SelectDBA",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "FieldQuery": "select DELETE_RULE, UPDATE_RULE from INFORMATION_SCHEMA.KEY_COLUMN_USAGE as KCU join INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS as RC on KCU.CONSTRAINT_NAME = RC.CONSTRAINT_NAME where 1 != 1",
    "Query": "select DELETE_RULE, UPDATE_RULE from INFORMATION_SCHEMA.KEY_COLUMN_USAGE as KCU join INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS as RC on KCU.CONSTRAINT_NAME = RC.CONSTRAINT_NAME where KCU.TABLE_SCHEMA = :__vtschemaname and KCU.TABLE_NAME = :KCU_TABLE_NAME and KCU.COLUMN_NAME = 'id' and KCU.REFERENCED_TABLE_SCHEMA = 'test' and KCU.CONSTRAINT_NAME = 'data_type_table_id_fkey' order by KCU.CONSTRAINT_NAME asc, KCU.COLUMN_NAME asc",
    "SysTableTableName": "[KCU_TABLE_NAME:VARBINARY(\"data_type_table\")]",
    "SysTableTableSchema": "[VARBINARY(\"test\")]",
    "Table": "INFORMATION_SCHEMA.KEY_COLUMN_USAGE, INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS"
  }
}
{
  "QueryType": "SELECT",
  "Original": "SELECT DELETE_RULE, UPDATE_RULE FROM  INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS KCU INNER JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS AS RC ON KCU.CONSTRAINT_NAME = RC.CONSTRAINT_NAME WHERE KCU.TABLE_SCHEMA = 'test' AND KCU.TABLE_NAME = 'data_type_table' AND KCU.COLUMN_NAME = 'id' AND KCU.REFERENCED_TABLE_SCHEMA = 'test' AND KCU.CONSTRAINT_NAME = 'data_type_table_id_fkey' ORDER BY KCU.CONSTRAINT_NAME, KCU.COLUMN_NAME",
  "Instructions": {
    "OperatorType": "Route",
    "Variant": "SelectDBA",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "FieldQuery": "select DELETE_RULE, UPDATE_RULE from INFORMATION_SCHEMA.KEY_COLUMN_USAGE as KCU, INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS as RC where 1 != 1",
    "Query": "select DELETE_RULE, UPDATE_RULE from INFORMATION_SCHEMA.KEY_COLUMN_USAGE as KCU, INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS as RC where KCU.TABLE_SCHEMA = :__vtschemaname and KCU.TABLE_NAME = :KCU_TABLE_NAME and KCU.COLUMN_NAME = 'id' and KCU.REFERENCED_TABLE_SCHEMA = 'test' and KCU.CONSTRAINT_NAME = 'data_type_table_id_fkey' and KCU.CONSTRAINT_NAME = RC.CONSTRAINT_NAME order by KCU.CONSTRAINT_NAME asc, KCU.COLUMN_NAME asc",
    "SysTableTableName": "[KCU_TABLE_NAME:VARBINARY(\"data_type_table\")]",
    "SysTableTableSchema": "[VARBINARY(\"test\")]",
    "Table": "INFORMATION_SCHEMA.KEY_COLUMN_USAGE, INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS"
  }
}

# Select from information schema query with three tables such that route for 2 should be merged but not for the last.
"SELECT KCU.DELETE_RULE, S.UPDATE_RULE FROM  INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS KCU INNER JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS AS RC ON KCU.CONSTRAINT_NAME = RC.CONSTRAINT_NAME, INFORMATION_SCHEMA.K AS S WHERE KCU.TABLE_SCHEMA = 'test' AND KCU.TABLE_NAME = 'data_type_table' AND KCU.TABLE_NAME = 'data_type_table' AND S.TABLE_SCHEMA = 'test' AND S.TABLE_NAME = 'sc' ORDER BY KCU.CONSTRAINT_NAME, KCU.COLUMN_NAME"
{
  "QueryType": "SELECT",
  "Original": "SELECT KCU.DELETE_RULE, S.UPDATE_RULE FROM  INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS KCU INNER JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS AS RC ON KCU.CONSTRAINT_NAME = RC.CONSTRAINT_NAME, INFORMATION_SCHEMA.K AS S WHERE KCU.TABLE_SCHEMA = 'test' AND KCU.TABLE_NAME = 'data_type_table' AND KCU.TABLE_NAME = 'data_type_table' AND S.TABLE_SCHEMA = 'test' AND S.TABLE_NAME = 'sc' ORDER BY KCU.CONSTRAINT_NAME, KCU.COLUMN_NAME",
  "Instructions": {
    "OperatorType": "Join",
    "Variant": "Join",
    "JoinColumnIndexes": "-1,1",
    "TableName": "INFORMATION_SCHEMA.KEY_COLUMN_USAGE, INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS_INFORMATION_SCHEMA.K",
    "Inputs": [
      {
        "OperatorType": "Route",
        "Variant": "SelectDBA",
        "Keyspace": {
          "Name": "main",
          "Sharded": false
        },
        "FieldQuery": "select KCU.DELETE_RULE from INFORMATION_SCHEMA.KEY_COLUMN_USAGE as KCU join INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS as RC on KCU.CONSTRAINT_NAME = RC.CONSTRAINT_NAME where 1 != 1",
        "Query": "select KCU.DELETE_RULE from INFORMATION_SCHEMA.KEY_COLUMN_USAGE as KCU join INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS as RC on KCU.CONSTRAINT_NAME = RC.CONSTRAINT_NAME where KCU.TABLE_SCHEMA = :__vtschemaname and KCU.TABLE_NAME = :KCU_TABLE_NAME and KCU.TABLE_NAME = :KCU_TABLE_NAME1 order by KCU.CONSTRAINT_NAME asc, KCU.COLUMN_NAME asc",
        "SysTableTableName": "[KCU_TABLE_NAME1:VARBINARY(\"data_type_table\"), KCU_TABLE_NAME:VARBINARY(\"data_type_table\")]",
        "SysTableTableSchema": "[VARBINARY(\"test\")]",
        "Table": "INFORMATION_SCHEMA.KEY_COLUMN_USAGE, INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS"
      },
      {
        "OperatorType": "Route",
        "Variant": "SelectDBA",
        "Keyspace": {
          "Name": "main",
          "Sharded": false
        },
        "FieldQuery": "select S.UPDATE_RULE from INFORMATION_SCHEMA.K as S where 1 != 1",
        "Query": "select S.UPDATE_RULE from INFORMATION_SCHEMA.K as S where S.TABLE_SCHEMA = :__vtschemaname and S.TABLE_NAME = :S_TABLE_NAME",
        "SysTableTableName": "[S_TABLE_NAME:VARBINARY(\"sc\")]",
        "SysTableTableSchema": "[VARBINARY(\"test\")]",
        "Table": "INFORMATION_SCHEMA.K"
      }
    ]
  }
}
{
  "QueryType": "SELECT",
  "Original": "SELECT KCU.DELETE_RULE, S.UPDATE_RULE FROM  INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS KCU INNER JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS AS RC ON KCU.CONSTRAINT_NAME = RC.CONSTRAINT_NAME, INFORMATION_SCHEMA.K AS S WHERE KCU.TABLE_SCHEMA = 'test' AND KCU.TABLE_NAME = 'data_type_table' AND KCU.TABLE_NAME = 'data_type_table' AND S.TABLE_SCHEMA = 'test' AND S.TABLE_NAME = 'sc' ORDER BY KCU.CONSTRAINT_NAME, KCU.COLUMN_NAME",
  "Instructions": {
    "OperatorType": "Route",
    "Variant": "SelectDBA",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "FieldQuery": "select KCU.DELETE_RULE, S.UPDATE_RULE from INFORMATION_SCHEMA.KEY_COLUMN_USAGE as KCU, INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS as RC, INFORMATION_SCHEMA.K as S where 1 != 1",
    "Query": "select KCU.DELETE_RULE, S.UPDATE_RULE from INFORMATION_SCHEMA.KEY_COLUMN_USAGE as KCU, INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS as RC, INFORMATION_SCHEMA.K as S where S.TABLE_SCHEMA = :__vtschemaname and S.TABLE_NAME = :S_TABLE_NAME and KCU.TABLE_SCHEMA = :__vtschemaname and KCU.TABLE_NAME = :KCU_TABLE_NAME and KCU.TABLE_NAME = :KCU_TABLE_NAME1 and KCU.CONSTRAINT_NAME = RC.CONSTRAINT_NAME order by KCU.CONSTRAINT_NAME asc, KCU.COLUMN_NAME asc",
    "SysTableTableName": "[KCU_TABLE_NAME1:VARBINARY(\"data_type_table\"), KCU_TABLE_NAME:VARBINARY(\"data_type_table\"), S_TABLE_NAME:VARBINARY(\"sc\")]",
    "SysTableTableSchema": "[VARBINARY(\"test\"), VARBINARY(\"test\")]",
    "Table": "INFORMATION_SCHEMA.K, INFORMATION_SCHEMA.KEY_COLUMN_USAGE, INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS"
  }
}

#information_schema.routines
"SELECT routine_name AS name, routine_definition AS definition FROM information_schema.routines WHERE ROUTINE_SCHEMA = ? AND ROUTINE_TYPE = 'PROCEDURE'"
{
  "QueryType": "SELECT",
  "Original": "SELECT routine_name AS name, routine_definition AS definition FROM information_schema.routines WHERE ROUTINE_SCHEMA = ? AND ROUTINE_TYPE = 'PROCEDURE'",
  "Instructions": {
    "OperatorType": "Route",
    "Variant": "SelectDBA",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "FieldQuery": "select routine_name as `name`, routine_definition as definition from information_schema.routines where 1 != 1",
    "Query": "select routine_name as `name`, routine_definition as definition from information_schema.routines where ROUTINE_SCHEMA = :__vtschemaname and ROUTINE_TYPE = 'PROCEDURE'",
    "SysTableTableSchema": "[:v1]",
    "Table": "information_schema.routines"
  }
}
Gen4 plan same as above

#information_schema table sizes
"SELECT SUM(data_length + index_length) as size FROM information_schema.TABLES WHERE table_schema = ?"
{
  "QueryType": "SELECT",
  "Original": "SELECT SUM(data_length + index_length) as size FROM information_schema.TABLES WHERE table_schema = ?",
  "Instructions": {
    "OperatorType": "Route",
    "Variant": "SelectDBA",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "FieldQuery": "select SUM(data_length + index_length) as size from information_schema.`TABLES` where 1 != 1",
    "Query": "select SUM(data_length + index_length) as size from information_schema.`TABLES` where table_schema = :__vtschemaname",
    "SysTableTableSchema": "[:v1]",
    "Table": "information_schema.`TABLES`"
  }
}
Gen4 plan same as above

#information_schema referential contraints
"SELECT kcu.constraint_name constraint_name, kcu.column_name column_name, kcu.referenced_table_name referenced_table_name, kcu.referenced_column_name referenced_column_name, kcu.ordinal_position ordinal_position, kcu.table_name table_name, rc.delete_rule delete_rule, rc.update_rule update_rule FROM information_schema.key_column_usage AS kcu INNER JOIN information_schema.referential_constraints AS rc ON kcu.constraint_name = rc.constraint_name WHERE kcu.table_schema = ? AND rc.constraint_schema = ? AND kcu.referenced_column_name IS NOT NULL ORDER BY ordinal_position"
{
  "QueryType": "SELECT",
  "Original": "SELECT kcu.constraint_name constraint_name, kcu.column_name column_name, kcu.referenced_table_name referenced_table_name, kcu.referenced_column_name referenced_column_name, kcu.ordinal_position ordinal_position, kcu.table_name table_name, rc.delete_rule delete_rule, rc.update_rule update_rule FROM information_schema.key_column_usage AS kcu INNER JOIN information_schema.referential_constraints AS rc ON kcu.constraint_name = rc.constraint_name WHERE kcu.table_schema = ? AND rc.constraint_schema = ? AND kcu.referenced_column_name IS NOT NULL ORDER BY ordinal_position",
  "Instructions": {
    "OperatorType": "Route",
    "Variant": "SelectDBA",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "FieldQuery": "select kcu.constraint_name as constraint_name, kcu.column_name as column_name, kcu.referenced_table_name as referenced_table_name, kcu.referenced_column_name as referenced_column_name, kcu.ordinal_position as ordinal_position, kcu.table_name as table_name, rc.delete_rule as delete_rule, rc.update_rule as update_rule from information_schema.key_column_usage as kcu join information_schema.referential_constraints as rc on kcu.constraint_name = rc.constraint_name where 1 != 1",
    "Query": "select kcu.constraint_name as constraint_name, kcu.column_name as column_name, kcu.referenced_table_name as referenced_table_name, kcu.referenced_column_name as referenced_column_name, kcu.ordinal_position as ordinal_position, kcu.table_name as table_name, rc.delete_rule as delete_rule, rc.update_rule as update_rule from information_schema.key_column_usage as kcu join information_schema.referential_constraints as rc on kcu.constraint_name = rc.constraint_name where kcu.table_schema = :__vtschemaname and rc.constraint_schema = :__vtschemaname and kcu.referenced_column_name is not null order by ordinal_position asc",
    "SysTableTableSchema": "[:v1, :v2]",
    "Table": "information_schema.key_column_usage, information_schema.referential_constraints"
  }
}
{
  "QueryType": "SELECT",
  "Original": "SELECT kcu.constraint_name constraint_name, kcu.column_name column_name, kcu.referenced_table_name referenced_table_name, kcu.referenced_column_name referenced_column_name, kcu.ordinal_position ordinal_position, kcu.table_name table_name, rc.delete_rule delete_rule, rc.update_rule update_rule FROM information_schema.key_column_usage AS kcu INNER JOIN information_schema.referential_constraints AS rc ON kcu.constraint_name = rc.constraint_name WHERE kcu.table_schema = ? AND rc.constraint_schema = ? AND kcu.referenced_column_name IS NOT NULL ORDER BY ordinal_position",
  "Instructions": {
    "OperatorType": "Route",
    "Variant": "SelectDBA",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "FieldQuery": "select kcu.constraint_name as constraint_name, kcu.column_name as column_name, kcu.referenced_table_name as referenced_table_name, kcu.referenced_column_name as referenced_column_name, kcu.ordinal_position as ordinal_position, kcu.table_name as table_name, rc.delete_rule as delete_rule, rc.update_rule as update_rule from information_schema.key_column_usage as kcu, information_schema.referential_constraints as rc where 1 != 1",
    "Query": "select kcu.constraint_name as constraint_name, kcu.column_name as column_name, kcu.referenced_table_name as referenced_table_name, kcu.referenced_column_name as referenced_column_name, kcu.ordinal_position as ordinal_position, kcu.table_name as table_name, rc.delete_rule as delete_rule, rc.update_rule as update_rule from information_schema.key_column_usage as kcu, information_schema.referential_constraints as rc where kcu.table_schema = :__vtschemaname and kcu.referenced_column_name is not null and rc.constraint_schema = :__vtschemaname and kcu.constraint_name = rc.constraint_name order by ordinal_position asc",
    "SysTableTableSchema": "[:v1, :v2]",
    "Table": "information_schema.key_column_usage, information_schema.referential_constraints"
  }
}

# rails query
"select fk.referenced_table_name as to_table, fk.referenced_column_name as primary_key, fk.column_name as `column`, fk.constraint_name as name, rc.update_rule as on_update, rc.delete_rule as on_delete from information_schema.referential_constraints as rc join information_schema.key_column_usage as fk using (constraint_schema, constraint_name) where fk.referenced_column_name is not null and fk.table_schema = database() and fk.table_name = ':vtg1' and rc.constraint_schema = database() and rc.table_name = ':vtg1'"
{
  "QueryType": "SELECT",
  "Original": "select fk.referenced_table_name as to_table, fk.referenced_column_name as primary_key, fk.column_name as `column`, fk.constraint_name as name, rc.update_rule as on_update, rc.delete_rule as on_delete from information_schema.referential_constraints as rc join information_schema.key_column_usage as fk using (constraint_schema, constraint_name) where fk.referenced_column_name is not null and fk.table_schema = database() and fk.table_name = ':vtg1' and rc.constraint_schema = database() and rc.table_name = ':vtg1'",
  "Instructions": {
    "OperatorType": "Route",
    "Variant": "SelectDBA",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "FieldQuery": "select fk.referenced_table_name as to_table, fk.referenced_column_name as primary_key, fk.column_name as `column`, fk.constraint_name as `name`, rc.update_rule as on_update, rc.delete_rule as on_delete from information_schema.referential_constraints as rc join information_schema.key_column_usage as fk on rc.constraint_schema = fk.constraint_schema and rc.constraint_name = fk.constraint_name where 1 != 1",
    "Query": "select fk.referenced_table_name as to_table, fk.referenced_column_name as primary_key, fk.column_name as `column`, fk.constraint_name as `name`, rc.update_rule as on_update, rc.delete_rule as on_delete from information_schema.referential_constraints as rc join information_schema.key_column_usage as fk on rc.constraint_schema = fk.constraint_schema and rc.constraint_name = fk.constraint_name where fk.referenced_column_name is not null and fk.table_schema = database() and fk.table_name = :fk_table_name and rc.constraint_schema = database() and rc.table_name = :rc_table_name",
    "SysTableTableName": "[fk_table_name:VARBINARY(\":vtg1\"), rc_table_name:VARBINARY(\":vtg1\")]",
    "Table": "information_schema.referential_constraints, information_schema.key_column_usage"
  }
}
{
  "QueryType": "SELECT",
  "Original": "select fk.referenced_table_name as to_table, fk.referenced_column_name as primary_key, fk.column_name as `column`, fk.constraint_name as name, rc.update_rule as on_update, rc.delete_rule as on_delete from information_schema.referential_constraints as rc join information_schema.key_column_usage as fk using (constraint_schema, constraint_name) where fk.referenced_column_name is not null and fk.table_schema = database() and fk.table_name = ':vtg1' and rc.constraint_schema = database() and rc.table_name = ':vtg1'",
  "Instructions": {
    "OperatorType": "Route",
    "Variant": "SelectDBA",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "FieldQuery": "select fk.referenced_table_name as to_table, fk.referenced_column_name as primary_key, fk.column_name as `column`, fk.constraint_name as `name`, rc.update_rule as on_update, rc.delete_rule as on_delete from information_schema.referential_constraints as rc, information_schema.key_column_usage as fk where 1 != 1",
    "Query": "select fk.referenced_table_name as to_table, fk.referenced_column_name as primary_key, fk.column_name as `column`, fk.constraint_name as `name`, rc.update_rule as on_update, rc.delete_rule as on_delete from information_schema.referential_constraints as rc, information_schema.key_column_usage as fk where rc.constraint_schema = database() and rc.table_name = :rc_table_name and fk.referenced_column_name is not null and fk.table_schema = database() and fk.table_name = :fk_table_name and rc.constraint_schema = fk.constraint_schema and rc.constraint_name = fk.constraint_name",
    "SysTableTableName": "[fk_table_name:VARBINARY(\":vtg1\"), rc_table_name:VARBINARY(\":vtg1\")]",
    "Table": "information_schema.key_column_usage, information_schema.referential_constraints"
  }
}

#rails_query 2
"SELECT * FROM information_schema.schemata WHERE schema_name = 'user'"
{
  "QueryType": "SELECT",
  "Original": "SELECT * FROM information_schema.schemata WHERE schema_name = 'user'",
  "Instructions": {
    "OperatorType": "Route",
    "Variant": "SelectDBA",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "FieldQuery": "select * from information_schema.schemata where 1 != 1",
    "Query": "select * from information_schema.schemata where schema_name = :__vtschemaname",
    "SysTableTableSchema": "[VARBINARY(\"user\")]",
    "Table": "information_schema.schemata"
  }
}
Gen4 plan same as above

#rails_query 3
"SELECT table_comment FROM information_schema.tables WHERE table_schema = 'schema_name' AND table_name = 'table_name'"
{
  "QueryType": "SELECT",
  "Original": "SELECT table_comment FROM information_schema.tables WHERE table_schema = 'schema_name' AND table_name = 'table_name'",
  "Instructions": {
    "OperatorType": "Route",
    "Variant": "SelectDBA",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "FieldQuery": "select table_comment from information_schema.`tables` where 1 != 1",
    "Query": "select table_comment from information_schema.`tables` where table_schema = :__vtschemaname and table_name = :table_name",
    "SysTableTableName": "[table_name:VARBINARY(\"table_name\")]",
    "SysTableTableSchema": "[VARBINARY(\"schema_name\")]",
    "Table": "information_schema.`tables`"
  }
}
Gen4 plan same as above

#rails_query 4
"SELECT fk.referenced_table_name AS 'to_table', fk.referenced_column_name AS 'primary_key',fk.column_name AS 'column',fk.constraint_name AS 'name',rc.update_rule AS 'on_update',rc.delete_rule AS 'on_delete' FROM information_schema.referential_constraints rc JOIN information_schema.key_column_usage fk USING (constraint_schema, constraint_name) WHERE fk.referenced_column_name IS NOT NULL AND fk.table_schema = 'table_schema' AND fk.table_name = 'table_name' AND rc.constraint_schema = 'table_schema' AND rc.table_name = 'table_name'"
{
  "QueryType": "SELECT",
  "Original": "SELECT fk.referenced_table_name AS 'to_table', fk.referenced_column_name AS 'primary_key',fk.column_name AS 'column',fk.constraint_name AS 'name',rc.update_rule AS 'on_update',rc.delete_rule AS 'on_delete' FROM information_schema.referential_constraints rc JOIN information_schema.key_column_usage fk USING (constraint_schema, constraint_name) WHERE fk.referenced_column_name IS NOT NULL AND fk.table_schema = 'table_schema' AND fk.table_name = 'table_name' AND rc.constraint_schema = 'table_schema' AND rc.table_name = 'table_name'",
  "Instructions": {
    "OperatorType": "Route",
    "Variant": "SelectDBA",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "FieldQuery": "select fk.referenced_table_name as to_table, fk.referenced_column_name as primary_key, fk.column_name as `column`, fk.constraint_name as `name`, rc.update_rule as on_update, rc.delete_rule as on_delete from information_schema.referential_constraints as rc join information_schema.key_column_usage as fk on rc.constraint_schema = fk.constraint_schema and rc.constraint_name = fk.constraint_name where 1 != 1",
    "Query": "select fk.referenced_table_name as to_table, fk.referenced_column_name as primary_key, fk.column_name as `column`, fk.constraint_name as `name`, rc.update_rule as on_update, rc.delete_rule as on_delete from information_schema.referential_constraints as rc join information_schema.key_column_usage as fk on rc.constraint_schema = fk.constraint_schema and rc.constraint_name = fk.constraint_name where fk.referenced_column_name is not null and fk.table_schema = :__vtschemaname and fk.table_name = :fk_table_name and rc.constraint_schema = :__vtschemaname and rc.table_name = :rc_table_name",
    "SysTableTableName": "[fk_table_name:VARBINARY(\"table_name\"), rc_table_name:VARBINARY(\"table_name\")]",
    "SysTableTableSchema": "[VARBINARY(\"table_schema\"), VARBINARY(\"table_schema\")]",
    "Table": "information_schema.referential_constraints, information_schema.key_column_usage"
  }
}
{
  "QueryType": "SELECT",
  "Original": "SELECT fk.referenced_table_name AS 'to_table', fk.referenced_column_name AS 'primary_key',fk.column_name AS 'column',fk.constraint_name AS 'name',rc.update_rule AS 'on_update',rc.delete_rule AS 'on_delete' FROM information_schema.referential_constraints rc JOIN information_schema.key_column_usage fk USING (constraint_schema, constraint_name) WHERE fk.referenced_column_name IS NOT NULL AND fk.table_schema = 'table_schema' AND fk.table_name = 'table_name' AND rc.constraint_schema = 'table_schema' AND rc.table_name = 'table_name'",
  "Instructions": {
    "OperatorType": "Route",
    "Variant": "SelectDBA",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "FieldQuery": "select fk.referenced_table_name as to_table, fk.referenced_column_name as primary_key, fk.column_name as `column`, fk.constraint_name as `name`, rc.update_rule as on_update, rc.delete_rule as on_delete from information_schema.referential_constraints as rc, information_schema.key_column_usage as fk where 1 != 1",
    "Query": "select fk.referenced_table_name as to_table, fk.referenced_column_name as primary_key, fk.column_name as `column`, fk.constraint_name as `name`, rc.update_rule as on_update, rc.delete_rule as on_delete from information_schema.referential_constraints as rc, information_schema.key_column_usage as fk where rc.constraint_schema = :__vtschemaname and rc.table_name = :rc_table_name and fk.referenced_column_name is not null and fk.table_schema = :__vtschemaname and fk.table_name = :fk_table_name and rc.constraint_schema = fk.constraint_schema and rc.constraint_name = fk.constraint_name",
    "SysTableTableName": "[fk_table_name:VARBINARY(\"table_name\"), rc_table_name:VARBINARY(\"table_name\")]",
    "SysTableTableSchema": "[VARBINARY(\"table_schema\"), VARBINARY(\"table_schema\")]",
    "Table": "information_schema.key_column_usage, information_schema.referential_constraints"
  }
}

#rails_query 5
"SELECT cc.constraint_name AS 'name', cc.check_clause AS 'expression' FROM information_schema.check_constraints cc JOIN information_schema.table_constraints tc USING (constraint_schema, constraint_name) WHERE tc.table_schema = 'table_schema' AND tc.table_name = 'table_name' AND cc.constraint_schema = 'constraint_schema'"
{
  "QueryType": "SELECT",
  "Original": "SELECT cc.constraint_name AS 'name', cc.check_clause AS 'expression' FROM information_schema.check_constraints cc JOIN information_schema.table_constraints tc USING (constraint_schema, constraint_name) WHERE tc.table_schema = 'table_schema' AND tc.table_name = 'table_name' AND cc.constraint_schema = 'constraint_schema'",
  "Instructions": {
    "OperatorType": "Route",
    "Variant": "SelectDBA",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "FieldQuery": "select cc.constraint_name as `name`, cc.check_clause as expression from information_schema.check_constraints as cc join information_schema.table_constraints as tc on cc.constraint_schema = tc.constraint_schema and cc.constraint_name = tc.constraint_name where 1 != 1",
    "Query": "select cc.constraint_name as `name`, cc.check_clause as expression from information_schema.check_constraints as cc join information_schema.table_constraints as tc on cc.constraint_schema = tc.constraint_schema and cc.constraint_name = tc.constraint_name where tc.table_schema = :__vtschemaname and tc.table_name = :tc_table_name and cc.constraint_schema = :__vtschemaname",
    "SysTableTableName": "[tc_table_name:VARBINARY(\"table_name\")]",
    "SysTableTableSchema": "[VARBINARY(\"table_schema\"), VARBINARY(\"constraint_schema\")]",
    "Table": "information_schema.check_constraints, information_schema.table_constraints"
  }
}
{
  "QueryType": "SELECT",
  "Original": "SELECT cc.constraint_name AS 'name', cc.check_clause AS 'expression' FROM information_schema.check_constraints cc JOIN information_schema.table_constraints tc USING (constraint_schema, constraint_name) WHERE tc.table_schema = 'table_schema' AND tc.table_name = 'table_name' AND cc.constraint_schema = 'constraint_schema'",
  "Instructions": {
    "OperatorType": "Route",
    "Variant": "SelectDBA",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "FieldQuery": "select cc.constraint_name as `name`, cc.check_clause as expression from information_schema.check_constraints as cc, information_schema.table_constraints as tc where 1 != 1",
    "Query": "select cc.constraint_name as `name`, cc.check_clause as expression from information_schema.check_constraints as cc, information_schema.table_constraints as tc where cc.constraint_schema = :__vtschemaname and tc.table_schema = :__vtschemaname and tc.table_name = :tc_table_name and cc.constraint_schema = tc.constraint_schema and cc.constraint_name = tc.constraint_name",
    "SysTableTableName": "[tc_table_name:VARBINARY(\"table_name\")]",
    "SysTableTableSchema": "[VARBINARY(\"constraint_schema\"), VARBINARY(\"table_schema\")]",
    "Table": "information_schema.check_constraints, information_schema.table_constraints"
  }
}

#rails_query 6
"SELECT column_name FROM information_schema.statistics WHERE index_name = 'PRIMARY' AND table_schema = 'table_schema' AND table_name = 'table_name' ORDER BY seq_in_index"
{
  "QueryType": "SELECT",
  "Original": "SELECT column_name FROM information_schema.statistics WHERE index_name = 'PRIMARY' AND table_schema = 'table_schema' AND table_name = 'table_name' ORDER BY seq_in_index",
  "Instructions": {
    "OperatorType": "Route",
    "Variant": "SelectDBA",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "FieldQuery": "select column_name from information_schema.statistics where 1 != 1",
    "Query": "select column_name from information_schema.statistics where index_name = 'PRIMARY' and table_schema = :__vtschemaname and table_name = :table_name order by seq_in_index asc",
    "SysTableTableName": "[table_name:VARBINARY(\"table_name\")]",
    "SysTableTableSchema": "[VARBINARY(\"table_schema\")]",
    "Table": "information_schema.statistics"
  }
}
Gen4 plan same as above

#rails_query 7
"SELECT generation_expression FROM information_schema.columns WHERE table_schema = 'table_schema' AND table_name = 'table_name' AND column_name = 'column_name'"
{
  "QueryType": "SELECT",
  "Original": "SELECT generation_expression FROM information_schema.columns WHERE table_schema = 'table_schema' AND table_name = 'table_name' AND column_name = 'column_name'",
  "Instructions": {
    "OperatorType": "Route",
    "Variant": "SelectDBA",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "FieldQuery": "select generation_expression from information_schema.`columns` where 1 != 1",
    "Query": "select generation_expression from information_schema.`columns` where table_schema = :__vtschemaname and table_name = :table_name and column_name = 'column_name'",
    "SysTableTableName": "[table_name:VARBINARY(\"table_name\")]",
    "SysTableTableSchema": "[VARBINARY(\"table_schema\")]",
    "Table": "information_schema.`columns`"
  }
}
Gen4 plan same as above

#rails_query 8
"SELECT id FROM information_schema.processlist WHERE info LIKE '% FOR UPDATE'"
{
  "QueryType": "SELECT",
  "Original": "SELECT id FROM information_schema.processlist WHERE info LIKE '% FOR UPDATE'",
  "Instructions": {
    "OperatorType": "Route",
    "Variant": "SelectDBA",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "FieldQuery": "select id from information_schema.`processlist` where 1 != 1",
    "Query": "select id from information_schema.`processlist` where info like '% FOR UPDATE'",
    "Table": "information_schema.`processlist`"
  }
}
Gen4 plan same as above

#rails_query 9
"SELECT table_name FROM (SELECT * FROM information_schema.tables WHERE table_schema = 'table_schema') _subquery"
{
  "QueryType": "SELECT",
  "Original": "SELECT table_name FROM (SELECT * FROM information_schema.tables WHERE table_schema = 'table_schema') _subquery",
  "Instructions": {
    "OperatorType": "Route",
    "Variant": "SelectDBA",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "FieldQuery": "select table_name from (select * from information_schema.`tables` where 1 != 1) as _subquery where 1 != 1",
    "Query": "select table_name from (select * from information_schema.`tables` where table_schema = :__vtschemaname) as _subquery",
    "SysTableTableSchema": "[VARBINARY(\"table_schema\")]",
    "Table": "information_schema.`tables`"
  }
}
Gen4 plan same as above

#rails_query 10
"SELECT table_name FROM (SELECT * FROM information_schema.tables WHERE table_schema = 'table_schema') _subquery WHERE _subquery.table_type = 'table_type' AND _subquery.table_name = 'table_name'"
{
  "QueryType": "SELECT",
  "Original": "SELECT table_name FROM (SELECT * FROM information_schema.tables WHERE table_schema = 'table_schema') _subquery WHERE _subquery.table_type = 'table_type' AND _subquery.table_name = 'table_name'",
  "Instructions": {
    "OperatorType": "Route",
    "Variant": "SelectDBA",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "FieldQuery": "select table_name from (select * from information_schema.`tables` where 1 != 1) as _subquery where 1 != 1",
    "Query": "select table_name from (select * from information_schema.`tables` where table_schema = :__vtschemaname) as _subquery where _subquery.table_type = 'table_type' and _subquery.table_name = :_subquery_table_name",
    "SysTableTableName": "[_subquery_table_name:VARBINARY(\"table_name\")]",
    "SysTableTableSchema": "[VARBINARY(\"table_schema\")]",
    "Table": "information_schema.`tables`"
  }
}

# two predicates specifying the database for the same table work if the database is the same
"SELECT cc.constraint_name AS 'name' FROM information_schema.check_constraints cc  WHERE cc.constraint_schema = 'a' AND cc.table_schema = 'a'"
{
  "QueryType": "SELECT",
  "Original": "SELECT cc.constraint_name AS 'name' FROM information_schema.check_constraints cc  WHERE cc.constraint_schema = 'a' AND cc.table_schema = 'a'",
  "Instructions": {
    "OperatorType": "Route",
    "Variant": "SelectDBA",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "FieldQuery": "select cc.constraint_name as `name` from information_schema.check_constraints as cc where 1 != 1",
    "Query": "select cc.constraint_name as `name` from information_schema.check_constraints as cc where cc.constraint_schema = :__vtschemaname and cc.table_schema = :__vtschemaname",
    "SysTableTableSchema": "[VARBINARY(\"a\"), VARBINARY(\"a\")]",
    "Table": "information_schema.check_constraints"
  }
}
Gen4 plan same as above

# system schema in where clause of information_schema query
"SELECT COUNT(*) FROM INFORMATION_SCHEMA.TABLES WHERE table_schema = 'performance_schema' AND table_name = 'foo'"
{
  "QueryType": "SELECT",
  "Original": "SELECT COUNT(*) FROM INFORMATION_SCHEMA.TABLES WHERE table_schema = 'performance_schema' AND table_name = 'foo'",
  "Instructions": {
    "OperatorType": "Route",
    "Variant": "SelectDBA",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "FieldQuery": "select COUNT(*) from INFORMATION_SCHEMA.`TABLES` where 1 != 1",
    "Query": "select COUNT(*) from INFORMATION_SCHEMA.`TABLES` where table_schema = :__vtschemaname and table_name = :table_name",
    "SysTableTableName": "[table_name:VARBINARY(\"foo\")]",
    "SysTableTableSchema": "[VARBINARY(\"performance_schema\")]",
    "Table": "INFORMATION_SCHEMA.`TABLES`"
  }
}
Gen4 plan same as above

# subquery of information_schema with itself
"select * from information_schema.a where id in (select * from information_schema.b)"
{
  "QueryType": "SELECT",
  "Original": "select * from information_schema.a where id in (select * from information_schema.b)",
  "Instructions": {
    "OperatorType": "Route",
    "Variant": "SelectDBA",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "FieldQuery": "select * from information_schema.a where 1 != 1",
    "Query": "select * from information_schema.a where id in (select * from information_schema.b)",
    "Table": "information_schema.a"
  }
}
Gen4 plan same as above

# query trying to query two different keyspaces at the same time
"SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = 'user' AND TABLE_SCHEMA = 'main'"
{
  "QueryType": "SELECT",
  "Original": "SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = 'user' AND TABLE_SCHEMA = 'main'",
  "Instructions": {
    "OperatorType": "Route",
    "Variant": "SelectDBA",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "FieldQuery": "select * from INFORMATION_SCHEMA.`TABLES` where 1 != 1",
    "Query": "select * from INFORMATION_SCHEMA.`TABLES` where TABLE_SCHEMA = :__vtschemaname and TABLE_SCHEMA = :__vtschemaname",
    "SysTableTableSchema": "[VARBINARY(\"user\"), VARBINARY(\"main\")]",
    "Table": "INFORMATION_SCHEMA.`TABLES`"
  }
}
{
  "QueryType": "SELECT",
  "Original": "SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = 'user' AND TABLE_SCHEMA = 'main'",
  "Instructions": {
    "OperatorType": "Route",
    "Variant": "SelectDBA",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "FieldQuery": "select * from INFORMATION_SCHEMA.`TABLES` where 1 != 1",
    "Query": "select * from INFORMATION_SCHEMA.`TABLES` where TABLE_SCHEMA = :__vtschemaname",
    "SysTableTableSchema": "[VARBINARY(\"user\"), VARBINARY(\"main\")]",
    "Table": "INFORMATION_SCHEMA.`TABLES`"
  }
}

# information_schema query using database() func
"SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = database()"
{
  "QueryType": "SELECT",
  "Original": "SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = database()",
  "Instructions": {
    "OperatorType": "Route",
    "Variant": "SelectDBA",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "FieldQuery": "select * from INFORMATION_SCHEMA.`TABLES` where 1 != 1",
    "Query": "select * from INFORMATION_SCHEMA.`TABLES` where TABLE_SCHEMA = database()",
    "Table": "INFORMATION_SCHEMA.`TABLES`"
  }
}
Gen4 plan same as above

# table_schema predicate the wrong way around
"SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE 'ks' = TABLE_SCHEMA"
{
  "QueryType": "SELECT",
  "Original": "SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE 'ks' = TABLE_SCHEMA",
  "Instructions": {
    "OperatorType": "Route",
    "Variant": "SelectDBA",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "FieldQuery": "select * from INFORMATION_SCHEMA.`TABLES` where 1 != 1",
    "Query": "select * from INFORMATION_SCHEMA.`TABLES` where TABLE_SCHEMA = :__vtschemaname",
    "SysTableTableSchema": "[VARBINARY(\"ks\")]",
    "Table": "INFORMATION_SCHEMA.`TABLES`"
  }
}
Gen4 plan same as above

# table_name predicate against a routed table
"SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = 'ks' AND TABLE_NAME = 'route1'"
{
  "QueryType": "SELECT",
  "Original": "SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = 'ks' AND TABLE_NAME = 'route1'",
  "Instructions": {
    "OperatorType": "Route",
    "Variant": "SelectDBA",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "FieldQuery": "select * from INFORMATION_SCHEMA.`TABLES` where 1 != 1",
    "Query": "select * from INFORMATION_SCHEMA.`TABLES` where TABLE_SCHEMA = :__vtschemaname and TABLE_NAME = :TABLE_NAME",
    "SysTableTableName": "[TABLE_NAME:VARBINARY(\"route1\")]",
    "SysTableTableSchema": "[VARBINARY(\"ks\")]",
    "Table": "INFORMATION_SCHEMA.`TABLES`"
  }
}
Gen4 plan same as above

# information_schema query with additional predicates
"SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = 'ks' and other_column = 42"
{
  "QueryType": "SELECT",
  "Original": "SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = 'ks' and other_column = 42",
  "Instructions": {
    "OperatorType": "Route",
    "Variant": "SelectDBA",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "FieldQuery": "select * from INFORMATION_SCHEMA.`TABLES` where 1 != 1",
    "Query": "select * from INFORMATION_SCHEMA.`TABLES` where TABLE_SCHEMA = :__vtschemaname and other_column = 42",
    "SysTableTableSchema": "[VARBINARY(\"ks\")]",
    "Table": "INFORMATION_SCHEMA.`TABLES`"
  }
}
Gen4 plan same as above

# able to isolate table_schema value even when hidden inside of ORs
"SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE (TABLE_SCHEMA = 'ks' and other_column = 42) OR (TABLE_SCHEMA = 'ks' and foobar = 'value')"
{
  "QueryType": "SELECT",
  "Original": "SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE (TABLE_SCHEMA = 'ks' and other_column = 42) OR (TABLE_SCHEMA = 'ks' and foobar = 'value')",
  "Instructions": {
    "OperatorType": "Route",
    "Variant": "SelectDBA",
    "Keyspace": {
      "Name": "main",
      "Sharded": false
    },
    "FieldQuery": "select * from INFORMATION_SCHEMA.`TABLES` where 1 != 1",
    "Query": "select * from INFORMATION_SCHEMA.`TABLES` where TABLE_SCHEMA = :__vtschemaname and (other_column = 42 or TABLE_SCHEMA = 'ks') and (other_column = 42 or foobar = 'value')",
    "SysTableTableSchema": "[VARBINARY(\"ks\")]",
    "Table": "INFORMATION_SCHEMA.`TABLES`"
  }
}
Gen4 plan same as above
