// Code generated by protoc-gen-go. DO NOT EDIT.
// source: vtgateservice.proto

package vtgateservice // import "vitess.io/vitess/go/vt/proto/vtgateservice"

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import query "vitess.io/vitess/go/vt/proto/query"
import vtgate "vitess.io/vitess/go/vt/proto/vtgate"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// VitessClient is the client API for Vitess service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type VitessClient interface {
	// Execute tries to route the query to the right shard.
	// It depends on the query and bind variables to provide enough
	// information in conjonction with the vindexes to route the query.
	// API group: v3
	Execute(ctx context.Context, in *vtgate.ExecuteRequest, opts ...grpc.CallOption) (*vtgate.ExecuteResponse, error)
	// ExecuteBatch tries to route the list of queries on the right shards.
	// It depends on the query and bind variables to provide enough
	// information in conjonction with the vindexes to route the query.
	// API group: v3
	ExecuteBatch(ctx context.Context, in *vtgate.ExecuteBatchRequest, opts ...grpc.CallOption) (*vtgate.ExecuteBatchResponse, error)
	// StreamExecute executes a streaming query based on shards.
	// It depends on the query and bind variables to provide enough
	// information in conjonction with the vindexes to route the query.
	// Use this method if the query returns a large number of rows.
	// API group: v3
	StreamExecute(ctx context.Context, in *vtgate.StreamExecuteRequest, opts ...grpc.CallOption) (Vitess_StreamExecuteClient, error)
	// ExecuteShards executes the query on the specified shards.
	// API group: Custom Sharding
	ExecuteShards(ctx context.Context, in *vtgate.ExecuteShardsRequest, opts ...grpc.CallOption) (*vtgate.ExecuteShardsResponse, error)
	// ExecuteKeyspaceIds executes the query based on the specified keyspace ids.
	// API group: Range-based Sharding
	ExecuteKeyspaceIds(ctx context.Context, in *vtgate.ExecuteKeyspaceIdsRequest, opts ...grpc.CallOption) (*vtgate.ExecuteKeyspaceIdsResponse, error)
	// ExecuteKeyRanges executes the query based on the specified key ranges.
	// API group: Range-based Sharding
	ExecuteKeyRanges(ctx context.Context, in *vtgate.ExecuteKeyRangesRequest, opts ...grpc.CallOption) (*vtgate.ExecuteKeyRangesResponse, error)
	// ExecuteEntityIds executes the query based on the specified external id to keyspace id map.
	// API group: Range-based Sharding
	ExecuteEntityIds(ctx context.Context, in *vtgate.ExecuteEntityIdsRequest, opts ...grpc.CallOption) (*vtgate.ExecuteEntityIdsResponse, error)
	// ExecuteBatchShards executes the list of queries on the specified shards.
	// API group: Custom Sharding
	ExecuteBatchShards(ctx context.Context, in *vtgate.ExecuteBatchShardsRequest, opts ...grpc.CallOption) (*vtgate.ExecuteBatchShardsResponse, error)
	// ExecuteBatchKeyspaceIds executes the list of queries based on the specified keyspace ids.
	// API group: Range-based Sharding
	ExecuteBatchKeyspaceIds(ctx context.Context, in *vtgate.ExecuteBatchKeyspaceIdsRequest, opts ...grpc.CallOption) (*vtgate.ExecuteBatchKeyspaceIdsResponse, error)
	// StreamExecuteShards executes a streaming query based on shards.
	// Use this method if the query returns a large number of rows.
	// API group: Custom Sharding
	StreamExecuteShards(ctx context.Context, in *vtgate.StreamExecuteShardsRequest, opts ...grpc.CallOption) (Vitess_StreamExecuteShardsClient, error)
	// StreamExecuteKeyspaceIds executes a streaming query based on keyspace ids.
	// Use this method if the query returns a large number of rows.
	// API group: Range-based Sharding
	StreamExecuteKeyspaceIds(ctx context.Context, in *vtgate.StreamExecuteKeyspaceIdsRequest, opts ...grpc.CallOption) (Vitess_StreamExecuteKeyspaceIdsClient, error)
	// StreamExecuteKeyRanges executes a streaming query based on key ranges.
	// Use this method if the query returns a large number of rows.
	// API group: Range-based Sharding
	StreamExecuteKeyRanges(ctx context.Context, in *vtgate.StreamExecuteKeyRangesRequest, opts ...grpc.CallOption) (Vitess_StreamExecuteKeyRangesClient, error)
	// Begin a transaction.
	// API group: Transactions
	Begin(ctx context.Context, in *vtgate.BeginRequest, opts ...grpc.CallOption) (*vtgate.BeginResponse, error)
	// Commit a transaction.
	// API group: Transactions
	Commit(ctx context.Context, in *vtgate.CommitRequest, opts ...grpc.CallOption) (*vtgate.CommitResponse, error)
	// Rollback a transaction.
	// API group: Transactions
	Rollback(ctx context.Context, in *vtgate.RollbackRequest, opts ...grpc.CallOption) (*vtgate.RollbackResponse, error)
	// ResolveTransaction resolves a transaction.
	// API group: Transactions
	ResolveTransaction(ctx context.Context, in *vtgate.ResolveTransactionRequest, opts ...grpc.CallOption) (*vtgate.ResolveTransactionResponse, error)
	// MessageStream streams messages from a message table.
	MessageStream(ctx context.Context, in *vtgate.MessageStreamRequest, opts ...grpc.CallOption) (Vitess_MessageStreamClient, error)
	// MessageAck acks messages for a table.
	MessageAck(ctx context.Context, in *vtgate.MessageAckRequest, opts ...grpc.CallOption) (*query.MessageAckResponse, error)
	// MessageAckKeyspaceIds routes Message Acks using the associated
	// keyspace ids.
	MessageAckKeyspaceIds(ctx context.Context, in *vtgate.MessageAckKeyspaceIdsRequest, opts ...grpc.CallOption) (*query.MessageAckResponse, error)
	// Split a query into non-overlapping sub queries
	// API group: Map Reduce
	SplitQuery(ctx context.Context, in *vtgate.SplitQueryRequest, opts ...grpc.CallOption) (*vtgate.SplitQueryResponse, error)
	// GetSrvKeyspace returns a SrvKeyspace object (as seen by this vtgate).
	// This method is provided as a convenient way for clients to take a
	// look at the sharding configuration for a Keyspace. Looking at the
	// sharding information should not be used for routing queries (as the
	// information may change, use the Execute calls for that).
	// It is convenient for monitoring applications for instance, or if
	// using custom sharding.
	// API group: Topology
	GetSrvKeyspace(ctx context.Context, in *vtgate.GetSrvKeyspaceRequest, opts ...grpc.CallOption) (*vtgate.GetSrvKeyspaceResponse, error)
	// UpdateStream asks the server for a stream of StreamEvent objects.
	// API group: Update Stream
	UpdateStream(ctx context.Context, in *vtgate.UpdateStreamRequest, opts ...grpc.CallOption) (Vitess_UpdateStreamClient, error)
}

type vitessClient struct {
	cc *grpc.ClientConn
}

func NewVitessClient(cc *grpc.ClientConn) VitessClient {
	return &vitessClient{cc}
}

func (c *vitessClient) Execute(ctx context.Context, in *vtgate.ExecuteRequest, opts ...grpc.CallOption) (*vtgate.ExecuteResponse, error) {
	out := new(vtgate.ExecuteResponse)
	err := c.cc.Invoke(ctx, "/vtgateservice.Vitess/Execute", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vitessClient) ExecuteBatch(ctx context.Context, in *vtgate.ExecuteBatchRequest, opts ...grpc.CallOption) (*vtgate.ExecuteBatchResponse, error) {
	out := new(vtgate.ExecuteBatchResponse)
	err := c.cc.Invoke(ctx, "/vtgateservice.Vitess/ExecuteBatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vitessClient) StreamExecute(ctx context.Context, in *vtgate.StreamExecuteRequest, opts ...grpc.CallOption) (Vitess_StreamExecuteClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Vitess_serviceDesc.Streams[0], "/vtgateservice.Vitess/StreamExecute", opts...)
	if err != nil {
		return nil, err
	}
	x := &vitessStreamExecuteClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Vitess_StreamExecuteClient interface {
	Recv() (*vtgate.StreamExecuteResponse, error)
	grpc.ClientStream
}

type vitessStreamExecuteClient struct {
	grpc.ClientStream
}

func (x *vitessStreamExecuteClient) Recv() (*vtgate.StreamExecuteResponse, error) {
	m := new(vtgate.StreamExecuteResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *vitessClient) ExecuteShards(ctx context.Context, in *vtgate.ExecuteShardsRequest, opts ...grpc.CallOption) (*vtgate.ExecuteShardsResponse, error) {
	out := new(vtgate.ExecuteShardsResponse)
	err := c.cc.Invoke(ctx, "/vtgateservice.Vitess/ExecuteShards", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vitessClient) ExecuteKeyspaceIds(ctx context.Context, in *vtgate.ExecuteKeyspaceIdsRequest, opts ...grpc.CallOption) (*vtgate.ExecuteKeyspaceIdsResponse, error) {
	out := new(vtgate.ExecuteKeyspaceIdsResponse)
	err := c.cc.Invoke(ctx, "/vtgateservice.Vitess/ExecuteKeyspaceIds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vitessClient) ExecuteKeyRanges(ctx context.Context, in *vtgate.ExecuteKeyRangesRequest, opts ...grpc.CallOption) (*vtgate.ExecuteKeyRangesResponse, error) {
	out := new(vtgate.ExecuteKeyRangesResponse)
	err := c.cc.Invoke(ctx, "/vtgateservice.Vitess/ExecuteKeyRanges", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vitessClient) ExecuteEntityIds(ctx context.Context, in *vtgate.ExecuteEntityIdsRequest, opts ...grpc.CallOption) (*vtgate.ExecuteEntityIdsResponse, error) {
	out := new(vtgate.ExecuteEntityIdsResponse)
	err := c.cc.Invoke(ctx, "/vtgateservice.Vitess/ExecuteEntityIds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vitessClient) ExecuteBatchShards(ctx context.Context, in *vtgate.ExecuteBatchShardsRequest, opts ...grpc.CallOption) (*vtgate.ExecuteBatchShardsResponse, error) {
	out := new(vtgate.ExecuteBatchShardsResponse)
	err := c.cc.Invoke(ctx, "/vtgateservice.Vitess/ExecuteBatchShards", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vitessClient) ExecuteBatchKeyspaceIds(ctx context.Context, in *vtgate.ExecuteBatchKeyspaceIdsRequest, opts ...grpc.CallOption) (*vtgate.ExecuteBatchKeyspaceIdsResponse, error) {
	out := new(vtgate.ExecuteBatchKeyspaceIdsResponse)
	err := c.cc.Invoke(ctx, "/vtgateservice.Vitess/ExecuteBatchKeyspaceIds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vitessClient) StreamExecuteShards(ctx context.Context, in *vtgate.StreamExecuteShardsRequest, opts ...grpc.CallOption) (Vitess_StreamExecuteShardsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Vitess_serviceDesc.Streams[1], "/vtgateservice.Vitess/StreamExecuteShards", opts...)
	if err != nil {
		return nil, err
	}
	x := &vitessStreamExecuteShardsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Vitess_StreamExecuteShardsClient interface {
	Recv() (*vtgate.StreamExecuteShardsResponse, error)
	grpc.ClientStream
}

type vitessStreamExecuteShardsClient struct {
	grpc.ClientStream
}

func (x *vitessStreamExecuteShardsClient) Recv() (*vtgate.StreamExecuteShardsResponse, error) {
	m := new(vtgate.StreamExecuteShardsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *vitessClient) StreamExecuteKeyspaceIds(ctx context.Context, in *vtgate.StreamExecuteKeyspaceIdsRequest, opts ...grpc.CallOption) (Vitess_StreamExecuteKeyspaceIdsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Vitess_serviceDesc.Streams[2], "/vtgateservice.Vitess/StreamExecuteKeyspaceIds", opts...)
	if err != nil {
		return nil, err
	}
	x := &vitessStreamExecuteKeyspaceIdsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Vitess_StreamExecuteKeyspaceIdsClient interface {
	Recv() (*vtgate.StreamExecuteKeyspaceIdsResponse, error)
	grpc.ClientStream
}

type vitessStreamExecuteKeyspaceIdsClient struct {
	grpc.ClientStream
}

func (x *vitessStreamExecuteKeyspaceIdsClient) Recv() (*vtgate.StreamExecuteKeyspaceIdsResponse, error) {
	m := new(vtgate.StreamExecuteKeyspaceIdsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *vitessClient) StreamExecuteKeyRanges(ctx context.Context, in *vtgate.StreamExecuteKeyRangesRequest, opts ...grpc.CallOption) (Vitess_StreamExecuteKeyRangesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Vitess_serviceDesc.Streams[3], "/vtgateservice.Vitess/StreamExecuteKeyRanges", opts...)
	if err != nil {
		return nil, err
	}
	x := &vitessStreamExecuteKeyRangesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Vitess_StreamExecuteKeyRangesClient interface {
	Recv() (*vtgate.StreamExecuteKeyRangesResponse, error)
	grpc.ClientStream
}

type vitessStreamExecuteKeyRangesClient struct {
	grpc.ClientStream
}

func (x *vitessStreamExecuteKeyRangesClient) Recv() (*vtgate.StreamExecuteKeyRangesResponse, error) {
	m := new(vtgate.StreamExecuteKeyRangesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *vitessClient) Begin(ctx context.Context, in *vtgate.BeginRequest, opts ...grpc.CallOption) (*vtgate.BeginResponse, error) {
	out := new(vtgate.BeginResponse)
	err := c.cc.Invoke(ctx, "/vtgateservice.Vitess/Begin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vitessClient) Commit(ctx context.Context, in *vtgate.CommitRequest, opts ...grpc.CallOption) (*vtgate.CommitResponse, error) {
	out := new(vtgate.CommitResponse)
	err := c.cc.Invoke(ctx, "/vtgateservice.Vitess/Commit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vitessClient) Rollback(ctx context.Context, in *vtgate.RollbackRequest, opts ...grpc.CallOption) (*vtgate.RollbackResponse, error) {
	out := new(vtgate.RollbackResponse)
	err := c.cc.Invoke(ctx, "/vtgateservice.Vitess/Rollback", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vitessClient) ResolveTransaction(ctx context.Context, in *vtgate.ResolveTransactionRequest, opts ...grpc.CallOption) (*vtgate.ResolveTransactionResponse, error) {
	out := new(vtgate.ResolveTransactionResponse)
	err := c.cc.Invoke(ctx, "/vtgateservice.Vitess/ResolveTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vitessClient) MessageStream(ctx context.Context, in *vtgate.MessageStreamRequest, opts ...grpc.CallOption) (Vitess_MessageStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Vitess_serviceDesc.Streams[4], "/vtgateservice.Vitess/MessageStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &vitessMessageStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Vitess_MessageStreamClient interface {
	Recv() (*query.MessageStreamResponse, error)
	grpc.ClientStream
}

type vitessMessageStreamClient struct {
	grpc.ClientStream
}

func (x *vitessMessageStreamClient) Recv() (*query.MessageStreamResponse, error) {
	m := new(query.MessageStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *vitessClient) MessageAck(ctx context.Context, in *vtgate.MessageAckRequest, opts ...grpc.CallOption) (*query.MessageAckResponse, error) {
	out := new(query.MessageAckResponse)
	err := c.cc.Invoke(ctx, "/vtgateservice.Vitess/MessageAck", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vitessClient) MessageAckKeyspaceIds(ctx context.Context, in *vtgate.MessageAckKeyspaceIdsRequest, opts ...grpc.CallOption) (*query.MessageAckResponse, error) {
	out := new(query.MessageAckResponse)
	err := c.cc.Invoke(ctx, "/vtgateservice.Vitess/MessageAckKeyspaceIds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vitessClient) SplitQuery(ctx context.Context, in *vtgate.SplitQueryRequest, opts ...grpc.CallOption) (*vtgate.SplitQueryResponse, error) {
	out := new(vtgate.SplitQueryResponse)
	err := c.cc.Invoke(ctx, "/vtgateservice.Vitess/SplitQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vitessClient) GetSrvKeyspace(ctx context.Context, in *vtgate.GetSrvKeyspaceRequest, opts ...grpc.CallOption) (*vtgate.GetSrvKeyspaceResponse, error) {
	out := new(vtgate.GetSrvKeyspaceResponse)
	err := c.cc.Invoke(ctx, "/vtgateservice.Vitess/GetSrvKeyspace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vitessClient) UpdateStream(ctx context.Context, in *vtgate.UpdateStreamRequest, opts ...grpc.CallOption) (Vitess_UpdateStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Vitess_serviceDesc.Streams[5], "/vtgateservice.Vitess/UpdateStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &vitessUpdateStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Vitess_UpdateStreamClient interface {
	Recv() (*vtgate.UpdateStreamResponse, error)
	grpc.ClientStream
}

type vitessUpdateStreamClient struct {
	grpc.ClientStream
}

func (x *vitessUpdateStreamClient) Recv() (*vtgate.UpdateStreamResponse, error) {
	m := new(vtgate.UpdateStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// VitessServer is the server API for Vitess service.
type VitessServer interface {
	// Execute tries to route the query to the right shard.
	// It depends on the query and bind variables to provide enough
	// information in conjonction with the vindexes to route the query.
	// API group: v3
	Execute(context.Context, *vtgate.ExecuteRequest) (*vtgate.ExecuteResponse, error)
	// ExecuteBatch tries to route the list of queries on the right shards.
	// It depends on the query and bind variables to provide enough
	// information in conjonction with the vindexes to route the query.
	// API group: v3
	ExecuteBatch(context.Context, *vtgate.ExecuteBatchRequest) (*vtgate.ExecuteBatchResponse, error)
	// StreamExecute executes a streaming query based on shards.
	// It depends on the query and bind variables to provide enough
	// information in conjonction with the vindexes to route the query.
	// Use this method if the query returns a large number of rows.
	// API group: v3
	StreamExecute(*vtgate.StreamExecuteRequest, Vitess_StreamExecuteServer) error
	// ExecuteShards executes the query on the specified shards.
	// API group: Custom Sharding
	ExecuteShards(context.Context, *vtgate.ExecuteShardsRequest) (*vtgate.ExecuteShardsResponse, error)
	// ExecuteKeyspaceIds executes the query based on the specified keyspace ids.
	// API group: Range-based Sharding
	ExecuteKeyspaceIds(context.Context, *vtgate.ExecuteKeyspaceIdsRequest) (*vtgate.ExecuteKeyspaceIdsResponse, error)
	// ExecuteKeyRanges executes the query based on the specified key ranges.
	// API group: Range-based Sharding
	ExecuteKeyRanges(context.Context, *vtgate.ExecuteKeyRangesRequest) (*vtgate.ExecuteKeyRangesResponse, error)
	// ExecuteEntityIds executes the query based on the specified external id to keyspace id map.
	// API group: Range-based Sharding
	ExecuteEntityIds(context.Context, *vtgate.ExecuteEntityIdsRequest) (*vtgate.ExecuteEntityIdsResponse, error)
	// ExecuteBatchShards executes the list of queries on the specified shards.
	// API group: Custom Sharding
	ExecuteBatchShards(context.Context, *vtgate.ExecuteBatchShardsRequest) (*vtgate.ExecuteBatchShardsResponse, error)
	// ExecuteBatchKeyspaceIds executes the list of queries based on the specified keyspace ids.
	// API group: Range-based Sharding
	ExecuteBatchKeyspaceIds(context.Context, *vtgate.ExecuteBatchKeyspaceIdsRequest) (*vtgate.ExecuteBatchKeyspaceIdsResponse, error)
	// StreamExecuteShards executes a streaming query based on shards.
	// Use this method if the query returns a large number of rows.
	// API group: Custom Sharding
	StreamExecuteShards(*vtgate.StreamExecuteShardsRequest, Vitess_StreamExecuteShardsServer) error
	// StreamExecuteKeyspaceIds executes a streaming query based on keyspace ids.
	// Use this method if the query returns a large number of rows.
	// API group: Range-based Sharding
	StreamExecuteKeyspaceIds(*vtgate.StreamExecuteKeyspaceIdsRequest, Vitess_StreamExecuteKeyspaceIdsServer) error
	// StreamExecuteKeyRanges executes a streaming query based on key ranges.
	// Use this method if the query returns a large number of rows.
	// API group: Range-based Sharding
	StreamExecuteKeyRanges(*vtgate.StreamExecuteKeyRangesRequest, Vitess_StreamExecuteKeyRangesServer) error
	// Begin a transaction.
	// API group: Transactions
	Begin(context.Context, *vtgate.BeginRequest) (*vtgate.BeginResponse, error)
	// Commit a transaction.
	// API group: Transactions
	Commit(context.Context, *vtgate.CommitRequest) (*vtgate.CommitResponse, error)
	// Rollback a transaction.
	// API group: Transactions
	Rollback(context.Context, *vtgate.RollbackRequest) (*vtgate.RollbackResponse, error)
	// ResolveTransaction resolves a transaction.
	// API group: Transactions
	ResolveTransaction(context.Context, *vtgate.ResolveTransactionRequest) (*vtgate.ResolveTransactionResponse, error)
	// MessageStream streams messages from a message table.
	MessageStream(*vtgate.MessageStreamRequest, Vitess_MessageStreamServer) error
	// MessageAck acks messages for a table.
	MessageAck(context.Context, *vtgate.MessageAckRequest) (*query.MessageAckResponse, error)
	// MessageAckKeyspaceIds routes Message Acks using the associated
	// keyspace ids.
	MessageAckKeyspaceIds(context.Context, *vtgate.MessageAckKeyspaceIdsRequest) (*query.MessageAckResponse, error)
	// Split a query into non-overlapping sub queries
	// API group: Map Reduce
	SplitQuery(context.Context, *vtgate.SplitQueryRequest) (*vtgate.SplitQueryResponse, error)
	// GetSrvKeyspace returns a SrvKeyspace object (as seen by this vtgate).
	// This method is provided as a convenient way for clients to take a
	// look at the sharding configuration for a Keyspace. Looking at the
	// sharding information should not be used for routing queries (as the
	// information may change, use the Execute calls for that).
	// It is convenient for monitoring applications for instance, or if
	// using custom sharding.
	// API group: Topology
	GetSrvKeyspace(context.Context, *vtgate.GetSrvKeyspaceRequest) (*vtgate.GetSrvKeyspaceResponse, error)
	// UpdateStream asks the server for a stream of StreamEvent objects.
	// API group: Update Stream
	UpdateStream(*vtgate.UpdateStreamRequest, Vitess_UpdateStreamServer) error
}

func RegisterVitessServer(s *grpc.Server, srv VitessServer) {
	s.RegisterService(&_Vitess_serviceDesc, srv)
}

func _Vitess_Execute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtgate.ExecuteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VitessServer).Execute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtgateservice.Vitess/Execute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VitessServer).Execute(ctx, req.(*vtgate.ExecuteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vitess_ExecuteBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtgate.ExecuteBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VitessServer).ExecuteBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtgateservice.Vitess/ExecuteBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VitessServer).ExecuteBatch(ctx, req.(*vtgate.ExecuteBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vitess_StreamExecute_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(vtgate.StreamExecuteRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VitessServer).StreamExecute(m, &vitessStreamExecuteServer{stream})
}

type Vitess_StreamExecuteServer interface {
	Send(*vtgate.StreamExecuteResponse) error
	grpc.ServerStream
}

type vitessStreamExecuteServer struct {
	grpc.ServerStream
}

func (x *vitessStreamExecuteServer) Send(m *vtgate.StreamExecuteResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Vitess_ExecuteShards_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtgate.ExecuteShardsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VitessServer).ExecuteShards(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtgateservice.Vitess/ExecuteShards",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VitessServer).ExecuteShards(ctx, req.(*vtgate.ExecuteShardsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vitess_ExecuteKeyspaceIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtgate.ExecuteKeyspaceIdsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VitessServer).ExecuteKeyspaceIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtgateservice.Vitess/ExecuteKeyspaceIds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VitessServer).ExecuteKeyspaceIds(ctx, req.(*vtgate.ExecuteKeyspaceIdsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vitess_ExecuteKeyRanges_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtgate.ExecuteKeyRangesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VitessServer).ExecuteKeyRanges(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtgateservice.Vitess/ExecuteKeyRanges",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VitessServer).ExecuteKeyRanges(ctx, req.(*vtgate.ExecuteKeyRangesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vitess_ExecuteEntityIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtgate.ExecuteEntityIdsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VitessServer).ExecuteEntityIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtgateservice.Vitess/ExecuteEntityIds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VitessServer).ExecuteEntityIds(ctx, req.(*vtgate.ExecuteEntityIdsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vitess_ExecuteBatchShards_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtgate.ExecuteBatchShardsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VitessServer).ExecuteBatchShards(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtgateservice.Vitess/ExecuteBatchShards",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VitessServer).ExecuteBatchShards(ctx, req.(*vtgate.ExecuteBatchShardsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vitess_ExecuteBatchKeyspaceIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtgate.ExecuteBatchKeyspaceIdsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VitessServer).ExecuteBatchKeyspaceIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtgateservice.Vitess/ExecuteBatchKeyspaceIds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VitessServer).ExecuteBatchKeyspaceIds(ctx, req.(*vtgate.ExecuteBatchKeyspaceIdsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vitess_StreamExecuteShards_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(vtgate.StreamExecuteShardsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VitessServer).StreamExecuteShards(m, &vitessStreamExecuteShardsServer{stream})
}

type Vitess_StreamExecuteShardsServer interface {
	Send(*vtgate.StreamExecuteShardsResponse) error
	grpc.ServerStream
}

type vitessStreamExecuteShardsServer struct {
	grpc.ServerStream
}

func (x *vitessStreamExecuteShardsServer) Send(m *vtgate.StreamExecuteShardsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Vitess_StreamExecuteKeyspaceIds_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(vtgate.StreamExecuteKeyspaceIdsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VitessServer).StreamExecuteKeyspaceIds(m, &vitessStreamExecuteKeyspaceIdsServer{stream})
}

type Vitess_StreamExecuteKeyspaceIdsServer interface {
	Send(*vtgate.StreamExecuteKeyspaceIdsResponse) error
	grpc.ServerStream
}

type vitessStreamExecuteKeyspaceIdsServer struct {
	grpc.ServerStream
}

func (x *vitessStreamExecuteKeyspaceIdsServer) Send(m *vtgate.StreamExecuteKeyspaceIdsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Vitess_StreamExecuteKeyRanges_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(vtgate.StreamExecuteKeyRangesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VitessServer).StreamExecuteKeyRanges(m, &vitessStreamExecuteKeyRangesServer{stream})
}

type Vitess_StreamExecuteKeyRangesServer interface {
	Send(*vtgate.StreamExecuteKeyRangesResponse) error
	grpc.ServerStream
}

type vitessStreamExecuteKeyRangesServer struct {
	grpc.ServerStream
}

func (x *vitessStreamExecuteKeyRangesServer) Send(m *vtgate.StreamExecuteKeyRangesResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Vitess_Begin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtgate.BeginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VitessServer).Begin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtgateservice.Vitess/Begin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VitessServer).Begin(ctx, req.(*vtgate.BeginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vitess_Commit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtgate.CommitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VitessServer).Commit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtgateservice.Vitess/Commit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VitessServer).Commit(ctx, req.(*vtgate.CommitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vitess_Rollback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtgate.RollbackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VitessServer).Rollback(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtgateservice.Vitess/Rollback",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VitessServer).Rollback(ctx, req.(*vtgate.RollbackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vitess_ResolveTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtgate.ResolveTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VitessServer).ResolveTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtgateservice.Vitess/ResolveTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VitessServer).ResolveTransaction(ctx, req.(*vtgate.ResolveTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vitess_MessageStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(vtgate.MessageStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VitessServer).MessageStream(m, &vitessMessageStreamServer{stream})
}

type Vitess_MessageStreamServer interface {
	Send(*query.MessageStreamResponse) error
	grpc.ServerStream
}

type vitessMessageStreamServer struct {
	grpc.ServerStream
}

func (x *vitessMessageStreamServer) Send(m *query.MessageStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Vitess_MessageAck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtgate.MessageAckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VitessServer).MessageAck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtgateservice.Vitess/MessageAck",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VitessServer).MessageAck(ctx, req.(*vtgate.MessageAckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vitess_MessageAckKeyspaceIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtgate.MessageAckKeyspaceIdsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VitessServer).MessageAckKeyspaceIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtgateservice.Vitess/MessageAckKeyspaceIds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VitessServer).MessageAckKeyspaceIds(ctx, req.(*vtgate.MessageAckKeyspaceIdsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vitess_SplitQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtgate.SplitQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VitessServer).SplitQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtgateservice.Vitess/SplitQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VitessServer).SplitQuery(ctx, req.(*vtgate.SplitQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vitess_GetSrvKeyspace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtgate.GetSrvKeyspaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VitessServer).GetSrvKeyspace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtgateservice.Vitess/GetSrvKeyspace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VitessServer).GetSrvKeyspace(ctx, req.(*vtgate.GetSrvKeyspaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vitess_UpdateStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(vtgate.UpdateStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VitessServer).UpdateStream(m, &vitessUpdateStreamServer{stream})
}

type Vitess_UpdateStreamServer interface {
	Send(*vtgate.UpdateStreamResponse) error
	grpc.ServerStream
}

type vitessUpdateStreamServer struct {
	grpc.ServerStream
}

func (x *vitessUpdateStreamServer) Send(m *vtgate.UpdateStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _Vitess_serviceDesc = grpc.ServiceDesc{
	ServiceName: "vtgateservice.Vitess",
	HandlerType: (*VitessServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Execute",
			Handler:    _Vitess_Execute_Handler,
		},
		{
			MethodName: "ExecuteBatch",
			Handler:    _Vitess_ExecuteBatch_Handler,
		},
		{
			MethodName: "ExecuteShards",
			Handler:    _Vitess_ExecuteShards_Handler,
		},
		{
			MethodName: "ExecuteKeyspaceIds",
			Handler:    _Vitess_ExecuteKeyspaceIds_Handler,
		},
		{
			MethodName: "ExecuteKeyRanges",
			Handler:    _Vitess_ExecuteKeyRanges_Handler,
		},
		{
			MethodName: "ExecuteEntityIds",
			Handler:    _Vitess_ExecuteEntityIds_Handler,
		},
		{
			MethodName: "ExecuteBatchShards",
			Handler:    _Vitess_ExecuteBatchShards_Handler,
		},
		{
			MethodName: "ExecuteBatchKeyspaceIds",
			Handler:    _Vitess_ExecuteBatchKeyspaceIds_Handler,
		},
		{
			MethodName: "Begin",
			Handler:    _Vitess_Begin_Handler,
		},
		{
			MethodName: "Commit",
			Handler:    _Vitess_Commit_Handler,
		},
		{
			MethodName: "Rollback",
			Handler:    _Vitess_Rollback_Handler,
		},
		{
			MethodName: "ResolveTransaction",
			Handler:    _Vitess_ResolveTransaction_Handler,
		},
		{
			MethodName: "MessageAck",
			Handler:    _Vitess_MessageAck_Handler,
		},
		{
			MethodName: "MessageAckKeyspaceIds",
			Handler:    _Vitess_MessageAckKeyspaceIds_Handler,
		},
		{
			MethodName: "SplitQuery",
			Handler:    _Vitess_SplitQuery_Handler,
		},
		{
			MethodName: "GetSrvKeyspace",
			Handler:    _Vitess_GetSrvKeyspace_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamExecute",
			Handler:       _Vitess_StreamExecute_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamExecuteShards",
			Handler:       _Vitess_StreamExecuteShards_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamExecuteKeyspaceIds",
			Handler:       _Vitess_StreamExecuteKeyspaceIds_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamExecuteKeyRanges",
			Handler:       _Vitess_StreamExecuteKeyRanges_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "MessageStream",
			Handler:       _Vitess_MessageStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "UpdateStream",
			Handler:       _Vitess_UpdateStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "vtgateservice.proto",
}

func init() { proto.RegisterFile("vtgateservice.proto", fileDescriptor_vtgateservice_6694e3d05903167c) }

var fileDescriptor_vtgateservice_6694e3d05903167c = []byte{
	// 579 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x95, 0xdb, 0x6f, 0xd3, 0x30,
	0x14, 0xc6, 0xe1, 0x81, 0x82, 0x0e, 0xed, 0x84, 0xbc, 0xad, 0xdb, 0xca, 0x75, 0x05, 0x36, 0xc4,
	0x43, 0x8b, 0x40, 0x42, 0x42, 0x42, 0x42, 0x2d, 0x54, 0x08, 0x4d, 0x03, 0xd6, 0x72, 0x91, 0x26,
	0xf1, 0xe0, 0xa6, 0x47, 0x59, 0xd4, 0x36, 0x49, 0x63, 0x37, 0xa2, 0xff, 0x20, 0x7f, 0x17, 0x5a,
	0x7c, 0x89, 0xed, 0xb8, 0xed, 0x5b, 0xf2, 0x7d, 0xdf, 0xf9, 0xc5, 0x3e, 0x39, 0xb2, 0x61, 0x37,
	0xe7, 0x21, 0xe5, 0xc8, 0x30, 0xcb, 0xa3, 0x00, 0x3b, 0x69, 0x96, 0xf0, 0x84, 0x34, 0x2c, 0xb1,
	0x55, 0x17, 0xaf, 0xc2, 0x6c, 0xdd, 0x5d, 0x2c, 0x31, 0x5b, 0x89, 0x97, 0xd7, 0xff, 0x76, 0xa0,
	0xf6, 0x2b, 0xe2, 0xc8, 0x18, 0x79, 0x0f, 0xb7, 0x07, 0x7f, 0x31, 0x58, 0x72, 0x24, 0xcd, 0x8e,
	0xac, 0x90, 0xc2, 0x10, 0x17, 0x4b, 0x64, 0xbc, 0x75, 0x50, 0xd1, 0x59, 0x9a, 0xc4, 0x0c, 0xdb,
	0x37, 0xc8, 0x19, 0xd4, 0xa5, 0xd8, 0xa7, 0x3c, 0xb8, 0x22, 0xf7, 0x9d, 0x68, 0xa1, 0x2a, 0xce,
	0x03, 0xbf, 0xa9, 0x61, 0xdf, 0xa1, 0x31, 0xe2, 0x19, 0xd2, 0xb9, 0x5a, 0x90, 0x2e, 0xb0, 0x64,
	0x85, 0x7b, 0xb8, 0xc6, 0x55, 0xbc, 0x57, 0x37, 0xc9, 0x57, 0x68, 0x48, 0x79, 0x74, 0x45, 0xb3,
	0x09, 0x23, 0xee, 0x12, 0x84, 0x5c, 0x21, 0x3a, 0xae, 0x5e, 0xe1, 0x1f, 0x20, 0xd2, 0x3a, 0xc3,
	0x15, 0x4b, 0x69, 0x80, 0x5f, 0x26, 0x8c, 0x1c, 0x3b, 0x65, 0x86, 0xa7, 0xc8, 0xed, 0x4d, 0x11,
	0x8d, 0xff, 0x0d, 0xf7, 0x4a, 0x7f, 0x48, 0xe3, 0x10, 0x19, 0x79, 0x5c, 0xad, 0x14, 0x8e, 0x42,
	0x3f, 0x59, 0x1f, 0xf0, 0x80, 0x07, 0x31, 0x8f, 0xf8, 0xea, 0x7a, 0xd5, 0x2e, 0x58, 0x3b, 0xeb,
	0xc0, 0x46, 0xc0, 0xd3, 0x90, 0xe2, 0x67, 0xca, 0x2e, 0x1f, 0xfb, 0x7e, 0xb4, 0xdd, 0xea, 0xf6,
	0xa6, 0x88, 0xc6, 0xcf, 0xe0, 0xc0, 0xf4, 0xcd, 0xa6, 0x9f, 0xf8, 0x00, 0x9e, 0xce, 0x9f, 0x6e,
	0xcd, 0xe9, 0xaf, 0x8d, 0x61, 0xd7, 0x1a, 0x25, 0xb9, 0x9b, 0xb6, 0x77, 0xce, 0xec, 0xed, 0x3c,
	0xdd, 0x98, 0x31, 0x26, 0x72, 0x01, 0x87, 0x56, 0xc4, 0xdc, 0xd2, 0xa9, 0x17, 0xe2, 0xd9, 0xd3,
	0x8b, 0xed, 0x41, 0xe3, 0x93, 0x53, 0x68, 0xba, 0x39, 0x39, 0x5b, 0xcf, 0xd7, 0x71, 0xec, 0x09,
	0x3b, 0xd9, 0x16, 0x33, 0x3e, 0xf6, 0x16, 0x6e, 0xf5, 0x31, 0x8c, 0x62, 0xb2, 0xa7, 0x8a, 0x8a,
	0x57, 0x85, 0xda, 0x77, 0x54, 0xdd, 0xfb, 0x77, 0x50, 0xfb, 0x98, 0xcc, 0xe7, 0x11, 0x27, 0x3a,
	0x22, 0xde, 0x55, 0x65, 0xd3, 0x95, 0x75, 0xe9, 0x07, 0xb8, 0x33, 0x4c, 0x66, 0xb3, 0x31, 0x0d,
	0xa6, 0x44, 0x1f, 0x55, 0x4a, 0x51, 0xe5, 0x87, 0x55, 0xc3, 0x1c, 0xe2, 0x21, 0xb2, 0x64, 0x96,
	0xe3, 0x8f, 0x8c, 0xc6, 0x8c, 0x06, 0x3c, 0x4a, 0xe2, 0x72, 0x88, 0xab, 0x5e, 0x65, 0x88, 0x7d,
	0x11, 0x8d, 0xff, 0x06, 0x8d, 0x73, 0x64, 0x8c, 0x86, 0x28, 0xfa, 0x57, 0x1e, 0x42, 0x96, 0x5c,
	0x9e, 0x92, 0xe2, 0xa4, 0x76, 0x4c, 0xa3, 0xc7, 0x9f, 0x00, 0xa4, 0xd9, 0x0b, 0xa6, 0xe4, 0xc8,
	0xa1, 0xf5, 0xca, 0x4d, 0x1f, 0xd9, 0xa8, 0x9e, 0xb5, 0xeb, 0x4b, 0xd8, 0x2f, 0x75, 0x73, 0x0c,
	0x9f, 0x55, 0x81, 0x9e, 0x19, 0xdc, 0xc8, 0x1e, 0x00, 0x8c, 0xd2, 0x59, 0xc4, 0x2f, 0xae, 0x23,
	0xe5, 0x0a, 0x4b, 0x4d, 0x51, 0x5a, 0x3e, 0x4b, 0x63, 0x2e, 0x60, 0xe7, 0x33, 0xf2, 0x51, 0x96,
	0xab, 0xef, 0x13, 0x7d, 0x42, 0xdb, 0xba, 0xc2, 0x3d, 0x5a, 0x67, 0x6b, 0xe4, 0x39, 0xd4, 0x7f,
	0xa6, 0x13, 0xca, 0xd5, 0xbf, 0xd0, 0x17, 0x96, 0xa9, 0x56, 0x2e, 0x2c, 0xdb, 0x2c, 0x7f, 0x45,
	0xbf, 0x0f, 0x7b, 0x51, 0xd2, 0xc9, 0x8b, 0xab, 0x54, 0xdc, 0xad, 0x9d, 0x30, 0x4b, 0x83, 0xcb,
	0x97, 0x52, 0x8a, 0x92, 0xae, 0x78, 0xea, 0x86, 0x49, 0x37, 0xe7, 0xdd, 0x22, 0xd2, 0xb5, 0xee,
	0xe9, 0x71, 0xad, 0x10, 0xdf, 0xfc, 0x0f, 0x00, 0x00, 0xff, 0xff, 0x38, 0xcc, 0x87, 0x4b, 0xd4,
	0x07, 0x00, 0x00,
}
