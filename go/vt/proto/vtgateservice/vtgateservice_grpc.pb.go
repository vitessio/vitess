// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package vtgateservice

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	vtgate "vitess.io/vitess/go/vt/proto/vtgate"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// VitessClient is the client API for Vitess service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VitessClient interface {
	// Execute tries to route the query to the right shard.
	// It depends on the query and bind variables to provide enough
	// information in conjunction with the vindexes to route the query.
	// API group: v3
	Execute(ctx context.Context, in *vtgate.ExecuteRequest, opts ...grpc.CallOption) (*vtgate.ExecuteResponse, error)
	// ExecuteBatch tries to route the list of queries on the right shards.
	// It depends on the query and bind variables to provide enough
	// information in conjunction with the vindexes to route the query.
	// API group: v3
	ExecuteBatch(ctx context.Context, in *vtgate.ExecuteBatchRequest, opts ...grpc.CallOption) (*vtgate.ExecuteBatchResponse, error)
	// StreamExecute executes a streaming query based on shards.
	// It depends on the query and bind variables to provide enough
	// information in conjunction with the vindexes to route the query.
	// Use this method if the query returns a large number of rows.
	// API group: v3
	StreamExecute(ctx context.Context, in *vtgate.StreamExecuteRequest, opts ...grpc.CallOption) (Vitess_StreamExecuteClient, error)
	// ResolveTransaction resolves a transaction.
	// API group: Transactions
	ResolveTransaction(ctx context.Context, in *vtgate.ResolveTransactionRequest, opts ...grpc.CallOption) (*vtgate.ResolveTransactionResponse, error)
	// VStream streams binlog events from the requested sources.
	VStream(ctx context.Context, in *vtgate.VStreamRequest, opts ...grpc.CallOption) (Vitess_VStreamClient, error)
	// Prepare is used by the MySQL server plugin as part of supporting prepared statements.
	Prepare(ctx context.Context, in *vtgate.PrepareRequest, opts ...grpc.CallOption) (*vtgate.PrepareResponse, error)
	// CloseSession closes the session, rolling back any implicit transactions.
	// This has the same effect as if a "rollback" statement was executed,
	// but does not affect the query statistics.
	CloseSession(ctx context.Context, in *vtgate.CloseSessionRequest, opts ...grpc.CallOption) (*vtgate.CloseSessionResponse, error)
}

type vitessClient struct {
	cc grpc.ClientConnInterface
}

func NewVitessClient(cc grpc.ClientConnInterface) VitessClient {
	return &vitessClient{cc}
}

func (c *vitessClient) Execute(ctx context.Context, in *vtgate.ExecuteRequest, opts ...grpc.CallOption) (*vtgate.ExecuteResponse, error) {
	out := new(vtgate.ExecuteResponse)
	err := c.cc.Invoke(ctx, "/vtgateservice.Vitess/Execute", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vitessClient) ExecuteBatch(ctx context.Context, in *vtgate.ExecuteBatchRequest, opts ...grpc.CallOption) (*vtgate.ExecuteBatchResponse, error) {
	out := new(vtgate.ExecuteBatchResponse)
	err := c.cc.Invoke(ctx, "/vtgateservice.Vitess/ExecuteBatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vitessClient) StreamExecute(ctx context.Context, in *vtgate.StreamExecuteRequest, opts ...grpc.CallOption) (Vitess_StreamExecuteClient, error) {
	stream, err := c.cc.NewStream(ctx, &Vitess_ServiceDesc.Streams[0], "/vtgateservice.Vitess/StreamExecute", opts...)
	if err != nil {
		return nil, err
	}
	x := &vitessStreamExecuteClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Vitess_StreamExecuteClient interface {
	Recv() (*vtgate.StreamExecuteResponse, error)
	grpc.ClientStream
}

type vitessStreamExecuteClient struct {
	grpc.ClientStream
}

func (x *vitessStreamExecuteClient) Recv() (*vtgate.StreamExecuteResponse, error) {
	m := new(vtgate.StreamExecuteResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *vitessClient) ResolveTransaction(ctx context.Context, in *vtgate.ResolveTransactionRequest, opts ...grpc.CallOption) (*vtgate.ResolveTransactionResponse, error) {
	out := new(vtgate.ResolveTransactionResponse)
	err := c.cc.Invoke(ctx, "/vtgateservice.Vitess/ResolveTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vitessClient) VStream(ctx context.Context, in *vtgate.VStreamRequest, opts ...grpc.CallOption) (Vitess_VStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &Vitess_ServiceDesc.Streams[1], "/vtgateservice.Vitess/VStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &vitessVStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Vitess_VStreamClient interface {
	Recv() (*vtgate.VStreamResponse, error)
	grpc.ClientStream
}

type vitessVStreamClient struct {
	grpc.ClientStream
}

func (x *vitessVStreamClient) Recv() (*vtgate.VStreamResponse, error) {
	m := new(vtgate.VStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *vitessClient) Prepare(ctx context.Context, in *vtgate.PrepareRequest, opts ...grpc.CallOption) (*vtgate.PrepareResponse, error) {
	out := new(vtgate.PrepareResponse)
	err := c.cc.Invoke(ctx, "/vtgateservice.Vitess/Prepare", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vitessClient) CloseSession(ctx context.Context, in *vtgate.CloseSessionRequest, opts ...grpc.CallOption) (*vtgate.CloseSessionResponse, error) {
	out := new(vtgate.CloseSessionResponse)
	err := c.cc.Invoke(ctx, "/vtgateservice.Vitess/CloseSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VitessServer is the server API for Vitess service.
// All implementations must embed UnimplementedVitessServer
// for forward compatibility
type VitessServer interface {
	// Execute tries to route the query to the right shard.
	// It depends on the query and bind variables to provide enough
	// information in conjunction with the vindexes to route the query.
	// API group: v3
	Execute(context.Context, *vtgate.ExecuteRequest) (*vtgate.ExecuteResponse, error)
	// ExecuteBatch tries to route the list of queries on the right shards.
	// It depends on the query and bind variables to provide enough
	// information in conjunction with the vindexes to route the query.
	// API group: v3
	ExecuteBatch(context.Context, *vtgate.ExecuteBatchRequest) (*vtgate.ExecuteBatchResponse, error)
	// StreamExecute executes a streaming query based on shards.
	// It depends on the query and bind variables to provide enough
	// information in conjunction with the vindexes to route the query.
	// Use this method if the query returns a large number of rows.
	// API group: v3
	StreamExecute(*vtgate.StreamExecuteRequest, Vitess_StreamExecuteServer) error
	// ResolveTransaction resolves a transaction.
	// API group: Transactions
	ResolveTransaction(context.Context, *vtgate.ResolveTransactionRequest) (*vtgate.ResolveTransactionResponse, error)
	// VStream streams binlog events from the requested sources.
	VStream(*vtgate.VStreamRequest, Vitess_VStreamServer) error
	// Prepare is used by the MySQL server plugin as part of supporting prepared statements.
	Prepare(context.Context, *vtgate.PrepareRequest) (*vtgate.PrepareResponse, error)
	// CloseSession closes the session, rolling back any implicit transactions.
	// This has the same effect as if a "rollback" statement was executed,
	// but does not affect the query statistics.
	CloseSession(context.Context, *vtgate.CloseSessionRequest) (*vtgate.CloseSessionResponse, error)
	mustEmbedUnimplementedVitessServer()
}

// UnimplementedVitessServer must be embedded to have forward compatible implementations.
type UnimplementedVitessServer struct {
}

func (UnimplementedVitessServer) Execute(context.Context, *vtgate.ExecuteRequest) (*vtgate.ExecuteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Execute not implemented")
}
func (UnimplementedVitessServer) ExecuteBatch(context.Context, *vtgate.ExecuteBatchRequest) (*vtgate.ExecuteBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteBatch not implemented")
}
func (UnimplementedVitessServer) StreamExecute(*vtgate.StreamExecuteRequest, Vitess_StreamExecuteServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamExecute not implemented")
}
func (UnimplementedVitessServer) ResolveTransaction(context.Context, *vtgate.ResolveTransactionRequest) (*vtgate.ResolveTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResolveTransaction not implemented")
}
func (UnimplementedVitessServer) VStream(*vtgate.VStreamRequest, Vitess_VStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method VStream not implemented")
}
func (UnimplementedVitessServer) Prepare(context.Context, *vtgate.PrepareRequest) (*vtgate.PrepareResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Prepare not implemented")
}
func (UnimplementedVitessServer) CloseSession(context.Context, *vtgate.CloseSessionRequest) (*vtgate.CloseSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseSession not implemented")
}
func (UnimplementedVitessServer) mustEmbedUnimplementedVitessServer() {}

// UnsafeVitessServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VitessServer will
// result in compilation errors.
type UnsafeVitessServer interface {
	mustEmbedUnimplementedVitessServer()
}

func RegisterVitessServer(s grpc.ServiceRegistrar, srv VitessServer) {
	s.RegisterService(&Vitess_ServiceDesc, srv)
}

func _Vitess_Execute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtgate.ExecuteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VitessServer).Execute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtgateservice.Vitess/Execute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VitessServer).Execute(ctx, req.(*vtgate.ExecuteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vitess_ExecuteBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtgate.ExecuteBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VitessServer).ExecuteBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtgateservice.Vitess/ExecuteBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VitessServer).ExecuteBatch(ctx, req.(*vtgate.ExecuteBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vitess_StreamExecute_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(vtgate.StreamExecuteRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VitessServer).StreamExecute(m, &vitessStreamExecuteServer{stream})
}

type Vitess_StreamExecuteServer interface {
	Send(*vtgate.StreamExecuteResponse) error
	grpc.ServerStream
}

type vitessStreamExecuteServer struct {
	grpc.ServerStream
}

func (x *vitessStreamExecuteServer) Send(m *vtgate.StreamExecuteResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Vitess_ResolveTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtgate.ResolveTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VitessServer).ResolveTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtgateservice.Vitess/ResolveTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VitessServer).ResolveTransaction(ctx, req.(*vtgate.ResolveTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vitess_VStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(vtgate.VStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VitessServer).VStream(m, &vitessVStreamServer{stream})
}

type Vitess_VStreamServer interface {
	Send(*vtgate.VStreamResponse) error
	grpc.ServerStream
}

type vitessVStreamServer struct {
	grpc.ServerStream
}

func (x *vitessVStreamServer) Send(m *vtgate.VStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Vitess_Prepare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtgate.PrepareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VitessServer).Prepare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtgateservice.Vitess/Prepare",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VitessServer).Prepare(ctx, req.(*vtgate.PrepareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vitess_CloseSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtgate.CloseSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VitessServer).CloseSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtgateservice.Vitess/CloseSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VitessServer).CloseSession(ctx, req.(*vtgate.CloseSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Vitess_ServiceDesc is the grpc.ServiceDesc for Vitess service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Vitess_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "vtgateservice.Vitess",
	HandlerType: (*VitessServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Execute",
			Handler:    _Vitess_Execute_Handler,
		},
		{
			MethodName: "ExecuteBatch",
			Handler:    _Vitess_ExecuteBatch_Handler,
		},
		{
			MethodName: "ResolveTransaction",
			Handler:    _Vitess_ResolveTransaction_Handler,
		},
		{
			MethodName: "Prepare",
			Handler:    _Vitess_Prepare_Handler,
		},
		{
			MethodName: "CloseSession",
			Handler:    _Vitess_CloseSession_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamExecute",
			Handler:       _Vitess_StreamExecute_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "VStream",
			Handler:       _Vitess_VStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "vtgateservice.proto",
}
