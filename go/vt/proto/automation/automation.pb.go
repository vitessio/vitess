// Code generated by protoc-gen-go.
// source: automation.proto
// DO NOT EDIT!

/*
Package automation is a generated protocol buffer package.

It is generated from these files:
	automation.proto

It has these top-level messages:
	ClusterOperation
	TaskContainer
	Task
	EnqueueClusterOperationRequest
	EnqueueClusterOperationResponse
	GetClusterOperationStateRequest
	GetClusterOperationStateResponse
	GetClusterOperationDetailsRequest
	GetClusterOperationDetailsResponse
*/
package automation

import proto "github.com/golang/protobuf/proto"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal

type ClusterOperationState int32

const (
	ClusterOperationState_UNKNOWN_CLUSTER_OPERATION_STATE ClusterOperationState = 0
	ClusterOperationState_CLUSTER_OPERATION_NOT_STARTED   ClusterOperationState = 1
	ClusterOperationState_CLUSTER_OPERATION_RUNNING       ClusterOperationState = 2
	ClusterOperationState_CLUSTER_OPERATION_DONE          ClusterOperationState = 3
)

var ClusterOperationState_name = map[int32]string{
	0: "UNKNOWN_CLUSTER_OPERATION_STATE",
	1: "CLUSTER_OPERATION_NOT_STARTED",
	2: "CLUSTER_OPERATION_RUNNING",
	3: "CLUSTER_OPERATION_DONE",
}
var ClusterOperationState_value = map[string]int32{
	"UNKNOWN_CLUSTER_OPERATION_STATE": 0,
	"CLUSTER_OPERATION_NOT_STARTED":   1,
	"CLUSTER_OPERATION_RUNNING":       2,
	"CLUSTER_OPERATION_DONE":          3,
}

func (x ClusterOperationState) String() string {
	return proto.EnumName(ClusterOperationState_name, int32(x))
}

type TaskState int32

const (
	TaskState_UNKNOWN_TASK_STATE TaskState = 0
	TaskState_NOT_STARTED        TaskState = 1
	TaskState_RUNNING            TaskState = 2
	TaskState_DONE               TaskState = 3
)

var TaskState_name = map[int32]string{
	0: "UNKNOWN_TASK_STATE",
	1: "NOT_STARTED",
	2: "RUNNING",
	3: "DONE",
}
var TaskState_value = map[string]int32{
	"UNKNOWN_TASK_STATE": 0,
	"NOT_STARTED":        1,
	"RUNNING":            2,
	"DONE":               3,
}

func (x TaskState) String() string {
	return proto.EnumName(TaskState_name, int32(x))
}

type ClusterOperation struct {
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// TaskContainer are processed sequentially, one at a time.
	SerialTasks []*TaskContainer `protobuf:"bytes,2,rep,name=serial_tasks" json:"serial_tasks,omitempty"`
	// Cached value. This has to be re-evaluated e.g. after a checkpoint load because running tasks may have already finished.
	State ClusterOperationState `protobuf:"varint,3,opt,name=state,enum=automation.ClusterOperationState" json:"state,omitempty"`
	// Error of the first task which failed. Set after state advanced to CLUSTER_OPERATION_DONE. If empty, all tasks succeeded. Cached value, see state above.
	Error string `protobuf:"bytes,4,opt,name=error" json:"error,omitempty"`
}

func (m *ClusterOperation) Reset()         { *m = ClusterOperation{} }
func (m *ClusterOperation) String() string { return proto.CompactTextString(m) }
func (*ClusterOperation) ProtoMessage()    {}

func (m *ClusterOperation) GetSerialTasks() []*TaskContainer {
	if m != nil {
		return m.SerialTasks
	}
	return nil
}

// TaskContainer holds one or more task which may be executed in parallel.
// "concurrency", if > 0, limits the amount of concurrently executed tasks.
type TaskContainer struct {
	ParallelTasks []*Task `protobuf:"bytes,1,rep,name=parallel_tasks" json:"parallel_tasks,omitempty"`
	Concurrency   int32   `protobuf:"varint,2,opt,name=concurrency" json:"concurrency,omitempty"`
}

func (m *TaskContainer) Reset()         { *m = TaskContainer{} }
func (m *TaskContainer) String() string { return proto.CompactTextString(m) }
func (*TaskContainer) ProtoMessage()    {}

func (m *TaskContainer) GetParallelTasks() []*Task {
	if m != nil {
		return m.ParallelTasks
	}
	return nil
}

// Task represents a specific task which should be automatically executed.
type Task struct {
	// Task specification.
	Name       string            `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Parameters map[string]string `protobuf:"bytes,2,rep,name=parameters" json:"parameters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Runtime data.
	Id    string    `protobuf:"bytes,3,opt,name=id" json:"id,omitempty"`
	State TaskState `protobuf:"varint,4,opt,name=state,enum=automation.TaskState" json:"state,omitempty"`
	// Set after state advanced to DONE.
	Output string `protobuf:"bytes,5,opt,name=output" json:"output,omitempty"`
	// Set after state advanced to DONE. If empty, the task did succeed.
	Error string `protobuf:"bytes,6,opt,name=error" json:"error,omitempty"`
}

func (m *Task) Reset()         { *m = Task{} }
func (m *Task) String() string { return proto.CompactTextString(m) }
func (*Task) ProtoMessage()    {}

func (m *Task) GetParameters() map[string]string {
	if m != nil {
		return m.Parameters
	}
	return nil
}

type EnqueueClusterOperationRequest struct {
	Name       string            `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Parameters map[string]string `protobuf:"bytes,2,rep,name=parameters" json:"parameters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *EnqueueClusterOperationRequest) Reset()         { *m = EnqueueClusterOperationRequest{} }
func (m *EnqueueClusterOperationRequest) String() string { return proto.CompactTextString(m) }
func (*EnqueueClusterOperationRequest) ProtoMessage()    {}

func (m *EnqueueClusterOperationRequest) GetParameters() map[string]string {
	if m != nil {
		return m.Parameters
	}
	return nil
}

type EnqueueClusterOperationResponse struct {
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *EnqueueClusterOperationResponse) Reset()         { *m = EnqueueClusterOperationResponse{} }
func (m *EnqueueClusterOperationResponse) String() string { return proto.CompactTextString(m) }
func (*EnqueueClusterOperationResponse) ProtoMessage()    {}

type GetClusterOperationStateRequest struct {
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *GetClusterOperationStateRequest) Reset()         { *m = GetClusterOperationStateRequest{} }
func (m *GetClusterOperationStateRequest) String() string { return proto.CompactTextString(m) }
func (*GetClusterOperationStateRequest) ProtoMessage()    {}

type GetClusterOperationStateResponse struct {
	State ClusterOperationState `protobuf:"varint,1,opt,name=state,enum=automation.ClusterOperationState" json:"state,omitempty"`
}

func (m *GetClusterOperationStateResponse) Reset()         { *m = GetClusterOperationStateResponse{} }
func (m *GetClusterOperationStateResponse) String() string { return proto.CompactTextString(m) }
func (*GetClusterOperationStateResponse) ProtoMessage()    {}

type GetClusterOperationDetailsRequest struct {
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *GetClusterOperationDetailsRequest) Reset()         { *m = GetClusterOperationDetailsRequest{} }
func (m *GetClusterOperationDetailsRequest) String() string { return proto.CompactTextString(m) }
func (*GetClusterOperationDetailsRequest) ProtoMessage()    {}

type GetClusterOperationDetailsResponse struct {
	// Full snapshot of the execution e.g. including output of each task.
	ClusterOp *ClusterOperation `protobuf:"bytes,2,opt,name=cluster_op" json:"cluster_op,omitempty"`
}

func (m *GetClusterOperationDetailsResponse) Reset()         { *m = GetClusterOperationDetailsResponse{} }
func (m *GetClusterOperationDetailsResponse) String() string { return proto.CompactTextString(m) }
func (*GetClusterOperationDetailsResponse) ProtoMessage()    {}

func (m *GetClusterOperationDetailsResponse) GetClusterOp() *ClusterOperation {
	if m != nil {
		return m.ClusterOp
	}
	return nil
}

func init() {
	proto.RegisterEnum("automation.ClusterOperationState", ClusterOperationState_name, ClusterOperationState_value)
	proto.RegisterEnum("automation.TaskState", TaskState_name, TaskState_value)
}

// Client API for Automation service

type AutomationClient interface {
	// Start a cluster operation.
	EnqueueClusterOperation(ctx context.Context, in *EnqueueClusterOperationRequest, opts ...grpc.CallOption) (*EnqueueClusterOperationResponse, error)
	// Get the current state of a given active cluster operation.
	// TODO(mberlin): Polling this is bad. Implement a subscribe mechanism to wait for changes?
	GetClusterOperationState(ctx context.Context, in *GetClusterOperationStateRequest, opts ...grpc.CallOption) (*GetClusterOperationStateResponse, error)
	// Get all details of an active cluster operation.
	GetClusterOperationDetails(ctx context.Context, in *GetClusterOperationDetailsRequest, opts ...grpc.CallOption) (*GetClusterOperationDetailsResponse, error)
}

type automationClient struct {
	cc *grpc.ClientConn
}

func NewAutomationClient(cc *grpc.ClientConn) AutomationClient {
	return &automationClient{cc}
}

func (c *automationClient) EnqueueClusterOperation(ctx context.Context, in *EnqueueClusterOperationRequest, opts ...grpc.CallOption) (*EnqueueClusterOperationResponse, error) {
	out := new(EnqueueClusterOperationResponse)
	err := grpc.Invoke(ctx, "/automation.Automation/EnqueueClusterOperation", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *automationClient) GetClusterOperationState(ctx context.Context, in *GetClusterOperationStateRequest, opts ...grpc.CallOption) (*GetClusterOperationStateResponse, error) {
	out := new(GetClusterOperationStateResponse)
	err := grpc.Invoke(ctx, "/automation.Automation/GetClusterOperationState", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *automationClient) GetClusterOperationDetails(ctx context.Context, in *GetClusterOperationDetailsRequest, opts ...grpc.CallOption) (*GetClusterOperationDetailsResponse, error) {
	out := new(GetClusterOperationDetailsResponse)
	err := grpc.Invoke(ctx, "/automation.Automation/GetClusterOperationDetails", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Automation service

type AutomationServer interface {
	// Start a cluster operation.
	EnqueueClusterOperation(context.Context, *EnqueueClusterOperationRequest) (*EnqueueClusterOperationResponse, error)
	// Get the current state of a given active cluster operation.
	// TODO(mberlin): Polling this is bad. Implement a subscribe mechanism to wait for changes?
	GetClusterOperationState(context.Context, *GetClusterOperationStateRequest) (*GetClusterOperationStateResponse, error)
	// Get all details of an active cluster operation.
	GetClusterOperationDetails(context.Context, *GetClusterOperationDetailsRequest) (*GetClusterOperationDetailsResponse, error)
}

func RegisterAutomationServer(s *grpc.Server, srv AutomationServer) {
	s.RegisterService(&_Automation_serviceDesc, srv)
}

func _Automation_EnqueueClusterOperation_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(EnqueueClusterOperationRequest)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(AutomationServer).EnqueueClusterOperation(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Automation_GetClusterOperationState_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(GetClusterOperationStateRequest)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(AutomationServer).GetClusterOperationState(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Automation_GetClusterOperationDetails_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(GetClusterOperationDetailsRequest)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(AutomationServer).GetClusterOperationDetails(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Automation_serviceDesc = grpc.ServiceDesc{
	ServiceName: "automation.Automation",
	HandlerType: (*AutomationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "EnqueueClusterOperation",
			Handler:    _Automation_EnqueueClusterOperation_Handler,
		},
		{
			MethodName: "GetClusterOperationState",
			Handler:    _Automation_GetClusterOperationState_Handler,
		},
		{
			MethodName: "GetClusterOperationDetails",
			Handler:    _Automation_GetClusterOperationDetails_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}
