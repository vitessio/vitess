// Code generated by protoc-gen-go.
// source: queryservice.proto
// DO NOT EDIT!

/*
Package queryservice is a generated protocol buffer package.

It is generated from these files:
	queryservice.proto

It has these top-level messages:
	SessionParams
	SessionInfo
	TransactionInfo
	Session
	BindVariable
	Query
	BoundQuery
	QueryList
	Field
	Cell
	Row
	QueryResult
	QueryResultList
	SplitQueryRequest
	QuerySplit
	SplitQueryResult
	CommitResponse
	RollbackResponse
*/
package queryservice

import proto "github.com/golang/protobuf/proto"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal

type BindVariable_Type int32

const (
	BindVariable_TYPE_NULL       BindVariable_Type = 0
	BindVariable_TYPE_BYTES      BindVariable_Type = 1
	BindVariable_TYPE_INT        BindVariable_Type = 2
	BindVariable_TYPE_UINT       BindVariable_Type = 3
	BindVariable_TYPE_FLOAT      BindVariable_Type = 4
	BindVariable_TYPE_BYTES_LIST BindVariable_Type = 5
	BindVariable_TYPE_INT_LIST   BindVariable_Type = 6
	BindVariable_TYPE_UINT_LIST  BindVariable_Type = 7
	BindVariable_TYPE_FLOAT_LIST BindVariable_Type = 8
)

var BindVariable_Type_name = map[int32]string{
	0: "TYPE_NULL",
	1: "TYPE_BYTES",
	2: "TYPE_INT",
	3: "TYPE_UINT",
	4: "TYPE_FLOAT",
	5: "TYPE_BYTES_LIST",
	6: "TYPE_INT_LIST",
	7: "TYPE_UINT_LIST",
	8: "TYPE_FLOAT_LIST",
}
var BindVariable_Type_value = map[string]int32{
	"TYPE_NULL":       0,
	"TYPE_BYTES":      1,
	"TYPE_INT":        2,
	"TYPE_UINT":       3,
	"TYPE_FLOAT":      4,
	"TYPE_BYTES_LIST": 5,
	"TYPE_INT_LIST":   6,
	"TYPE_UINT_LIST":  7,
	"TYPE_FLOAT_LIST": 8,
}

func (x BindVariable_Type) String() string {
	return proto.EnumName(BindVariable_Type_name, int32(x))
}

// Type follows enum_field_types from mysql.h.
type Field_Type int32

const (
	Field_TYPE_DECIMAL     Field_Type = 0
	Field_TYPE_TINY        Field_Type = 1
	Field_TYPE_SHORT       Field_Type = 2
	Field_TYPE_LONG        Field_Type = 3
	Field_TYPE_FLOAT       Field_Type = 4
	Field_TYPE_DOUBLE      Field_Type = 5
	Field_TYPE_NULL        Field_Type = 6
	Field_TYPE_TIMESTAMP   Field_Type = 7
	Field_TYPE_LONGLONG    Field_Type = 8
	Field_TYPE_INT24       Field_Type = 9
	Field_TYPE_DATE        Field_Type = 10
	Field_TYPE_TIME        Field_Type = 11
	Field_TYPE_DATETIME    Field_Type = 12
	Field_TYPE_YEAR        Field_Type = 13
	Field_TYPE_NEWDATE     Field_Type = 14
	Field_TYPE_VARCHAR     Field_Type = 15
	Field_TYPE_BIT         Field_Type = 16
	Field_TYPE_NEWDECIMAL  Field_Type = 246
	Field_TYPE_ENUM        Field_Type = 247
	Field_TYPE_SET         Field_Type = 248
	Field_TYPE_TINY_BLOB   Field_Type = 249
	Field_TYPE_MEDIUM_BLOB Field_Type = 250
	Field_TYPE_LONG_BLOB   Field_Type = 251
	Field_TYPE_BLOB        Field_Type = 252
	Field_TYPE_VAR_STRING  Field_Type = 253
	Field_TYPE_STRING      Field_Type = 254
	Field_TYPE_GEOMETRY    Field_Type = 255
)

var Field_Type_name = map[int32]string{
	0:   "TYPE_DECIMAL",
	1:   "TYPE_TINY",
	2:   "TYPE_SHORT",
	3:   "TYPE_LONG",
	4:   "TYPE_FLOAT",
	5:   "TYPE_DOUBLE",
	6:   "TYPE_NULL",
	7:   "TYPE_TIMESTAMP",
	8:   "TYPE_LONGLONG",
	9:   "TYPE_INT24",
	10:  "TYPE_DATE",
	11:  "TYPE_TIME",
	12:  "TYPE_DATETIME",
	13:  "TYPE_YEAR",
	14:  "TYPE_NEWDATE",
	15:  "TYPE_VARCHAR",
	16:  "TYPE_BIT",
	246: "TYPE_NEWDECIMAL",
	247: "TYPE_ENUM",
	248: "TYPE_SET",
	249: "TYPE_TINY_BLOB",
	250: "TYPE_MEDIUM_BLOB",
	251: "TYPE_LONG_BLOB",
	252: "TYPE_BLOB",
	253: "TYPE_VAR_STRING",
	254: "TYPE_STRING",
	255: "TYPE_GEOMETRY",
}
var Field_Type_value = map[string]int32{
	"TYPE_DECIMAL":     0,
	"TYPE_TINY":        1,
	"TYPE_SHORT":       2,
	"TYPE_LONG":        3,
	"TYPE_FLOAT":       4,
	"TYPE_DOUBLE":      5,
	"TYPE_NULL":        6,
	"TYPE_TIMESTAMP":   7,
	"TYPE_LONGLONG":    8,
	"TYPE_INT24":       9,
	"TYPE_DATE":        10,
	"TYPE_TIME":        11,
	"TYPE_DATETIME":    12,
	"TYPE_YEAR":        13,
	"TYPE_NEWDATE":     14,
	"TYPE_VARCHAR":     15,
	"TYPE_BIT":         16,
	"TYPE_NEWDECIMAL":  246,
	"TYPE_ENUM":        247,
	"TYPE_SET":         248,
	"TYPE_TINY_BLOB":   249,
	"TYPE_MEDIUM_BLOB": 250,
	"TYPE_LONG_BLOB":   251,
	"TYPE_BLOB":        252,
	"TYPE_VAR_STRING":  253,
	"TYPE_STRING":      254,
	"TYPE_GEOMETRY":    255,
}

func (x Field_Type) String() string {
	return proto.EnumName(Field_Type_name, int32(x))
}

// Flag contains the MySQL field flags bitset values e.g. to
// distinguish between signed and unsigned integer.  These numbers
// should exactly match values defined in
// dist/mysql-5.1.52/include/mysql_com.h
type Field_Flag int32

const (
	// ZEROVALUE_FLAG is not part of the MySQL specification and only
	// used in unit tests.
	Field_VT_ZEROVALUE_FLAG        Field_Flag = 0
	Field_VT_NOT_NULL_FLAG         Field_Flag = 1
	Field_VT_PRI_KEY_FLAG          Field_Flag = 2
	Field_VT_UNIQUE_KEY_FLAG       Field_Flag = 4
	Field_VT_MULTIPLE_KEY_FLAG     Field_Flag = 8
	Field_VT_BLOB_FLAG             Field_Flag = 16
	Field_VT_UNSIGNED_FLAG         Field_Flag = 32
	Field_VT_ZEROFILL_FLAG         Field_Flag = 64
	Field_VT_BINARY_FLAG           Field_Flag = 128
	Field_VT_ENUM_FLAG             Field_Flag = 256
	Field_VT_AUTO_INCREMENT_FLAG   Field_Flag = 512
	Field_VT_TIMESTAMP_FLAG        Field_Flag = 1024
	Field_VT_SET_FLAG              Field_Flag = 2048
	Field_VT_NO_DEFAULT_VALUE_FLAG Field_Flag = 4096
	Field_VT_ON_UPDATE_NOW_FLAG    Field_Flag = 8192
	Field_VT_NUM_FLAG              Field_Flag = 32768
)

var Field_Flag_name = map[int32]string{
	0:     "VT_ZEROVALUE_FLAG",
	1:     "VT_NOT_NULL_FLAG",
	2:     "VT_PRI_KEY_FLAG",
	4:     "VT_UNIQUE_KEY_FLAG",
	8:     "VT_MULTIPLE_KEY_FLAG",
	16:    "VT_BLOB_FLAG",
	32:    "VT_UNSIGNED_FLAG",
	64:    "VT_ZEROFILL_FLAG",
	128:   "VT_BINARY_FLAG",
	256:   "VT_ENUM_FLAG",
	512:   "VT_AUTO_INCREMENT_FLAG",
	1024:  "VT_TIMESTAMP_FLAG",
	2048:  "VT_SET_FLAG",
	4096:  "VT_NO_DEFAULT_VALUE_FLAG",
	8192:  "VT_ON_UPDATE_NOW_FLAG",
	32768: "VT_NUM_FLAG",
}
var Field_Flag_value = map[string]int32{
	"VT_ZEROVALUE_FLAG":        0,
	"VT_NOT_NULL_FLAG":         1,
	"VT_PRI_KEY_FLAG":          2,
	"VT_UNIQUE_KEY_FLAG":       4,
	"VT_MULTIPLE_KEY_FLAG":     8,
	"VT_BLOB_FLAG":             16,
	"VT_UNSIGNED_FLAG":         32,
	"VT_ZEROFILL_FLAG":         64,
	"VT_BINARY_FLAG":           128,
	"VT_ENUM_FLAG":             256,
	"VT_AUTO_INCREMENT_FLAG":   512,
	"VT_TIMESTAMP_FLAG":        1024,
	"VT_SET_FLAG":              2048,
	"VT_NO_DEFAULT_VALUE_FLAG": 4096,
	"VT_ON_UPDATE_NOW_FLAG":    8192,
	"VT_NUM_FLAG":              32768,
}

func (x Field_Flag) String() string {
	return proto.EnumName(Field_Flag_name, int32(x))
}

// SessionParams is passed to GetSessionId. The server will
// double-check the keyspace and shard are what the tablet is serving.
type SessionParams struct {
	Keyspace string `protobuf:"bytes,1,opt,name=keyspace" json:"keyspace,omitempty"`
	Shard    string `protobuf:"bytes,2,opt,name=shard" json:"shard,omitempty"`
}

func (m *SessionParams) Reset()         { *m = SessionParams{} }
func (m *SessionParams) String() string { return proto.CompactTextString(m) }
func (*SessionParams) ProtoMessage()    {}

// SessionInfo is returned by GetSessionId. Use the provided
// session_id in the Session object for any subsequent call.
type SessionInfo struct {
	SessionId int64 `protobuf:"varint,1,opt,name=session_id" json:"session_id,omitempty"`
}

func (m *SessionInfo) Reset()         { *m = SessionInfo{} }
func (m *SessionInfo) String() string { return proto.CompactTextString(m) }
func (*SessionInfo) ProtoMessage()    {}

// TransactionInfo is returned by Begin. Use the provided
// transaction_id in the Session object for any subsequent call to be inside
// the transaction.
type TransactionInfo struct {
	TransactionId int64 `protobuf:"varint,1,opt,name=transaction_id" json:"transaction_id,omitempty"`
}

func (m *TransactionInfo) Reset()         { *m = TransactionInfo{} }
func (m *TransactionInfo) String() string { return proto.CompactTextString(m) }
func (*TransactionInfo) ProtoMessage()    {}

// Session is passed to all calls.
type Session struct {
	// session_id comes from SessionInfo and is required.
	SessionId int64 `protobuf:"varint,1,opt,name=session_id" json:"session_id,omitempty"`
	// transaction_id comes from TransactionInfo and is required for queries
	// inside a transaction.
	TransactionId int64 `protobuf:"varint,2,opt,name=transaction_id" json:"transaction_id,omitempty"`
}

func (m *Session) Reset()         { *m = Session{} }
func (m *Session) String() string { return proto.CompactTextString(m) }
func (*Session) ProtoMessage()    {}

// BindVariable represents a single bind variable in a Query
type BindVariable struct {
	Name           string            `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Type           BindVariable_Type `protobuf:"varint,2,opt,name=type,enum=queryservice.BindVariable_Type" json:"type,omitempty"`
	ValueBytes     []byte            `protobuf:"bytes,3,opt,name=value_bytes,proto3" json:"value_bytes,omitempty"`
	ValueInt       int64             `protobuf:"varint,4,opt,name=value_int" json:"value_int,omitempty"`
	ValueUint      uint64            `protobuf:"varint,5,opt,name=value_uint" json:"value_uint,omitempty"`
	ValueFloat     float64           `protobuf:"fixed64,6,opt,name=value_float" json:"value_float,omitempty"`
	ValueBytesList [][]byte          `protobuf:"bytes,7,rep,name=value_bytes_list,proto3" json:"value_bytes_list,omitempty"`
	ValueIntList   []int64           `protobuf:"varint,8,rep,name=value_int_list" json:"value_int_list,omitempty"`
	ValueUintList  []uint64          `protobuf:"varint,9,rep,name=value_uint_list" json:"value_uint_list,omitempty"`
	ValueFloatList []float64         `protobuf:"fixed64,10,rep,name=value_float_list" json:"value_float_list,omitempty"`
}

func (m *BindVariable) Reset()         { *m = BindVariable{} }
func (m *BindVariable) String() string { return proto.CompactTextString(m) }
func (*BindVariable) ProtoMessage()    {}

// Query is the payload to Execute
type Query struct {
	Sql           []byte          `protobuf:"bytes,1,opt,name=sql,proto3" json:"sql,omitempty"`
	BindVariables []*BindVariable `protobuf:"bytes,2,rep,name=bind_variables" json:"bind_variables,omitempty"`
	Session       *Session        `protobuf:"bytes,3,opt,name=session" json:"session,omitempty"`
}

func (m *Query) Reset()         { *m = Query{} }
func (m *Query) String() string { return proto.CompactTextString(m) }
func (*Query) ProtoMessage()    {}

func (m *Query) GetBindVariables() []*BindVariable {
	if m != nil {
		return m.BindVariables
	}
	return nil
}

func (m *Query) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

// BoundQuery is one query in a QueryList
type BoundQuery struct {
	Sql           []byte          `protobuf:"bytes,1,opt,name=sql,proto3" json:"sql,omitempty"`
	BindVariables []*BindVariable `protobuf:"bytes,2,rep,name=bind_variables" json:"bind_variables,omitempty"`
}

func (m *BoundQuery) Reset()         { *m = BoundQuery{} }
func (m *BoundQuery) String() string { return proto.CompactTextString(m) }
func (*BoundQuery) ProtoMessage()    {}

func (m *BoundQuery) GetBindVariables() []*BindVariable {
	if m != nil {
		return m.BindVariables
	}
	return nil
}

// QueryList is the payload to ExecuteBatch
type QueryList struct {
	Queries []*BoundQuery `protobuf:"bytes,1,rep,name=queries" json:"queries,omitempty"`
	Session *Session      `protobuf:"bytes,2,opt,name=session" json:"session,omitempty"`
}

func (m *QueryList) Reset()         { *m = QueryList{} }
func (m *QueryList) String() string { return proto.CompactTextString(m) }
func (*QueryList) ProtoMessage()    {}

func (m *QueryList) GetQueries() []*BoundQuery {
	if m != nil {
		return m.Queries
	}
	return nil
}

func (m *QueryList) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

// Field describes a single column returned by a query
type Field struct {
	// name of the field as returned by mysql C API
	Name string     `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Type Field_Type `protobuf:"varint,2,opt,name=type,enum=queryservice.Field_Type" json:"type,omitempty"`
	// flags is essentially a bitset<Flag>.
	Flags int64 `protobuf:"varint,3,opt,name=flags" json:"flags,omitempty"`
}

func (m *Field) Reset()         { *m = Field{} }
func (m *Field) String() string { return proto.CompactTextString(m) }
func (*Field) ProtoMessage()    {}

// Cell is a single value, an array of Cell is a Row
type Cell struct {
	Value []byte `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Cell) Reset()         { *m = Cell{} }
func (m *Cell) String() string { return proto.CompactTextString(m) }
func (*Cell) ProtoMessage()    {}

// Row is a database row.
type Row struct {
	Values []*Cell `protobuf:"bytes,1,rep,name=values" json:"values,omitempty"`
}

func (m *Row) Reset()         { *m = Row{} }
func (m *Row) String() string { return proto.CompactTextString(m) }
func (*Row) ProtoMessage()    {}

func (m *Row) GetValues() []*Cell {
	if m != nil {
		return m.Values
	}
	return nil
}

// QueryResult is returned by Execute and ExecuteStream.
//
// As returned by Execute, len(fields) is always equal to len(row)
// (for each row in rows).
//
// As returned by StreamExecute, the first QueryResult has the fields
// set, and subsequent QueryResult have rows set. And as Execute,
// len(QueryResult[0].fields) is always equal to len(row) (for each
// row in rows for each QueryResult in QueryResult[1:]).
type QueryResult struct {
	Fields       []*Field `protobuf:"bytes,1,rep,name=fields" json:"fields,omitempty"`
	RowsAffected uint64   `protobuf:"varint,2,opt,name=rows_affected" json:"rows_affected,omitempty"`
	InsertId     uint64   `protobuf:"varint,3,opt,name=insert_id" json:"insert_id,omitempty"`
	Rows         []*Row   `protobuf:"bytes,4,rep,name=rows" json:"rows,omitempty"`
}

func (m *QueryResult) Reset()         { *m = QueryResult{} }
func (m *QueryResult) String() string { return proto.CompactTextString(m) }
func (*QueryResult) ProtoMessage()    {}

func (m *QueryResult) GetFields() []*Field {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *QueryResult) GetRows() []*Row {
	if m != nil {
		return m.Rows
	}
	return nil
}

// QueryResultList is the return type for ExecuteBatch
type QueryResultList struct {
	List []*QueryResult `protobuf:"bytes,1,rep,name=list" json:"list,omitempty"`
}

func (m *QueryResultList) Reset()         { *m = QueryResultList{} }
func (m *QueryResultList) String() string { return proto.CompactTextString(m) }
func (*QueryResultList) ProtoMessage()    {}

func (m *QueryResultList) GetList() []*QueryResult {
	if m != nil {
		return m.List
	}
	return nil
}

// SplitQueryRequest is the payload for SplitQuery
type SplitQueryRequest struct {
	Query      *BoundQuery `protobuf:"bytes,1,opt,name=query" json:"query,omitempty"`
	SplitCount int64       `protobuf:"varint,2,opt,name=split_count" json:"split_count,omitempty"`
	Session    *Session    `protobuf:"bytes,3,opt,name=session" json:"session,omitempty"`
}

func (m *SplitQueryRequest) Reset()         { *m = SplitQueryRequest{} }
func (m *SplitQueryRequest) String() string { return proto.CompactTextString(m) }
func (*SplitQueryRequest) ProtoMessage()    {}

func (m *SplitQueryRequest) GetQuery() *BoundQuery {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *SplitQueryRequest) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

// QuerySplit represents one query to execute on the tablet
type QuerySplit struct {
	Query    *BoundQuery `protobuf:"bytes,1,opt,name=query" json:"query,omitempty"`
	RowCount int64       `protobuf:"varint,2,opt,name=row_count" json:"row_count,omitempty"`
}

func (m *QuerySplit) Reset()         { *m = QuerySplit{} }
func (m *QuerySplit) String() string { return proto.CompactTextString(m) }
func (*QuerySplit) ProtoMessage()    {}

func (m *QuerySplit) GetQuery() *BoundQuery {
	if m != nil {
		return m.Query
	}
	return nil
}

// SplitQueryResult is returned by SplitQuery and represents all the queries
// to execute in order to get the entire data set.
type SplitQueryResult struct {
	Queries []*QuerySplit `protobuf:"bytes,1,rep,name=queries" json:"queries,omitempty"`
}

func (m *SplitQueryResult) Reset()         { *m = SplitQueryResult{} }
func (m *SplitQueryResult) String() string { return proto.CompactTextString(m) }
func (*SplitQueryResult) ProtoMessage()    {}

func (m *SplitQueryResult) GetQueries() []*QuerySplit {
	if m != nil {
		return m.Queries
	}
	return nil
}

// CommitResponse is returned by Commit, and empty.
type CommitResponse struct {
}

func (m *CommitResponse) Reset()         { *m = CommitResponse{} }
func (m *CommitResponse) String() string { return proto.CompactTextString(m) }
func (*CommitResponse) ProtoMessage()    {}

// RollbackResponse is returned by Rollback, and empty.
type RollbackResponse struct {
}

func (m *RollbackResponse) Reset()         { *m = RollbackResponse{} }
func (m *RollbackResponse) String() string { return proto.CompactTextString(m) }
func (*RollbackResponse) ProtoMessage()    {}

func init() {
	proto.RegisterEnum("queryservice.BindVariable_Type", BindVariable_Type_name, BindVariable_Type_value)
	proto.RegisterEnum("queryservice.Field_Type", Field_Type_name, Field_Type_value)
	proto.RegisterEnum("queryservice.Field_Flag", Field_Flag_name, Field_Flag_value)
}

// Client API for SqlQuery service

type SqlQueryClient interface {
	// GetSessionId returns a valid session id to be used for
	// subsequent calls. This should be the first call by clients.
	GetSessionId(ctx context.Context, in *SessionParams, opts ...grpc.CallOption) (*SessionInfo, error)
	// Execute executes the specified SQL query (might be in a
	// transaction context, if Query.session.transaction_id is set).
	Execute(ctx context.Context, in *Query, opts ...grpc.CallOption) (*QueryResult, error)
	// ExecuteBatch executes a list of queries, and returns the result
	// for each query.
	ExecuteBatch(ctx context.Context, in *QueryList, opts ...grpc.CallOption) (*QueryResultList, error)
	// StreamExecute executes a streaming query. Use this method if the
	// query returns a large number of rows. The first QueryResult will
	// contain the Fields, subsequent QueryResult messages will contain
	// the rows.
	StreamExecute(ctx context.Context, in *Query, opts ...grpc.CallOption) (SqlQuery_StreamExecuteClient, error)
	// Begin a transaction.
	Begin(ctx context.Context, in *Session, opts ...grpc.CallOption) (*TransactionInfo, error)
	// Commit a transaction.
	Commit(ctx context.Context, in *Session, opts ...grpc.CallOption) (*CommitResponse, error)
	// Rollback a transaction.
	Rollback(ctx context.Context, in *Session, opts ...grpc.CallOption) (*RollbackResponse, error)
	// SplitQuery is the API to facilitate MapReduce-type iterations
	// over large data sets (like full table dumps).
	SplitQuery(ctx context.Context, in *SplitQueryRequest, opts ...grpc.CallOption) (*SplitQueryResult, error)
}

type sqlQueryClient struct {
	cc *grpc.ClientConn
}

func NewSqlQueryClient(cc *grpc.ClientConn) SqlQueryClient {
	return &sqlQueryClient{cc}
}

func (c *sqlQueryClient) GetSessionId(ctx context.Context, in *SessionParams, opts ...grpc.CallOption) (*SessionInfo, error) {
	out := new(SessionInfo)
	err := grpc.Invoke(ctx, "/queryservice.SqlQuery/GetSessionId", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sqlQueryClient) Execute(ctx context.Context, in *Query, opts ...grpc.CallOption) (*QueryResult, error) {
	out := new(QueryResult)
	err := grpc.Invoke(ctx, "/queryservice.SqlQuery/Execute", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sqlQueryClient) ExecuteBatch(ctx context.Context, in *QueryList, opts ...grpc.CallOption) (*QueryResultList, error) {
	out := new(QueryResultList)
	err := grpc.Invoke(ctx, "/queryservice.SqlQuery/ExecuteBatch", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sqlQueryClient) StreamExecute(ctx context.Context, in *Query, opts ...grpc.CallOption) (SqlQuery_StreamExecuteClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_SqlQuery_serviceDesc.Streams[0], c.cc, "/queryservice.SqlQuery/StreamExecute", opts...)
	if err != nil {
		return nil, err
	}
	x := &sqlQueryStreamExecuteClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SqlQuery_StreamExecuteClient interface {
	Recv() (*QueryResult, error)
	grpc.ClientStream
}

type sqlQueryStreamExecuteClient struct {
	grpc.ClientStream
}

func (x *sqlQueryStreamExecuteClient) Recv() (*QueryResult, error) {
	m := new(QueryResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *sqlQueryClient) Begin(ctx context.Context, in *Session, opts ...grpc.CallOption) (*TransactionInfo, error) {
	out := new(TransactionInfo)
	err := grpc.Invoke(ctx, "/queryservice.SqlQuery/Begin", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sqlQueryClient) Commit(ctx context.Context, in *Session, opts ...grpc.CallOption) (*CommitResponse, error) {
	out := new(CommitResponse)
	err := grpc.Invoke(ctx, "/queryservice.SqlQuery/Commit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sqlQueryClient) Rollback(ctx context.Context, in *Session, opts ...grpc.CallOption) (*RollbackResponse, error) {
	out := new(RollbackResponse)
	err := grpc.Invoke(ctx, "/queryservice.SqlQuery/Rollback", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sqlQueryClient) SplitQuery(ctx context.Context, in *SplitQueryRequest, opts ...grpc.CallOption) (*SplitQueryResult, error) {
	out := new(SplitQueryResult)
	err := grpc.Invoke(ctx, "/queryservice.SqlQuery/SplitQuery", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for SqlQuery service

type SqlQueryServer interface {
	// GetSessionId returns a valid session id to be used for
	// subsequent calls. This should be the first call by clients.
	GetSessionId(context.Context, *SessionParams) (*SessionInfo, error)
	// Execute executes the specified SQL query (might be in a
	// transaction context, if Query.session.transaction_id is set).
	Execute(context.Context, *Query) (*QueryResult, error)
	// ExecuteBatch executes a list of queries, and returns the result
	// for each query.
	ExecuteBatch(context.Context, *QueryList) (*QueryResultList, error)
	// StreamExecute executes a streaming query. Use this method if the
	// query returns a large number of rows. The first QueryResult will
	// contain the Fields, subsequent QueryResult messages will contain
	// the rows.
	StreamExecute(*Query, SqlQuery_StreamExecuteServer) error
	// Begin a transaction.
	Begin(context.Context, *Session) (*TransactionInfo, error)
	// Commit a transaction.
	Commit(context.Context, *Session) (*CommitResponse, error)
	// Rollback a transaction.
	Rollback(context.Context, *Session) (*RollbackResponse, error)
	// SplitQuery is the API to facilitate MapReduce-type iterations
	// over large data sets (like full table dumps).
	SplitQuery(context.Context, *SplitQueryRequest) (*SplitQueryResult, error)
}

func RegisterSqlQueryServer(s *grpc.Server, srv SqlQueryServer) {
	s.RegisterService(&_SqlQuery_serviceDesc, srv)
}

func _SqlQuery_GetSessionId_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(SessionParams)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(SqlQueryServer).GetSessionId(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _SqlQuery_Execute_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Query)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(SqlQueryServer).Execute(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _SqlQuery_ExecuteBatch_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(QueryList)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(SqlQueryServer).ExecuteBatch(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _SqlQuery_StreamExecute_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Query)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SqlQueryServer).StreamExecute(m, &sqlQueryStreamExecuteServer{stream})
}

type SqlQuery_StreamExecuteServer interface {
	Send(*QueryResult) error
	grpc.ServerStream
}

type sqlQueryStreamExecuteServer struct {
	grpc.ServerStream
}

func (x *sqlQueryStreamExecuteServer) Send(m *QueryResult) error {
	return x.ServerStream.SendMsg(m)
}

func _SqlQuery_Begin_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Session)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(SqlQueryServer).Begin(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _SqlQuery_Commit_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Session)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(SqlQueryServer).Commit(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _SqlQuery_Rollback_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Session)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(SqlQueryServer).Rollback(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _SqlQuery_SplitQuery_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(SplitQueryRequest)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(SqlQueryServer).SplitQuery(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _SqlQuery_serviceDesc = grpc.ServiceDesc{
	ServiceName: "queryservice.SqlQuery",
	HandlerType: (*SqlQueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSessionId",
			Handler:    _SqlQuery_GetSessionId_Handler,
		},
		{
			MethodName: "Execute",
			Handler:    _SqlQuery_Execute_Handler,
		},
		{
			MethodName: "ExecuteBatch",
			Handler:    _SqlQuery_ExecuteBatch_Handler,
		},
		{
			MethodName: "Begin",
			Handler:    _SqlQuery_Begin_Handler,
		},
		{
			MethodName: "Commit",
			Handler:    _SqlQuery_Commit_Handler,
		},
		{
			MethodName: "Rollback",
			Handler:    _SqlQuery_Rollback_Handler,
		},
		{
			MethodName: "SplitQuery",
			Handler:    _SqlQuery_SplitQuery_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamExecute",
			Handler:       _SqlQuery_StreamExecute_Handler,
			ServerStreams: true,
		},
	},
}
