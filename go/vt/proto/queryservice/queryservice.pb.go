// Code generated by protoc-gen-go.
// source: queryservice.proto
// DO NOT EDIT!

/*
Package queryservice is a generated protocol buffer package.

It is generated from these files:
	queryservice.proto

It has these top-level messages:
*/
package queryservice

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import query "github.com/youtube/vitess/go/vt/proto/query"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion1

// Client API for Query service

type QueryClient interface {
	// GetSessionId gets a session id from the server. This call is being
	// deprecated in favor of using the Target field of the subsequent
	// queries, but is still here for backward compatibility.
	GetSessionId(ctx context.Context, in *query.GetSessionIdRequest, opts ...grpc.CallOption) (*query.GetSessionIdResponse, error)
	// Execute executes the specified SQL query (might be in a
	// transaction context, if Query.transaction_id is set).
	Execute(ctx context.Context, in *query.ExecuteRequest, opts ...grpc.CallOption) (*query.ExecuteResponse, error)
	// ExecuteBatch executes a list of queries, and returns the result
	// for each query.
	ExecuteBatch(ctx context.Context, in *query.ExecuteBatchRequest, opts ...grpc.CallOption) (*query.ExecuteBatchResponse, error)
	// StreamExecute executes a streaming query. Use this method if the
	// query returns a large number of rows. The first QueryResult will
	// contain the Fields, subsequent QueryResult messages will contain
	// the rows.
	StreamExecute(ctx context.Context, in *query.StreamExecuteRequest, opts ...grpc.CallOption) (Query_StreamExecuteClient, error)
	// Begin a transaction.
	Begin(ctx context.Context, in *query.BeginRequest, opts ...grpc.CallOption) (*query.BeginResponse, error)
	// Commit a transaction.
	Commit(ctx context.Context, in *query.CommitRequest, opts ...grpc.CallOption) (*query.CommitResponse, error)
	// Rollback a transaction.
	Rollback(ctx context.Context, in *query.RollbackRequest, opts ...grpc.CallOption) (*query.RollbackResponse, error)
	// SplitQuery is the API to facilitate MapReduce-type iterations
	// over large data sets (like full table dumps).
	SplitQuery(ctx context.Context, in *query.SplitQueryRequest, opts ...grpc.CallOption) (*query.SplitQueryResponse, error)
	// StreamHealth runs a streaming RPC to the tablet, that returns the
	// current health of the tablet on a regular basis.
	StreamHealth(ctx context.Context, in *query.StreamHealthRequest, opts ...grpc.CallOption) (Query_StreamHealthClient, error)
}

type queryClient struct {
	cc *grpc.ClientConn
}

func NewQueryClient(cc *grpc.ClientConn) QueryClient {
	return &queryClient{cc}
}

func (c *queryClient) GetSessionId(ctx context.Context, in *query.GetSessionIdRequest, opts ...grpc.CallOption) (*query.GetSessionIdResponse, error) {
	out := new(query.GetSessionIdResponse)
	err := grpc.Invoke(ctx, "/queryservice.Query/GetSessionId", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Execute(ctx context.Context, in *query.ExecuteRequest, opts ...grpc.CallOption) (*query.ExecuteResponse, error) {
	out := new(query.ExecuteResponse)
	err := grpc.Invoke(ctx, "/queryservice.Query/Execute", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ExecuteBatch(ctx context.Context, in *query.ExecuteBatchRequest, opts ...grpc.CallOption) (*query.ExecuteBatchResponse, error) {
	out := new(query.ExecuteBatchResponse)
	err := grpc.Invoke(ctx, "/queryservice.Query/ExecuteBatch", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) StreamExecute(ctx context.Context, in *query.StreamExecuteRequest, opts ...grpc.CallOption) (Query_StreamExecuteClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Query_serviceDesc.Streams[0], c.cc, "/queryservice.Query/StreamExecute", opts...)
	if err != nil {
		return nil, err
	}
	x := &queryStreamExecuteClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Query_StreamExecuteClient interface {
	Recv() (*query.StreamExecuteResponse, error)
	grpc.ClientStream
}

type queryStreamExecuteClient struct {
	grpc.ClientStream
}

func (x *queryStreamExecuteClient) Recv() (*query.StreamExecuteResponse, error) {
	m := new(query.StreamExecuteResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queryClient) Begin(ctx context.Context, in *query.BeginRequest, opts ...grpc.CallOption) (*query.BeginResponse, error) {
	out := new(query.BeginResponse)
	err := grpc.Invoke(ctx, "/queryservice.Query/Begin", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Commit(ctx context.Context, in *query.CommitRequest, opts ...grpc.CallOption) (*query.CommitResponse, error) {
	out := new(query.CommitResponse)
	err := grpc.Invoke(ctx, "/queryservice.Query/Commit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Rollback(ctx context.Context, in *query.RollbackRequest, opts ...grpc.CallOption) (*query.RollbackResponse, error) {
	out := new(query.RollbackResponse)
	err := grpc.Invoke(ctx, "/queryservice.Query/Rollback", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) SplitQuery(ctx context.Context, in *query.SplitQueryRequest, opts ...grpc.CallOption) (*query.SplitQueryResponse, error) {
	out := new(query.SplitQueryResponse)
	err := grpc.Invoke(ctx, "/queryservice.Query/SplitQuery", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) StreamHealth(ctx context.Context, in *query.StreamHealthRequest, opts ...grpc.CallOption) (Query_StreamHealthClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Query_serviceDesc.Streams[1], c.cc, "/queryservice.Query/StreamHealth", opts...)
	if err != nil {
		return nil, err
	}
	x := &queryStreamHealthClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Query_StreamHealthClient interface {
	Recv() (*query.StreamHealthResponse, error)
	grpc.ClientStream
}

type queryStreamHealthClient struct {
	grpc.ClientStream
}

func (x *queryStreamHealthClient) Recv() (*query.StreamHealthResponse, error) {
	m := new(query.StreamHealthResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Query service

type QueryServer interface {
	// GetSessionId gets a session id from the server. This call is being
	// deprecated in favor of using the Target field of the subsequent
	// queries, but is still here for backward compatibility.
	GetSessionId(context.Context, *query.GetSessionIdRequest) (*query.GetSessionIdResponse, error)
	// Execute executes the specified SQL query (might be in a
	// transaction context, if Query.transaction_id is set).
	Execute(context.Context, *query.ExecuteRequest) (*query.ExecuteResponse, error)
	// ExecuteBatch executes a list of queries, and returns the result
	// for each query.
	ExecuteBatch(context.Context, *query.ExecuteBatchRequest) (*query.ExecuteBatchResponse, error)
	// StreamExecute executes a streaming query. Use this method if the
	// query returns a large number of rows. The first QueryResult will
	// contain the Fields, subsequent QueryResult messages will contain
	// the rows.
	StreamExecute(*query.StreamExecuteRequest, Query_StreamExecuteServer) error
	// Begin a transaction.
	Begin(context.Context, *query.BeginRequest) (*query.BeginResponse, error)
	// Commit a transaction.
	Commit(context.Context, *query.CommitRequest) (*query.CommitResponse, error)
	// Rollback a transaction.
	Rollback(context.Context, *query.RollbackRequest) (*query.RollbackResponse, error)
	// SplitQuery is the API to facilitate MapReduce-type iterations
	// over large data sets (like full table dumps).
	SplitQuery(context.Context, *query.SplitQueryRequest) (*query.SplitQueryResponse, error)
	// StreamHealth runs a streaming RPC to the tablet, that returns the
	// current health of the tablet on a regular basis.
	StreamHealth(*query.StreamHealthRequest, Query_StreamHealthServer) error
}

func RegisterQueryServer(s *grpc.Server, srv QueryServer) {
	s.RegisterService(&_Query_serviceDesc, srv)
}

func _Query_GetSessionId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(query.GetSessionIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(QueryServer).GetSessionId(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Query_Execute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(query.ExecuteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(QueryServer).Execute(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Query_ExecuteBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(query.ExecuteBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(QueryServer).ExecuteBatch(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Query_StreamExecute_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(query.StreamExecuteRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServer).StreamExecute(m, &queryStreamExecuteServer{stream})
}

type Query_StreamExecuteServer interface {
	Send(*query.StreamExecuteResponse) error
	grpc.ServerStream
}

type queryStreamExecuteServer struct {
	grpc.ServerStream
}

func (x *queryStreamExecuteServer) Send(m *query.StreamExecuteResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Query_Begin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(query.BeginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(QueryServer).Begin(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Query_Commit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(query.CommitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(QueryServer).Commit(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Query_Rollback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(query.RollbackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(QueryServer).Rollback(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Query_SplitQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(query.SplitQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(QueryServer).SplitQuery(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Query_StreamHealth_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(query.StreamHealthRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServer).StreamHealth(m, &queryStreamHealthServer{stream})
}

type Query_StreamHealthServer interface {
	Send(*query.StreamHealthResponse) error
	grpc.ServerStream
}

type queryStreamHealthServer struct {
	grpc.ServerStream
}

func (x *queryStreamHealthServer) Send(m *query.StreamHealthResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _Query_serviceDesc = grpc.ServiceDesc{
	ServiceName: "queryservice.Query",
	HandlerType: (*QueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSessionId",
			Handler:    _Query_GetSessionId_Handler,
		},
		{
			MethodName: "Execute",
			Handler:    _Query_Execute_Handler,
		},
		{
			MethodName: "ExecuteBatch",
			Handler:    _Query_ExecuteBatch_Handler,
		},
		{
			MethodName: "Begin",
			Handler:    _Query_Begin_Handler,
		},
		{
			MethodName: "Commit",
			Handler:    _Query_Commit_Handler,
		},
		{
			MethodName: "Rollback",
			Handler:    _Query_Rollback_Handler,
		},
		{
			MethodName: "SplitQuery",
			Handler:    _Query_SplitQuery_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamExecute",
			Handler:       _Query_StreamExecute_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamHealth",
			Handler:       _Query_StreamHealth_Handler,
			ServerStreams: true,
		},
	},
}

var fileDescriptor0 = []byte{
	// 281 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x6c, 0x92, 0xdd, 0x4a, 0xc3, 0x40,
	0x10, 0x85, 0x15, 0x6c, 0x95, 0x31, 0xde, 0x8c, 0xd6, 0x9f, 0xe8, 0x95, 0x0f, 0x50, 0x44, 0x05,
	0x41, 0xf0, 0xa6, 0x45, 0xb4, 0x08, 0x82, 0xcd, 0x13, 0xa4, 0x71, 0xd0, 0xc5, 0x24, 0x1b, 0xb3,
	0x53, 0xd1, 0x47, 0xf6, 0x2d, 0xac, 0xd9, 0xcc, 0x26, 0xd9, 0xe6, 0x72, 0xbe, 0x33, 0xe7, 0x70,
	0xb2, 0x13, 0xc0, 0xcf, 0x25, 0x95, 0x3f, 0x86, 0xca, 0x2f, 0x95, 0xd0, 0xb8, 0x28, 0x35, 0x6b,
	0x0c, 0xda, 0x2c, 0xdc, 0xad, 0x26, 0x2b, 0x5d, 0xfe, 0x6e, 0xc1, 0xe0, 0xe5, 0x7f, 0xc6, 0x19,
	0x04, 0x0f, 0xc4, 0x11, 0x19, 0xa3, 0x74, 0x3e, 0x7b, 0xc5, 0x70, 0x6c, 0xf7, 0xda, 0x70, 0x4e,
	0x2b, 0x66, 0x38, 0x3c, 0xed, 0xd5, 0x4c, 0xa1, 0x73, 0x43, 0xe7, 0x1b, 0x78, 0x0b, 0xdb, 0xf7,
	0xdf, 0x94, 0x2c, 0x99, 0x70, 0x54, 0x6f, 0xd6, 0xb3, 0x04, 0x1c, 0xfa, 0xd8, 0x79, 0x57, 0x35,
	0x6a, 0x38, 0x89, 0x39, 0x79, 0x77, 0x35, 0xda, 0xd0, 0xaf, 0xd1, 0xd5, 0x5c, 0xd4, 0x33, 0xec,
	0x45, 0x5c, 0x52, 0x9c, 0x49, 0x19, 0xd9, 0xef, 0x50, 0x09, 0x3b, 0xeb, 0x17, 0x25, 0xed, 0x62,
	0x13, 0xaf, 0x61, 0x30, 0xa1, 0x37, 0x95, 0xe3, 0x7e, 0xbd, 0x5a, 0x4d, 0xe2, 0x3f, 0xe8, 0x42,
	0xd7, 0xe2, 0x06, 0x86, 0x53, 0x9d, 0x65, 0x8a, 0x51, 0x36, 0xec, 0x28, 0xbe, 0x91, 0x47, 0x9d,
	0xf1, 0x0e, 0x76, 0xe6, 0x3a, 0x4d, 0x17, 0x71, 0xf2, 0x81, 0xf2, 0x5e, 0x02, 0xc4, 0x7c, 0xb4,
	0xc6, 0x9d, 0x7d, 0x0a, 0x10, 0x15, 0xa9, 0x62, 0x7b, 0xdd, 0x63, 0xf9, 0x3a, 0x87, 0x24, 0xe2,
	0xa4, 0x47, 0x71, 0x21, 0x4f, 0x10, 0xd8, 0xf7, 0x78, 0xa4, 0x38, 0xe5, 0xe6, 0x1a, 0x6d, 0xe8,
	0x5f, 0xa3, 0xab, 0x35, 0xef, 0xb7, 0x18, 0x56, 0xbf, 0xdc, 0xd5, 0x5f, 0x00, 0x00, 0x00, 0xff,
	0xff, 0xb4, 0x5c, 0x99, 0x9c, 0xa3, 0x02, 0x00, 0x00,
}
