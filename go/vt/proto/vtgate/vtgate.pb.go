// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: vtgate.proto

package vtgate

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	proto "github.com/golang/protobuf/proto"
	binlogdata "vitess.io/vitess/go/vt/proto/binlogdata"
	query "vitess.io/vitess/go/vt/proto/query"
	topodata "vitess.io/vitess/go/vt/proto/topodata"
	vtrpc "vitess.io/vitess/go/vt/proto/vtrpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// TransactionMode controls the execution of distributed transaction
// across multiple shards.
type TransactionMode int32

const (
	// UNSPECIFIED uses the transaction mode set by the VTGate flag 'transaction_mode'.
	TransactionMode_UNSPECIFIED TransactionMode = 0
	// SINGLE disallows distributed transactions.
	TransactionMode_SINGLE TransactionMode = 1
	// MULTI allows distributed transactions with best effort commit.
	TransactionMode_MULTI TransactionMode = 2
	// TWOPC is for distributed transactions with atomic commits.
	TransactionMode_TWOPC TransactionMode = 3
)

var TransactionMode_name = map[int32]string{
	0: "UNSPECIFIED",
	1: "SINGLE",
	2: "MULTI",
	3: "TWOPC",
}

var TransactionMode_value = map[string]int32{
	"UNSPECIFIED": 0,
	"SINGLE":      1,
	"MULTI":       2,
	"TWOPC":       3,
}

func (x TransactionMode) String() string {
	return proto.EnumName(TransactionMode_name, int32(x))
}

func (TransactionMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{0}
}

// CommitOrder is used to designate which of the ShardSessions
// get used for transactions.
type CommitOrder int32

const (
	// NORMAL is the default commit order.
	CommitOrder_NORMAL CommitOrder = 0
	// PRE is used to designate pre_sessions.
	CommitOrder_PRE CommitOrder = 1
	// POST is used to designate post_sessions.
	CommitOrder_POST CommitOrder = 2
	// AUTOCOMMIT is used to run the statement as autocommitted transaction.
	CommitOrder_AUTOCOMMIT CommitOrder = 3
)

var CommitOrder_name = map[int32]string{
	0: "NORMAL",
	1: "PRE",
	2: "POST",
	3: "AUTOCOMMIT",
}

var CommitOrder_value = map[string]int32{
	"NORMAL":     0,
	"PRE":        1,
	"POST":       2,
	"AUTOCOMMIT": 3,
}

func (x CommitOrder) String() string {
	return proto.EnumName(CommitOrder_name, int32(x))
}

func (CommitOrder) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{1}
}

// Session objects are exchanged like cookies through various
// calls to VTGate. The behavior differs between V2 & V3 APIs.
// V3 APIs are Execute, ExecuteBatch and StreamExecute. All
// other APIs are V2. For the V3 APIs, the session
// must be sent with every call to Execute or ExecuteBatch.
// For the V2 APIs, Begin does not accept a session. It instead
// returns a brand new one with in_transaction set to true.
// After a call to Commit or Rollback, the session can be
// discarded. If you're not in a transaction, Session is
// an optional parameter for the V2 APIs.
type Session struct {
	// in_transaction is set to true if the session is in a transaction.
	InTransaction bool `protobuf:"varint,1,opt,name=in_transaction,json=inTransaction,proto3" json:"in_transaction,omitempty"`
	// shard_sessions keep track of per-shard transaction info.
	ShardSessions []*Session_ShardSession `protobuf:"bytes,2,rep,name=shard_sessions,json=shardSessions,proto3" json:"shard_sessions,omitempty"`
	// autocommit specifies if the session is in autocommit mode.
	// This is used only for V3.
	Autocommit bool `protobuf:"varint,4,opt,name=autocommit,proto3" json:"autocommit,omitempty"`
	// target_string is the target expressed as a string. Valid
	// names are: keyspace:shard@target, keyspace@target or @target.
	// This is used only for V3.
	TargetString string `protobuf:"bytes,5,opt,name=target_string,json=targetString,proto3" json:"target_string,omitempty"`
	// options is used only for V3.
	Options *query.ExecuteOptions `protobuf:"bytes,6,opt,name=options,proto3" json:"options,omitempty"`
	// transaction_mode specifies the current transaction mode.
	TransactionMode TransactionMode `protobuf:"varint,7,opt,name=transaction_mode,json=transactionMode,proto3,enum=vtgate.TransactionMode" json:"transaction_mode,omitempty"`
	// warnings contains non-fatal warnings from the previous query
	Warnings []*query.QueryWarning `protobuf:"bytes,8,rep,name=warnings,proto3" json:"warnings,omitempty"`
	// pre_sessions contains sessions that have to be committed first.
	PreSessions []*Session_ShardSession `protobuf:"bytes,9,rep,name=pre_sessions,json=preSessions,proto3" json:"pre_sessions,omitempty"`
	// post_sessions contains sessions that have to be committed last.
	PostSessions []*Session_ShardSession `protobuf:"bytes,10,rep,name=post_sessions,json=postSessions,proto3" json:"post_sessions,omitempty"`
	// last_insert_id keeps track of the last seen insert_id for this session
	LastInsertId uint64 `protobuf:"varint,11,opt,name=last_insert_id,json=lastInsertId,proto3" json:"last_insert_id,omitempty"`
	// found_rows keeps track of how many rows the last query returned
	FoundRows uint64 `protobuf:"varint,12,opt,name=found_rows,json=foundRows,proto3" json:"found_rows,omitempty"`
	// user_defined_variables contains all the @variables defined for this session
	UserDefinedVariables map[string]*query.BindVariable `protobuf:"bytes,13,rep,name=user_defined_variables,json=userDefinedVariables,proto3" json:"user_defined_variables,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// system_variables keeps track of all session variables set for this connection
	// TODO: systay should we keep this so we can apply it ordered?
	SystemVariables map[string]string `protobuf:"bytes,14,rep,name=system_variables,json=systemVariables,proto3" json:"system_variables,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// row_count keeps track of the last seen rows affected for this session
	RowCount int64 `protobuf:"varint,15,opt,name=row_count,json=rowCount,proto3" json:"row_count,omitempty"`
	// Stores savepoint and release savepoint calls inside a transaction
	// and is reset once transaction is committed or rolled back.
	Savepoints []string `protobuf:"bytes,16,rep,name=savepoints,proto3" json:"savepoints,omitempty"`
	// in_reserved_conn is set to true if the session should be using reserved connections.
	InReservedConn bool `protobuf:"varint,17,opt,name=in_reserved_conn,json=inReservedConn,proto3" json:"in_reserved_conn,omitempty"`
	// lock_session keep tracks of shard on which the lock query is sent.
	LockSession *Session_ShardSession `protobuf:"bytes,18,opt,name=lock_session,json=lockSession,proto3" json:"lock_session,omitempty"`
	// last_lock_heartbeat keep tracks of when last lock heartbeat was sent.
	LastLockHeartbeat int64 `protobuf:"varint,19,opt,name=last_lock_heartbeat,json=lastLockHeartbeat,proto3" json:"last_lock_heartbeat,omitempty"`
	// read_after_write tracks the ReadAfterWrite settings for this session.
	ReadAfterWrite *ReadAfterWrite `protobuf:"bytes,20,opt,name=read_after_write,json=readAfterWrite,proto3" json:"read_after_write,omitempty"`
	// DDL strategy
	DDLStrategy string `protobuf:"bytes,21,opt,name=DDLStrategy,proto3" json:"DDLStrategy,omitempty"`
	// Session UUID
	SessionUUID string `protobuf:"bytes,22,opt,name=SessionUUID,proto3" json:"SessionUUID,omitempty"`
	// enable_system_settings defines if we can use reserved connections.
	EnableSystemSettings bool     `protobuf:"varint,23,opt,name=enable_system_settings,json=enableSystemSettings,proto3" json:"enable_system_settings,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Session) Reset()         { *m = Session{} }
func (m *Session) String() string { return proto.CompactTextString(m) }
func (*Session) ProtoMessage()    {}
func (*Session) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{0}
}
func (m *Session) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Session) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Session.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Session) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Session.Merge(m, src)
}
func (m *Session) XXX_Size() int {
	return m.Size()
}
func (m *Session) XXX_DiscardUnknown() {
	xxx_messageInfo_Session.DiscardUnknown(m)
}

var xxx_messageInfo_Session proto.InternalMessageInfo

func (m *Session) GetInTransaction() bool {
	if m != nil {
		return m.InTransaction
	}
	return false
}

func (m *Session) GetShardSessions() []*Session_ShardSession {
	if m != nil {
		return m.ShardSessions
	}
	return nil
}

func (m *Session) GetAutocommit() bool {
	if m != nil {
		return m.Autocommit
	}
	return false
}

func (m *Session) GetTargetString() string {
	if m != nil {
		return m.TargetString
	}
	return ""
}

func (m *Session) GetOptions() *query.ExecuteOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *Session) GetTransactionMode() TransactionMode {
	if m != nil {
		return m.TransactionMode
	}
	return TransactionMode_UNSPECIFIED
}

func (m *Session) GetWarnings() []*query.QueryWarning {
	if m != nil {
		return m.Warnings
	}
	return nil
}

func (m *Session) GetPreSessions() []*Session_ShardSession {
	if m != nil {
		return m.PreSessions
	}
	return nil
}

func (m *Session) GetPostSessions() []*Session_ShardSession {
	if m != nil {
		return m.PostSessions
	}
	return nil
}

func (m *Session) GetLastInsertId() uint64 {
	if m != nil {
		return m.LastInsertId
	}
	return 0
}

func (m *Session) GetFoundRows() uint64 {
	if m != nil {
		return m.FoundRows
	}
	return 0
}

func (m *Session) GetUserDefinedVariables() map[string]*query.BindVariable {
	if m != nil {
		return m.UserDefinedVariables
	}
	return nil
}

func (m *Session) GetSystemVariables() map[string]string {
	if m != nil {
		return m.SystemVariables
	}
	return nil
}

func (m *Session) GetRowCount() int64 {
	if m != nil {
		return m.RowCount
	}
	return 0
}

func (m *Session) GetSavepoints() []string {
	if m != nil {
		return m.Savepoints
	}
	return nil
}

func (m *Session) GetInReservedConn() bool {
	if m != nil {
		return m.InReservedConn
	}
	return false
}

func (m *Session) GetLockSession() *Session_ShardSession {
	if m != nil {
		return m.LockSession
	}
	return nil
}

func (m *Session) GetLastLockHeartbeat() int64 {
	if m != nil {
		return m.LastLockHeartbeat
	}
	return 0
}

func (m *Session) GetReadAfterWrite() *ReadAfterWrite {
	if m != nil {
		return m.ReadAfterWrite
	}
	return nil
}

func (m *Session) GetDDLStrategy() string {
	if m != nil {
		return m.DDLStrategy
	}
	return ""
}

func (m *Session) GetSessionUUID() string {
	if m != nil {
		return m.SessionUUID
	}
	return ""
}

func (m *Session) GetEnableSystemSettings() bool {
	if m != nil {
		return m.EnableSystemSettings
	}
	return false
}

type Session_ShardSession struct {
	Target        *query.Target         `protobuf:"bytes,1,opt,name=target,proto3" json:"target,omitempty"`
	TransactionId int64                 `protobuf:"varint,2,opt,name=transaction_id,json=transactionId,proto3" json:"transaction_id,omitempty"`
	TabletAlias   *topodata.TabletAlias `protobuf:"bytes,3,opt,name=tablet_alias,json=tabletAlias,proto3" json:"tablet_alias,omitempty"`
	// reserved connection if a dedicated connection is needed
	ReservedId           int64    `protobuf:"varint,4,opt,name=reserved_id,json=reservedId,proto3" json:"reserved_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Session_ShardSession) Reset()         { *m = Session_ShardSession{} }
func (m *Session_ShardSession) String() string { return proto.CompactTextString(m) }
func (*Session_ShardSession) ProtoMessage()    {}
func (*Session_ShardSession) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{0, 0}
}
func (m *Session_ShardSession) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Session_ShardSession) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Session_ShardSession.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Session_ShardSession) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Session_ShardSession.Merge(m, src)
}
func (m *Session_ShardSession) XXX_Size() int {
	return m.Size()
}
func (m *Session_ShardSession) XXX_DiscardUnknown() {
	xxx_messageInfo_Session_ShardSession.DiscardUnknown(m)
}

var xxx_messageInfo_Session_ShardSession proto.InternalMessageInfo

func (m *Session_ShardSession) GetTarget() *query.Target {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *Session_ShardSession) GetTransactionId() int64 {
	if m != nil {
		return m.TransactionId
	}
	return 0
}

func (m *Session_ShardSession) GetTabletAlias() *topodata.TabletAlias {
	if m != nil {
		return m.TabletAlias
	}
	return nil
}

func (m *Session_ShardSession) GetReservedId() int64 {
	if m != nil {
		return m.ReservedId
	}
	return 0
}

// ReadAfterWrite contains information regarding gtid set and timeout
// Also if the gtid information needs to be passed to client.
type ReadAfterWrite struct {
	ReadAfterWriteGtid    string   `protobuf:"bytes,1,opt,name=read_after_write_gtid,json=readAfterWriteGtid,proto3" json:"read_after_write_gtid,omitempty"`
	ReadAfterWriteTimeout float64  `protobuf:"fixed64,2,opt,name=read_after_write_timeout,json=readAfterWriteTimeout,proto3" json:"read_after_write_timeout,omitempty"`
	SessionTrackGtids     bool     `protobuf:"varint,3,opt,name=session_track_gtids,json=sessionTrackGtids,proto3" json:"session_track_gtids,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *ReadAfterWrite) Reset()         { *m = ReadAfterWrite{} }
func (m *ReadAfterWrite) String() string { return proto.CompactTextString(m) }
func (*ReadAfterWrite) ProtoMessage()    {}
func (*ReadAfterWrite) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{1}
}
func (m *ReadAfterWrite) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadAfterWrite) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadAfterWrite.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadAfterWrite) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadAfterWrite.Merge(m, src)
}
func (m *ReadAfterWrite) XXX_Size() int {
	return m.Size()
}
func (m *ReadAfterWrite) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadAfterWrite.DiscardUnknown(m)
}

var xxx_messageInfo_ReadAfterWrite proto.InternalMessageInfo

func (m *ReadAfterWrite) GetReadAfterWriteGtid() string {
	if m != nil {
		return m.ReadAfterWriteGtid
	}
	return ""
}

func (m *ReadAfterWrite) GetReadAfterWriteTimeout() float64 {
	if m != nil {
		return m.ReadAfterWriteTimeout
	}
	return 0
}

func (m *ReadAfterWrite) GetSessionTrackGtids() bool {
	if m != nil {
		return m.SessionTrackGtids
	}
	return false
}

// ExecuteRequest is the payload to Execute.
type ExecuteRequest struct {
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"caller_id,omitempty"`
	// session carries the session state.
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// query is the query and bind variables to execute.
	Query *query.BoundQuery `protobuf:"bytes,3,opt,name=query,proto3" json:"query,omitempty"`
	// These values are deprecated. Use session instead.
	// TODO(sougou): remove in 3.1
	TabletType           topodata.TabletType   `protobuf:"varint,4,opt,name=tablet_type,json=tabletType,proto3,enum=topodata.TabletType" json:"tablet_type,omitempty"`
	KeyspaceShard        string                `protobuf:"bytes,6,opt,name=keyspace_shard,json=keyspaceShard,proto3" json:"keyspace_shard,omitempty"`
	Options              *query.ExecuteOptions `protobuf:"bytes,7,opt,name=options,proto3" json:"options,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *ExecuteRequest) Reset()         { *m = ExecuteRequest{} }
func (m *ExecuteRequest) String() string { return proto.CompactTextString(m) }
func (*ExecuteRequest) ProtoMessage()    {}
func (*ExecuteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{2}
}
func (m *ExecuteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecuteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecuteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecuteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecuteRequest.Merge(m, src)
}
func (m *ExecuteRequest) XXX_Size() int {
	return m.Size()
}
func (m *ExecuteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecuteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ExecuteRequest proto.InternalMessageInfo

func (m *ExecuteRequest) GetCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.CallerId
	}
	return nil
}

func (m *ExecuteRequest) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *ExecuteRequest) GetQuery() *query.BoundQuery {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *ExecuteRequest) GetTabletType() topodata.TabletType {
	if m != nil {
		return m.TabletType
	}
	return topodata.TabletType_UNKNOWN
}

func (m *ExecuteRequest) GetKeyspaceShard() string {
	if m != nil {
		return m.KeyspaceShard
	}
	return ""
}

func (m *ExecuteRequest) GetOptions() *query.ExecuteOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

// ExecuteResponse is the returned value from Execute.
type ExecuteResponse struct {
	// error contains an application level error if necessary. Note the
	// session may have changed, even when an error is returned (for
	// instance if a database integrity error happened).
	Error *vtrpc.RPCError `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	// session is the updated session information.
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// result contains the query result, only set if error is unset.
	Result               *query.QueryResult `protobuf:"bytes,3,opt,name=result,proto3" json:"result,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *ExecuteResponse) Reset()         { *m = ExecuteResponse{} }
func (m *ExecuteResponse) String() string { return proto.CompactTextString(m) }
func (*ExecuteResponse) ProtoMessage()    {}
func (*ExecuteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{3}
}
func (m *ExecuteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecuteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecuteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecuteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecuteResponse.Merge(m, src)
}
func (m *ExecuteResponse) XXX_Size() int {
	return m.Size()
}
func (m *ExecuteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecuteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ExecuteResponse proto.InternalMessageInfo

func (m *ExecuteResponse) GetError() *vtrpc.RPCError {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *ExecuteResponse) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *ExecuteResponse) GetResult() *query.QueryResult {
	if m != nil {
		return m.Result
	}
	return nil
}

// ExecuteBatchRequest is the payload to ExecuteBatch.
type ExecuteBatchRequest struct {
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"caller_id,omitempty"`
	// session carries the session state.
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// queries is a list of query and bind variables to execute.
	Queries []*query.BoundQuery `protobuf:"bytes,3,rep,name=queries,proto3" json:"queries,omitempty"`
	// These values are deprecated. Use session instead.
	// TODO(sougou): remove in 3.1
	TabletType           topodata.TabletType   `protobuf:"varint,4,opt,name=tablet_type,json=tabletType,proto3,enum=topodata.TabletType" json:"tablet_type,omitempty"`
	AsTransaction        bool                  `protobuf:"varint,5,opt,name=as_transaction,json=asTransaction,proto3" json:"as_transaction,omitempty"`
	KeyspaceShard        string                `protobuf:"bytes,6,opt,name=keyspace_shard,json=keyspaceShard,proto3" json:"keyspace_shard,omitempty"`
	Options              *query.ExecuteOptions `protobuf:"bytes,7,opt,name=options,proto3" json:"options,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *ExecuteBatchRequest) Reset()         { *m = ExecuteBatchRequest{} }
func (m *ExecuteBatchRequest) String() string { return proto.CompactTextString(m) }
func (*ExecuteBatchRequest) ProtoMessage()    {}
func (*ExecuteBatchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{4}
}
func (m *ExecuteBatchRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecuteBatchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecuteBatchRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecuteBatchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecuteBatchRequest.Merge(m, src)
}
func (m *ExecuteBatchRequest) XXX_Size() int {
	return m.Size()
}
func (m *ExecuteBatchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecuteBatchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ExecuteBatchRequest proto.InternalMessageInfo

func (m *ExecuteBatchRequest) GetCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.CallerId
	}
	return nil
}

func (m *ExecuteBatchRequest) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *ExecuteBatchRequest) GetQueries() []*query.BoundQuery {
	if m != nil {
		return m.Queries
	}
	return nil
}

func (m *ExecuteBatchRequest) GetTabletType() topodata.TabletType {
	if m != nil {
		return m.TabletType
	}
	return topodata.TabletType_UNKNOWN
}

func (m *ExecuteBatchRequest) GetAsTransaction() bool {
	if m != nil {
		return m.AsTransaction
	}
	return false
}

func (m *ExecuteBatchRequest) GetKeyspaceShard() string {
	if m != nil {
		return m.KeyspaceShard
	}
	return ""
}

func (m *ExecuteBatchRequest) GetOptions() *query.ExecuteOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

// ExecuteBatchResponse is the returned value from ExecuteBatch.
type ExecuteBatchResponse struct {
	// error contains an application level error if necessary. Note the
	// session may have changed, even when an error is returned (for
	// instance if a database integrity error happened).
	Error *vtrpc.RPCError `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	// session is the updated session information.
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// results contains the query results, only set if application level error is unset.
	Results              []*query.ResultWithError `protobuf:"bytes,3,rep,name=results,proto3" json:"results,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *ExecuteBatchResponse) Reset()         { *m = ExecuteBatchResponse{} }
func (m *ExecuteBatchResponse) String() string { return proto.CompactTextString(m) }
func (*ExecuteBatchResponse) ProtoMessage()    {}
func (*ExecuteBatchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{5}
}
func (m *ExecuteBatchResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecuteBatchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecuteBatchResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecuteBatchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecuteBatchResponse.Merge(m, src)
}
func (m *ExecuteBatchResponse) XXX_Size() int {
	return m.Size()
}
func (m *ExecuteBatchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecuteBatchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ExecuteBatchResponse proto.InternalMessageInfo

func (m *ExecuteBatchResponse) GetError() *vtrpc.RPCError {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *ExecuteBatchResponse) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *ExecuteBatchResponse) GetResults() []*query.ResultWithError {
	if m != nil {
		return m.Results
	}
	return nil
}

// StreamExecuteRequest is the payload to StreamExecute.
type StreamExecuteRequest struct {
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"caller_id,omitempty"`
	// query is the query and bind variables to execute.
	Query *query.BoundQuery `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
	// These values are deprecated. Use session instead.
	// TODO(sougou): remove in 3.1
	TabletType    topodata.TabletType   `protobuf:"varint,3,opt,name=tablet_type,json=tabletType,proto3,enum=topodata.TabletType" json:"tablet_type,omitempty"`
	KeyspaceShard string                `protobuf:"bytes,4,opt,name=keyspace_shard,json=keyspaceShard,proto3" json:"keyspace_shard,omitempty"`
	Options       *query.ExecuteOptions `protobuf:"bytes,5,opt,name=options,proto3" json:"options,omitempty"`
	// session carries the session state.
	Session              *Session `protobuf:"bytes,6,opt,name=session,proto3" json:"session,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StreamExecuteRequest) Reset()         { *m = StreamExecuteRequest{} }
func (m *StreamExecuteRequest) String() string { return proto.CompactTextString(m) }
func (*StreamExecuteRequest) ProtoMessage()    {}
func (*StreamExecuteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{6}
}
func (m *StreamExecuteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamExecuteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamExecuteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamExecuteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamExecuteRequest.Merge(m, src)
}
func (m *StreamExecuteRequest) XXX_Size() int {
	return m.Size()
}
func (m *StreamExecuteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamExecuteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StreamExecuteRequest proto.InternalMessageInfo

func (m *StreamExecuteRequest) GetCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.CallerId
	}
	return nil
}

func (m *StreamExecuteRequest) GetQuery() *query.BoundQuery {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *StreamExecuteRequest) GetTabletType() topodata.TabletType {
	if m != nil {
		return m.TabletType
	}
	return topodata.TabletType_UNKNOWN
}

func (m *StreamExecuteRequest) GetKeyspaceShard() string {
	if m != nil {
		return m.KeyspaceShard
	}
	return ""
}

func (m *StreamExecuteRequest) GetOptions() *query.ExecuteOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *StreamExecuteRequest) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

// StreamExecuteResponse is the returned value from StreamExecute.
// The session is currently not returned because StreamExecute is
// not expected to modify it.
type StreamExecuteResponse struct {
	// result contains the result data.
	// The first value contains only Fields information.
	// The next values contain the actual rows, a few values per result.
	Result               *query.QueryResult `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *StreamExecuteResponse) Reset()         { *m = StreamExecuteResponse{} }
func (m *StreamExecuteResponse) String() string { return proto.CompactTextString(m) }
func (*StreamExecuteResponse) ProtoMessage()    {}
func (*StreamExecuteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{7}
}
func (m *StreamExecuteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamExecuteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamExecuteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamExecuteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamExecuteResponse.Merge(m, src)
}
func (m *StreamExecuteResponse) XXX_Size() int {
	return m.Size()
}
func (m *StreamExecuteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamExecuteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StreamExecuteResponse proto.InternalMessageInfo

func (m *StreamExecuteResponse) GetResult() *query.QueryResult {
	if m != nil {
		return m.Result
	}
	return nil
}

// ResolveTransactionRequest is the payload to ResolveTransaction.
type ResolveTransactionRequest struct {
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"caller_id,omitempty"`
	// dtid is the dtid of the transaction to be resolved.
	Dtid                 string   `protobuf:"bytes,2,opt,name=dtid,proto3" json:"dtid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResolveTransactionRequest) Reset()         { *m = ResolveTransactionRequest{} }
func (m *ResolveTransactionRequest) String() string { return proto.CompactTextString(m) }
func (*ResolveTransactionRequest) ProtoMessage()    {}
func (*ResolveTransactionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{8}
}
func (m *ResolveTransactionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResolveTransactionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResolveTransactionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResolveTransactionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResolveTransactionRequest.Merge(m, src)
}
func (m *ResolveTransactionRequest) XXX_Size() int {
	return m.Size()
}
func (m *ResolveTransactionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ResolveTransactionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ResolveTransactionRequest proto.InternalMessageInfo

func (m *ResolveTransactionRequest) GetCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.CallerId
	}
	return nil
}

func (m *ResolveTransactionRequest) GetDtid() string {
	if m != nil {
		return m.Dtid
	}
	return ""
}

// ResolveTransactionResponse is the returned value from Rollback.
type ResolveTransactionResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResolveTransactionResponse) Reset()         { *m = ResolveTransactionResponse{} }
func (m *ResolveTransactionResponse) String() string { return proto.CompactTextString(m) }
func (*ResolveTransactionResponse) ProtoMessage()    {}
func (*ResolveTransactionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{9}
}
func (m *ResolveTransactionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResolveTransactionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResolveTransactionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResolveTransactionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResolveTransactionResponse.Merge(m, src)
}
func (m *ResolveTransactionResponse) XXX_Size() int {
	return m.Size()
}
func (m *ResolveTransactionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ResolveTransactionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ResolveTransactionResponse proto.InternalMessageInfo

type VStreamFlags struct {
	MinimizeSkew         bool     `protobuf:"varint,1,opt,name=minimize_skew,json=minimizeSkew,proto3" json:"minimize_skew,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VStreamFlags) Reset()         { *m = VStreamFlags{} }
func (m *VStreamFlags) String() string { return proto.CompactTextString(m) }
func (*VStreamFlags) ProtoMessage()    {}
func (*VStreamFlags) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{10}
}
func (m *VStreamFlags) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VStreamFlags) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VStreamFlags.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VStreamFlags) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VStreamFlags.Merge(m, src)
}
func (m *VStreamFlags) XXX_Size() int {
	return m.Size()
}
func (m *VStreamFlags) XXX_DiscardUnknown() {
	xxx_messageInfo_VStreamFlags.DiscardUnknown(m)
}

var xxx_messageInfo_VStreamFlags proto.InternalMessageInfo

func (m *VStreamFlags) GetMinimizeSkew() bool {
	if m != nil {
		return m.MinimizeSkew
	}
	return false
}

// VStreamRequest is the payload for VStream.
type VStreamRequest struct {
	CallerId   *vtrpc.CallerID     `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"caller_id,omitempty"`
	TabletType topodata.TabletType `protobuf:"varint,2,opt,name=tablet_type,json=tabletType,proto3,enum=topodata.TabletType" json:"tablet_type,omitempty"`
	// position specifies the starting point of the bin log positions
	// as well as the keyspace-shards to pull events from.
	// position is of the form 'ks1:0@MySQL56/<mysql_pos>|ks2:-80@MySQL56/<mysql_pos>'.
	Vgtid                *binlogdata.VGtid  `protobuf:"bytes,3,opt,name=vgtid,proto3" json:"vgtid,omitempty"`
	Filter               *binlogdata.Filter `protobuf:"bytes,4,opt,name=filter,proto3" json:"filter,omitempty"`
	Flags                *VStreamFlags      `protobuf:"bytes,5,opt,name=flags,proto3" json:"flags,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *VStreamRequest) Reset()         { *m = VStreamRequest{} }
func (m *VStreamRequest) String() string { return proto.CompactTextString(m) }
func (*VStreamRequest) ProtoMessage()    {}
func (*VStreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{11}
}
func (m *VStreamRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VStreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VStreamRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VStreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VStreamRequest.Merge(m, src)
}
func (m *VStreamRequest) XXX_Size() int {
	return m.Size()
}
func (m *VStreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VStreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VStreamRequest proto.InternalMessageInfo

func (m *VStreamRequest) GetCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.CallerId
	}
	return nil
}

func (m *VStreamRequest) GetTabletType() topodata.TabletType {
	if m != nil {
		return m.TabletType
	}
	return topodata.TabletType_UNKNOWN
}

func (m *VStreamRequest) GetVgtid() *binlogdata.VGtid {
	if m != nil {
		return m.Vgtid
	}
	return nil
}

func (m *VStreamRequest) GetFilter() *binlogdata.Filter {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *VStreamRequest) GetFlags() *VStreamFlags {
	if m != nil {
		return m.Flags
	}
	return nil
}

// VStreamResponse is streamed by VStream.
type VStreamResponse struct {
	Events               []*binlogdata.VEvent `protobuf:"bytes,1,rep,name=events,proto3" json:"events,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *VStreamResponse) Reset()         { *m = VStreamResponse{} }
func (m *VStreamResponse) String() string { return proto.CompactTextString(m) }
func (*VStreamResponse) ProtoMessage()    {}
func (*VStreamResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{12}
}
func (m *VStreamResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VStreamResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VStreamResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VStreamResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VStreamResponse.Merge(m, src)
}
func (m *VStreamResponse) XXX_Size() int {
	return m.Size()
}
func (m *VStreamResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VStreamResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VStreamResponse proto.InternalMessageInfo

func (m *VStreamResponse) GetEvents() []*binlogdata.VEvent {
	if m != nil {
		return m.Events
	}
	return nil
}

func init() {
	proto.RegisterEnum("vtgate.TransactionMode", TransactionMode_name, TransactionMode_value)
	proto.RegisterEnum("vtgate.CommitOrder", CommitOrder_name, CommitOrder_value)
	proto.RegisterType((*Session)(nil), "vtgate.Session")
	proto.RegisterMapType((map[string]string)(nil), "vtgate.Session.SystemVariablesEntry")
	proto.RegisterMapType((map[string]*query.BindVariable)(nil), "vtgate.Session.UserDefinedVariablesEntry")
	proto.RegisterType((*Session_ShardSession)(nil), "vtgate.Session.ShardSession")
	proto.RegisterType((*ReadAfterWrite)(nil), "vtgate.ReadAfterWrite")
	proto.RegisterType((*ExecuteRequest)(nil), "vtgate.ExecuteRequest")
	proto.RegisterType((*ExecuteResponse)(nil), "vtgate.ExecuteResponse")
	proto.RegisterType((*ExecuteBatchRequest)(nil), "vtgate.ExecuteBatchRequest")
	proto.RegisterType((*ExecuteBatchResponse)(nil), "vtgate.ExecuteBatchResponse")
	proto.RegisterType((*StreamExecuteRequest)(nil), "vtgate.StreamExecuteRequest")
	proto.RegisterType((*StreamExecuteResponse)(nil), "vtgate.StreamExecuteResponse")
	proto.RegisterType((*ResolveTransactionRequest)(nil), "vtgate.ResolveTransactionRequest")
	proto.RegisterType((*ResolveTransactionResponse)(nil), "vtgate.ResolveTransactionResponse")
	proto.RegisterType((*VStreamFlags)(nil), "vtgate.VStreamFlags")
	proto.RegisterType((*VStreamRequest)(nil), "vtgate.VStreamRequest")
	proto.RegisterType((*VStreamResponse)(nil), "vtgate.VStreamResponse")
}

func init() { proto.RegisterFile("vtgate.proto", fileDescriptor_aab96496ceaf1ebb) }

var fileDescriptor_aab96496ceaf1ebb = []byte{
	// 1454 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x57, 0xdd, 0x6e, 0x1b, 0xb7,
	0x12, 0xce, 0xea, 0x5f, 0xa3, 0xbf, 0x35, 0x2d, 0x3b, 0x1b, 0x9f, 0x1c, 0x1f, 0x41, 0x49, 0x10,
	0xc5, 0xa7, 0xb0, 0x5b, 0xa7, 0x45, 0x83, 0xa2, 0x45, 0x6b, 0xcb, 0x76, 0xaa, 0xc0, 0x8e, 0x5c,
	0x4a, 0xb6, 0x81, 0xa2, 0xc5, 0x62, 0xad, 0xa5, 0x65, 0xc2, 0xd2, 0xae, 0x42, 0x52, 0x52, 0xd5,
	0x97, 0xe8, 0x6d, 0xd1, 0x17, 0xe8, 0x4d, 0xef, 0xfb, 0x0a, 0xbd, 0x6c, 0xde, 0xa0, 0x48, 0xdf,
	0xa1, 0xd7, 0x05, 0xb9, 0x5c, 0x79, 0xa5, 0xb8, 0x8d, 0x93, 0x20, 0x37, 0x82, 0x38, 0xdf, 0x70,
	0x38, 0xfc, 0xbe, 0x19, 0x92, 0x0b, 0xf9, 0x91, 0xe8, 0x3a, 0x82, 0xac, 0x0f, 0x98, 0x2f, 0x7c,
	0x94, 0x0a, 0x46, 0x2b, 0xe6, 0x29, 0xf5, 0x7a, 0x7e, 0xd7, 0x75, 0x84, 0x13, 0x20, 0x2b, 0xb9,
	0x67, 0x43, 0xc2, 0x26, 0x7a, 0x50, 0x14, 0xfe, 0xc0, 0x8f, 0x82, 0x23, 0xc1, 0x06, 0x9d, 0x60,
	0x50, 0x7d, 0x9e, 0x83, 0x74, 0x8b, 0x70, 0x4e, 0x7d, 0x0f, 0xdd, 0x83, 0x22, 0xf5, 0x6c, 0xc1,
	0x1c, 0x8f, 0x3b, 0x1d, 0x41, 0x7d, 0xcf, 0x32, 0x2a, 0x46, 0x2d, 0x83, 0x0b, 0xd4, 0x6b, 0x5f,
	0x1a, 0x51, 0x1d, 0x8a, 0xfc, 0xdc, 0x61, 0xae, 0xcd, 0x83, 0x79, 0xdc, 0x8a, 0x55, 0xe2, 0xb5,
	0xdc, 0xe6, 0xed, 0x75, 0x9d, 0x9d, 0x8e, 0xb7, 0xde, 0x92, 0x5e, 0x7a, 0x80, 0x0b, 0x3c, 0x32,
	0xe2, 0x68, 0x15, 0xc0, 0x19, 0x0a, 0xbf, 0xe3, 0xf7, 0xfb, 0x54, 0x58, 0x09, 0xb5, 0x4e, 0xc4,
	0x82, 0xee, 0x40, 0x41, 0x38, 0xac, 0x4b, 0x84, 0xcd, 0x05, 0xa3, 0x5e, 0xd7, 0x4a, 0x56, 0x8c,
	0x5a, 0x16, 0xe7, 0x03, 0x63, 0x4b, 0xd9, 0xd0, 0x06, 0xa4, 0xfd, 0x81, 0x50, 0x29, 0xa4, 0x2a,
	0x46, 0x2d, 0xb7, 0xb9, 0xb4, 0x1e, 0x6c, 0x7c, 0xf7, 0x3b, 0xd2, 0x19, 0x0a, 0xd2, 0x0c, 0x40,
	0x1c, 0x7a, 0xa1, 0x6d, 0x30, 0x23, 0xdb, 0xb3, 0xfb, 0xbe, 0x4b, 0xac, 0x74, 0xc5, 0xa8, 0x15,
	0x37, 0x6f, 0x86, 0xc9, 0x47, 0x76, 0x7a, 0xe0, 0xbb, 0x04, 0x97, 0xc4, 0xac, 0x01, 0x6d, 0x40,
	0x66, 0xec, 0x30, 0x8f, 0x7a, 0x5d, 0x6e, 0x65, 0xd4, 0xc6, 0x17, 0xf5, 0xaa, 0x5f, 0xc9, 0xdf,
	0x93, 0x00, 0xc3, 0x53, 0x27, 0xf4, 0x39, 0xe4, 0x07, 0x8c, 0x5c, 0xb2, 0x95, 0xbd, 0x06, 0x5b,
	0xb9, 0x01, 0x23, 0x53, 0xae, 0xb6, 0xa0, 0x30, 0xf0, 0xb9, 0xb8, 0x8c, 0x00, 0xd7, 0x88, 0x90,
	0x97, 0x53, 0xa6, 0x21, 0xee, 0x42, 0xb1, 0xe7, 0x70, 0x61, 0x53, 0x8f, 0x13, 0x26, 0x6c, 0xea,
	0x5a, 0xb9, 0x8a, 0x51, 0x4b, 0xe0, 0xbc, 0xb4, 0x36, 0x94, 0xb1, 0xe1, 0xa2, 0xff, 0x02, 0x9c,
	0xf9, 0x43, 0xcf, 0xb5, 0x99, 0x3f, 0xe6, 0x56, 0x5e, 0x79, 0x64, 0x95, 0x05, 0xfb, 0x63, 0x8e,
	0x6c, 0x58, 0x1e, 0x72, 0xc2, 0x6c, 0x97, 0x9c, 0x51, 0x8f, 0xb8, 0xf6, 0xc8, 0x61, 0xd4, 0x39,
	0xed, 0x11, 0x6e, 0x15, 0x54, 0x42, 0x0f, 0xe6, 0x13, 0x3a, 0xe2, 0x84, 0xed, 0x04, 0xce, 0xc7,
	0xa1, 0xef, 0xae, 0x27, 0xd8, 0x04, 0x97, 0x87, 0x57, 0x40, 0xa8, 0x09, 0x26, 0x9f, 0x70, 0x41,
	0xfa, 0x91, 0xd0, 0x45, 0x15, 0xfa, 0xee, 0x4b, 0x7b, 0x55, 0x7e, 0x73, 0x51, 0x4b, 0x7c, 0xd6,
	0x8a, 0xfe, 0x03, 0x59, 0xe6, 0x8f, 0xed, 0x8e, 0x3f, 0xf4, 0x84, 0x55, 0xaa, 0x18, 0xb5, 0x38,
	0xce, 0x30, 0x7f, 0x5c, 0x97, 0x63, 0x59, 0x82, 0xdc, 0x19, 0x91, 0x81, 0x4f, 0x3d, 0xc1, 0x2d,
	0xb3, 0x12, 0xaf, 0x65, 0x71, 0xc4, 0x82, 0x6a, 0x60, 0x52, 0xcf, 0x66, 0x84, 0x13, 0x36, 0x22,
	0xae, 0xdd, 0xf1, 0x3d, 0xcf, 0x5a, 0x50, 0x85, 0x5a, 0xa4, 0x1e, 0xd6, 0xe6, 0xba, 0xef, 0x79,
	0x52, 0xe1, 0x9e, 0xdf, 0xb9, 0x08, 0x05, 0xb2, 0x90, 0x2a, 0xc6, 0x57, 0x28, 0x2c, 0x67, 0x84,
	0x9d, 0xb7, 0x0e, 0x8b, 0x4a, 0x1e, 0x15, 0xe5, 0x9c, 0x38, 0x4c, 0x9c, 0x12, 0x47, 0x58, 0x8b,
	0x2a, 0xe3, 0x05, 0x09, 0xed, 0xfb, 0x9d, 0x8b, 0x2f, 0x43, 0x00, 0x7d, 0x01, 0x26, 0x23, 0x8e,
	0x6b, 0x3b, 0x67, 0x82, 0x30, 0x7b, 0xcc, 0xa8, 0x20, 0x56, 0x59, 0x2d, 0xba, 0x1c, 0x2e, 0x8a,
	0x89, 0xe3, 0x6e, 0x49, 0xf8, 0x44, 0xa2, 0xb8, 0xc8, 0x66, 0xc6, 0xa8, 0x02, 0xb9, 0x9d, 0x9d,
	0xfd, 0x96, 0x60, 0x8e, 0x20, 0xdd, 0x89, 0xb5, 0xa4, 0xba, 0x2b, 0x6a, 0x92, 0x1e, 0x3a, 0xbd,
	0xa3, 0xa3, 0xc6, 0x8e, 0xb5, 0x1c, 0x78, 0x44, 0x4c, 0xe8, 0x43, 0x58, 0x26, 0x9e, 0x24, 0xda,
	0xd6, 0xaa, 0x71, 0x22, 0x84, 0xea, 0x8b, 0x9b, 0x8a, 0xa6, 0x72, 0x80, 0x06, 0x52, 0xb5, 0x34,
	0xb6, 0xf2, 0xab, 0x01, 0xf9, 0x28, 0x13, 0xe8, 0x1e, 0xa4, 0x82, 0xae, 0x56, 0xc7, 0x4d, 0x6e,
	0xb3, 0xa0, 0xdb, 0xa9, 0xad, 0x8c, 0x58, 0x83, 0xf2, 0x74, 0x8a, 0xf6, 0x2e, 0x75, 0xad, 0x98,
	0xa2, 0xa7, 0x10, 0xb1, 0x36, 0x5c, 0xf4, 0x08, 0xf2, 0x42, 0xae, 0x2a, 0x6c, 0xa7, 0x47, 0x1d,
	0x6e, 0xc5, 0xf5, 0xc1, 0x30, 0x3d, 0x04, 0xdb, 0x0a, 0xdd, 0x92, 0x20, 0xce, 0x89, 0xcb, 0x01,
	0xfa, 0x1f, 0xe4, 0xa6, 0x62, 0x53, 0x57, 0x9d, 0x49, 0x71, 0x0c, 0xa1, 0xa9, 0xe1, 0xae, 0x7c,
	0x03, 0xb7, 0xfe, 0xb1, 0xa2, 0x91, 0x09, 0xf1, 0x0b, 0x32, 0x51, 0x5b, 0xc8, 0x62, 0xf9, 0x17,
	0x3d, 0x80, 0xe4, 0xc8, 0xe9, 0x0d, 0x89, 0xca, 0xf3, 0xf2, 0x94, 0xd8, 0xa6, 0xde, 0x74, 0x2e,
	0x0e, 0x3c, 0x3e, 0x89, 0x3d, 0x32, 0x56, 0xb6, 0xa1, 0x7c, 0x55, 0x51, 0x5f, 0x11, 0xb8, 0x1c,
	0x0d, 0x9c, 0x8d, 0xc4, 0x78, 0x92, 0xc8, 0xc4, 0xcd, 0x44, 0xf5, 0x17, 0x03, 0x8a, 0xb3, 0xf2,
	0xa3, 0x0f, 0x60, 0x69, 0xbe, 0x60, 0xec, 0xae, 0xa0, 0xae, 0x0e, 0x8b, 0x66, 0xab, 0xe3, 0xb1,
	0xa0, 0x2e, 0xfa, 0x18, 0xac, 0x97, 0xa6, 0x08, 0xda, 0x27, 0xfe, 0x50, 0xa8, 0x85, 0x0d, 0xbc,
	0x34, 0x3b, 0xab, 0x1d, 0x80, 0xb2, 0x98, 0x75, 0x23, 0xc8, 0xbb, 0xa4, 0x73, 0xa1, 0x16, 0x0a,
	0x84, 0xc8, 0xe0, 0x05, 0x0d, 0xb5, 0x25, 0x22, 0xd7, 0xe1, 0xd5, 0x9f, 0x63, 0x50, 0xd4, 0x07,
	0x36, 0x26, 0xcf, 0x86, 0x84, 0x0b, 0xf4, 0x1e, 0x64, 0x3b, 0x4e, 0xaf, 0x47, 0x98, 0xad, 0x53,
	0xcc, 0x6d, 0x96, 0xd6, 0x83, 0x6b, 0xab, 0xae, 0xec, 0x8d, 0x1d, 0x9c, 0x09, 0x3c, 0x1a, 0x2e,
	0x7a, 0x00, 0xe9, 0xb0, 0xf3, 0x62, 0x53, 0xdf, 0x68, 0xe7, 0xe1, 0x10, 0x47, 0xf7, 0x21, 0xa9,
	0x54, 0xd0, 0x65, 0xb1, 0x10, 0x6a, 0x22, 0xcf, 0x38, 0x75, 0x7c, 0xe3, 0x00, 0x47, 0x1f, 0x81,
	0xae, 0x0d, 0x5b, 0x4c, 0x06, 0x44, 0x15, 0x43, 0x71, 0xb3, 0x3c, 0x5f, 0x45, 0xed, 0xc9, 0x80,
	0x60, 0x10, 0xd3, 0xff, 0xb2, 0x48, 0x2f, 0xc8, 0x84, 0x0f, 0x9c, 0x0e, 0xb1, 0xd5, 0x85, 0xa7,
	0x2e, 0xa6, 0x2c, 0x2e, 0x84, 0x56, 0x55, 0xf9, 0xd1, 0x8b, 0x2b, 0x7d, 0x9d, 0x8b, 0xeb, 0x49,
	0x22, 0x93, 0x34, 0x53, 0xd5, 0x1f, 0x0c, 0x28, 0x4d, 0x99, 0xe2, 0x03, 0xdf, 0xe3, 0x72, 0xc5,
	0x24, 0x61, 0xcc, 0x67, 0x73, 0x34, 0xe1, 0xc3, 0xfa, 0xae, 0x34, 0xe3, 0x00, 0x7d, 0x1d, 0x8e,
	0xd6, 0x20, 0xc5, 0x08, 0x1f, 0xf6, 0x84, 0x26, 0x09, 0x45, 0xaf, 0x37, 0xac, 0x10, 0xac, 0x3d,
	0xaa, 0xcf, 0x63, 0xb0, 0xa8, 0x33, 0xda, 0x76, 0x44, 0xe7, 0xfc, 0x9d, 0x0b, 0xf8, 0x7f, 0x48,
	0xcb, 0x6c, 0x28, 0x91, 0x05, 0x15, 0xbf, 0x5a, 0xc2, 0xd0, 0xe3, 0x2d, 0x44, 0x74, 0xf8, 0xcc,
	0x3b, 0x28, 0x19, 0xbc, 0x83, 0x1c, 0x1e, 0x7d, 0x07, 0xbd, 0x23, 0xad, 0xab, 0x3f, 0x19, 0x50,
	0x9e, 0xe5, 0xf4, 0x9d, 0x49, 0xfd, 0x3e, 0xa4, 0x03, 0x21, 0x43, 0x36, 0x97, 0x75, 0x6e, 0x81,
	0xcc, 0x27, 0x54, 0x9c, 0x07, 0xa1, 0x43, 0x37, 0xd9, 0xac, 0xe5, 0x96, 0x60, 0xc4, 0xe9, 0xbf,
	0x55, 0xcb, 0x4e, 0xfb, 0x30, 0xf6, 0x7a, 0x7d, 0x18, 0x7f, 0xe3, 0x3e, 0x4c, 0xbc, 0x42, 0x9b,
	0xe4, 0xb5, 0x1e, 0x90, 0x11, 0x6e, 0x53, 0xff, 0xce, 0x6d, 0xb5, 0x0e, 0x4b, 0x73, 0x44, 0x69,
	0x19, 0x2f, 0xfb, 0xcb, 0x78, 0x65, 0x7f, 0x7d, 0x0b, 0xb7, 0x30, 0xe1, 0x7e, 0x6f, 0x44, 0x22,
	0x95, 0xf7, 0x66, 0x94, 0x23, 0x48, 0xb8, 0x42, 0xdf, 0x9a, 0x59, 0xac, 0xfe, 0x57, 0x6f, 0xc3,
	0xca, 0x55, 0xe1, 0x83, 0x44, 0xab, 0x0f, 0x21, 0x7f, 0x1c, 0x6c, 0x61, 0xaf, 0xe7, 0x74, 0xb9,
	0x7c, 0x93, 0xf7, 0xa9, 0x47, 0xfb, 0xf4, 0x7b, 0x62, 0xf3, 0x0b, 0x32, 0xd6, 0x9f, 0x07, 0xf9,
	0xd0, 0xd8, 0xba, 0x20, 0xe3, 0xea, 0x5f, 0x06, 0x14, 0xf5, 0xac, 0x37, 0xcb, 0x73, 0x4e, 0xf1,
	0xd8, 0x35, 0x15, 0xbf, 0x0f, 0xc9, 0x91, 0xba, 0xd1, 0xc2, 0x93, 0x3d, 0xf2, 0x51, 0x74, 0x2c,
	0x2f, 0x1a, 0x1c, 0xe0, 0x92, 0xfe, 0x33, 0xda, 0x13, 0x84, 0xa9, 0x92, 0x90, 0xf4, 0x47, 0x3c,
	0xf7, 0x14, 0x82, 0xb5, 0x07, 0x5a, 0x83, 0xe4, 0x99, 0xdc, 0xba, 0xae, 0x8e, 0x72, 0x28, 0x76,
	0x94, 0x16, 0x1c, 0xb8, 0x54, 0x3f, 0x83, 0xd2, 0x74, 0xdf, 0x97, 0x4a, 0x93, 0x11, 0x91, 0xaf,
	0x4b, 0x43, 0x75, 0xd7, 0xcc, 0x52, 0xc7, 0xbb, 0x12, 0xc2, 0xda, 0x63, 0x6d, 0x07, 0x4a, 0x73,
	0x9f, 0x1e, 0xa8, 0x04, 0xb9, 0xa3, 0xa7, 0xad, 0xc3, 0xdd, 0x7a, 0x63, 0xaf, 0xb1, 0xbb, 0x63,
	0xde, 0x40, 0x00, 0xa9, 0x56, 0xe3, 0xe9, 0xe3, 0xfd, 0x5d, 0xd3, 0x40, 0x59, 0x48, 0x1e, 0x1c,
	0xed, 0xb7, 0x1b, 0x66, 0x4c, 0xfe, 0x6d, 0x9f, 0x34, 0x0f, 0xeb, 0x66, 0x7c, 0xed, 0x53, 0xc8,
	0xd5, 0xd5, 0x07, 0x54, 0x93, 0xb9, 0x84, 0xc9, 0x09, 0x4f, 0x9b, 0xf8, 0x60, 0x6b, 0xdf, 0xbc,
	0x81, 0xd2, 0x10, 0x3f, 0xc4, 0x72, 0x66, 0x06, 0x12, 0x87, 0xcd, 0x56, 0xdb, 0x8c, 0xa1, 0x22,
	0xc0, 0xd6, 0x51, 0xbb, 0x59, 0x6f, 0x1e, 0x1c, 0x34, 0xda, 0x66, 0x7c, 0x7b, 0xef, 0xb7, 0x17,
	0xab, 0xc6, 0xef, 0x2f, 0x56, 0x8d, 0x3f, 0x5e, 0xac, 0x1a, 0x3f, 0xfe, 0xb9, 0x7a, 0x03, 0x4a,
	0xd4, 0x5f, 0x1f, 0x51, 0x41, 0x38, 0x0f, 0xbe, 0x17, 0xbf, 0xbe, 0xa3, 0x47, 0xd4, 0xdf, 0x08,
	0xfe, 0x6d, 0x74, 0xfd, 0x8d, 0x91, 0xd8, 0x50, 0xe8, 0x46, 0x40, 0xcf, 0x69, 0x4a, 0x8d, 0x1e,
	0xfe, 0x1d, 0x00, 0x00, 0xff, 0xff, 0xb1, 0xa5, 0xb0, 0xf3, 0xaf, 0x0e, 0x00, 0x00,
}

func (m *Session) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Session) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Session) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EnableSystemSettings {
		i--
		if m.EnableSystemSettings {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if len(m.SessionUUID) > 0 {
		i -= len(m.SessionUUID)
		copy(dAtA[i:], m.SessionUUID)
		i = encodeVarintVtgate(dAtA, i, uint64(len(m.SessionUUID)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if len(m.DDLStrategy) > 0 {
		i -= len(m.DDLStrategy)
		copy(dAtA[i:], m.DDLStrategy)
		i = encodeVarintVtgate(dAtA, i, uint64(len(m.DDLStrategy)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.ReadAfterWrite != nil {
		{
			size, err := m.ReadAfterWrite.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVtgate(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.LastLockHeartbeat != 0 {
		i = encodeVarintVtgate(dAtA, i, uint64(m.LastLockHeartbeat))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.LockSession != nil {
		{
			size, err := m.LockSession.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVtgate(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.InReservedConn {
		i--
		if m.InReservedConn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if len(m.Savepoints) > 0 {
		for iNdEx := len(m.Savepoints) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Savepoints[iNdEx])
			copy(dAtA[i:], m.Savepoints[iNdEx])
			i = encodeVarintVtgate(dAtA, i, uint64(len(m.Savepoints[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if m.RowCount != 0 {
		i = encodeVarintVtgate(dAtA, i, uint64(m.RowCount))
		i--
		dAtA[i] = 0x78
	}
	if len(m.SystemVariables) > 0 {
		for k := range m.SystemVariables {
			v := m.SystemVariables[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintVtgate(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintVtgate(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintVtgate(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.UserDefinedVariables) > 0 {
		for k := range m.UserDefinedVariables {
			v := m.UserDefinedVariables[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintVtgate(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintVtgate(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintVtgate(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6a
		}
	}
	if m.FoundRows != 0 {
		i = encodeVarintVtgate(dAtA, i, uint64(m.FoundRows))
		i--
		dAtA[i] = 0x60
	}
	if m.LastInsertId != 0 {
		i = encodeVarintVtgate(dAtA, i, uint64(m.LastInsertId))
		i--
		dAtA[i] = 0x58
	}
	if len(m.PostSessions) > 0 {
		for iNdEx := len(m.PostSessions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PostSessions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintVtgate(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.PreSessions) > 0 {
		for iNdEx := len(m.PreSessions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PreSessions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintVtgate(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Warnings) > 0 {
		for iNdEx := len(m.Warnings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Warnings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintVtgate(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.TransactionMode != 0 {
		i = encodeVarintVtgate(dAtA, i, uint64(m.TransactionMode))
		i--
		dAtA[i] = 0x38
	}
	if m.Options != nil {
		{
			size, err := m.Options.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVtgate(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.TargetString) > 0 {
		i -= len(m.TargetString)
		copy(dAtA[i:], m.TargetString)
		i = encodeVarintVtgate(dAtA, i, uint64(len(m.TargetString)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Autocommit {
		i--
		if m.Autocommit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.ShardSessions) > 0 {
		for iNdEx := len(m.ShardSessions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ShardSessions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintVtgate(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.InTransaction {
		i--
		if m.InTransaction {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Session_ShardSession) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Session_ShardSession) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Session_ShardSession) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ReservedId != 0 {
		i = encodeVarintVtgate(dAtA, i, uint64(m.ReservedId))
		i--
		dAtA[i] = 0x20
	}
	if m.TabletAlias != nil {
		{
			size, err := m.TabletAlias.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVtgate(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.TransactionId != 0 {
		i = encodeVarintVtgate(dAtA, i, uint64(m.TransactionId))
		i--
		dAtA[i] = 0x10
	}
	if m.Target != nil {
		{
			size, err := m.Target.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVtgate(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReadAfterWrite) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadAfterWrite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadAfterWrite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SessionTrackGtids {
		i--
		if m.SessionTrackGtids {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.ReadAfterWriteTimeout != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ReadAfterWriteTimeout))))
		i--
		dAtA[i] = 0x11
	}
	if len(m.ReadAfterWriteGtid) > 0 {
		i -= len(m.ReadAfterWriteGtid)
		copy(dAtA[i:], m.ReadAfterWriteGtid)
		i = encodeVarintVtgate(dAtA, i, uint64(len(m.ReadAfterWriteGtid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecuteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecuteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Options != nil {
		{
			size, err := m.Options.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVtgate(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.KeyspaceShard) > 0 {
		i -= len(m.KeyspaceShard)
		copy(dAtA[i:], m.KeyspaceShard)
		i = encodeVarintVtgate(dAtA, i, uint64(len(m.KeyspaceShard)))
		i--
		dAtA[i] = 0x32
	}
	if m.TabletType != 0 {
		i = encodeVarintVtgate(dAtA, i, uint64(m.TabletType))
		i--
		dAtA[i] = 0x20
	}
	if m.Query != nil {
		{
			size, err := m.Query.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVtgate(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Session != nil {
		{
			size, err := m.Session.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVtgate(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.CallerId != nil {
		{
			size, err := m.CallerId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVtgate(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecuteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecuteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Result != nil {
		{
			size, err := m.Result.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVtgate(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Session != nil {
		{
			size, err := m.Session.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVtgate(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVtgate(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecuteBatchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteBatchRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecuteBatchRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Options != nil {
		{
			size, err := m.Options.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVtgate(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.KeyspaceShard) > 0 {
		i -= len(m.KeyspaceShard)
		copy(dAtA[i:], m.KeyspaceShard)
		i = encodeVarintVtgate(dAtA, i, uint64(len(m.KeyspaceShard)))
		i--
		dAtA[i] = 0x32
	}
	if m.AsTransaction {
		i--
		if m.AsTransaction {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.TabletType != 0 {
		i = encodeVarintVtgate(dAtA, i, uint64(m.TabletType))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Queries) > 0 {
		for iNdEx := len(m.Queries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Queries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintVtgate(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Session != nil {
		{
			size, err := m.Session.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVtgate(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.CallerId != nil {
		{
			size, err := m.CallerId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVtgate(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecuteBatchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteBatchResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecuteBatchResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Results) > 0 {
		for iNdEx := len(m.Results) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Results[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintVtgate(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Session != nil {
		{
			size, err := m.Session.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVtgate(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVtgate(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StreamExecuteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamExecuteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamExecuteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Session != nil {
		{
			size, err := m.Session.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVtgate(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Options != nil {
		{
			size, err := m.Options.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVtgate(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.KeyspaceShard) > 0 {
		i -= len(m.KeyspaceShard)
		copy(dAtA[i:], m.KeyspaceShard)
		i = encodeVarintVtgate(dAtA, i, uint64(len(m.KeyspaceShard)))
		i--
		dAtA[i] = 0x22
	}
	if m.TabletType != 0 {
		i = encodeVarintVtgate(dAtA, i, uint64(m.TabletType))
		i--
		dAtA[i] = 0x18
	}
	if m.Query != nil {
		{
			size, err := m.Query.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVtgate(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.CallerId != nil {
		{
			size, err := m.CallerId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVtgate(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StreamExecuteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamExecuteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamExecuteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Result != nil {
		{
			size, err := m.Result.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVtgate(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResolveTransactionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResolveTransactionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResolveTransactionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Dtid) > 0 {
		i -= len(m.Dtid)
		copy(dAtA[i:], m.Dtid)
		i = encodeVarintVtgate(dAtA, i, uint64(len(m.Dtid)))
		i--
		dAtA[i] = 0x12
	}
	if m.CallerId != nil {
		{
			size, err := m.CallerId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVtgate(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResolveTransactionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResolveTransactionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResolveTransactionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *VStreamFlags) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VStreamFlags) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VStreamFlags) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MinimizeSkew {
		i--
		if m.MinimizeSkew {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VStreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VStreamRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VStreamRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Flags != nil {
		{
			size, err := m.Flags.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVtgate(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Filter != nil {
		{
			size, err := m.Filter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVtgate(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Vgtid != nil {
		{
			size, err := m.Vgtid.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVtgate(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.TabletType != 0 {
		i = encodeVarintVtgate(dAtA, i, uint64(m.TabletType))
		i--
		dAtA[i] = 0x10
	}
	if m.CallerId != nil {
		{
			size, err := m.CallerId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVtgate(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VStreamResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VStreamResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VStreamResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Events) > 0 {
		for iNdEx := len(m.Events) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Events[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintVtgate(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintVtgate(dAtA []byte, offset int, v uint64) int {
	offset -= sovVtgate(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Session) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InTransaction {
		n += 2
	}
	if len(m.ShardSessions) > 0 {
		for _, e := range m.ShardSessions {
			l = e.Size()
			n += 1 + l + sovVtgate(uint64(l))
		}
	}
	if m.Autocommit {
		n += 2
	}
	l = len(m.TargetString)
	if l > 0 {
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Options != nil {
		l = m.Options.Size()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.TransactionMode != 0 {
		n += 1 + sovVtgate(uint64(m.TransactionMode))
	}
	if len(m.Warnings) > 0 {
		for _, e := range m.Warnings {
			l = e.Size()
			n += 1 + l + sovVtgate(uint64(l))
		}
	}
	if len(m.PreSessions) > 0 {
		for _, e := range m.PreSessions {
			l = e.Size()
			n += 1 + l + sovVtgate(uint64(l))
		}
	}
	if len(m.PostSessions) > 0 {
		for _, e := range m.PostSessions {
			l = e.Size()
			n += 1 + l + sovVtgate(uint64(l))
		}
	}
	if m.LastInsertId != 0 {
		n += 1 + sovVtgate(uint64(m.LastInsertId))
	}
	if m.FoundRows != 0 {
		n += 1 + sovVtgate(uint64(m.FoundRows))
	}
	if len(m.UserDefinedVariables) > 0 {
		for k, v := range m.UserDefinedVariables {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovVtgate(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovVtgate(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovVtgate(uint64(mapEntrySize))
		}
	}
	if len(m.SystemVariables) > 0 {
		for k, v := range m.SystemVariables {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovVtgate(uint64(len(k))) + 1 + len(v) + sovVtgate(uint64(len(v)))
			n += mapEntrySize + 1 + sovVtgate(uint64(mapEntrySize))
		}
	}
	if m.RowCount != 0 {
		n += 1 + sovVtgate(uint64(m.RowCount))
	}
	if len(m.Savepoints) > 0 {
		for _, s := range m.Savepoints {
			l = len(s)
			n += 2 + l + sovVtgate(uint64(l))
		}
	}
	if m.InReservedConn {
		n += 3
	}
	if m.LockSession != nil {
		l = m.LockSession.Size()
		n += 2 + l + sovVtgate(uint64(l))
	}
	if m.LastLockHeartbeat != 0 {
		n += 2 + sovVtgate(uint64(m.LastLockHeartbeat))
	}
	if m.ReadAfterWrite != nil {
		l = m.ReadAfterWrite.Size()
		n += 2 + l + sovVtgate(uint64(l))
	}
	l = len(m.DDLStrategy)
	if l > 0 {
		n += 2 + l + sovVtgate(uint64(l))
	}
	l = len(m.SessionUUID)
	if l > 0 {
		n += 2 + l + sovVtgate(uint64(l))
	}
	if m.EnableSystemSettings {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Session_ShardSession) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Target != nil {
		l = m.Target.Size()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.TransactionId != 0 {
		n += 1 + sovVtgate(uint64(m.TransactionId))
	}
	if m.TabletAlias != nil {
		l = m.TabletAlias.Size()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.ReservedId != 0 {
		n += 1 + sovVtgate(uint64(m.ReservedId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReadAfterWrite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ReadAfterWriteGtid)
	if l > 0 {
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.ReadAfterWriteTimeout != 0 {
		n += 9
	}
	if m.SessionTrackGtids {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExecuteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.Size()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.Size()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Query != nil {
		l = m.Query.Size()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.TabletType != 0 {
		n += 1 + sovVtgate(uint64(m.TabletType))
	}
	l = len(m.KeyspaceShard)
	if l > 0 {
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Options != nil {
		l = m.Options.Size()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExecuteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.Size()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExecuteBatchRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.Size()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.Size()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if len(m.Queries) > 0 {
		for _, e := range m.Queries {
			l = e.Size()
			n += 1 + l + sovVtgate(uint64(l))
		}
	}
	if m.TabletType != 0 {
		n += 1 + sovVtgate(uint64(m.TabletType))
	}
	if m.AsTransaction {
		n += 2
	}
	l = len(m.KeyspaceShard)
	if l > 0 {
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Options != nil {
		l = m.Options.Size()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExecuteBatchResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.Size()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if len(m.Results) > 0 {
		for _, e := range m.Results {
			l = e.Size()
			n += 1 + l + sovVtgate(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StreamExecuteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.Size()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Query != nil {
		l = m.Query.Size()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.TabletType != 0 {
		n += 1 + sovVtgate(uint64(m.TabletType))
	}
	l = len(m.KeyspaceShard)
	if l > 0 {
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Options != nil {
		l = m.Options.Size()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.Size()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StreamExecuteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResolveTransactionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.Size()
		n += 1 + l + sovVtgate(uint64(l))
	}
	l = len(m.Dtid)
	if l > 0 {
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResolveTransactionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VStreamFlags) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MinimizeSkew {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VStreamRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.Size()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.TabletType != 0 {
		n += 1 + sovVtgate(uint64(m.TabletType))
	}
	if m.Vgtid != nil {
		l = m.Vgtid.Size()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Filter != nil {
		l = m.Filter.Size()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Flags != nil {
		l = m.Flags.Size()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VStreamResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovVtgate(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovVtgate(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozVtgate(x uint64) (n int) {
	return sovVtgate(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Session) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Session: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Session: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InTransaction", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InTransaction = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardSessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardSessions = append(m.ShardSessions, &Session_ShardSession{})
			if err := m.ShardSessions[len(m.ShardSessions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Autocommit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Autocommit = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetString = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &query.ExecuteOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionMode", wireType)
			}
			m.TransactionMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransactionMode |= TransactionMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Warnings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Warnings = append(m.Warnings, &query.QueryWarning{})
			if err := m.Warnings[len(m.Warnings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreSessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreSessions = append(m.PreSessions, &Session_ShardSession{})
			if err := m.PreSessions[len(m.PreSessions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostSessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PostSessions = append(m.PostSessions, &Session_ShardSession{})
			if err := m.PostSessions[len(m.PostSessions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastInsertId", wireType)
			}
			m.LastInsertId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastInsertId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FoundRows", wireType)
			}
			m.FoundRows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FoundRows |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserDefinedVariables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserDefinedVariables == nil {
				m.UserDefinedVariables = make(map[string]*query.BindVariable)
			}
			var mapkey string
			var mapvalue *query.BindVariable
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVtgate
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVtgate
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthVtgate
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthVtgate
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVtgate
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthVtgate
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthVtgate
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &query.BindVariable{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipVtgate(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthVtgate
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.UserDefinedVariables[mapkey] = mapvalue
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemVariables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SystemVariables == nil {
				m.SystemVariables = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVtgate
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVtgate
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthVtgate
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthVtgate
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVtgate
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthVtgate
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthVtgate
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipVtgate(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthVtgate
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SystemVariables[mapkey] = mapvalue
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowCount", wireType)
			}
			m.RowCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RowCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Savepoints", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Savepoints = append(m.Savepoints, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InReservedConn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InReservedConn = bool(v != 0)
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockSession", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LockSession == nil {
				m.LockSession = &Session_ShardSession{}
			}
			if err := m.LockSession.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastLockHeartbeat", wireType)
			}
			m.LastLockHeartbeat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastLockHeartbeat |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadAfterWrite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadAfterWrite == nil {
				m.ReadAfterWrite = &ReadAfterWrite{}
			}
			if err := m.ReadAfterWrite.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DDLStrategy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DDLStrategy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionUUID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionUUID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableSystemSettings", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableSystemSettings = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Session_ShardSession) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardSession: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardSession: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &query.Target{}
			}
			if err := m.Target.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionId", wireType)
			}
			m.TransactionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransactionId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabletAlias", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TabletAlias == nil {
				m.TabletAlias = &topodata.TabletAlias{}
			}
			if err := m.TabletAlias.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReservedId", wireType)
			}
			m.ReservedId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReservedId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadAfterWrite) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadAfterWrite: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadAfterWrite: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadAfterWriteGtid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReadAfterWriteGtid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadAfterWriteTimeout", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ReadAfterWriteTimeout = float64(math.Float64frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionTrackGtids", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SessionTrackGtids = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Query == nil {
				m.Query = &query.BoundQuery{}
			}
			if err := m.Query.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabletType", wireType)
			}
			m.TabletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabletType |= topodata.TabletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyspaceShard", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyspaceShard = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &query.ExecuteOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &vtrpc.RPCError{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &query.QueryResult{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteBatchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteBatchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteBatchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Queries = append(m.Queries, &query.BoundQuery{})
			if err := m.Queries[len(m.Queries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabletType", wireType)
			}
			m.TabletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabletType |= topodata.TabletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsTransaction", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AsTransaction = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyspaceShard", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyspaceShard = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &query.ExecuteOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteBatchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteBatchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteBatchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &vtrpc.RPCError{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Results = append(m.Results, &query.ResultWithError{})
			if err := m.Results[len(m.Results)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamExecuteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamExecuteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamExecuteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Query == nil {
				m.Query = &query.BoundQuery{}
			}
			if err := m.Query.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabletType", wireType)
			}
			m.TabletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabletType |= topodata.TabletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyspaceShard", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyspaceShard = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &query.ExecuteOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamExecuteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamExecuteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamExecuteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &query.QueryResult{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResolveTransactionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResolveTransactionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResolveTransactionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dtid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dtid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResolveTransactionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResolveTransactionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResolveTransactionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VStreamFlags) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VStreamFlags: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VStreamFlags: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimizeSkew", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MinimizeSkew = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VStreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VStreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VStreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabletType", wireType)
			}
			m.TabletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabletType |= topodata.TabletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vgtid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vgtid == nil {
				m.Vgtid = &binlogdata.VGtid{}
			}
			if err := m.Vgtid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = &binlogdata.Filter{}
			}
			if err := m.Filter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Flags == nil {
				m.Flags = &VStreamFlags{}
			}
			if err := m.Flags.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VStreamResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VStreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VStreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &binlogdata.VEvent{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipVtgate(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthVtgate
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupVtgate
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthVtgate
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthVtgate        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowVtgate          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupVtgate = fmt.Errorf("proto: unexpected end of group")
)
