//
//Copyright 2019 The Vitess Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// Data definitions for service vtgateservice.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.9
// 	protoc        v3.21.3
// source: vtgate.proto

package vtgate

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
	binlogdata "vitess.io/vitess/go/vt/proto/binlogdata"
	query "vitess.io/vitess/go/vt/proto/query"
	topodata "vitess.io/vitess/go/vt/proto/topodata"
	vtrpc "vitess.io/vitess/go/vt/proto/vtrpc"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// TransactionMode controls the execution of distributed transaction
// across multiple shards.
type TransactionMode int32

const (
	// UNSPECIFIED uses the transaction mode set by the VTGate flag 'transaction_mode'.
	TransactionMode_UNSPECIFIED TransactionMode = 0
	// SINGLE disallows distributed transactions.
	TransactionMode_SINGLE TransactionMode = 1
	// MULTI allows distributed transactions with best effort commit.
	TransactionMode_MULTI TransactionMode = 2
	// TWOPC is for distributed transactions with atomic commits.
	TransactionMode_TWOPC TransactionMode = 3
)

// Enum value maps for TransactionMode.
var (
	TransactionMode_name = map[int32]string{
		0: "UNSPECIFIED",
		1: "SINGLE",
		2: "MULTI",
		3: "TWOPC",
	}
	TransactionMode_value = map[string]int32{
		"UNSPECIFIED": 0,
		"SINGLE":      1,
		"MULTI":       2,
		"TWOPC":       3,
	}
)

func (x TransactionMode) Enum() *TransactionMode {
	p := new(TransactionMode)
	*p = x
	return p
}

func (x TransactionMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TransactionMode) Descriptor() protoreflect.EnumDescriptor {
	return file_vtgate_proto_enumTypes[0].Descriptor()
}

func (TransactionMode) Type() protoreflect.EnumType {
	return &file_vtgate_proto_enumTypes[0]
}

func (x TransactionMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TransactionMode.Descriptor instead.
func (TransactionMode) EnumDescriptor() ([]byte, []int) {
	return file_vtgate_proto_rawDescGZIP(), []int{0}
}

// CommitOrder is used to designate which of the ShardSessions
// get used for transactions.
type CommitOrder int32

const (
	// NORMAL is the default commit order.
	CommitOrder_NORMAL CommitOrder = 0
	// PRE is used to designate pre_sessions.
	CommitOrder_PRE CommitOrder = 1
	// POST is used to designate post_sessions.
	CommitOrder_POST CommitOrder = 2
	// AUTOCOMMIT is used to run the statement as autocommitted transaction.
	CommitOrder_AUTOCOMMIT CommitOrder = 3
)

// Enum value maps for CommitOrder.
var (
	CommitOrder_name = map[int32]string{
		0: "NORMAL",
		1: "PRE",
		2: "POST",
		3: "AUTOCOMMIT",
	}
	CommitOrder_value = map[string]int32{
		"NORMAL":     0,
		"PRE":        1,
		"POST":       2,
		"AUTOCOMMIT": 3,
	}
)

func (x CommitOrder) Enum() *CommitOrder {
	p := new(CommitOrder)
	*p = x
	return p
}

func (x CommitOrder) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CommitOrder) Descriptor() protoreflect.EnumDescriptor {
	return file_vtgate_proto_enumTypes[1].Descriptor()
}

func (CommitOrder) Type() protoreflect.EnumType {
	return &file_vtgate_proto_enumTypes[1]
}

func (x CommitOrder) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CommitOrder.Descriptor instead.
func (CommitOrder) EnumDescriptor() ([]byte, []int) {
	return file_vtgate_proto_rawDescGZIP(), []int{1}
}

// Session objects are exchanged like cookies through various
// calls to VTGate. The behavior differs between V2 & V3 APIs.
// V3 APIs are Execute, ExecuteBatch and StreamExecute. All
// other APIs are V2. For the V3 APIs, the session
// must be sent with every call to Execute or ExecuteBatch.
// For the V2 APIs, Begin does not accept a session. It instead
// returns a brand new one with in_transaction set to true.
// After a call to Commit or Rollback, the session can be
// discarded. If you're not in a transaction, Session is
// an optional parameter for the V2 APIs.
type Session struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// in_transaction is set to true if the session is in a transaction.
	InTransaction bool `protobuf:"varint,1,opt,name=in_transaction,json=inTransaction,proto3" json:"in_transaction,omitempty"`
	// shard_sessions keep track of per-shard transaction info.
	ShardSessions []*Session_ShardSession `protobuf:"bytes,2,rep,name=shard_sessions,json=shardSessions,proto3" json:"shard_sessions,omitempty"`
	// autocommit specifies if the session is in autocommit mode.
	// This is used only for V3.
	Autocommit bool `protobuf:"varint,4,opt,name=autocommit,proto3" json:"autocommit,omitempty"`
	// target_string is the target expressed as a string. Valid
	// names are: keyspace:shard@target, keyspace@target or @target.
	// This is used only for V3.
	TargetString string `protobuf:"bytes,5,opt,name=target_string,json=targetString,proto3" json:"target_string,omitempty"`
	// options is used only for V3.
	Options *query.ExecuteOptions `protobuf:"bytes,6,opt,name=options,proto3" json:"options,omitempty"`
	// transaction_mode specifies the current transaction mode.
	TransactionMode TransactionMode `protobuf:"varint,7,opt,name=transaction_mode,json=transactionMode,proto3,enum=vtgate.TransactionMode" json:"transaction_mode,omitempty"`
	// warnings contains non-fatal warnings from the previous query
	Warnings []*query.QueryWarning `protobuf:"bytes,8,rep,name=warnings,proto3" json:"warnings,omitempty"`
	// pre_sessions contains sessions that have to be committed first.
	PreSessions []*Session_ShardSession `protobuf:"bytes,9,rep,name=pre_sessions,json=preSessions,proto3" json:"pre_sessions,omitempty"`
	// post_sessions contains sessions that have to be committed last.
	PostSessions []*Session_ShardSession `protobuf:"bytes,10,rep,name=post_sessions,json=postSessions,proto3" json:"post_sessions,omitempty"`
	// last_insert_id keeps track of the last seen insert_id for this session
	LastInsertId uint64 `protobuf:"varint,11,opt,name=last_insert_id,json=lastInsertId,proto3" json:"last_insert_id,omitempty"`
	// found_rows keeps track of how many rows the last query returned
	FoundRows uint64 `protobuf:"varint,12,opt,name=found_rows,json=foundRows,proto3" json:"found_rows,omitempty"`
	// user_defined_variables contains all the @variables defined for this session
	UserDefinedVariables map[string]*query.BindVariable `protobuf:"bytes,13,rep,name=user_defined_variables,json=userDefinedVariables,proto3" json:"user_defined_variables,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// system_variables keeps track of all session variables set for this connection
	// TODO: systay should we keep this so we can apply it ordered?
	SystemVariables map[string]string `protobuf:"bytes,14,rep,name=system_variables,json=systemVariables,proto3" json:"system_variables,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// row_count keeps track of the last seen rows affected for this session
	RowCount int64 `protobuf:"varint,15,opt,name=row_count,json=rowCount,proto3" json:"row_count,omitempty"`
	// Stores savepoint and release savepoint calls inside a transaction
	// and is reset once transaction is committed or rolled back.
	Savepoints []string `protobuf:"bytes,16,rep,name=savepoints,proto3" json:"savepoints,omitempty"`
	// in_reserved_conn is set to true if the session should be using reserved connections.
	InReservedConn bool `protobuf:"varint,17,opt,name=in_reserved_conn,json=inReservedConn,proto3" json:"in_reserved_conn,omitempty"`
	// lock_session keep tracks of shard on which the lock query is sent.
	LockSession *Session_ShardSession `protobuf:"bytes,18,opt,name=lock_session,json=lockSession,proto3" json:"lock_session,omitempty"`
	// last_lock_heartbeat keep tracks of when last lock heartbeat was sent.
	LastLockHeartbeat int64 `protobuf:"varint,19,opt,name=last_lock_heartbeat,json=lastLockHeartbeat,proto3" json:"last_lock_heartbeat,omitempty"`
	// read_after_write tracks the ReadAfterWrite settings for this session.
	ReadAfterWrite *ReadAfterWrite `protobuf:"bytes,20,opt,name=read_after_write,json=readAfterWrite,proto3" json:"read_after_write,omitempty"`
	// DDL strategy
	DDLStrategy string `protobuf:"bytes,21,opt,name=DDLStrategy,proto3" json:"DDLStrategy,omitempty"`
	// Session UUID
	SessionUUID string `protobuf:"bytes,22,opt,name=SessionUUID,proto3" json:"SessionUUID,omitempty"`
	// enable_system_settings defines if we can use reserved connections.
	EnableSystemSettings bool             `protobuf:"varint,23,opt,name=enable_system_settings,json=enableSystemSettings,proto3" json:"enable_system_settings,omitempty"`
	AdvisoryLock         map[string]int64 `protobuf:"bytes,24,rep,name=advisory_lock,json=advisoryLock,proto3" json:"advisory_lock,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	// query_timeout is the maximum amount of time a query is permitted to run
	QueryTimeout     int64                   `protobuf:"varint,25,opt,name=query_timeout,json=queryTimeout,proto3" json:"query_timeout,omitempty"`
	PrepareStatement map[string]*PrepareData `protobuf:"bytes,26,rep,name=prepare_statement,json=prepareStatement,proto3" json:"prepare_statement,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// MigrationContext
	MigrationContext   string `protobuf:"bytes,27,opt,name=migration_context,json=migrationContext,proto3" json:"migration_context,omitempty"`
	ErrorUntilRollback bool   `protobuf:"varint,28,opt,name=error_until_rollback,json=errorUntilRollback,proto3" json:"error_until_rollback,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *Session) Reset() {
	*x = Session{}
	mi := &file_vtgate_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Session) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Session) ProtoMessage() {}

func (x *Session) ProtoReflect() protoreflect.Message {
	mi := &file_vtgate_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Session.ProtoReflect.Descriptor instead.
func (*Session) Descriptor() ([]byte, []int) {
	return file_vtgate_proto_rawDescGZIP(), []int{0}
}

func (x *Session) GetInTransaction() bool {
	if x != nil {
		return x.InTransaction
	}
	return false
}

func (x *Session) GetShardSessions() []*Session_ShardSession {
	if x != nil {
		return x.ShardSessions
	}
	return nil
}

func (x *Session) GetAutocommit() bool {
	if x != nil {
		return x.Autocommit
	}
	return false
}

func (x *Session) GetTargetString() string {
	if x != nil {
		return x.TargetString
	}
	return ""
}

func (x *Session) GetOptions() *query.ExecuteOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

func (x *Session) GetTransactionMode() TransactionMode {
	if x != nil {
		return x.TransactionMode
	}
	return TransactionMode_UNSPECIFIED
}

func (x *Session) GetWarnings() []*query.QueryWarning {
	if x != nil {
		return x.Warnings
	}
	return nil
}

func (x *Session) GetPreSessions() []*Session_ShardSession {
	if x != nil {
		return x.PreSessions
	}
	return nil
}

func (x *Session) GetPostSessions() []*Session_ShardSession {
	if x != nil {
		return x.PostSessions
	}
	return nil
}

func (x *Session) GetLastInsertId() uint64 {
	if x != nil {
		return x.LastInsertId
	}
	return 0
}

func (x *Session) GetFoundRows() uint64 {
	if x != nil {
		return x.FoundRows
	}
	return 0
}

func (x *Session) GetUserDefinedVariables() map[string]*query.BindVariable {
	if x != nil {
		return x.UserDefinedVariables
	}
	return nil
}

func (x *Session) GetSystemVariables() map[string]string {
	if x != nil {
		return x.SystemVariables
	}
	return nil
}

func (x *Session) GetRowCount() int64 {
	if x != nil {
		return x.RowCount
	}
	return 0
}

func (x *Session) GetSavepoints() []string {
	if x != nil {
		return x.Savepoints
	}
	return nil
}

func (x *Session) GetInReservedConn() bool {
	if x != nil {
		return x.InReservedConn
	}
	return false
}

func (x *Session) GetLockSession() *Session_ShardSession {
	if x != nil {
		return x.LockSession
	}
	return nil
}

func (x *Session) GetLastLockHeartbeat() int64 {
	if x != nil {
		return x.LastLockHeartbeat
	}
	return 0
}

func (x *Session) GetReadAfterWrite() *ReadAfterWrite {
	if x != nil {
		return x.ReadAfterWrite
	}
	return nil
}

func (x *Session) GetDDLStrategy() string {
	if x != nil {
		return x.DDLStrategy
	}
	return ""
}

func (x *Session) GetSessionUUID() string {
	if x != nil {
		return x.SessionUUID
	}
	return ""
}

func (x *Session) GetEnableSystemSettings() bool {
	if x != nil {
		return x.EnableSystemSettings
	}
	return false
}

func (x *Session) GetAdvisoryLock() map[string]int64 {
	if x != nil {
		return x.AdvisoryLock
	}
	return nil
}

func (x *Session) GetQueryTimeout() int64 {
	if x != nil {
		return x.QueryTimeout
	}
	return 0
}

func (x *Session) GetPrepareStatement() map[string]*PrepareData {
	if x != nil {
		return x.PrepareStatement
	}
	return nil
}

func (x *Session) GetMigrationContext() string {
	if x != nil {
		return x.MigrationContext
	}
	return ""
}

func (x *Session) GetErrorUntilRollback() bool {
	if x != nil {
		return x.ErrorUntilRollback
	}
	return false
}

// PrepareData keeps the prepared statement and other information related for execution of it.
type PrepareData struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	PrepareStatement string                 `protobuf:"bytes,1,opt,name=prepare_statement,json=prepareStatement,proto3" json:"prepare_statement,omitempty"`
	ParamsCount      int32                  `protobuf:"varint,2,opt,name=params_count,json=paramsCount,proto3" json:"params_count,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *PrepareData) Reset() {
	*x = PrepareData{}
	mi := &file_vtgate_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PrepareData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PrepareData) ProtoMessage() {}

func (x *PrepareData) ProtoReflect() protoreflect.Message {
	mi := &file_vtgate_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PrepareData.ProtoReflect.Descriptor instead.
func (*PrepareData) Descriptor() ([]byte, []int) {
	return file_vtgate_proto_rawDescGZIP(), []int{1}
}

func (x *PrepareData) GetPrepareStatement() string {
	if x != nil {
		return x.PrepareStatement
	}
	return ""
}

func (x *PrepareData) GetParamsCount() int32 {
	if x != nil {
		return x.ParamsCount
	}
	return 0
}

// ReadAfterWrite contains information regarding gtid set and timeout
// Also if the gtid information needs to be passed to client.
type ReadAfterWrite struct {
	state                 protoimpl.MessageState `protogen:"open.v1"`
	ReadAfterWriteGtid    string                 `protobuf:"bytes,1,opt,name=read_after_write_gtid,json=readAfterWriteGtid,proto3" json:"read_after_write_gtid,omitempty"`
	ReadAfterWriteTimeout float64                `protobuf:"fixed64,2,opt,name=read_after_write_timeout,json=readAfterWriteTimeout,proto3" json:"read_after_write_timeout,omitempty"`
	SessionTrackGtids     bool                   `protobuf:"varint,3,opt,name=session_track_gtids,json=sessionTrackGtids,proto3" json:"session_track_gtids,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *ReadAfterWrite) Reset() {
	*x = ReadAfterWrite{}
	mi := &file_vtgate_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReadAfterWrite) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReadAfterWrite) ProtoMessage() {}

func (x *ReadAfterWrite) ProtoReflect() protoreflect.Message {
	mi := &file_vtgate_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReadAfterWrite.ProtoReflect.Descriptor instead.
func (*ReadAfterWrite) Descriptor() ([]byte, []int) {
	return file_vtgate_proto_rawDescGZIP(), []int{2}
}

func (x *ReadAfterWrite) GetReadAfterWriteGtid() string {
	if x != nil {
		return x.ReadAfterWriteGtid
	}
	return ""
}

func (x *ReadAfterWrite) GetReadAfterWriteTimeout() float64 {
	if x != nil {
		return x.ReadAfterWriteTimeout
	}
	return 0
}

func (x *ReadAfterWrite) GetSessionTrackGtids() bool {
	if x != nil {
		return x.SessionTrackGtids
	}
	return false
}

// ExecuteMultiRequest is the payload to ExecuteMulti.
type ExecuteMultiRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"caller_id,omitempty"`
	// sql contains the set of queries to execute.
	Sql string `protobuf:"bytes,2,opt,name=sql,proto3" json:"sql,omitempty"`
	// session carries the session state.
	Session       *Session `protobuf:"bytes,3,opt,name=session,proto3" json:"session,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExecuteMultiRequest) Reset() {
	*x = ExecuteMultiRequest{}
	mi := &file_vtgate_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExecuteMultiRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExecuteMultiRequest) ProtoMessage() {}

func (x *ExecuteMultiRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vtgate_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExecuteMultiRequest.ProtoReflect.Descriptor instead.
func (*ExecuteMultiRequest) Descriptor() ([]byte, []int) {
	return file_vtgate_proto_rawDescGZIP(), []int{3}
}

func (x *ExecuteMultiRequest) GetCallerId() *vtrpc.CallerID {
	if x != nil {
		return x.CallerId
	}
	return nil
}

func (x *ExecuteMultiRequest) GetSql() string {
	if x != nil {
		return x.Sql
	}
	return ""
}

func (x *ExecuteMultiRequest) GetSession() *Session {
	if x != nil {
		return x.Session
	}
	return nil
}

// ExecuteMultiResponse is the returned value from ExecuteMulti.
type ExecuteMultiResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// error contains an application level error if necessary. Note the
	// session may have changed, even when an error is returned (for
	// instance if a database integrity error happened).
	Error *vtrpc.RPCError `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	// session is the updated session information.
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// results contain the query results. There can be some results even if the
	// error is set.
	Results       []*query.QueryResult `protobuf:"bytes,3,rep,name=results,proto3" json:"results,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExecuteMultiResponse) Reset() {
	*x = ExecuteMultiResponse{}
	mi := &file_vtgate_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExecuteMultiResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExecuteMultiResponse) ProtoMessage() {}

func (x *ExecuteMultiResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vtgate_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExecuteMultiResponse.ProtoReflect.Descriptor instead.
func (*ExecuteMultiResponse) Descriptor() ([]byte, []int) {
	return file_vtgate_proto_rawDescGZIP(), []int{4}
}

func (x *ExecuteMultiResponse) GetError() *vtrpc.RPCError {
	if x != nil {
		return x.Error
	}
	return nil
}

func (x *ExecuteMultiResponse) GetSession() *Session {
	if x != nil {
		return x.Session
	}
	return nil
}

func (x *ExecuteMultiResponse) GetResults() []*query.QueryResult {
	if x != nil {
		return x.Results
	}
	return nil
}

// ExecuteRequest is the payload to Execute.
type ExecuteRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"caller_id,omitempty"`
	// session carries the session state.
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// query is the query and bind variables to execute.
	Query         *query.BoundQuery `protobuf:"bytes,3,opt,name=query,proto3" json:"query,omitempty"`
	Prepared      bool              `protobuf:"varint,8,opt,name=prepared,proto3" json:"prepared,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExecuteRequest) Reset() {
	*x = ExecuteRequest{}
	mi := &file_vtgate_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExecuteRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExecuteRequest) ProtoMessage() {}

func (x *ExecuteRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vtgate_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExecuteRequest.ProtoReflect.Descriptor instead.
func (*ExecuteRequest) Descriptor() ([]byte, []int) {
	return file_vtgate_proto_rawDescGZIP(), []int{5}
}

func (x *ExecuteRequest) GetCallerId() *vtrpc.CallerID {
	if x != nil {
		return x.CallerId
	}
	return nil
}

func (x *ExecuteRequest) GetSession() *Session {
	if x != nil {
		return x.Session
	}
	return nil
}

func (x *ExecuteRequest) GetQuery() *query.BoundQuery {
	if x != nil {
		return x.Query
	}
	return nil
}

func (x *ExecuteRequest) GetPrepared() bool {
	if x != nil {
		return x.Prepared
	}
	return false
}

// ExecuteResponse is the returned value from Execute.
type ExecuteResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// error contains an application level error if necessary. Note the
	// session may have changed, even when an error is returned (for
	// instance if a database integrity error happened).
	Error *vtrpc.RPCError `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	// session is the updated session information.
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// result contains the query result, only set if error is unset.
	Result        *query.QueryResult `protobuf:"bytes,3,opt,name=result,proto3" json:"result,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExecuteResponse) Reset() {
	*x = ExecuteResponse{}
	mi := &file_vtgate_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExecuteResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExecuteResponse) ProtoMessage() {}

func (x *ExecuteResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vtgate_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExecuteResponse.ProtoReflect.Descriptor instead.
func (*ExecuteResponse) Descriptor() ([]byte, []int) {
	return file_vtgate_proto_rawDescGZIP(), []int{6}
}

func (x *ExecuteResponse) GetError() *vtrpc.RPCError {
	if x != nil {
		return x.Error
	}
	return nil
}

func (x *ExecuteResponse) GetSession() *Session {
	if x != nil {
		return x.Session
	}
	return nil
}

func (x *ExecuteResponse) GetResult() *query.QueryResult {
	if x != nil {
		return x.Result
	}
	return nil
}

// ExecuteBatchRequest is the payload to ExecuteBatch.
type ExecuteBatchRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"caller_id,omitempty"`
	// session carries the session state.
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// queries is a list of query and bind variables to execute.
	Queries       []*query.BoundQuery `protobuf:"bytes,3,rep,name=queries,proto3" json:"queries,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExecuteBatchRequest) Reset() {
	*x = ExecuteBatchRequest{}
	mi := &file_vtgate_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExecuteBatchRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExecuteBatchRequest) ProtoMessage() {}

func (x *ExecuteBatchRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vtgate_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExecuteBatchRequest.ProtoReflect.Descriptor instead.
func (*ExecuteBatchRequest) Descriptor() ([]byte, []int) {
	return file_vtgate_proto_rawDescGZIP(), []int{7}
}

func (x *ExecuteBatchRequest) GetCallerId() *vtrpc.CallerID {
	if x != nil {
		return x.CallerId
	}
	return nil
}

func (x *ExecuteBatchRequest) GetSession() *Session {
	if x != nil {
		return x.Session
	}
	return nil
}

func (x *ExecuteBatchRequest) GetQueries() []*query.BoundQuery {
	if x != nil {
		return x.Queries
	}
	return nil
}

// ExecuteBatchResponse is the returned value from ExecuteBatch.
type ExecuteBatchResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// error contains an application level error if necessary. Note the
	// session may have changed, even when an error is returned (for
	// instance if a database integrity error happened).
	Error *vtrpc.RPCError `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	// session is the updated session information.
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// results contains the query results, only set if application level error is unset.
	Results       []*query.ResultWithError `protobuf:"bytes,3,rep,name=results,proto3" json:"results,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExecuteBatchResponse) Reset() {
	*x = ExecuteBatchResponse{}
	mi := &file_vtgate_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExecuteBatchResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExecuteBatchResponse) ProtoMessage() {}

func (x *ExecuteBatchResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vtgate_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExecuteBatchResponse.ProtoReflect.Descriptor instead.
func (*ExecuteBatchResponse) Descriptor() ([]byte, []int) {
	return file_vtgate_proto_rawDescGZIP(), []int{8}
}

func (x *ExecuteBatchResponse) GetError() *vtrpc.RPCError {
	if x != nil {
		return x.Error
	}
	return nil
}

func (x *ExecuteBatchResponse) GetSession() *Session {
	if x != nil {
		return x.Session
	}
	return nil
}

func (x *ExecuteBatchResponse) GetResults() []*query.ResultWithError {
	if x != nil {
		return x.Results
	}
	return nil
}

// StreamExecuteRequest is the payload to StreamExecute.
type StreamExecuteRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"caller_id,omitempty"`
	// query is the query and bind variables to execute.
	Query *query.BoundQuery `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
	// session carries the session state.
	Session       *Session `protobuf:"bytes,6,opt,name=session,proto3" json:"session,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamExecuteRequest) Reset() {
	*x = StreamExecuteRequest{}
	mi := &file_vtgate_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamExecuteRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamExecuteRequest) ProtoMessage() {}

func (x *StreamExecuteRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vtgate_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamExecuteRequest.ProtoReflect.Descriptor instead.
func (*StreamExecuteRequest) Descriptor() ([]byte, []int) {
	return file_vtgate_proto_rawDescGZIP(), []int{9}
}

func (x *StreamExecuteRequest) GetCallerId() *vtrpc.CallerID {
	if x != nil {
		return x.CallerId
	}
	return nil
}

func (x *StreamExecuteRequest) GetQuery() *query.BoundQuery {
	if x != nil {
		return x.Query
	}
	return nil
}

func (x *StreamExecuteRequest) GetSession() *Session {
	if x != nil {
		return x.Session
	}
	return nil
}

// StreamExecuteResponse is the returned value from StreamExecute.
// The session is currently not returned because StreamExecute is
// not expected to modify it.
type StreamExecuteResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// result contains the result data.
	// The first value contains only Fields information.
	// The next values contain the actual rows, a few values per result.
	Result *query.QueryResult `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
	// session is the updated session information.
	Session       *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamExecuteResponse) Reset() {
	*x = StreamExecuteResponse{}
	mi := &file_vtgate_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamExecuteResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamExecuteResponse) ProtoMessage() {}

func (x *StreamExecuteResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vtgate_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamExecuteResponse.ProtoReflect.Descriptor instead.
func (*StreamExecuteResponse) Descriptor() ([]byte, []int) {
	return file_vtgate_proto_rawDescGZIP(), []int{10}
}

func (x *StreamExecuteResponse) GetResult() *query.QueryResult {
	if x != nil {
		return x.Result
	}
	return nil
}

func (x *StreamExecuteResponse) GetSession() *Session {
	if x != nil {
		return x.Session
	}
	return nil
}

// StreamExecuteMultiRequest is the payload to StreamExecuteMulti.
type StreamExecuteMultiRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"caller_id,omitempty"`
	// sql contains the set of queries to execute.
	Sql string `protobuf:"bytes,2,opt,name=sql,proto3" json:"sql,omitempty"`
	// session carries the session state.
	Session       *Session `protobuf:"bytes,3,opt,name=session,proto3" json:"session,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamExecuteMultiRequest) Reset() {
	*x = StreamExecuteMultiRequest{}
	mi := &file_vtgate_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamExecuteMultiRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamExecuteMultiRequest) ProtoMessage() {}

func (x *StreamExecuteMultiRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vtgate_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamExecuteMultiRequest.ProtoReflect.Descriptor instead.
func (*StreamExecuteMultiRequest) Descriptor() ([]byte, []int) {
	return file_vtgate_proto_rawDescGZIP(), []int{11}
}

func (x *StreamExecuteMultiRequest) GetCallerId() *vtrpc.CallerID {
	if x != nil {
		return x.CallerId
	}
	return nil
}

func (x *StreamExecuteMultiRequest) GetSql() string {
	if x != nil {
		return x.Sql
	}
	return ""
}

func (x *StreamExecuteMultiRequest) GetSession() *Session {
	if x != nil {
		return x.Session
	}
	return nil
}

// StreamExecuteMultiResponse is the returned value from StreamExecuteMulti.
type StreamExecuteMultiResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// result contains the result set or an error if one occurred while executing the query.
	Result *query.ResultWithError `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
	// more_results is set to true if there are more results to follow after this one has concluded.
	MoreResults bool `protobuf:"varint,2,opt,name=more_results,json=moreResults,proto3" json:"more_results,omitempty"`
	// new_result signifies a new result has started with this packet.
	NewResult bool `protobuf:"varint,3,opt,name=new_result,json=newResult,proto3" json:"new_result,omitempty"`
	// session is the updated session information.
	Session       *Session `protobuf:"bytes,4,opt,name=session,proto3" json:"session,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamExecuteMultiResponse) Reset() {
	*x = StreamExecuteMultiResponse{}
	mi := &file_vtgate_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamExecuteMultiResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamExecuteMultiResponse) ProtoMessage() {}

func (x *StreamExecuteMultiResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vtgate_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamExecuteMultiResponse.ProtoReflect.Descriptor instead.
func (*StreamExecuteMultiResponse) Descriptor() ([]byte, []int) {
	return file_vtgate_proto_rawDescGZIP(), []int{12}
}

func (x *StreamExecuteMultiResponse) GetResult() *query.ResultWithError {
	if x != nil {
		return x.Result
	}
	return nil
}

func (x *StreamExecuteMultiResponse) GetMoreResults() bool {
	if x != nil {
		return x.MoreResults
	}
	return false
}

func (x *StreamExecuteMultiResponse) GetNewResult() bool {
	if x != nil {
		return x.NewResult
	}
	return false
}

func (x *StreamExecuteMultiResponse) GetSession() *Session {
	if x != nil {
		return x.Session
	}
	return nil
}

// ResolveTransactionRequest is the payload to ResolveTransaction.
type ResolveTransactionRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"caller_id,omitempty"`
	// dtid is the dtid of the transaction to be resolved.
	Dtid          string `protobuf:"bytes,2,opt,name=dtid,proto3" json:"dtid,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ResolveTransactionRequest) Reset() {
	*x = ResolveTransactionRequest{}
	mi := &file_vtgate_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ResolveTransactionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ResolveTransactionRequest) ProtoMessage() {}

func (x *ResolveTransactionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vtgate_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ResolveTransactionRequest.ProtoReflect.Descriptor instead.
func (*ResolveTransactionRequest) Descriptor() ([]byte, []int) {
	return file_vtgate_proto_rawDescGZIP(), []int{13}
}

func (x *ResolveTransactionRequest) GetCallerId() *vtrpc.CallerID {
	if x != nil {
		return x.CallerId
	}
	return nil
}

func (x *ResolveTransactionRequest) GetDtid() string {
	if x != nil {
		return x.Dtid
	}
	return ""
}

// ResolveTransactionResponse is the returned value from Rollback.
type ResolveTransactionResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ResolveTransactionResponse) Reset() {
	*x = ResolveTransactionResponse{}
	mi := &file_vtgate_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ResolveTransactionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ResolveTransactionResponse) ProtoMessage() {}

func (x *ResolveTransactionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vtgate_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ResolveTransactionResponse.ProtoReflect.Descriptor instead.
func (*ResolveTransactionResponse) Descriptor() ([]byte, []int) {
	return file_vtgate_proto_rawDescGZIP(), []int{14}
}

type VStreamFlags struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// align streams
	MinimizeSkew bool `protobuf:"varint,1,opt,name=minimize_skew,json=minimizeSkew,proto3" json:"minimize_skew,omitempty"`
	// how often heartbeats must be sent when idle (seconds)
	HeartbeatInterval uint32 `protobuf:"varint,2,opt,name=heartbeat_interval,json=heartbeatInterval,proto3" json:"heartbeat_interval,omitempty"`
	// stop streams on a reshard (journal event)
	StopOnReshard bool `protobuf:"varint,3,opt,name=stop_on_reshard,json=stopOnReshard,proto3" json:"stop_on_reshard,omitempty"`
	// if specified, these cells (comma-separated) are used to pick source tablets from.
	// defaults to the cell of the vtgate serving the VStream API.
	Cells          string `protobuf:"bytes,4,opt,name=cells,proto3" json:"cells,omitempty"`
	CellPreference string `protobuf:"bytes,5,opt,name=cell_preference,json=cellPreference,proto3" json:"cell_preference,omitempty"`
	TabletOrder    string `protobuf:"bytes,6,opt,name=tablet_order,json=tabletOrder,proto3" json:"tablet_order,omitempty"`
	// When set, all new row events from the `heartbeat` table, for all shards, in the sidecardb will be streamed.
	StreamKeyspaceHeartbeats bool `protobuf:"varint,7,opt,name=stream_keyspace_heartbeats,json=streamKeyspaceHeartbeats,proto3" json:"stream_keyspace_heartbeats,omitempty"`
	// Include reshard journal events in the stream.
	IncludeReshardJournalEvents bool `protobuf:"varint,8,opt,name=include_reshard_journal_events,json=includeReshardJournalEvents,proto3" json:"include_reshard_journal_events,omitempty"`
	// Copy only these tables, skip the rest in the filter.
	// If not provided, the default behaviour is to copy all tables.
	TablesToCopy []string `protobuf:"bytes,9,rep,name=tables_to_copy,json=tablesToCopy,proto3" json:"tables_to_copy,omitempty"`
	// Exclude the keyspace from the table name that is sent to the vstream client
	ExcludeKeyspaceFromTableName bool `protobuf:"varint,10,opt,name=exclude_keyspace_from_table_name,json=excludeKeyspaceFromTableName,proto3" json:"exclude_keyspace_from_table_name,omitempty"`
	// Transaction chunk threshold in bytes. When a transaction exceeds this size,
	// VTGate will acquire a lock to ensure contiguous, non-interleaved delivery
	// (BEGIN...ROW...COMMIT sent sequentially without mixing events from other shards).
	// Events are still chunked to prevent OOM. Transactions smaller than this are sent
	// without locking for better parallelism.
	TransactionChunkSize int64 `protobuf:"varint,11,opt,name=transaction_chunk_size,json=transactionChunkSize,proto3" json:"transaction_chunk_size,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *VStreamFlags) Reset() {
	*x = VStreamFlags{}
	mi := &file_vtgate_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VStreamFlags) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VStreamFlags) ProtoMessage() {}

func (x *VStreamFlags) ProtoReflect() protoreflect.Message {
	mi := &file_vtgate_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VStreamFlags.ProtoReflect.Descriptor instead.
func (*VStreamFlags) Descriptor() ([]byte, []int) {
	return file_vtgate_proto_rawDescGZIP(), []int{15}
}

func (x *VStreamFlags) GetMinimizeSkew() bool {
	if x != nil {
		return x.MinimizeSkew
	}
	return false
}

func (x *VStreamFlags) GetHeartbeatInterval() uint32 {
	if x != nil {
		return x.HeartbeatInterval
	}
	return 0
}

func (x *VStreamFlags) GetStopOnReshard() bool {
	if x != nil {
		return x.StopOnReshard
	}
	return false
}

func (x *VStreamFlags) GetCells() string {
	if x != nil {
		return x.Cells
	}
	return ""
}

func (x *VStreamFlags) GetCellPreference() string {
	if x != nil {
		return x.CellPreference
	}
	return ""
}

func (x *VStreamFlags) GetTabletOrder() string {
	if x != nil {
		return x.TabletOrder
	}
	return ""
}

func (x *VStreamFlags) GetStreamKeyspaceHeartbeats() bool {
	if x != nil {
		return x.StreamKeyspaceHeartbeats
	}
	return false
}

func (x *VStreamFlags) GetIncludeReshardJournalEvents() bool {
	if x != nil {
		return x.IncludeReshardJournalEvents
	}
	return false
}

func (x *VStreamFlags) GetTablesToCopy() []string {
	if x != nil {
		return x.TablesToCopy
	}
	return nil
}

func (x *VStreamFlags) GetExcludeKeyspaceFromTableName() bool {
	if x != nil {
		return x.ExcludeKeyspaceFromTableName
	}
	return false
}

func (x *VStreamFlags) GetTransactionChunkSize() int64 {
	if x != nil {
		return x.TransactionChunkSize
	}
	return 0
}

// VStreamRequest is the payload for VStream.
type VStreamRequest struct {
	state      protoimpl.MessageState `protogen:"open.v1"`
	CallerId   *vtrpc.CallerID        `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"caller_id,omitempty"`
	TabletType topodata.TabletType    `protobuf:"varint,2,opt,name=tablet_type,json=tabletType,proto3,enum=topodata.TabletType" json:"tablet_type,omitempty"`
	// position specifies the starting point of the bin log positions
	// as well as the keyspace-shards to pull events from.
	// position is of the form 'ks1:0@MySQL56/<mysql_pos>|ks2:-80@MySQL56/<mysql_pos>'.
	Vgtid         *binlogdata.VGtid  `protobuf:"bytes,3,opt,name=vgtid,proto3" json:"vgtid,omitempty"`
	Filter        *binlogdata.Filter `protobuf:"bytes,4,opt,name=filter,proto3" json:"filter,omitempty"`
	Flags         *VStreamFlags      `protobuf:"bytes,5,opt,name=flags,proto3" json:"flags,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VStreamRequest) Reset() {
	*x = VStreamRequest{}
	mi := &file_vtgate_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VStreamRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VStreamRequest) ProtoMessage() {}

func (x *VStreamRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vtgate_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VStreamRequest.ProtoReflect.Descriptor instead.
func (*VStreamRequest) Descriptor() ([]byte, []int) {
	return file_vtgate_proto_rawDescGZIP(), []int{16}
}

func (x *VStreamRequest) GetCallerId() *vtrpc.CallerID {
	if x != nil {
		return x.CallerId
	}
	return nil
}

func (x *VStreamRequest) GetTabletType() topodata.TabletType {
	if x != nil {
		return x.TabletType
	}
	return topodata.TabletType(0)
}

func (x *VStreamRequest) GetVgtid() *binlogdata.VGtid {
	if x != nil {
		return x.Vgtid
	}
	return nil
}

func (x *VStreamRequest) GetFilter() *binlogdata.Filter {
	if x != nil {
		return x.Filter
	}
	return nil
}

func (x *VStreamRequest) GetFlags() *VStreamFlags {
	if x != nil {
		return x.Flags
	}
	return nil
}

// VStreamResponse is streamed by VStream.
type VStreamResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Events        []*binlogdata.VEvent   `protobuf:"bytes,1,rep,name=events,proto3" json:"events,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VStreamResponse) Reset() {
	*x = VStreamResponse{}
	mi := &file_vtgate_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VStreamResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VStreamResponse) ProtoMessage() {}

func (x *VStreamResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vtgate_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VStreamResponse.ProtoReflect.Descriptor instead.
func (*VStreamResponse) Descriptor() ([]byte, []int) {
	return file_vtgate_proto_rawDescGZIP(), []int{17}
}

func (x *VStreamResponse) GetEvents() []*binlogdata.VEvent {
	if x != nil {
		return x.Events
	}
	return nil
}

// PrepareRequest is the payload to Prepare.
type PrepareRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"caller_id,omitempty"`
	// session carries the session state.
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// query is the query and bind variables to execute.
	Query         *query.BoundQuery `protobuf:"bytes,3,opt,name=query,proto3" json:"query,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PrepareRequest) Reset() {
	*x = PrepareRequest{}
	mi := &file_vtgate_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PrepareRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PrepareRequest) ProtoMessage() {}

func (x *PrepareRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vtgate_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PrepareRequest.ProtoReflect.Descriptor instead.
func (*PrepareRequest) Descriptor() ([]byte, []int) {
	return file_vtgate_proto_rawDescGZIP(), []int{18}
}

func (x *PrepareRequest) GetCallerId() *vtrpc.CallerID {
	if x != nil {
		return x.CallerId
	}
	return nil
}

func (x *PrepareRequest) GetSession() *Session {
	if x != nil {
		return x.Session
	}
	return nil
}

func (x *PrepareRequest) GetQuery() *query.BoundQuery {
	if x != nil {
		return x.Query
	}
	return nil
}

// PrepareResponse is the returned value from Prepare.
type PrepareResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// error contains an application level error if necessary. Note the
	// session may have changed, even when an error is returned (for
	// instance if a database integrity error happened).
	Error *vtrpc.RPCError `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	// session is the updated session information.
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// fields contains the fields, only set if error is unset.
	Fields        []*query.Field `protobuf:"bytes,3,rep,name=fields,proto3" json:"fields,omitempty"`
	ParamsCount   uint32         `protobuf:"varint,4,opt,name=params_count,json=paramsCount,proto3" json:"params_count,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PrepareResponse) Reset() {
	*x = PrepareResponse{}
	mi := &file_vtgate_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PrepareResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PrepareResponse) ProtoMessage() {}

func (x *PrepareResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vtgate_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PrepareResponse.ProtoReflect.Descriptor instead.
func (*PrepareResponse) Descriptor() ([]byte, []int) {
	return file_vtgate_proto_rawDescGZIP(), []int{19}
}

func (x *PrepareResponse) GetError() *vtrpc.RPCError {
	if x != nil {
		return x.Error
	}
	return nil
}

func (x *PrepareResponse) GetSession() *Session {
	if x != nil {
		return x.Session
	}
	return nil
}

func (x *PrepareResponse) GetFields() []*query.Field {
	if x != nil {
		return x.Fields
	}
	return nil
}

func (x *PrepareResponse) GetParamsCount() uint32 {
	if x != nil {
		return x.ParamsCount
	}
	return 0
}

// CloseSessionRequest is the payload to CloseSession.
type CloseSessionRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"caller_id,omitempty"`
	// session carries the session state.
	Session       *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CloseSessionRequest) Reset() {
	*x = CloseSessionRequest{}
	mi := &file_vtgate_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CloseSessionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CloseSessionRequest) ProtoMessage() {}

func (x *CloseSessionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vtgate_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CloseSessionRequest.ProtoReflect.Descriptor instead.
func (*CloseSessionRequest) Descriptor() ([]byte, []int) {
	return file_vtgate_proto_rawDescGZIP(), []int{20}
}

func (x *CloseSessionRequest) GetCallerId() *vtrpc.CallerID {
	if x != nil {
		return x.CallerId
	}
	return nil
}

func (x *CloseSessionRequest) GetSession() *Session {
	if x != nil {
		return x.Session
	}
	return nil
}

// CloseSessionResponse is the returned value from CloseSession.
type CloseSessionResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// error contains an application level error if necessary. Note the
	// session may have changed, even when an error is returned (for
	// instance if a database integrity error happened).
	Error         *vtrpc.RPCError `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CloseSessionResponse) Reset() {
	*x = CloseSessionResponse{}
	mi := &file_vtgate_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CloseSessionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CloseSessionResponse) ProtoMessage() {}

func (x *CloseSessionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vtgate_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CloseSessionResponse.ProtoReflect.Descriptor instead.
func (*CloseSessionResponse) Descriptor() ([]byte, []int) {
	return file_vtgate_proto_rawDescGZIP(), []int{21}
}

func (x *CloseSessionResponse) GetError() *vtrpc.RPCError {
	if x != nil {
		return x.Error
	}
	return nil
}

type Session_ShardSession struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Target        *query.Target          `protobuf:"bytes,1,opt,name=target,proto3" json:"target,omitempty"`
	TransactionId int64                  `protobuf:"varint,2,opt,name=transaction_id,json=transactionId,proto3" json:"transaction_id,omitempty"`
	TabletAlias   *topodata.TabletAlias  `protobuf:"bytes,3,opt,name=tablet_alias,json=tabletAlias,proto3" json:"tablet_alias,omitempty"`
	// reserved connection if a dedicated connection is needed
	ReservedId int64 `protobuf:"varint,4,opt,name=reserved_id,json=reservedId,proto3" json:"reserved_id,omitempty"`
	// read_only is true if the session has only executed read queries.
	ReadOnly bool `protobuf:"varint,5,opt,name=read_only,json=readOnly,proto3" json:"read_only,omitempty"`
	// rows_affected tracks if any query has modified the rows.
	RowsAffected  bool `protobuf:"varint,6,opt,name=rows_affected,json=rowsAffected,proto3" json:"rows_affected,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Session_ShardSession) Reset() {
	*x = Session_ShardSession{}
	mi := &file_vtgate_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Session_ShardSession) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Session_ShardSession) ProtoMessage() {}

func (x *Session_ShardSession) ProtoReflect() protoreflect.Message {
	mi := &file_vtgate_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Session_ShardSession.ProtoReflect.Descriptor instead.
func (*Session_ShardSession) Descriptor() ([]byte, []int) {
	return file_vtgate_proto_rawDescGZIP(), []int{0, 0}
}

func (x *Session_ShardSession) GetTarget() *query.Target {
	if x != nil {
		return x.Target
	}
	return nil
}

func (x *Session_ShardSession) GetTransactionId() int64 {
	if x != nil {
		return x.TransactionId
	}
	return 0
}

func (x *Session_ShardSession) GetTabletAlias() *topodata.TabletAlias {
	if x != nil {
		return x.TabletAlias
	}
	return nil
}

func (x *Session_ShardSession) GetReservedId() int64 {
	if x != nil {
		return x.ReservedId
	}
	return 0
}

func (x *Session_ShardSession) GetReadOnly() bool {
	if x != nil {
		return x.ReadOnly
	}
	return false
}

func (x *Session_ShardSession) GetRowsAffected() bool {
	if x != nil {
		return x.RowsAffected
	}
	return false
}

var File_vtgate_proto protoreflect.FileDescriptor

const file_vtgate_proto_rawDesc = "" +
	"\n" +
	"\fvtgate.proto\x12\x06vtgate\x1a\x10binlogdata.proto\x1a\vquery.proto\x1a\x0etopodata.proto\x1a\vvtrpc.proto\"\xce\x0f\n" +
	"\aSession\x12%\n" +
	"\x0ein_transaction\x18\x01 \x01(\bR\rinTransaction\x12C\n" +
	"\x0eshard_sessions\x18\x02 \x03(\v2\x1c.vtgate.Session.ShardSessionR\rshardSessions\x12\x1e\n" +
	"\n" +
	"autocommit\x18\x04 \x01(\bR\n" +
	"autocommit\x12#\n" +
	"\rtarget_string\x18\x05 \x01(\tR\ftargetString\x12/\n" +
	"\aoptions\x18\x06 \x01(\v2\x15.query.ExecuteOptionsR\aoptions\x12B\n" +
	"\x10transaction_mode\x18\a \x01(\x0e2\x17.vtgate.TransactionModeR\x0ftransactionMode\x12/\n" +
	"\bwarnings\x18\b \x03(\v2\x13.query.QueryWarningR\bwarnings\x12?\n" +
	"\fpre_sessions\x18\t \x03(\v2\x1c.vtgate.Session.ShardSessionR\vpreSessions\x12A\n" +
	"\rpost_sessions\x18\n" +
	" \x03(\v2\x1c.vtgate.Session.ShardSessionR\fpostSessions\x12$\n" +
	"\x0elast_insert_id\x18\v \x01(\x04R\flastInsertId\x12\x1d\n" +
	"\n" +
	"found_rows\x18\f \x01(\x04R\tfoundRows\x12_\n" +
	"\x16user_defined_variables\x18\r \x03(\v2).vtgate.Session.UserDefinedVariablesEntryR\x14userDefinedVariables\x12O\n" +
	"\x10system_variables\x18\x0e \x03(\v2$.vtgate.Session.SystemVariablesEntryR\x0fsystemVariables\x12\x1b\n" +
	"\trow_count\x18\x0f \x01(\x03R\browCount\x12\x1e\n" +
	"\n" +
	"savepoints\x18\x10 \x03(\tR\n" +
	"savepoints\x12(\n" +
	"\x10in_reserved_conn\x18\x11 \x01(\bR\x0einReservedConn\x12?\n" +
	"\flock_session\x18\x12 \x01(\v2\x1c.vtgate.Session.ShardSessionR\vlockSession\x12.\n" +
	"\x13last_lock_heartbeat\x18\x13 \x01(\x03R\x11lastLockHeartbeat\x12@\n" +
	"\x10read_after_write\x18\x14 \x01(\v2\x16.vtgate.ReadAfterWriteR\x0ereadAfterWrite\x12 \n" +
	"\vDDLStrategy\x18\x15 \x01(\tR\vDDLStrategy\x12 \n" +
	"\vSessionUUID\x18\x16 \x01(\tR\vSessionUUID\x124\n" +
	"\x16enable_system_settings\x18\x17 \x01(\bR\x14enableSystemSettings\x12F\n" +
	"\radvisory_lock\x18\x18 \x03(\v2!.vtgate.Session.AdvisoryLockEntryR\fadvisoryLock\x12#\n" +
	"\rquery_timeout\x18\x19 \x01(\x03R\fqueryTimeout\x12R\n" +
	"\x11prepare_statement\x18\x1a \x03(\v2%.vtgate.Session.PrepareStatementEntryR\x10prepareStatement\x12+\n" +
	"\x11migration_context\x18\x1b \x01(\tR\x10migrationContext\x120\n" +
	"\x14error_until_rollback\x18\x1c \x01(\bR\x12errorUntilRollback\x1a\xf9\x01\n" +
	"\fShardSession\x12%\n" +
	"\x06target\x18\x01 \x01(\v2\r.query.TargetR\x06target\x12%\n" +
	"\x0etransaction_id\x18\x02 \x01(\x03R\rtransactionId\x128\n" +
	"\ftablet_alias\x18\x03 \x01(\v2\x15.topodata.TabletAliasR\vtabletAlias\x12\x1f\n" +
	"\vreserved_id\x18\x04 \x01(\x03R\n" +
	"reservedId\x12\x1b\n" +
	"\tread_only\x18\x05 \x01(\bR\breadOnly\x12#\n" +
	"\rrows_affected\x18\x06 \x01(\bR\frowsAffected\x1a\\\n" +
	"\x19UserDefinedVariablesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12)\n" +
	"\x05value\x18\x02 \x01(\v2\x13.query.BindVariableR\x05value:\x028\x01\x1aB\n" +
	"\x14SystemVariablesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1a?\n" +
	"\x11AdvisoryLockEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\x03R\x05value:\x028\x01\x1aX\n" +
	"\x15PrepareStatementEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12)\n" +
	"\x05value\x18\x02 \x01(\v2\x13.vtgate.PrepareDataR\x05value:\x028\x01J\x04\b\x03\x10\x04\"]\n" +
	"\vPrepareData\x12+\n" +
	"\x11prepare_statement\x18\x01 \x01(\tR\x10prepareStatement\x12!\n" +
	"\fparams_count\x18\x02 \x01(\x05R\vparamsCount\"\xac\x01\n" +
	"\x0eReadAfterWrite\x121\n" +
	"\x15read_after_write_gtid\x18\x01 \x01(\tR\x12readAfterWriteGtid\x127\n" +
	"\x18read_after_write_timeout\x18\x02 \x01(\x01R\x15readAfterWriteTimeout\x12.\n" +
	"\x13session_track_gtids\x18\x03 \x01(\bR\x11sessionTrackGtids\"\x80\x01\n" +
	"\x13ExecuteMultiRequest\x12,\n" +
	"\tcaller_id\x18\x01 \x01(\v2\x0f.vtrpc.CallerIDR\bcallerId\x12\x10\n" +
	"\x03sql\x18\x02 \x01(\tR\x03sql\x12)\n" +
	"\asession\x18\x03 \x01(\v2\x0f.vtgate.SessionR\asession\"\x96\x01\n" +
	"\x14ExecuteMultiResponse\x12%\n" +
	"\x05error\x18\x01 \x01(\v2\x0f.vtrpc.RPCErrorR\x05error\x12)\n" +
	"\asession\x18\x02 \x01(\v2\x0f.vtgate.SessionR\asession\x12,\n" +
	"\aresults\x18\x03 \x03(\v2\x12.query.QueryResultR\aresults\"\xc6\x01\n" +
	"\x0eExecuteRequest\x12,\n" +
	"\tcaller_id\x18\x01 \x01(\v2\x0f.vtrpc.CallerIDR\bcallerId\x12)\n" +
	"\asession\x18\x02 \x01(\v2\x0f.vtgate.SessionR\asession\x12'\n" +
	"\x05query\x18\x03 \x01(\v2\x11.query.BoundQueryR\x05query\x12\x1a\n" +
	"\bprepared\x18\b \x01(\bR\bpreparedJ\x04\b\x04\x10\x05J\x04\b\x05\x10\x06J\x04\b\x06\x10\aJ\x04\b\a\x10\b\"\x8f\x01\n" +
	"\x0fExecuteResponse\x12%\n" +
	"\x05error\x18\x01 \x01(\v2\x0f.vtrpc.RPCErrorR\x05error\x12)\n" +
	"\asession\x18\x02 \x01(\v2\x0f.vtgate.SessionR\asession\x12*\n" +
	"\x06result\x18\x03 \x01(\v2\x12.query.QueryResultR\x06result\"\xb3\x01\n" +
	"\x13ExecuteBatchRequest\x12,\n" +
	"\tcaller_id\x18\x01 \x01(\v2\x0f.vtrpc.CallerIDR\bcallerId\x12)\n" +
	"\asession\x18\x02 \x01(\v2\x0f.vtgate.SessionR\asession\x12+\n" +
	"\aqueries\x18\x03 \x03(\v2\x11.query.BoundQueryR\aqueriesJ\x04\b\x04\x10\x05J\x04\b\x05\x10\x06J\x04\b\x06\x10\aJ\x04\b\a\x10\b\"\x9a\x01\n" +
	"\x14ExecuteBatchResponse\x12%\n" +
	"\x05error\x18\x01 \x01(\v2\x0f.vtrpc.RPCErrorR\x05error\x12)\n" +
	"\asession\x18\x02 \x01(\v2\x0f.vtgate.SessionR\asession\x120\n" +
	"\aresults\x18\x03 \x03(\v2\x16.query.ResultWithErrorR\aresults\"\xaa\x01\n" +
	"\x14StreamExecuteRequest\x12,\n" +
	"\tcaller_id\x18\x01 \x01(\v2\x0f.vtrpc.CallerIDR\bcallerId\x12'\n" +
	"\x05query\x18\x02 \x01(\v2\x11.query.BoundQueryR\x05query\x12)\n" +
	"\asession\x18\x06 \x01(\v2\x0f.vtgate.SessionR\asessionJ\x04\b\x03\x10\x04J\x04\b\x04\x10\x05J\x04\b\x05\x10\x06\"n\n" +
	"\x15StreamExecuteResponse\x12*\n" +
	"\x06result\x18\x01 \x01(\v2\x12.query.QueryResultR\x06result\x12)\n" +
	"\asession\x18\x02 \x01(\v2\x0f.vtgate.SessionR\asession\"\x86\x01\n" +
	"\x19StreamExecuteMultiRequest\x12,\n" +
	"\tcaller_id\x18\x01 \x01(\v2\x0f.vtrpc.CallerIDR\bcallerId\x12\x10\n" +
	"\x03sql\x18\x02 \x01(\tR\x03sql\x12)\n" +
	"\asession\x18\x03 \x01(\v2\x0f.vtgate.SessionR\asession\"\xb9\x01\n" +
	"\x1aStreamExecuteMultiResponse\x12.\n" +
	"\x06result\x18\x01 \x01(\v2\x16.query.ResultWithErrorR\x06result\x12!\n" +
	"\fmore_results\x18\x02 \x01(\bR\vmoreResults\x12\x1d\n" +
	"\n" +
	"new_result\x18\x03 \x01(\bR\tnewResult\x12)\n" +
	"\asession\x18\x04 \x01(\v2\x0f.vtgate.SessionR\asession\"]\n" +
	"\x19ResolveTransactionRequest\x12,\n" +
	"\tcaller_id\x18\x01 \x01(\v2\x0f.vtrpc.CallerIDR\bcallerId\x12\x12\n" +
	"\x04dtid\x18\x02 \x01(\tR\x04dtid\"\x1c\n" +
	"\x1aResolveTransactionResponse\"\x93\x04\n" +
	"\fVStreamFlags\x12#\n" +
	"\rminimize_skew\x18\x01 \x01(\bR\fminimizeSkew\x12-\n" +
	"\x12heartbeat_interval\x18\x02 \x01(\rR\x11heartbeatInterval\x12&\n" +
	"\x0fstop_on_reshard\x18\x03 \x01(\bR\rstopOnReshard\x12\x14\n" +
	"\x05cells\x18\x04 \x01(\tR\x05cells\x12'\n" +
	"\x0fcell_preference\x18\x05 \x01(\tR\x0ecellPreference\x12!\n" +
	"\ftablet_order\x18\x06 \x01(\tR\vtabletOrder\x12<\n" +
	"\x1astream_keyspace_heartbeats\x18\a \x01(\bR\x18streamKeyspaceHeartbeats\x12C\n" +
	"\x1einclude_reshard_journal_events\x18\b \x01(\bR\x1bincludeReshardJournalEvents\x12$\n" +
	"\x0etables_to_copy\x18\t \x03(\tR\ftablesToCopy\x12F\n" +
	" exclude_keyspace_from_table_name\x18\n" +
	" \x01(\bR\x1cexcludeKeyspaceFromTableName\x124\n" +
	"\x16transaction_chunk_size\x18\v \x01(\x03R\x14transactionChunkSize\"\xf6\x01\n" +
	"\x0eVStreamRequest\x12,\n" +
	"\tcaller_id\x18\x01 \x01(\v2\x0f.vtrpc.CallerIDR\bcallerId\x125\n" +
	"\vtablet_type\x18\x02 \x01(\x0e2\x14.topodata.TabletTypeR\n" +
	"tabletType\x12'\n" +
	"\x05vgtid\x18\x03 \x01(\v2\x11.binlogdata.VGtidR\x05vgtid\x12*\n" +
	"\x06filter\x18\x04 \x01(\v2\x12.binlogdata.FilterR\x06filter\x12*\n" +
	"\x05flags\x18\x05 \x01(\v2\x14.vtgate.VStreamFlagsR\x05flags\"=\n" +
	"\x0fVStreamResponse\x12*\n" +
	"\x06events\x18\x01 \x03(\v2\x12.binlogdata.VEventR\x06events\"\x92\x01\n" +
	"\x0ePrepareRequest\x12,\n" +
	"\tcaller_id\x18\x01 \x01(\v2\x0f.vtrpc.CallerIDR\bcallerId\x12)\n" +
	"\asession\x18\x02 \x01(\v2\x0f.vtgate.SessionR\asession\x12'\n" +
	"\x05query\x18\x03 \x01(\v2\x11.query.BoundQueryR\x05query\"\xac\x01\n" +
	"\x0fPrepareResponse\x12%\n" +
	"\x05error\x18\x01 \x01(\v2\x0f.vtrpc.RPCErrorR\x05error\x12)\n" +
	"\asession\x18\x02 \x01(\v2\x0f.vtgate.SessionR\asession\x12$\n" +
	"\x06fields\x18\x03 \x03(\v2\f.query.FieldR\x06fields\x12!\n" +
	"\fparams_count\x18\x04 \x01(\rR\vparamsCount\"n\n" +
	"\x13CloseSessionRequest\x12,\n" +
	"\tcaller_id\x18\x01 \x01(\v2\x0f.vtrpc.CallerIDR\bcallerId\x12)\n" +
	"\asession\x18\x02 \x01(\v2\x0f.vtgate.SessionR\asession\"=\n" +
	"\x14CloseSessionResponse\x12%\n" +
	"\x05error\x18\x01 \x01(\v2\x0f.vtrpc.RPCErrorR\x05error*D\n" +
	"\x0fTransactionMode\x12\x0f\n" +
	"\vUNSPECIFIED\x10\x00\x12\n" +
	"\n" +
	"\x06SINGLE\x10\x01\x12\t\n" +
	"\x05MULTI\x10\x02\x12\t\n" +
	"\x05TWOPC\x10\x03*<\n" +
	"\vCommitOrder\x12\n" +
	"\n" +
	"\x06NORMAL\x10\x00\x12\a\n" +
	"\x03PRE\x10\x01\x12\b\n" +
	"\x04POST\x10\x02\x12\x0e\n" +
	"\n" +
	"AUTOCOMMIT\x10\x03B6\n" +
	"\x0fio.vitess.protoZ#vitess.io/vitess/go/vt/proto/vtgateb\x06proto3"

var (
	file_vtgate_proto_rawDescOnce sync.Once
	file_vtgate_proto_rawDescData []byte
)

func file_vtgate_proto_rawDescGZIP() []byte {
	file_vtgate_proto_rawDescOnce.Do(func() {
		file_vtgate_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_vtgate_proto_rawDesc), len(file_vtgate_proto_rawDesc)))
	})
	return file_vtgate_proto_rawDescData
}

var file_vtgate_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_vtgate_proto_msgTypes = make([]protoimpl.MessageInfo, 27)
var file_vtgate_proto_goTypes = []any{
	(TransactionMode)(0),               // 0: vtgate.TransactionMode
	(CommitOrder)(0),                   // 1: vtgate.CommitOrder
	(*Session)(nil),                    // 2: vtgate.Session
	(*PrepareData)(nil),                // 3: vtgate.PrepareData
	(*ReadAfterWrite)(nil),             // 4: vtgate.ReadAfterWrite
	(*ExecuteMultiRequest)(nil),        // 5: vtgate.ExecuteMultiRequest
	(*ExecuteMultiResponse)(nil),       // 6: vtgate.ExecuteMultiResponse
	(*ExecuteRequest)(nil),             // 7: vtgate.ExecuteRequest
	(*ExecuteResponse)(nil),            // 8: vtgate.ExecuteResponse
	(*ExecuteBatchRequest)(nil),        // 9: vtgate.ExecuteBatchRequest
	(*ExecuteBatchResponse)(nil),       // 10: vtgate.ExecuteBatchResponse
	(*StreamExecuteRequest)(nil),       // 11: vtgate.StreamExecuteRequest
	(*StreamExecuteResponse)(nil),      // 12: vtgate.StreamExecuteResponse
	(*StreamExecuteMultiRequest)(nil),  // 13: vtgate.StreamExecuteMultiRequest
	(*StreamExecuteMultiResponse)(nil), // 14: vtgate.StreamExecuteMultiResponse
	(*ResolveTransactionRequest)(nil),  // 15: vtgate.ResolveTransactionRequest
	(*ResolveTransactionResponse)(nil), // 16: vtgate.ResolveTransactionResponse
	(*VStreamFlags)(nil),               // 17: vtgate.VStreamFlags
	(*VStreamRequest)(nil),             // 18: vtgate.VStreamRequest
	(*VStreamResponse)(nil),            // 19: vtgate.VStreamResponse
	(*PrepareRequest)(nil),             // 20: vtgate.PrepareRequest
	(*PrepareResponse)(nil),            // 21: vtgate.PrepareResponse
	(*CloseSessionRequest)(nil),        // 22: vtgate.CloseSessionRequest
	(*CloseSessionResponse)(nil),       // 23: vtgate.CloseSessionResponse
	(*Session_ShardSession)(nil),       // 24: vtgate.Session.ShardSession
	nil,                                // 25: vtgate.Session.UserDefinedVariablesEntry
	nil,                                // 26: vtgate.Session.SystemVariablesEntry
	nil,                                // 27: vtgate.Session.AdvisoryLockEntry
	nil,                                // 28: vtgate.Session.PrepareStatementEntry
	(*query.ExecuteOptions)(nil),       // 29: query.ExecuteOptions
	(*query.QueryWarning)(nil),         // 30: query.QueryWarning
	(*vtrpc.CallerID)(nil),             // 31: vtrpc.CallerID
	(*vtrpc.RPCError)(nil),             // 32: vtrpc.RPCError
	(*query.QueryResult)(nil),          // 33: query.QueryResult
	(*query.BoundQuery)(nil),           // 34: query.BoundQuery
	(*query.ResultWithError)(nil),      // 35: query.ResultWithError
	(topodata.TabletType)(0),           // 36: topodata.TabletType
	(*binlogdata.VGtid)(nil),           // 37: binlogdata.VGtid
	(*binlogdata.Filter)(nil),          // 38: binlogdata.Filter
	(*binlogdata.VEvent)(nil),          // 39: binlogdata.VEvent
	(*query.Field)(nil),                // 40: query.Field
	(*query.Target)(nil),               // 41: query.Target
	(*topodata.TabletAlias)(nil),       // 42: topodata.TabletAlias
	(*query.BindVariable)(nil),         // 43: query.BindVariable
}
var file_vtgate_proto_depIdxs = []int32{
	24, // 0: vtgate.Session.shard_sessions:type_name -> vtgate.Session.ShardSession
	29, // 1: vtgate.Session.options:type_name -> query.ExecuteOptions
	0,  // 2: vtgate.Session.transaction_mode:type_name -> vtgate.TransactionMode
	30, // 3: vtgate.Session.warnings:type_name -> query.QueryWarning
	24, // 4: vtgate.Session.pre_sessions:type_name -> vtgate.Session.ShardSession
	24, // 5: vtgate.Session.post_sessions:type_name -> vtgate.Session.ShardSession
	25, // 6: vtgate.Session.user_defined_variables:type_name -> vtgate.Session.UserDefinedVariablesEntry
	26, // 7: vtgate.Session.system_variables:type_name -> vtgate.Session.SystemVariablesEntry
	24, // 8: vtgate.Session.lock_session:type_name -> vtgate.Session.ShardSession
	4,  // 9: vtgate.Session.read_after_write:type_name -> vtgate.ReadAfterWrite
	27, // 10: vtgate.Session.advisory_lock:type_name -> vtgate.Session.AdvisoryLockEntry
	28, // 11: vtgate.Session.prepare_statement:type_name -> vtgate.Session.PrepareStatementEntry
	31, // 12: vtgate.ExecuteMultiRequest.caller_id:type_name -> vtrpc.CallerID
	2,  // 13: vtgate.ExecuteMultiRequest.session:type_name -> vtgate.Session
	32, // 14: vtgate.ExecuteMultiResponse.error:type_name -> vtrpc.RPCError
	2,  // 15: vtgate.ExecuteMultiResponse.session:type_name -> vtgate.Session
	33, // 16: vtgate.ExecuteMultiResponse.results:type_name -> query.QueryResult
	31, // 17: vtgate.ExecuteRequest.caller_id:type_name -> vtrpc.CallerID
	2,  // 18: vtgate.ExecuteRequest.session:type_name -> vtgate.Session
	34, // 19: vtgate.ExecuteRequest.query:type_name -> query.BoundQuery
	32, // 20: vtgate.ExecuteResponse.error:type_name -> vtrpc.RPCError
	2,  // 21: vtgate.ExecuteResponse.session:type_name -> vtgate.Session
	33, // 22: vtgate.ExecuteResponse.result:type_name -> query.QueryResult
	31, // 23: vtgate.ExecuteBatchRequest.caller_id:type_name -> vtrpc.CallerID
	2,  // 24: vtgate.ExecuteBatchRequest.session:type_name -> vtgate.Session
	34, // 25: vtgate.ExecuteBatchRequest.queries:type_name -> query.BoundQuery
	32, // 26: vtgate.ExecuteBatchResponse.error:type_name -> vtrpc.RPCError
	2,  // 27: vtgate.ExecuteBatchResponse.session:type_name -> vtgate.Session
	35, // 28: vtgate.ExecuteBatchResponse.results:type_name -> query.ResultWithError
	31, // 29: vtgate.StreamExecuteRequest.caller_id:type_name -> vtrpc.CallerID
	34, // 30: vtgate.StreamExecuteRequest.query:type_name -> query.BoundQuery
	2,  // 31: vtgate.StreamExecuteRequest.session:type_name -> vtgate.Session
	33, // 32: vtgate.StreamExecuteResponse.result:type_name -> query.QueryResult
	2,  // 33: vtgate.StreamExecuteResponse.session:type_name -> vtgate.Session
	31, // 34: vtgate.StreamExecuteMultiRequest.caller_id:type_name -> vtrpc.CallerID
	2,  // 35: vtgate.StreamExecuteMultiRequest.session:type_name -> vtgate.Session
	35, // 36: vtgate.StreamExecuteMultiResponse.result:type_name -> query.ResultWithError
	2,  // 37: vtgate.StreamExecuteMultiResponse.session:type_name -> vtgate.Session
	31, // 38: vtgate.ResolveTransactionRequest.caller_id:type_name -> vtrpc.CallerID
	31, // 39: vtgate.VStreamRequest.caller_id:type_name -> vtrpc.CallerID
	36, // 40: vtgate.VStreamRequest.tablet_type:type_name -> topodata.TabletType
	37, // 41: vtgate.VStreamRequest.vgtid:type_name -> binlogdata.VGtid
	38, // 42: vtgate.VStreamRequest.filter:type_name -> binlogdata.Filter
	17, // 43: vtgate.VStreamRequest.flags:type_name -> vtgate.VStreamFlags
	39, // 44: vtgate.VStreamResponse.events:type_name -> binlogdata.VEvent
	31, // 45: vtgate.PrepareRequest.caller_id:type_name -> vtrpc.CallerID
	2,  // 46: vtgate.PrepareRequest.session:type_name -> vtgate.Session
	34, // 47: vtgate.PrepareRequest.query:type_name -> query.BoundQuery
	32, // 48: vtgate.PrepareResponse.error:type_name -> vtrpc.RPCError
	2,  // 49: vtgate.PrepareResponse.session:type_name -> vtgate.Session
	40, // 50: vtgate.PrepareResponse.fields:type_name -> query.Field
	31, // 51: vtgate.CloseSessionRequest.caller_id:type_name -> vtrpc.CallerID
	2,  // 52: vtgate.CloseSessionRequest.session:type_name -> vtgate.Session
	32, // 53: vtgate.CloseSessionResponse.error:type_name -> vtrpc.RPCError
	41, // 54: vtgate.Session.ShardSession.target:type_name -> query.Target
	42, // 55: vtgate.Session.ShardSession.tablet_alias:type_name -> topodata.TabletAlias
	43, // 56: vtgate.Session.UserDefinedVariablesEntry.value:type_name -> query.BindVariable
	3,  // 57: vtgate.Session.PrepareStatementEntry.value:type_name -> vtgate.PrepareData
	58, // [58:58] is the sub-list for method output_type
	58, // [58:58] is the sub-list for method input_type
	58, // [58:58] is the sub-list for extension type_name
	58, // [58:58] is the sub-list for extension extendee
	0,  // [0:58] is the sub-list for field type_name
}

func init() { file_vtgate_proto_init() }
func file_vtgate_proto_init() {
	if File_vtgate_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_vtgate_proto_rawDesc), len(file_vtgate_proto_rawDesc)),
			NumEnums:      2,
			NumMessages:   27,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_vtgate_proto_goTypes,
		DependencyIndexes: file_vtgate_proto_depIdxs,
		EnumInfos:         file_vtgate_proto_enumTypes,
		MessageInfos:      file_vtgate_proto_msgTypes,
	}.Build()
	File_vtgate_proto = out.File
	file_vtgate_proto_goTypes = nil
	file_vtgate_proto_depIdxs = nil
}
