// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: vtgate.proto

package vtgate

import (
	fmt "fmt"
	io "io"
	math "math"

	proto "github.com/gogo/protobuf/proto"
	binlogdata "vitess.io/vitess/go/vt/proto/binlogdata"
	query "vitess.io/vitess/go/vt/proto/query"
	topodata "vitess.io/vitess/go/vt/proto/topodata"
	vtrpc "vitess.io/vitess/go/vt/proto/vtrpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// TransactionMode controls the execution of distributed transaction
// across multiple shards.
type TransactionMode int32

const (
	// UNSPECIFIED uses the transaction mode set by the VTGate flag 'transaction_mode'.
	TransactionMode_UNSPECIFIED TransactionMode = 0
	// SINGLE disallows distributed transactions.
	TransactionMode_SINGLE TransactionMode = 1
	// MULTI allows distributed transactions with best effort commit.
	TransactionMode_MULTI TransactionMode = 2
	// TWOPC is for distributed transactions with atomic commits.
	TransactionMode_TWOPC TransactionMode = 3
)

var TransactionMode_name = map[int32]string{
	0: "UNSPECIFIED",
	1: "SINGLE",
	2: "MULTI",
	3: "TWOPC",
}

var TransactionMode_value = map[string]int32{
	"UNSPECIFIED": 0,
	"SINGLE":      1,
	"MULTI":       2,
	"TWOPC":       3,
}

func (x TransactionMode) String() string {
	return proto.EnumName(TransactionMode_name, int32(x))
}

func (TransactionMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{0}
}

// CommitOrder is used to designate which of the ShardSessions
// get used for transactions.
type CommitOrder int32

const (
	// NORMAL is the default commit order.
	CommitOrder_NORMAL CommitOrder = 0
	// PRE is used to designate pre_sessions.
	CommitOrder_PRE CommitOrder = 1
	// POST is used to designate post_sessions.
	CommitOrder_POST CommitOrder = 2
	// AUTOCOMMIT is used to run the statement as autocommitted transaction.
	CommitOrder_AUTOCOMMIT CommitOrder = 3
)

var CommitOrder_name = map[int32]string{
	0: "NORMAL",
	1: "PRE",
	2: "POST",
	3: "AUTOCOMMIT",
}

var CommitOrder_value = map[string]int32{
	"NORMAL":     0,
	"PRE":        1,
	"POST":       2,
	"AUTOCOMMIT": 3,
}

func (x CommitOrder) String() string {
	return proto.EnumName(CommitOrder_name, int32(x))
}

func (CommitOrder) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{1}
}

// Session objects are exchanged like cookies through various
// calls to VTGate. The behavior differs between V2 & V3 APIs.
// V3 APIs are Execute, ExecuteBatch and StreamExecute. All
// other APIs are V2. For the V3 APIs, the session
// must be sent with every call to Execute or ExecuteBatch.
// For the V2 APIs, Begin does not accept a session. It instead
// returns a brand new one with in_transaction set to true.
// After a call to Commit or Rollback, the session can be
// discarded. If you're not in a transaction, Session is
// an optional parameter for the V2 APIs.
type Session struct {
	// in_transaction is set to true if the session is in a transaction.
	InTransaction bool `protobuf:"varint,1,opt,name=in_transaction,json=inTransaction,proto3" json:"in_transaction,omitempty"`
	// shard_sessions keep track of per-shard transaction info.
	ShardSessions []*Session_ShardSession `protobuf:"bytes,2,rep,name=shard_sessions,json=shardSessions,proto3" json:"shard_sessions,omitempty"`
	// single_db is deprecated. Use transaction_mode instead.
	// The value specifies if the transaction should be restricted
	// to a single shard.
	// TODO(sougou): remove in 3.1
	SingleDb bool `protobuf:"varint,3,opt,name=single_db,json=singleDb,proto3" json:"single_db,omitempty"`
	// autocommit specifies if the session is in autocommit mode.
	// This is used only for V3.
	Autocommit bool `protobuf:"varint,4,opt,name=autocommit,proto3" json:"autocommit,omitempty"`
	// target_string is the target expressed as a string. Valid
	// names are: keyspace:shard@target, keyspace@target or @target.
	// This is used only for V3.
	TargetString string `protobuf:"bytes,5,opt,name=target_string,json=targetString,proto3" json:"target_string,omitempty"`
	// options is used only for V3.
	Options *query.ExecuteOptions `protobuf:"bytes,6,opt,name=options,proto3" json:"options,omitempty"`
	// transaction_mode specifies the current transaction mode.
	TransactionMode TransactionMode `protobuf:"varint,7,opt,name=transaction_mode,json=transactionMode,proto3,enum=vtgate.TransactionMode" json:"transaction_mode,omitempty"`
	// warnings contains non-fatal warnings from the previous query
	Warnings []*query.QueryWarning `protobuf:"bytes,8,rep,name=warnings,proto3" json:"warnings,omitempty"`
	// pre_sessions contains sessions that have to be committed first.
	PreSessions []*Session_ShardSession `protobuf:"bytes,9,rep,name=pre_sessions,json=preSessions,proto3" json:"pre_sessions,omitempty"`
	// post_sessions contains sessions that have to be committed last.
	PostSessions         []*Session_ShardSession `protobuf:"bytes,10,rep,name=post_sessions,json=postSessions,proto3" json:"post_sessions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *Session) Reset()         { *m = Session{} }
func (m *Session) String() string { return proto.CompactTextString(m) }
func (*Session) ProtoMessage()    {}
func (*Session) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{0}
}
func (m *Session) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Session) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Session.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Session) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Session.Merge(m, src)
}
func (m *Session) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Session) XXX_DiscardUnknown() {
	xxx_messageInfo_Session.DiscardUnknown(m)
}

var xxx_messageInfo_Session proto.InternalMessageInfo

func (m *Session) GetInTransaction() bool {
	if m != nil {
		return m.InTransaction
	}
	return false
}

func (m *Session) GetShardSessions() []*Session_ShardSession {
	if m != nil {
		return m.ShardSessions
	}
	return nil
}

func (m *Session) GetSingleDb() bool {
	if m != nil {
		return m.SingleDb
	}
	return false
}

func (m *Session) GetAutocommit() bool {
	if m != nil {
		return m.Autocommit
	}
	return false
}

func (m *Session) GetTargetString() string {
	if m != nil {
		return m.TargetString
	}
	return ""
}

func (m *Session) GetOptions() *query.ExecuteOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *Session) GetTransactionMode() TransactionMode {
	if m != nil {
		return m.TransactionMode
	}
	return TransactionMode_UNSPECIFIED
}

func (m *Session) GetWarnings() []*query.QueryWarning {
	if m != nil {
		return m.Warnings
	}
	return nil
}

func (m *Session) GetPreSessions() []*Session_ShardSession {
	if m != nil {
		return m.PreSessions
	}
	return nil
}

func (m *Session) GetPostSessions() []*Session_ShardSession {
	if m != nil {
		return m.PostSessions
	}
	return nil
}

type Session_ShardSession struct {
	Target               *query.Target `protobuf:"bytes,1,opt,name=target,proto3" json:"target,omitempty"`
	TransactionId        int64         `protobuf:"varint,2,opt,name=transaction_id,json=transactionId,proto3" json:"transaction_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Session_ShardSession) Reset()         { *m = Session_ShardSession{} }
func (m *Session_ShardSession) String() string { return proto.CompactTextString(m) }
func (*Session_ShardSession) ProtoMessage()    {}
func (*Session_ShardSession) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{0, 0}
}
func (m *Session_ShardSession) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Session_ShardSession) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Session_ShardSession.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Session_ShardSession) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Session_ShardSession.Merge(m, src)
}
func (m *Session_ShardSession) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Session_ShardSession) XXX_DiscardUnknown() {
	xxx_messageInfo_Session_ShardSession.DiscardUnknown(m)
}

var xxx_messageInfo_Session_ShardSession proto.InternalMessageInfo

func (m *Session_ShardSession) GetTarget() *query.Target {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *Session_ShardSession) GetTransactionId() int64 {
	if m != nil {
		return m.TransactionId
	}
	return 0
}

// ExecuteRequest is the payload to Execute.
type ExecuteRequest struct {
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"caller_id,omitempty"`
	// session carries the session state.
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// query is the query and bind variables to execute.
	Query *query.BoundQuery `protobuf:"bytes,3,opt,name=query,proto3" json:"query,omitempty"`
	// These values are deprecated. Use session instead.
	// TODO(sougou): remove in 3.1
	TabletType           topodata.TabletType   `protobuf:"varint,4,opt,name=tablet_type,json=tabletType,proto3,enum=topodata.TabletType" json:"tablet_type,omitempty"`
	NotInTransaction     bool                  `protobuf:"varint,5,opt,name=not_in_transaction,json=notInTransaction,proto3" json:"not_in_transaction,omitempty"`
	KeyspaceShard        string                `protobuf:"bytes,6,opt,name=keyspace_shard,json=keyspaceShard,proto3" json:"keyspace_shard,omitempty"`
	Options              *query.ExecuteOptions `protobuf:"bytes,7,opt,name=options,proto3" json:"options,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *ExecuteRequest) Reset()         { *m = ExecuteRequest{} }
func (m *ExecuteRequest) String() string { return proto.CompactTextString(m) }
func (*ExecuteRequest) ProtoMessage()    {}
func (*ExecuteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{1}
}
func (m *ExecuteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecuteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecuteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecuteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecuteRequest.Merge(m, src)
}
func (m *ExecuteRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExecuteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecuteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ExecuteRequest proto.InternalMessageInfo

func (m *ExecuteRequest) GetCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.CallerId
	}
	return nil
}

func (m *ExecuteRequest) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *ExecuteRequest) GetQuery() *query.BoundQuery {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *ExecuteRequest) GetTabletType() topodata.TabletType {
	if m != nil {
		return m.TabletType
	}
	return topodata.TabletType_UNKNOWN
}

func (m *ExecuteRequest) GetNotInTransaction() bool {
	if m != nil {
		return m.NotInTransaction
	}
	return false
}

func (m *ExecuteRequest) GetKeyspaceShard() string {
	if m != nil {
		return m.KeyspaceShard
	}
	return ""
}

func (m *ExecuteRequest) GetOptions() *query.ExecuteOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

// ExecuteResponse is the returned value from Execute.
type ExecuteResponse struct {
	// error contains an application level error if necessary. Note the
	// session may have changed, even when an error is returned (for
	// instance if a database integrity error happened).
	Error *vtrpc.RPCError `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	// session is the updated session information.
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// result contains the query result, only set if error is unset.
	Result               *query.QueryResult `protobuf:"bytes,3,opt,name=result,proto3" json:"result,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *ExecuteResponse) Reset()         { *m = ExecuteResponse{} }
func (m *ExecuteResponse) String() string { return proto.CompactTextString(m) }
func (*ExecuteResponse) ProtoMessage()    {}
func (*ExecuteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{2}
}
func (m *ExecuteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecuteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecuteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecuteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecuteResponse.Merge(m, src)
}
func (m *ExecuteResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExecuteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecuteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ExecuteResponse proto.InternalMessageInfo

func (m *ExecuteResponse) GetError() *vtrpc.RPCError {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *ExecuteResponse) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *ExecuteResponse) GetResult() *query.QueryResult {
	if m != nil {
		return m.Result
	}
	return nil
}

// ExecuteShardsRequest is the payload to ExecuteShards.
type ExecuteShardsRequest struct {
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"caller_id,omitempty"`
	// session carries the current transaction data. It is returned by Begin.
	// Do not fill it in if outside of a transaction.
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// query is the query and bind variables to execute.
	Query *query.BoundQuery `protobuf:"bytes,3,opt,name=query,proto3" json:"query,omitempty"`
	// keyspace to target the query to.
	Keyspace string `protobuf:"bytes,4,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	// shards to target the query to. A DML can only target one shard.
	Shards []string `protobuf:"bytes,5,rep,name=shards,proto3" json:"shards,omitempty"`
	// tablet_type is the type of tablets that this query is targeted to.
	TabletType topodata.TabletType `protobuf:"varint,6,opt,name=tablet_type,json=tabletType,proto3,enum=topodata.TabletType" json:"tablet_type,omitempty"`
	// not_in_transaction is deprecated.
	NotInTransaction bool `protobuf:"varint,7,opt,name=not_in_transaction,json=notInTransaction,proto3" json:"not_in_transaction,omitempty"`
	// options
	Options              *query.ExecuteOptions `protobuf:"bytes,8,opt,name=options,proto3" json:"options,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *ExecuteShardsRequest) Reset()         { *m = ExecuteShardsRequest{} }
func (m *ExecuteShardsRequest) String() string { return proto.CompactTextString(m) }
func (*ExecuteShardsRequest) ProtoMessage()    {}
func (*ExecuteShardsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{3}
}
func (m *ExecuteShardsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecuteShardsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecuteShardsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecuteShardsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecuteShardsRequest.Merge(m, src)
}
func (m *ExecuteShardsRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExecuteShardsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecuteShardsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ExecuteShardsRequest proto.InternalMessageInfo

func (m *ExecuteShardsRequest) GetCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.CallerId
	}
	return nil
}

func (m *ExecuteShardsRequest) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *ExecuteShardsRequest) GetQuery() *query.BoundQuery {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *ExecuteShardsRequest) GetKeyspace() string {
	if m != nil {
		return m.Keyspace
	}
	return ""
}

func (m *ExecuteShardsRequest) GetShards() []string {
	if m != nil {
		return m.Shards
	}
	return nil
}

func (m *ExecuteShardsRequest) GetTabletType() topodata.TabletType {
	if m != nil {
		return m.TabletType
	}
	return topodata.TabletType_UNKNOWN
}

func (m *ExecuteShardsRequest) GetNotInTransaction() bool {
	if m != nil {
		return m.NotInTransaction
	}
	return false
}

func (m *ExecuteShardsRequest) GetOptions() *query.ExecuteOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

// ExecuteShardsResponse is the returned value from ExecuteShards.
type ExecuteShardsResponse struct {
	// error contains an application level error if necessary. Note the
	// session may have changed, even when an error is returned (for
	// instance if a database integrity error happened).
	Error *vtrpc.RPCError `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	// session is the updated session information (only returned inside a transaction).
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// result contains the query result, only set if error is unset.
	Result               *query.QueryResult `protobuf:"bytes,3,opt,name=result,proto3" json:"result,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *ExecuteShardsResponse) Reset()         { *m = ExecuteShardsResponse{} }
func (m *ExecuteShardsResponse) String() string { return proto.CompactTextString(m) }
func (*ExecuteShardsResponse) ProtoMessage()    {}
func (*ExecuteShardsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{4}
}
func (m *ExecuteShardsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecuteShardsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecuteShardsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecuteShardsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecuteShardsResponse.Merge(m, src)
}
func (m *ExecuteShardsResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExecuteShardsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecuteShardsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ExecuteShardsResponse proto.InternalMessageInfo

func (m *ExecuteShardsResponse) GetError() *vtrpc.RPCError {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *ExecuteShardsResponse) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *ExecuteShardsResponse) GetResult() *query.QueryResult {
	if m != nil {
		return m.Result
	}
	return nil
}

// ExecuteKeyspaceIdsRequest is the payload to ExecuteKeyspaceIds.
type ExecuteKeyspaceIdsRequest struct {
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"caller_id,omitempty"`
	// session carries the current transaction data. It is returned by Begin.
	// Do not fill it in if outside of a transaction.
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// query is the query and bind variables to execute.
	Query *query.BoundQuery `protobuf:"bytes,3,opt,name=query,proto3" json:"query,omitempty"`
	// keyspace to target the query to.
	Keyspace string `protobuf:"bytes,4,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	// keyspace_ids contains the list of keyspace_ids affected by this query.
	// Will be used to find the shards to send the query to.
	KeyspaceIds [][]byte `protobuf:"bytes,5,rep,name=keyspace_ids,json=keyspaceIds,proto3" json:"keyspace_ids,omitempty"`
	// tablet_type is the type of tablets that this query is targeted to.
	TabletType topodata.TabletType `protobuf:"varint,6,opt,name=tablet_type,json=tabletType,proto3,enum=topodata.TabletType" json:"tablet_type,omitempty"`
	// not_in_transaction is deprecated.
	NotInTransaction bool `protobuf:"varint,7,opt,name=not_in_transaction,json=notInTransaction,proto3" json:"not_in_transaction,omitempty"`
	// options
	Options              *query.ExecuteOptions `protobuf:"bytes,8,opt,name=options,proto3" json:"options,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *ExecuteKeyspaceIdsRequest) Reset()         { *m = ExecuteKeyspaceIdsRequest{} }
func (m *ExecuteKeyspaceIdsRequest) String() string { return proto.CompactTextString(m) }
func (*ExecuteKeyspaceIdsRequest) ProtoMessage()    {}
func (*ExecuteKeyspaceIdsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{5}
}
func (m *ExecuteKeyspaceIdsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecuteKeyspaceIdsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecuteKeyspaceIdsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecuteKeyspaceIdsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecuteKeyspaceIdsRequest.Merge(m, src)
}
func (m *ExecuteKeyspaceIdsRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExecuteKeyspaceIdsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecuteKeyspaceIdsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ExecuteKeyspaceIdsRequest proto.InternalMessageInfo

func (m *ExecuteKeyspaceIdsRequest) GetCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.CallerId
	}
	return nil
}

func (m *ExecuteKeyspaceIdsRequest) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *ExecuteKeyspaceIdsRequest) GetQuery() *query.BoundQuery {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *ExecuteKeyspaceIdsRequest) GetKeyspace() string {
	if m != nil {
		return m.Keyspace
	}
	return ""
}

func (m *ExecuteKeyspaceIdsRequest) GetKeyspaceIds() [][]byte {
	if m != nil {
		return m.KeyspaceIds
	}
	return nil
}

func (m *ExecuteKeyspaceIdsRequest) GetTabletType() topodata.TabletType {
	if m != nil {
		return m.TabletType
	}
	return topodata.TabletType_UNKNOWN
}

func (m *ExecuteKeyspaceIdsRequest) GetNotInTransaction() bool {
	if m != nil {
		return m.NotInTransaction
	}
	return false
}

func (m *ExecuteKeyspaceIdsRequest) GetOptions() *query.ExecuteOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

// ExecuteKeyspaceIdsResponse is the returned value from ExecuteKeyspaceIds.
type ExecuteKeyspaceIdsResponse struct {
	// error contains an application level error if necessary. Note the
	// session may have changed, even when an error is returned (for
	// instance if a database integrity error happened).
	Error *vtrpc.RPCError `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	// session is the updated session information (only returned inside a transaction).
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// result contains the query result, only set if error is unset.
	Result               *query.QueryResult `protobuf:"bytes,3,opt,name=result,proto3" json:"result,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *ExecuteKeyspaceIdsResponse) Reset()         { *m = ExecuteKeyspaceIdsResponse{} }
func (m *ExecuteKeyspaceIdsResponse) String() string { return proto.CompactTextString(m) }
func (*ExecuteKeyspaceIdsResponse) ProtoMessage()    {}
func (*ExecuteKeyspaceIdsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{6}
}
func (m *ExecuteKeyspaceIdsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecuteKeyspaceIdsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecuteKeyspaceIdsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecuteKeyspaceIdsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecuteKeyspaceIdsResponse.Merge(m, src)
}
func (m *ExecuteKeyspaceIdsResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExecuteKeyspaceIdsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecuteKeyspaceIdsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ExecuteKeyspaceIdsResponse proto.InternalMessageInfo

func (m *ExecuteKeyspaceIdsResponse) GetError() *vtrpc.RPCError {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *ExecuteKeyspaceIdsResponse) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *ExecuteKeyspaceIdsResponse) GetResult() *query.QueryResult {
	if m != nil {
		return m.Result
	}
	return nil
}

// ExecuteKeyRangesRequest is the payload to ExecuteKeyRanges.
type ExecuteKeyRangesRequest struct {
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"caller_id,omitempty"`
	// session carries the current transaction data. It is returned by Begin.
	// Do not fill it in if outside of a transaction.
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// query is the query and bind variables to execute.
	Query *query.BoundQuery `protobuf:"bytes,3,opt,name=query,proto3" json:"query,omitempty"`
	// keyspace to target the query to
	Keyspace string `protobuf:"bytes,4,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	// key_ranges contains the list of key ranges affected by this query.
	// Will be used to find the shards to send the query to.
	KeyRanges []*topodata.KeyRange `protobuf:"bytes,5,rep,name=key_ranges,json=keyRanges,proto3" json:"key_ranges,omitempty"`
	// tablet_type is the type of tablets that this query is targeted to.
	TabletType topodata.TabletType `protobuf:"varint,6,opt,name=tablet_type,json=tabletType,proto3,enum=topodata.TabletType" json:"tablet_type,omitempty"`
	// not_in_transaction is deprecated.
	NotInTransaction bool `protobuf:"varint,7,opt,name=not_in_transaction,json=notInTransaction,proto3" json:"not_in_transaction,omitempty"`
	// options
	Options              *query.ExecuteOptions `protobuf:"bytes,8,opt,name=options,proto3" json:"options,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *ExecuteKeyRangesRequest) Reset()         { *m = ExecuteKeyRangesRequest{} }
func (m *ExecuteKeyRangesRequest) String() string { return proto.CompactTextString(m) }
func (*ExecuteKeyRangesRequest) ProtoMessage()    {}
func (*ExecuteKeyRangesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{7}
}
func (m *ExecuteKeyRangesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecuteKeyRangesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecuteKeyRangesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecuteKeyRangesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecuteKeyRangesRequest.Merge(m, src)
}
func (m *ExecuteKeyRangesRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExecuteKeyRangesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecuteKeyRangesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ExecuteKeyRangesRequest proto.InternalMessageInfo

func (m *ExecuteKeyRangesRequest) GetCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.CallerId
	}
	return nil
}

func (m *ExecuteKeyRangesRequest) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *ExecuteKeyRangesRequest) GetQuery() *query.BoundQuery {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *ExecuteKeyRangesRequest) GetKeyspace() string {
	if m != nil {
		return m.Keyspace
	}
	return ""
}

func (m *ExecuteKeyRangesRequest) GetKeyRanges() []*topodata.KeyRange {
	if m != nil {
		return m.KeyRanges
	}
	return nil
}

func (m *ExecuteKeyRangesRequest) GetTabletType() topodata.TabletType {
	if m != nil {
		return m.TabletType
	}
	return topodata.TabletType_UNKNOWN
}

func (m *ExecuteKeyRangesRequest) GetNotInTransaction() bool {
	if m != nil {
		return m.NotInTransaction
	}
	return false
}

func (m *ExecuteKeyRangesRequest) GetOptions() *query.ExecuteOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

// ExecuteKeyRangesResponse is the returned value from ExecuteKeyRanges.
type ExecuteKeyRangesResponse struct {
	// error contains an application level error if necessary. Note the
	// session may have changed, even when an error is returned (for
	// instance if a database integrity error happened).
	Error *vtrpc.RPCError `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	// session is the updated session information (only returned inside a transaction).
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// result contains the query result, only set if error is unset.
	Result               *query.QueryResult `protobuf:"bytes,3,opt,name=result,proto3" json:"result,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *ExecuteKeyRangesResponse) Reset()         { *m = ExecuteKeyRangesResponse{} }
func (m *ExecuteKeyRangesResponse) String() string { return proto.CompactTextString(m) }
func (*ExecuteKeyRangesResponse) ProtoMessage()    {}
func (*ExecuteKeyRangesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{8}
}
func (m *ExecuteKeyRangesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecuteKeyRangesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecuteKeyRangesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecuteKeyRangesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecuteKeyRangesResponse.Merge(m, src)
}
func (m *ExecuteKeyRangesResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExecuteKeyRangesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecuteKeyRangesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ExecuteKeyRangesResponse proto.InternalMessageInfo

func (m *ExecuteKeyRangesResponse) GetError() *vtrpc.RPCError {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *ExecuteKeyRangesResponse) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *ExecuteKeyRangesResponse) GetResult() *query.QueryResult {
	if m != nil {
		return m.Result
	}
	return nil
}

// ExecuteEntityIdsRequest is the payload to ExecuteEntityIds.
type ExecuteEntityIdsRequest struct {
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"caller_id,omitempty"`
	// session carries the current transaction data. It is returned by Begin.
	// Do not fill it in if outside of a transaction.
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// query is the query and bind variables to execute.
	Query *query.BoundQuery `protobuf:"bytes,3,opt,name=query,proto3" json:"query,omitempty"`
	// keyspace to target the query to.
	Keyspace string `protobuf:"bytes,4,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	// entity_column_name is the column name to use.
	EntityColumnName string `protobuf:"bytes,5,opt,name=entity_column_name,json=entityColumnName,proto3" json:"entity_column_name,omitempty"`
	// entity_keyspace_ids are pairs of entity_column_name values
	// associated with its corresponding keyspace_id.
	EntityKeyspaceIds []*ExecuteEntityIdsRequest_EntityId `protobuf:"bytes,6,rep,name=entity_keyspace_ids,json=entityKeyspaceIds,proto3" json:"entity_keyspace_ids,omitempty"`
	// tablet_type is the type of tablets that this query is targeted to.
	TabletType topodata.TabletType `protobuf:"varint,7,opt,name=tablet_type,json=tabletType,proto3,enum=topodata.TabletType" json:"tablet_type,omitempty"`
	// not_in_transaction is deprecated.
	NotInTransaction bool `protobuf:"varint,8,opt,name=not_in_transaction,json=notInTransaction,proto3" json:"not_in_transaction,omitempty"`
	// options
	Options              *query.ExecuteOptions `protobuf:"bytes,9,opt,name=options,proto3" json:"options,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *ExecuteEntityIdsRequest) Reset()         { *m = ExecuteEntityIdsRequest{} }
func (m *ExecuteEntityIdsRequest) String() string { return proto.CompactTextString(m) }
func (*ExecuteEntityIdsRequest) ProtoMessage()    {}
func (*ExecuteEntityIdsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{9}
}
func (m *ExecuteEntityIdsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecuteEntityIdsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecuteEntityIdsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecuteEntityIdsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecuteEntityIdsRequest.Merge(m, src)
}
func (m *ExecuteEntityIdsRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExecuteEntityIdsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecuteEntityIdsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ExecuteEntityIdsRequest proto.InternalMessageInfo

func (m *ExecuteEntityIdsRequest) GetCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.CallerId
	}
	return nil
}

func (m *ExecuteEntityIdsRequest) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *ExecuteEntityIdsRequest) GetQuery() *query.BoundQuery {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *ExecuteEntityIdsRequest) GetKeyspace() string {
	if m != nil {
		return m.Keyspace
	}
	return ""
}

func (m *ExecuteEntityIdsRequest) GetEntityColumnName() string {
	if m != nil {
		return m.EntityColumnName
	}
	return ""
}

func (m *ExecuteEntityIdsRequest) GetEntityKeyspaceIds() []*ExecuteEntityIdsRequest_EntityId {
	if m != nil {
		return m.EntityKeyspaceIds
	}
	return nil
}

func (m *ExecuteEntityIdsRequest) GetTabletType() topodata.TabletType {
	if m != nil {
		return m.TabletType
	}
	return topodata.TabletType_UNKNOWN
}

func (m *ExecuteEntityIdsRequest) GetNotInTransaction() bool {
	if m != nil {
		return m.NotInTransaction
	}
	return false
}

func (m *ExecuteEntityIdsRequest) GetOptions() *query.ExecuteOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

type ExecuteEntityIdsRequest_EntityId struct {
	// type is the type of the entity's value. Can be NULL_TYPE.
	Type query.Type `protobuf:"varint,1,opt,name=type,proto3,enum=query.Type" json:"type,omitempty"`
	// value is the value for the entity. Not set if type is NULL_TYPE.
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	// keyspace_id is the associated keyspace_id for the entity.
	KeyspaceId           []byte   `protobuf:"bytes,3,opt,name=keyspace_id,json=keyspaceId,proto3" json:"keyspace_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExecuteEntityIdsRequest_EntityId) Reset()         { *m = ExecuteEntityIdsRequest_EntityId{} }
func (m *ExecuteEntityIdsRequest_EntityId) String() string { return proto.CompactTextString(m) }
func (*ExecuteEntityIdsRequest_EntityId) ProtoMessage()    {}
func (*ExecuteEntityIdsRequest_EntityId) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{9, 0}
}
func (m *ExecuteEntityIdsRequest_EntityId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecuteEntityIdsRequest_EntityId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecuteEntityIdsRequest_EntityId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecuteEntityIdsRequest_EntityId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecuteEntityIdsRequest_EntityId.Merge(m, src)
}
func (m *ExecuteEntityIdsRequest_EntityId) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExecuteEntityIdsRequest_EntityId) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecuteEntityIdsRequest_EntityId.DiscardUnknown(m)
}

var xxx_messageInfo_ExecuteEntityIdsRequest_EntityId proto.InternalMessageInfo

func (m *ExecuteEntityIdsRequest_EntityId) GetType() query.Type {
	if m != nil {
		return m.Type
	}
	return query.Type_NULL_TYPE
}

func (m *ExecuteEntityIdsRequest_EntityId) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *ExecuteEntityIdsRequest_EntityId) GetKeyspaceId() []byte {
	if m != nil {
		return m.KeyspaceId
	}
	return nil
}

// ExecuteEntityIdsResponse is the returned value from ExecuteEntityIds.
type ExecuteEntityIdsResponse struct {
	// error contains an application level error if necessary. Note the
	// session may have changed, even when an error is returned (for
	// instance if a database integrity error happened).
	Error *vtrpc.RPCError `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	// session is the updated session information (only returned inside a transaction).
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// result contains the query result, only set if error is unset.
	Result               *query.QueryResult `protobuf:"bytes,3,opt,name=result,proto3" json:"result,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *ExecuteEntityIdsResponse) Reset()         { *m = ExecuteEntityIdsResponse{} }
func (m *ExecuteEntityIdsResponse) String() string { return proto.CompactTextString(m) }
func (*ExecuteEntityIdsResponse) ProtoMessage()    {}
func (*ExecuteEntityIdsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{10}
}
func (m *ExecuteEntityIdsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecuteEntityIdsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecuteEntityIdsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecuteEntityIdsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecuteEntityIdsResponse.Merge(m, src)
}
func (m *ExecuteEntityIdsResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExecuteEntityIdsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecuteEntityIdsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ExecuteEntityIdsResponse proto.InternalMessageInfo

func (m *ExecuteEntityIdsResponse) GetError() *vtrpc.RPCError {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *ExecuteEntityIdsResponse) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *ExecuteEntityIdsResponse) GetResult() *query.QueryResult {
	if m != nil {
		return m.Result
	}
	return nil
}

// ExecuteBatchRequest is the payload to ExecuteBatch.
type ExecuteBatchRequest struct {
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"caller_id,omitempty"`
	// session carries the session state.
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// queries is a list of query and bind variables to execute.
	Queries []*query.BoundQuery `protobuf:"bytes,3,rep,name=queries,proto3" json:"queries,omitempty"`
	// These values are deprecated. Use session instead.
	// TODO(sougou): remove in 3.1
	TabletType           topodata.TabletType   `protobuf:"varint,4,opt,name=tablet_type,json=tabletType,proto3,enum=topodata.TabletType" json:"tablet_type,omitempty"`
	AsTransaction        bool                  `protobuf:"varint,5,opt,name=as_transaction,json=asTransaction,proto3" json:"as_transaction,omitempty"`
	KeyspaceShard        string                `protobuf:"bytes,6,opt,name=keyspace_shard,json=keyspaceShard,proto3" json:"keyspace_shard,omitempty"`
	Options              *query.ExecuteOptions `protobuf:"bytes,7,opt,name=options,proto3" json:"options,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *ExecuteBatchRequest) Reset()         { *m = ExecuteBatchRequest{} }
func (m *ExecuteBatchRequest) String() string { return proto.CompactTextString(m) }
func (*ExecuteBatchRequest) ProtoMessage()    {}
func (*ExecuteBatchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{11}
}
func (m *ExecuteBatchRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecuteBatchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecuteBatchRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecuteBatchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecuteBatchRequest.Merge(m, src)
}
func (m *ExecuteBatchRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExecuteBatchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecuteBatchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ExecuteBatchRequest proto.InternalMessageInfo

func (m *ExecuteBatchRequest) GetCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.CallerId
	}
	return nil
}

func (m *ExecuteBatchRequest) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *ExecuteBatchRequest) GetQueries() []*query.BoundQuery {
	if m != nil {
		return m.Queries
	}
	return nil
}

func (m *ExecuteBatchRequest) GetTabletType() topodata.TabletType {
	if m != nil {
		return m.TabletType
	}
	return topodata.TabletType_UNKNOWN
}

func (m *ExecuteBatchRequest) GetAsTransaction() bool {
	if m != nil {
		return m.AsTransaction
	}
	return false
}

func (m *ExecuteBatchRequest) GetKeyspaceShard() string {
	if m != nil {
		return m.KeyspaceShard
	}
	return ""
}

func (m *ExecuteBatchRequest) GetOptions() *query.ExecuteOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

// ExecuteBatchResponse is the returned value from ExecuteBatch.
type ExecuteBatchResponse struct {
	// error contains an application level error if necessary. Note the
	// session may have changed, even when an error is returned (for
	// instance if a database integrity error happened).
	Error *vtrpc.RPCError `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	// session is the updated session information.
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// results contains the query results, only set if application level error is unset.
	Results              []*query.ResultWithError `protobuf:"bytes,3,rep,name=results,proto3" json:"results,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *ExecuteBatchResponse) Reset()         { *m = ExecuteBatchResponse{} }
func (m *ExecuteBatchResponse) String() string { return proto.CompactTextString(m) }
func (*ExecuteBatchResponse) ProtoMessage()    {}
func (*ExecuteBatchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{12}
}
func (m *ExecuteBatchResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecuteBatchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecuteBatchResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecuteBatchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecuteBatchResponse.Merge(m, src)
}
func (m *ExecuteBatchResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExecuteBatchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecuteBatchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ExecuteBatchResponse proto.InternalMessageInfo

func (m *ExecuteBatchResponse) GetError() *vtrpc.RPCError {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *ExecuteBatchResponse) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *ExecuteBatchResponse) GetResults() []*query.ResultWithError {
	if m != nil {
		return m.Results
	}
	return nil
}

// BoundShardQuery represents a single query request for the
// specified list of shards. This is used in a list for
// ExecuteBatchShardsRequest.
type BoundShardQuery struct {
	// query is the query and bind variables to execute.
	Query *query.BoundQuery `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	// keyspace to target the query to.
	Keyspace string `protobuf:"bytes,2,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	// shards to target the query to. A DML can only target one shard.
	Shards               []string `protobuf:"bytes,3,rep,name=shards,proto3" json:"shards,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BoundShardQuery) Reset()         { *m = BoundShardQuery{} }
func (m *BoundShardQuery) String() string { return proto.CompactTextString(m) }
func (*BoundShardQuery) ProtoMessage()    {}
func (*BoundShardQuery) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{13}
}
func (m *BoundShardQuery) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BoundShardQuery) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BoundShardQuery.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BoundShardQuery) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BoundShardQuery.Merge(m, src)
}
func (m *BoundShardQuery) XXX_Size() int {
	return m.ProtoSize()
}
func (m *BoundShardQuery) XXX_DiscardUnknown() {
	xxx_messageInfo_BoundShardQuery.DiscardUnknown(m)
}

var xxx_messageInfo_BoundShardQuery proto.InternalMessageInfo

func (m *BoundShardQuery) GetQuery() *query.BoundQuery {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *BoundShardQuery) GetKeyspace() string {
	if m != nil {
		return m.Keyspace
	}
	return ""
}

func (m *BoundShardQuery) GetShards() []string {
	if m != nil {
		return m.Shards
	}
	return nil
}

// ExecuteBatchShardsRequest is the payload to ExecuteBatchShards
type ExecuteBatchShardsRequest struct {
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"caller_id,omitempty"`
	// session carries the current transaction data. It is returned by Begin.
	// Do not fill it in if outside of a transaction.
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// queries carries all the queries to execute.
	Queries []*BoundShardQuery `protobuf:"bytes,3,rep,name=queries,proto3" json:"queries,omitempty"`
	// tablet_type is the type of tablets that this query is targeted to.
	TabletType topodata.TabletType `protobuf:"varint,4,opt,name=tablet_type,json=tabletType,proto3,enum=topodata.TabletType" json:"tablet_type,omitempty"`
	// as_transaction will execute the queries in this batch in a single transaction per shard, created for this purpose.
	// (this can be seen as adding a 'begin' before and 'commit' after the queries).
	// Only makes sense if tablet_type is master. If set, the Session is ignored.
	AsTransaction bool `protobuf:"varint,5,opt,name=as_transaction,json=asTransaction,proto3" json:"as_transaction,omitempty"`
	// options
	Options              *query.ExecuteOptions `protobuf:"bytes,6,opt,name=options,proto3" json:"options,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *ExecuteBatchShardsRequest) Reset()         { *m = ExecuteBatchShardsRequest{} }
func (m *ExecuteBatchShardsRequest) String() string { return proto.CompactTextString(m) }
func (*ExecuteBatchShardsRequest) ProtoMessage()    {}
func (*ExecuteBatchShardsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{14}
}
func (m *ExecuteBatchShardsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecuteBatchShardsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecuteBatchShardsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecuteBatchShardsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecuteBatchShardsRequest.Merge(m, src)
}
func (m *ExecuteBatchShardsRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExecuteBatchShardsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecuteBatchShardsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ExecuteBatchShardsRequest proto.InternalMessageInfo

func (m *ExecuteBatchShardsRequest) GetCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.CallerId
	}
	return nil
}

func (m *ExecuteBatchShardsRequest) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *ExecuteBatchShardsRequest) GetQueries() []*BoundShardQuery {
	if m != nil {
		return m.Queries
	}
	return nil
}

func (m *ExecuteBatchShardsRequest) GetTabletType() topodata.TabletType {
	if m != nil {
		return m.TabletType
	}
	return topodata.TabletType_UNKNOWN
}

func (m *ExecuteBatchShardsRequest) GetAsTransaction() bool {
	if m != nil {
		return m.AsTransaction
	}
	return false
}

func (m *ExecuteBatchShardsRequest) GetOptions() *query.ExecuteOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

// ExecuteBatchShardsResponse is the returned value from ExecuteBatchShards.
type ExecuteBatchShardsResponse struct {
	// error contains an application level error if necessary. Note the
	// session may have changed, even when an error is returned (for
	// instance if a database integrity error happened).
	Error *vtrpc.RPCError `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	// session is the updated session information (only returned inside a transaction).
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// result contains the query result, only set if error is unset.
	Results              []*query.QueryResult `protobuf:"bytes,3,rep,name=results,proto3" json:"results,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *ExecuteBatchShardsResponse) Reset()         { *m = ExecuteBatchShardsResponse{} }
func (m *ExecuteBatchShardsResponse) String() string { return proto.CompactTextString(m) }
func (*ExecuteBatchShardsResponse) ProtoMessage()    {}
func (*ExecuteBatchShardsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{15}
}
func (m *ExecuteBatchShardsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecuteBatchShardsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecuteBatchShardsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecuteBatchShardsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecuteBatchShardsResponse.Merge(m, src)
}
func (m *ExecuteBatchShardsResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExecuteBatchShardsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecuteBatchShardsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ExecuteBatchShardsResponse proto.InternalMessageInfo

func (m *ExecuteBatchShardsResponse) GetError() *vtrpc.RPCError {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *ExecuteBatchShardsResponse) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *ExecuteBatchShardsResponse) GetResults() []*query.QueryResult {
	if m != nil {
		return m.Results
	}
	return nil
}

// BoundKeyspaceIdQuery represents a single query request for the
// specified list of keyspace ids. This is used in a list for
// ExecuteBatchKeyspaceIdsRequest.
type BoundKeyspaceIdQuery struct {
	// query is the query and bind variables to execute.
	Query *query.BoundQuery `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	// keyspace to target the query to.
	Keyspace string `protobuf:"bytes,2,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	// keyspace_ids contains the list of keyspace_ids affected by this query.
	// Will be used to find the shards to send the query to.
	KeyspaceIds          [][]byte `protobuf:"bytes,3,rep,name=keyspace_ids,json=keyspaceIds,proto3" json:"keyspace_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BoundKeyspaceIdQuery) Reset()         { *m = BoundKeyspaceIdQuery{} }
func (m *BoundKeyspaceIdQuery) String() string { return proto.CompactTextString(m) }
func (*BoundKeyspaceIdQuery) ProtoMessage()    {}
func (*BoundKeyspaceIdQuery) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{16}
}
func (m *BoundKeyspaceIdQuery) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BoundKeyspaceIdQuery) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BoundKeyspaceIdQuery.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BoundKeyspaceIdQuery) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BoundKeyspaceIdQuery.Merge(m, src)
}
func (m *BoundKeyspaceIdQuery) XXX_Size() int {
	return m.ProtoSize()
}
func (m *BoundKeyspaceIdQuery) XXX_DiscardUnknown() {
	xxx_messageInfo_BoundKeyspaceIdQuery.DiscardUnknown(m)
}

var xxx_messageInfo_BoundKeyspaceIdQuery proto.InternalMessageInfo

func (m *BoundKeyspaceIdQuery) GetQuery() *query.BoundQuery {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *BoundKeyspaceIdQuery) GetKeyspace() string {
	if m != nil {
		return m.Keyspace
	}
	return ""
}

func (m *BoundKeyspaceIdQuery) GetKeyspaceIds() [][]byte {
	if m != nil {
		return m.KeyspaceIds
	}
	return nil
}

// ExecuteBatchKeyspaceIdsRequest is the payload to ExecuteBatchKeyspaceId.
type ExecuteBatchKeyspaceIdsRequest struct {
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"caller_id,omitempty"`
	// session carries the current transaction data. It is returned by Begin.
	// Do not fill it in if outside of a transaction.
	Session *Session                `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	Queries []*BoundKeyspaceIdQuery `protobuf:"bytes,3,rep,name=queries,proto3" json:"queries,omitempty"`
	// tablet_type is the type of tablets that this query is targeted to.
	TabletType topodata.TabletType `protobuf:"varint,4,opt,name=tablet_type,json=tabletType,proto3,enum=topodata.TabletType" json:"tablet_type,omitempty"`
	// as_transaction will execute the queries in this batch in a single transaction per shard, created for this purpose.
	// (this can be seen as adding a 'begin' before and 'commit' after the queries).
	// Only makes sense if tablet_type is master. If set, the Session is ignored.
	AsTransaction bool `protobuf:"varint,5,opt,name=as_transaction,json=asTransaction,proto3" json:"as_transaction,omitempty"`
	// options
	Options              *query.ExecuteOptions `protobuf:"bytes,6,opt,name=options,proto3" json:"options,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *ExecuteBatchKeyspaceIdsRequest) Reset()         { *m = ExecuteBatchKeyspaceIdsRequest{} }
func (m *ExecuteBatchKeyspaceIdsRequest) String() string { return proto.CompactTextString(m) }
func (*ExecuteBatchKeyspaceIdsRequest) ProtoMessage()    {}
func (*ExecuteBatchKeyspaceIdsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{17}
}
func (m *ExecuteBatchKeyspaceIdsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecuteBatchKeyspaceIdsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecuteBatchKeyspaceIdsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecuteBatchKeyspaceIdsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecuteBatchKeyspaceIdsRequest.Merge(m, src)
}
func (m *ExecuteBatchKeyspaceIdsRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExecuteBatchKeyspaceIdsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecuteBatchKeyspaceIdsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ExecuteBatchKeyspaceIdsRequest proto.InternalMessageInfo

func (m *ExecuteBatchKeyspaceIdsRequest) GetCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.CallerId
	}
	return nil
}

func (m *ExecuteBatchKeyspaceIdsRequest) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *ExecuteBatchKeyspaceIdsRequest) GetQueries() []*BoundKeyspaceIdQuery {
	if m != nil {
		return m.Queries
	}
	return nil
}

func (m *ExecuteBatchKeyspaceIdsRequest) GetTabletType() topodata.TabletType {
	if m != nil {
		return m.TabletType
	}
	return topodata.TabletType_UNKNOWN
}

func (m *ExecuteBatchKeyspaceIdsRequest) GetAsTransaction() bool {
	if m != nil {
		return m.AsTransaction
	}
	return false
}

func (m *ExecuteBatchKeyspaceIdsRequest) GetOptions() *query.ExecuteOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

// ExecuteBatchKeyspaceIdsResponse is the returned value from ExecuteBatchKeyspaceId.
type ExecuteBatchKeyspaceIdsResponse struct {
	// error contains an application level error if necessary. Note the
	// session may have changed, even when an error is returned (for
	// instance if a database integrity error happened).
	Error *vtrpc.RPCError `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	// session is the updated session information (only returned inside a transaction).
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// result contains the query result, only set if error is unset.
	Results              []*query.QueryResult `protobuf:"bytes,3,rep,name=results,proto3" json:"results,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *ExecuteBatchKeyspaceIdsResponse) Reset()         { *m = ExecuteBatchKeyspaceIdsResponse{} }
func (m *ExecuteBatchKeyspaceIdsResponse) String() string { return proto.CompactTextString(m) }
func (*ExecuteBatchKeyspaceIdsResponse) ProtoMessage()    {}
func (*ExecuteBatchKeyspaceIdsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{18}
}
func (m *ExecuteBatchKeyspaceIdsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecuteBatchKeyspaceIdsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecuteBatchKeyspaceIdsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecuteBatchKeyspaceIdsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecuteBatchKeyspaceIdsResponse.Merge(m, src)
}
func (m *ExecuteBatchKeyspaceIdsResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExecuteBatchKeyspaceIdsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecuteBatchKeyspaceIdsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ExecuteBatchKeyspaceIdsResponse proto.InternalMessageInfo

func (m *ExecuteBatchKeyspaceIdsResponse) GetError() *vtrpc.RPCError {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *ExecuteBatchKeyspaceIdsResponse) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *ExecuteBatchKeyspaceIdsResponse) GetResults() []*query.QueryResult {
	if m != nil {
		return m.Results
	}
	return nil
}

// StreamExecuteRequest is the payload to StreamExecute.
type StreamExecuteRequest struct {
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"caller_id,omitempty"`
	// query is the query and bind variables to execute.
	Query *query.BoundQuery `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
	// These values are deprecated. Use session instead.
	// TODO(sougou): remove in 3.1
	TabletType    topodata.TabletType   `protobuf:"varint,3,opt,name=tablet_type,json=tabletType,proto3,enum=topodata.TabletType" json:"tablet_type,omitempty"`
	KeyspaceShard string                `protobuf:"bytes,4,opt,name=keyspace_shard,json=keyspaceShard,proto3" json:"keyspace_shard,omitempty"`
	Options       *query.ExecuteOptions `protobuf:"bytes,5,opt,name=options,proto3" json:"options,omitempty"`
	// session carries the session state.
	Session              *Session `protobuf:"bytes,6,opt,name=session,proto3" json:"session,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StreamExecuteRequest) Reset()         { *m = StreamExecuteRequest{} }
func (m *StreamExecuteRequest) String() string { return proto.CompactTextString(m) }
func (*StreamExecuteRequest) ProtoMessage()    {}
func (*StreamExecuteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{19}
}
func (m *StreamExecuteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamExecuteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamExecuteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamExecuteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamExecuteRequest.Merge(m, src)
}
func (m *StreamExecuteRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *StreamExecuteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamExecuteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StreamExecuteRequest proto.InternalMessageInfo

func (m *StreamExecuteRequest) GetCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.CallerId
	}
	return nil
}

func (m *StreamExecuteRequest) GetQuery() *query.BoundQuery {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *StreamExecuteRequest) GetTabletType() topodata.TabletType {
	if m != nil {
		return m.TabletType
	}
	return topodata.TabletType_UNKNOWN
}

func (m *StreamExecuteRequest) GetKeyspaceShard() string {
	if m != nil {
		return m.KeyspaceShard
	}
	return ""
}

func (m *StreamExecuteRequest) GetOptions() *query.ExecuteOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *StreamExecuteRequest) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

// StreamExecuteResponse is the returned value from StreamExecute.
// The session is currently not returned because StreamExecute is
// not expected to modify it.
type StreamExecuteResponse struct {
	// result contains the result data.
	// The first value contains only Fields information.
	// The next values contain the actual rows, a few values per result.
	Result               *query.QueryResult `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *StreamExecuteResponse) Reset()         { *m = StreamExecuteResponse{} }
func (m *StreamExecuteResponse) String() string { return proto.CompactTextString(m) }
func (*StreamExecuteResponse) ProtoMessage()    {}
func (*StreamExecuteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{20}
}
func (m *StreamExecuteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamExecuteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamExecuteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamExecuteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamExecuteResponse.Merge(m, src)
}
func (m *StreamExecuteResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *StreamExecuteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamExecuteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StreamExecuteResponse proto.InternalMessageInfo

func (m *StreamExecuteResponse) GetResult() *query.QueryResult {
	if m != nil {
		return m.Result
	}
	return nil
}

// StreamExecuteShardsRequest is the payload to StreamExecuteShards.
type StreamExecuteShardsRequest struct {
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"caller_id,omitempty"`
	// query is the query and bind variables to execute.
	Query *query.BoundQuery `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
	// keyspace to target the query to.
	Keyspace string `protobuf:"bytes,3,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	// shards to target the query to.
	Shards []string `protobuf:"bytes,4,rep,name=shards,proto3" json:"shards,omitempty"`
	// tablet_type is the type of tablets that this query is targeted to.
	TabletType topodata.TabletType `protobuf:"varint,5,opt,name=tablet_type,json=tabletType,proto3,enum=topodata.TabletType" json:"tablet_type,omitempty"`
	// options
	Options              *query.ExecuteOptions `protobuf:"bytes,6,opt,name=options,proto3" json:"options,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *StreamExecuteShardsRequest) Reset()         { *m = StreamExecuteShardsRequest{} }
func (m *StreamExecuteShardsRequest) String() string { return proto.CompactTextString(m) }
func (*StreamExecuteShardsRequest) ProtoMessage()    {}
func (*StreamExecuteShardsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{21}
}
func (m *StreamExecuteShardsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamExecuteShardsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamExecuteShardsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamExecuteShardsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamExecuteShardsRequest.Merge(m, src)
}
func (m *StreamExecuteShardsRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *StreamExecuteShardsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamExecuteShardsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StreamExecuteShardsRequest proto.InternalMessageInfo

func (m *StreamExecuteShardsRequest) GetCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.CallerId
	}
	return nil
}

func (m *StreamExecuteShardsRequest) GetQuery() *query.BoundQuery {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *StreamExecuteShardsRequest) GetKeyspace() string {
	if m != nil {
		return m.Keyspace
	}
	return ""
}

func (m *StreamExecuteShardsRequest) GetShards() []string {
	if m != nil {
		return m.Shards
	}
	return nil
}

func (m *StreamExecuteShardsRequest) GetTabletType() topodata.TabletType {
	if m != nil {
		return m.TabletType
	}
	return topodata.TabletType_UNKNOWN
}

func (m *StreamExecuteShardsRequest) GetOptions() *query.ExecuteOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

// StreamExecuteShardsResponse is the returned value from StreamExecuteShards.
type StreamExecuteShardsResponse struct {
	// result contains the result data.
	// The first value contains only Fields information.
	// The next values contain the actual rows, a few values per result.
	Result               *query.QueryResult `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *StreamExecuteShardsResponse) Reset()         { *m = StreamExecuteShardsResponse{} }
func (m *StreamExecuteShardsResponse) String() string { return proto.CompactTextString(m) }
func (*StreamExecuteShardsResponse) ProtoMessage()    {}
func (*StreamExecuteShardsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{22}
}
func (m *StreamExecuteShardsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamExecuteShardsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamExecuteShardsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamExecuteShardsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamExecuteShardsResponse.Merge(m, src)
}
func (m *StreamExecuteShardsResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *StreamExecuteShardsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamExecuteShardsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StreamExecuteShardsResponse proto.InternalMessageInfo

func (m *StreamExecuteShardsResponse) GetResult() *query.QueryResult {
	if m != nil {
		return m.Result
	}
	return nil
}

// StreamExecuteKeyspaceIdsRequest is the payload to StreamExecuteKeyspaceIds.
type StreamExecuteKeyspaceIdsRequest struct {
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"caller_id,omitempty"`
	// query is the query and bind variables to execute.
	Query *query.BoundQuery `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
	// keyspace to target the query to.
	Keyspace string `protobuf:"bytes,3,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	// keyspace_ids contains the list of keyspace_ids affected by this query.
	// Will be used to find the shards to send the query to.
	KeyspaceIds [][]byte `protobuf:"bytes,4,rep,name=keyspace_ids,json=keyspaceIds,proto3" json:"keyspace_ids,omitempty"`
	// tablet_type is the type of tablets that this query is targeted to.
	TabletType topodata.TabletType `protobuf:"varint,5,opt,name=tablet_type,json=tabletType,proto3,enum=topodata.TabletType" json:"tablet_type,omitempty"`
	// options
	Options              *query.ExecuteOptions `protobuf:"bytes,6,opt,name=options,proto3" json:"options,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *StreamExecuteKeyspaceIdsRequest) Reset()         { *m = StreamExecuteKeyspaceIdsRequest{} }
func (m *StreamExecuteKeyspaceIdsRequest) String() string { return proto.CompactTextString(m) }
func (*StreamExecuteKeyspaceIdsRequest) ProtoMessage()    {}
func (*StreamExecuteKeyspaceIdsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{23}
}
func (m *StreamExecuteKeyspaceIdsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamExecuteKeyspaceIdsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamExecuteKeyspaceIdsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamExecuteKeyspaceIdsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamExecuteKeyspaceIdsRequest.Merge(m, src)
}
func (m *StreamExecuteKeyspaceIdsRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *StreamExecuteKeyspaceIdsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamExecuteKeyspaceIdsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StreamExecuteKeyspaceIdsRequest proto.InternalMessageInfo

func (m *StreamExecuteKeyspaceIdsRequest) GetCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.CallerId
	}
	return nil
}

func (m *StreamExecuteKeyspaceIdsRequest) GetQuery() *query.BoundQuery {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *StreamExecuteKeyspaceIdsRequest) GetKeyspace() string {
	if m != nil {
		return m.Keyspace
	}
	return ""
}

func (m *StreamExecuteKeyspaceIdsRequest) GetKeyspaceIds() [][]byte {
	if m != nil {
		return m.KeyspaceIds
	}
	return nil
}

func (m *StreamExecuteKeyspaceIdsRequest) GetTabletType() topodata.TabletType {
	if m != nil {
		return m.TabletType
	}
	return topodata.TabletType_UNKNOWN
}

func (m *StreamExecuteKeyspaceIdsRequest) GetOptions() *query.ExecuteOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

// StreamExecuteKeyspaceIdsResponse is the returned value from StreamExecuteKeyspaceIds.
type StreamExecuteKeyspaceIdsResponse struct {
	// result contains the result data.
	// The first value contains only Fields information.
	// The next values contain the actual rows, a few values per result.
	Result               *query.QueryResult `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *StreamExecuteKeyspaceIdsResponse) Reset()         { *m = StreamExecuteKeyspaceIdsResponse{} }
func (m *StreamExecuteKeyspaceIdsResponse) String() string { return proto.CompactTextString(m) }
func (*StreamExecuteKeyspaceIdsResponse) ProtoMessage()    {}
func (*StreamExecuteKeyspaceIdsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{24}
}
func (m *StreamExecuteKeyspaceIdsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamExecuteKeyspaceIdsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamExecuteKeyspaceIdsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamExecuteKeyspaceIdsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamExecuteKeyspaceIdsResponse.Merge(m, src)
}
func (m *StreamExecuteKeyspaceIdsResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *StreamExecuteKeyspaceIdsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamExecuteKeyspaceIdsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StreamExecuteKeyspaceIdsResponse proto.InternalMessageInfo

func (m *StreamExecuteKeyspaceIdsResponse) GetResult() *query.QueryResult {
	if m != nil {
		return m.Result
	}
	return nil
}

// StreamExecuteKeyRangesRequest is the payload to StreamExecuteKeyRanges.
type StreamExecuteKeyRangesRequest struct {
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"caller_id,omitempty"`
	// query is the query and bind variables to execute.
	Query *query.BoundQuery `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
	// keyspace to target the query to.
	Keyspace string `protobuf:"bytes,3,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	// key_ranges contains the list of key ranges affected by this query.
	// Will be used to find the shards to send the query to.
	KeyRanges []*topodata.KeyRange `protobuf:"bytes,4,rep,name=key_ranges,json=keyRanges,proto3" json:"key_ranges,omitempty"`
	// tablet_type is the type of tablets that this query is targeted to.
	TabletType topodata.TabletType `protobuf:"varint,5,opt,name=tablet_type,json=tabletType,proto3,enum=topodata.TabletType" json:"tablet_type,omitempty"`
	// options
	Options              *query.ExecuteOptions `protobuf:"bytes,6,opt,name=options,proto3" json:"options,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *StreamExecuteKeyRangesRequest) Reset()         { *m = StreamExecuteKeyRangesRequest{} }
func (m *StreamExecuteKeyRangesRequest) String() string { return proto.CompactTextString(m) }
func (*StreamExecuteKeyRangesRequest) ProtoMessage()    {}
func (*StreamExecuteKeyRangesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{25}
}
func (m *StreamExecuteKeyRangesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamExecuteKeyRangesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamExecuteKeyRangesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamExecuteKeyRangesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamExecuteKeyRangesRequest.Merge(m, src)
}
func (m *StreamExecuteKeyRangesRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *StreamExecuteKeyRangesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamExecuteKeyRangesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StreamExecuteKeyRangesRequest proto.InternalMessageInfo

func (m *StreamExecuteKeyRangesRequest) GetCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.CallerId
	}
	return nil
}

func (m *StreamExecuteKeyRangesRequest) GetQuery() *query.BoundQuery {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *StreamExecuteKeyRangesRequest) GetKeyspace() string {
	if m != nil {
		return m.Keyspace
	}
	return ""
}

func (m *StreamExecuteKeyRangesRequest) GetKeyRanges() []*topodata.KeyRange {
	if m != nil {
		return m.KeyRanges
	}
	return nil
}

func (m *StreamExecuteKeyRangesRequest) GetTabletType() topodata.TabletType {
	if m != nil {
		return m.TabletType
	}
	return topodata.TabletType_UNKNOWN
}

func (m *StreamExecuteKeyRangesRequest) GetOptions() *query.ExecuteOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

// StreamExecuteKeyRangesResponse is the returned value from StreamExecuteKeyRanges.
type StreamExecuteKeyRangesResponse struct {
	// result contains the result data.
	// The first value contains only Fields information.
	// The next values contain the actual rows, a few values per result.
	Result               *query.QueryResult `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *StreamExecuteKeyRangesResponse) Reset()         { *m = StreamExecuteKeyRangesResponse{} }
func (m *StreamExecuteKeyRangesResponse) String() string { return proto.CompactTextString(m) }
func (*StreamExecuteKeyRangesResponse) ProtoMessage()    {}
func (*StreamExecuteKeyRangesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{26}
}
func (m *StreamExecuteKeyRangesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamExecuteKeyRangesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamExecuteKeyRangesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamExecuteKeyRangesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamExecuteKeyRangesResponse.Merge(m, src)
}
func (m *StreamExecuteKeyRangesResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *StreamExecuteKeyRangesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamExecuteKeyRangesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StreamExecuteKeyRangesResponse proto.InternalMessageInfo

func (m *StreamExecuteKeyRangesResponse) GetResult() *query.QueryResult {
	if m != nil {
		return m.Result
	}
	return nil
}

// BeginRequest is the payload to Begin.
type BeginRequest struct {
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"caller_id,omitempty"`
	// single_db is deprecated. Use transaction_mode instead.
	// The value specifies if the transaction should be restricted
	// to a single database.
	// TODO(sougou): remove in 3.1
	SingleDb             bool     `protobuf:"varint,2,opt,name=single_db,json=singleDb,proto3" json:"single_db,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BeginRequest) Reset()         { *m = BeginRequest{} }
func (m *BeginRequest) String() string { return proto.CompactTextString(m) }
func (*BeginRequest) ProtoMessage()    {}
func (*BeginRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{27}
}
func (m *BeginRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BeginRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BeginRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BeginRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BeginRequest.Merge(m, src)
}
func (m *BeginRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *BeginRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BeginRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BeginRequest proto.InternalMessageInfo

func (m *BeginRequest) GetCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.CallerId
	}
	return nil
}

func (m *BeginRequest) GetSingleDb() bool {
	if m != nil {
		return m.SingleDb
	}
	return false
}

// BeginResponse is the returned value from Begin.
type BeginResponse struct {
	// session is the initial session information to use for subsequent queries.
	Session              *Session `protobuf:"bytes,1,opt,name=session,proto3" json:"session,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BeginResponse) Reset()         { *m = BeginResponse{} }
func (m *BeginResponse) String() string { return proto.CompactTextString(m) }
func (*BeginResponse) ProtoMessage()    {}
func (*BeginResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{28}
}
func (m *BeginResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BeginResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BeginResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BeginResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BeginResponse.Merge(m, src)
}
func (m *BeginResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *BeginResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BeginResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BeginResponse proto.InternalMessageInfo

func (m *BeginResponse) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

// CommitRequest is the payload to Commit.
type CommitRequest struct {
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"caller_id,omitempty"`
	// session carries the current transaction data to commit.
	Session *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	// atomic is deprecated. Use transaction_mode instead.
	// The value specifies if the commit should go through the
	// 2PC workflow to ensure atomicity.
	// TODO(sougou): remove in 3.1
	Atomic               bool     `protobuf:"varint,3,opt,name=atomic,proto3" json:"atomic,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommitRequest) Reset()         { *m = CommitRequest{} }
func (m *CommitRequest) String() string { return proto.CompactTextString(m) }
func (*CommitRequest) ProtoMessage()    {}
func (*CommitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{29}
}
func (m *CommitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommitRequest.Merge(m, src)
}
func (m *CommitRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CommitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CommitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CommitRequest proto.InternalMessageInfo

func (m *CommitRequest) GetCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.CallerId
	}
	return nil
}

func (m *CommitRequest) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *CommitRequest) GetAtomic() bool {
	if m != nil {
		return m.Atomic
	}
	return false
}

// CommitResponse is the returned value from Commit.
type CommitResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommitResponse) Reset()         { *m = CommitResponse{} }
func (m *CommitResponse) String() string { return proto.CompactTextString(m) }
func (*CommitResponse) ProtoMessage()    {}
func (*CommitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{30}
}
func (m *CommitResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommitResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommitResponse.Merge(m, src)
}
func (m *CommitResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CommitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CommitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CommitResponse proto.InternalMessageInfo

// RollbackRequest is the payload to Rollback.
type RollbackRequest struct {
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"caller_id,omitempty"`
	// session carries the current transaction data to rollback.
	Session              *Session `protobuf:"bytes,2,opt,name=session,proto3" json:"session,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RollbackRequest) Reset()         { *m = RollbackRequest{} }
func (m *RollbackRequest) String() string { return proto.CompactTextString(m) }
func (*RollbackRequest) ProtoMessage()    {}
func (*RollbackRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{31}
}
func (m *RollbackRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RollbackRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RollbackRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RollbackRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RollbackRequest.Merge(m, src)
}
func (m *RollbackRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RollbackRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RollbackRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RollbackRequest proto.InternalMessageInfo

func (m *RollbackRequest) GetCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.CallerId
	}
	return nil
}

func (m *RollbackRequest) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

// RollbackResponse is the returned value from Rollback.
type RollbackResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RollbackResponse) Reset()         { *m = RollbackResponse{} }
func (m *RollbackResponse) String() string { return proto.CompactTextString(m) }
func (*RollbackResponse) ProtoMessage()    {}
func (*RollbackResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{32}
}
func (m *RollbackResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RollbackResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RollbackResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RollbackResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RollbackResponse.Merge(m, src)
}
func (m *RollbackResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RollbackResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RollbackResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RollbackResponse proto.InternalMessageInfo

// ResolveTransactionRequest is the payload to ResolveTransaction.
type ResolveTransactionRequest struct {
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"caller_id,omitempty"`
	// dtid is the dtid of the transaction to be resolved.
	Dtid                 string   `protobuf:"bytes,2,opt,name=dtid,proto3" json:"dtid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResolveTransactionRequest) Reset()         { *m = ResolveTransactionRequest{} }
func (m *ResolveTransactionRequest) String() string { return proto.CompactTextString(m) }
func (*ResolveTransactionRequest) ProtoMessage()    {}
func (*ResolveTransactionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{33}
}
func (m *ResolveTransactionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResolveTransactionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResolveTransactionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResolveTransactionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResolveTransactionRequest.Merge(m, src)
}
func (m *ResolveTransactionRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ResolveTransactionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ResolveTransactionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ResolveTransactionRequest proto.InternalMessageInfo

func (m *ResolveTransactionRequest) GetCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.CallerId
	}
	return nil
}

func (m *ResolveTransactionRequest) GetDtid() string {
	if m != nil {
		return m.Dtid
	}
	return ""
}

// MessageStreamRequest is the request payload for MessageStream.
type MessageStreamRequest struct {
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"caller_id,omitempty"`
	// keyspace to target the query to.
	Keyspace string `protobuf:"bytes,2,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	// shard to target the query to, for unsharded keyspaces.
	Shard string `protobuf:"bytes,3,opt,name=shard,proto3" json:"shard,omitempty"`
	// KeyRange to target the query to, for sharded keyspaces.
	KeyRange *topodata.KeyRange `protobuf:"bytes,4,opt,name=key_range,json=keyRange,proto3" json:"key_range,omitempty"`
	// name is the message table name.
	Name                 string   `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessageStreamRequest) Reset()         { *m = MessageStreamRequest{} }
func (m *MessageStreamRequest) String() string { return proto.CompactTextString(m) }
func (*MessageStreamRequest) ProtoMessage()    {}
func (*MessageStreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{34}
}
func (m *MessageStreamRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageStreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageStreamRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageStreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageStreamRequest.Merge(m, src)
}
func (m *MessageStreamRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *MessageStreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageStreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MessageStreamRequest proto.InternalMessageInfo

func (m *MessageStreamRequest) GetCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.CallerId
	}
	return nil
}

func (m *MessageStreamRequest) GetKeyspace() string {
	if m != nil {
		return m.Keyspace
	}
	return ""
}

func (m *MessageStreamRequest) GetShard() string {
	if m != nil {
		return m.Shard
	}
	return ""
}

func (m *MessageStreamRequest) GetKeyRange() *topodata.KeyRange {
	if m != nil {
		return m.KeyRange
	}
	return nil
}

func (m *MessageStreamRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// MessageAckRequest is the request payload for MessageAck.
type MessageAckRequest struct {
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"caller_id,omitempty"`
	// keyspace to target the message to.
	Keyspace string `protobuf:"bytes,2,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	// name is the message table name.
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// ids is the list of ids to ack.
	Ids                  []*query.Value `protobuf:"bytes,4,rep,name=ids,proto3" json:"ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *MessageAckRequest) Reset()         { *m = MessageAckRequest{} }
func (m *MessageAckRequest) String() string { return proto.CompactTextString(m) }
func (*MessageAckRequest) ProtoMessage()    {}
func (*MessageAckRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{35}
}
func (m *MessageAckRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageAckRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageAckRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageAckRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageAckRequest.Merge(m, src)
}
func (m *MessageAckRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *MessageAckRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageAckRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MessageAckRequest proto.InternalMessageInfo

func (m *MessageAckRequest) GetCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.CallerId
	}
	return nil
}

func (m *MessageAckRequest) GetKeyspace() string {
	if m != nil {
		return m.Keyspace
	}
	return ""
}

func (m *MessageAckRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MessageAckRequest) GetIds() []*query.Value {
	if m != nil {
		return m.Ids
	}
	return nil
}

// IdKeyspaceId represents an id and keyspace_id pair.
// The kesypace_id represents the routing info for id.
type IdKeyspaceId struct {
	// id represents the message id.
	Id *query.Value `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// keyspace_id is the associated keyspace_id for the id.
	KeyspaceId           []byte   `protobuf:"bytes,2,opt,name=keyspace_id,json=keyspaceId,proto3" json:"keyspace_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IdKeyspaceId) Reset()         { *m = IdKeyspaceId{} }
func (m *IdKeyspaceId) String() string { return proto.CompactTextString(m) }
func (*IdKeyspaceId) ProtoMessage()    {}
func (*IdKeyspaceId) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{36}
}
func (m *IdKeyspaceId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IdKeyspaceId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IdKeyspaceId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IdKeyspaceId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IdKeyspaceId.Merge(m, src)
}
func (m *IdKeyspaceId) XXX_Size() int {
	return m.ProtoSize()
}
func (m *IdKeyspaceId) XXX_DiscardUnknown() {
	xxx_messageInfo_IdKeyspaceId.DiscardUnknown(m)
}

var xxx_messageInfo_IdKeyspaceId proto.InternalMessageInfo

func (m *IdKeyspaceId) GetId() *query.Value {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *IdKeyspaceId) GetKeyspaceId() []byte {
	if m != nil {
		return m.KeyspaceId
	}
	return nil
}

// MessageAckKeyspaceIdsRequest is the payload to MessageAckKeyspaceIds.
type MessageAckKeyspaceIdsRequest struct {
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"caller_id,omitempty"`
	// Optional keyspace for message table.
	Keyspace string `protobuf:"bytes,2,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	// name is the message table name.
	Name                 string          `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	IdKeyspaceIds        []*IdKeyspaceId `protobuf:"bytes,4,rep,name=id_keyspace_ids,json=idKeyspaceIds,proto3" json:"id_keyspace_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *MessageAckKeyspaceIdsRequest) Reset()         { *m = MessageAckKeyspaceIdsRequest{} }
func (m *MessageAckKeyspaceIdsRequest) String() string { return proto.CompactTextString(m) }
func (*MessageAckKeyspaceIdsRequest) ProtoMessage()    {}
func (*MessageAckKeyspaceIdsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{37}
}
func (m *MessageAckKeyspaceIdsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageAckKeyspaceIdsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageAckKeyspaceIdsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageAckKeyspaceIdsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageAckKeyspaceIdsRequest.Merge(m, src)
}
func (m *MessageAckKeyspaceIdsRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *MessageAckKeyspaceIdsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageAckKeyspaceIdsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MessageAckKeyspaceIdsRequest proto.InternalMessageInfo

func (m *MessageAckKeyspaceIdsRequest) GetCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.CallerId
	}
	return nil
}

func (m *MessageAckKeyspaceIdsRequest) GetKeyspace() string {
	if m != nil {
		return m.Keyspace
	}
	return ""
}

func (m *MessageAckKeyspaceIdsRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MessageAckKeyspaceIdsRequest) GetIdKeyspaceIds() []*IdKeyspaceId {
	if m != nil {
		return m.IdKeyspaceIds
	}
	return nil
}

// ResolveTransactionResponse is the returned value from Rollback.
type ResolveTransactionResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResolveTransactionResponse) Reset()         { *m = ResolveTransactionResponse{} }
func (m *ResolveTransactionResponse) String() string { return proto.CompactTextString(m) }
func (*ResolveTransactionResponse) ProtoMessage()    {}
func (*ResolveTransactionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{38}
}
func (m *ResolveTransactionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResolveTransactionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResolveTransactionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResolveTransactionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResolveTransactionResponse.Merge(m, src)
}
func (m *ResolveTransactionResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ResolveTransactionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ResolveTransactionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ResolveTransactionResponse proto.InternalMessageInfo

// SplitQueryRequest is the payload to SplitQuery.
//
// SplitQuery takes a "SELECT" query and generates a list of queries called
// "query-parts". Each query-part consists of the original query with an
// added WHERE clause that restricts the query-part to operate only on
// rows whose values in the columns listed in the "split_column" field
// of the request (see below) are in a particular range.
//
// It is guaranteed that the set of rows obtained from
// executing each query-part on a database snapshot
// and merging (without deduping) the results is equal to the set of rows
// obtained from executing the original query on the same snapshot
// with the rows containing NULL values in any of the split_column's excluded.
//
// This is typically called by the MapReduce master when reading from Vitess.
// There it's desirable that the sets of rows returned by the query-parts
// have roughly the same size.
type SplitQueryRequest struct {
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"caller_id,omitempty"`
	// keyspace to target the query to.
	Keyspace string `protobuf:"bytes,2,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	// The query and bind variables to produce splits for.
	// The given query must be a simple query of the form
	// SELECT <cols> FROM <table> WHERE <filter>.
	// It must not contain subqueries nor any of the keywords
	// JOIN, GROUP BY, ORDER BY, LIMIT, DISTINCT.
	// Furthermore, <table> must be a single concrete table.
	// It cannot be a view.
	Query *query.BoundQuery `protobuf:"bytes,3,opt,name=query,proto3" json:"query,omitempty"`
	// Each generated query-part will be restricted to rows whose values
	// in the columns listed in this field are in a particular range.
	// The list of columns named here must be a prefix of the list of
	// columns defining some index or primary key of the table
	// referenced in 'query'. For many tables using the primary key columns
	// (in order) is sufficient and this is the default if this field is omitted.
	// See the comment on the 'algorithm' field for more restrictions and
	// information.
	SplitColumn []string `protobuf:"bytes,4,rep,name=split_column,json=splitColumn,proto3" json:"split_column,omitempty"`
	// You can specify either an estimate of the number of query-parts to
	// generate or an estimate of the number of rows each query-part should
	// return.
	// Thus, exactly one of split_count or num_rows_per_query_part
	// should be nonzero.
	// The non-given parameter is calculated from the given parameter
	// using the formula: split_count * num_rows_per_query_pary = table_size,
	// where table_size is an approximation of the number of rows in the
	// table.
	// Note that if "split_count" is given it is regarded as an estimate.
	// The number of query-parts returned may differ slightly (in particular,
	// if it's not a whole multiple of the number of vitess shards).
	SplitCount          int64 `protobuf:"varint,5,opt,name=split_count,json=splitCount,proto3" json:"split_count,omitempty"`
	NumRowsPerQueryPart int64 `protobuf:"varint,6,opt,name=num_rows_per_query_part,json=numRowsPerQueryPart,proto3" json:"num_rows_per_query_part,omitempty"`
	// The algorithm to use to split the query. The split algorithm is performed
	// on each database shard in parallel. The lists of query-parts generated
	// by the shards are merged and returned to the caller.
	// Two algorithms are supported:
	//  EQUAL_SPLITS
	//    If this algorithm is selected then only the first 'split_column' given
	//    is used (or the first primary key column if the 'split_column' field is
	//    empty). In the rest of this algorithm's description, we refer to
	//    this column as "the split column".
	//    The split column must have numeric type (integral or floating point).
	//    The algorithm works by taking the interval [min, max], where min and
	//    max are the minimum and maximum values of the split column in
	//    the table-shard, respectively, and partitioning it into 'split_count'
	//    sub-intervals of equal size. The added WHERE clause of each query-part
	//    restricts that part to rows whose value in the split column belongs to
	//    a particular sub-interval. This is fast, but requires that the
	//    distribution of values of the split column be uniform in [min, max]
	//    for the number of rows returned by each query part to be roughly the
	//    same.
	//  FULL_SCAN
	//    If this algorithm is used then the split_column must be the primary key
	//    columns (in order).
	//    This algorithm performs a full-scan of the table-shard referenced
	//    in 'query' to get "boundary" rows that are num_rows_per_query_part
	//    apart when the table is ordered by the columns listed in
	//    'split_column'. It then restricts each query-part to the rows
	//    located between two successive boundary rows.
	//    This algorithm supports multiple split_column's of any type,
	//    but is slower than EQUAL_SPLITS.
	Algorithm query.SplitQueryRequest_Algorithm `protobuf:"varint,7,opt,name=algorithm,proto3,enum=query.SplitQueryRequest_Algorithm" json:"algorithm,omitempty"`
	// TODO(erez): This field is no longer used by the server code.
	// Remove this field after this new server code is released to prod.
	// We must keep it for now, so that clients can still send it to the old
	// server code currently in production.
	UseSplitQueryV2      bool     `protobuf:"varint,8,opt,name=use_split_query_v2,json=useSplitQueryV2,proto3" json:"use_split_query_v2,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SplitQueryRequest) Reset()         { *m = SplitQueryRequest{} }
func (m *SplitQueryRequest) String() string { return proto.CompactTextString(m) }
func (*SplitQueryRequest) ProtoMessage()    {}
func (*SplitQueryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{39}
}
func (m *SplitQueryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SplitQueryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SplitQueryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SplitQueryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SplitQueryRequest.Merge(m, src)
}
func (m *SplitQueryRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SplitQueryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SplitQueryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SplitQueryRequest proto.InternalMessageInfo

func (m *SplitQueryRequest) GetCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.CallerId
	}
	return nil
}

func (m *SplitQueryRequest) GetKeyspace() string {
	if m != nil {
		return m.Keyspace
	}
	return ""
}

func (m *SplitQueryRequest) GetQuery() *query.BoundQuery {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *SplitQueryRequest) GetSplitColumn() []string {
	if m != nil {
		return m.SplitColumn
	}
	return nil
}

func (m *SplitQueryRequest) GetSplitCount() int64 {
	if m != nil {
		return m.SplitCount
	}
	return 0
}

func (m *SplitQueryRequest) GetNumRowsPerQueryPart() int64 {
	if m != nil {
		return m.NumRowsPerQueryPart
	}
	return 0
}

func (m *SplitQueryRequest) GetAlgorithm() query.SplitQueryRequest_Algorithm {
	if m != nil {
		return m.Algorithm
	}
	return query.SplitQueryRequest_EQUAL_SPLITS
}

func (m *SplitQueryRequest) GetUseSplitQueryV2() bool {
	if m != nil {
		return m.UseSplitQueryV2
	}
	return false
}

// SplitQueryResponse is the returned value from SplitQuery.
type SplitQueryResponse struct {
	// splits contains the queries to run to fetch the entire data set.
	Splits               []*SplitQueryResponse_Part `protobuf:"bytes,1,rep,name=splits,proto3" json:"splits,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *SplitQueryResponse) Reset()         { *m = SplitQueryResponse{} }
func (m *SplitQueryResponse) String() string { return proto.CompactTextString(m) }
func (*SplitQueryResponse) ProtoMessage()    {}
func (*SplitQueryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{40}
}
func (m *SplitQueryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SplitQueryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SplitQueryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SplitQueryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SplitQueryResponse.Merge(m, src)
}
func (m *SplitQueryResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SplitQueryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SplitQueryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SplitQueryResponse proto.InternalMessageInfo

func (m *SplitQueryResponse) GetSplits() []*SplitQueryResponse_Part {
	if m != nil {
		return m.Splits
	}
	return nil
}

type SplitQueryResponse_KeyRangePart struct {
	// keyspace to target the query to.
	Keyspace string `protobuf:"bytes,1,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	// key ranges to target the query to.
	KeyRanges            []*topodata.KeyRange `protobuf:"bytes,2,rep,name=key_ranges,json=keyRanges,proto3" json:"key_ranges,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *SplitQueryResponse_KeyRangePart) Reset()         { *m = SplitQueryResponse_KeyRangePart{} }
func (m *SplitQueryResponse_KeyRangePart) String() string { return proto.CompactTextString(m) }
func (*SplitQueryResponse_KeyRangePart) ProtoMessage()    {}
func (*SplitQueryResponse_KeyRangePart) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{40, 0}
}
func (m *SplitQueryResponse_KeyRangePart) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SplitQueryResponse_KeyRangePart) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SplitQueryResponse_KeyRangePart.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SplitQueryResponse_KeyRangePart) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SplitQueryResponse_KeyRangePart.Merge(m, src)
}
func (m *SplitQueryResponse_KeyRangePart) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SplitQueryResponse_KeyRangePart) XXX_DiscardUnknown() {
	xxx_messageInfo_SplitQueryResponse_KeyRangePart.DiscardUnknown(m)
}

var xxx_messageInfo_SplitQueryResponse_KeyRangePart proto.InternalMessageInfo

func (m *SplitQueryResponse_KeyRangePart) GetKeyspace() string {
	if m != nil {
		return m.Keyspace
	}
	return ""
}

func (m *SplitQueryResponse_KeyRangePart) GetKeyRanges() []*topodata.KeyRange {
	if m != nil {
		return m.KeyRanges
	}
	return nil
}

type SplitQueryResponse_ShardPart struct {
	// keyspace to target the query to.
	Keyspace string `protobuf:"bytes,1,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	// shards to target the query to.
	Shards               []string `protobuf:"bytes,2,rep,name=shards,proto3" json:"shards,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SplitQueryResponse_ShardPart) Reset()         { *m = SplitQueryResponse_ShardPart{} }
func (m *SplitQueryResponse_ShardPart) String() string { return proto.CompactTextString(m) }
func (*SplitQueryResponse_ShardPart) ProtoMessage()    {}
func (*SplitQueryResponse_ShardPart) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{40, 1}
}
func (m *SplitQueryResponse_ShardPart) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SplitQueryResponse_ShardPart) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SplitQueryResponse_ShardPart.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SplitQueryResponse_ShardPart) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SplitQueryResponse_ShardPart.Merge(m, src)
}
func (m *SplitQueryResponse_ShardPart) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SplitQueryResponse_ShardPart) XXX_DiscardUnknown() {
	xxx_messageInfo_SplitQueryResponse_ShardPart.DiscardUnknown(m)
}

var xxx_messageInfo_SplitQueryResponse_ShardPart proto.InternalMessageInfo

func (m *SplitQueryResponse_ShardPart) GetKeyspace() string {
	if m != nil {
		return m.Keyspace
	}
	return ""
}

func (m *SplitQueryResponse_ShardPart) GetShards() []string {
	if m != nil {
		return m.Shards
	}
	return nil
}

type SplitQueryResponse_Part struct {
	// query is the query and bind variables to execute.
	Query *query.BoundQuery `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	// key_range_part is set if the query should be executed by
	// ExecuteKeyRanges.
	KeyRangePart *SplitQueryResponse_KeyRangePart `protobuf:"bytes,2,opt,name=key_range_part,json=keyRangePart,proto3" json:"key_range_part,omitempty"`
	// shard_part is set if the query should be executed by ExecuteShards.
	ShardPart *SplitQueryResponse_ShardPart `protobuf:"bytes,3,opt,name=shard_part,json=shardPart,proto3" json:"shard_part,omitempty"`
	// size is the approximate number of rows this query will return.
	Size                 int64    `protobuf:"varint,4,opt,name=size,proto3" json:"size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SplitQueryResponse_Part) Reset()         { *m = SplitQueryResponse_Part{} }
func (m *SplitQueryResponse_Part) String() string { return proto.CompactTextString(m) }
func (*SplitQueryResponse_Part) ProtoMessage()    {}
func (*SplitQueryResponse_Part) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{40, 2}
}
func (m *SplitQueryResponse_Part) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SplitQueryResponse_Part) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SplitQueryResponse_Part.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SplitQueryResponse_Part) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SplitQueryResponse_Part.Merge(m, src)
}
func (m *SplitQueryResponse_Part) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SplitQueryResponse_Part) XXX_DiscardUnknown() {
	xxx_messageInfo_SplitQueryResponse_Part.DiscardUnknown(m)
}

var xxx_messageInfo_SplitQueryResponse_Part proto.InternalMessageInfo

func (m *SplitQueryResponse_Part) GetQuery() *query.BoundQuery {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *SplitQueryResponse_Part) GetKeyRangePart() *SplitQueryResponse_KeyRangePart {
	if m != nil {
		return m.KeyRangePart
	}
	return nil
}

func (m *SplitQueryResponse_Part) GetShardPart() *SplitQueryResponse_ShardPart {
	if m != nil {
		return m.ShardPart
	}
	return nil
}

func (m *SplitQueryResponse_Part) GetSize() int64 {
	if m != nil {
		return m.Size
	}
	return 0
}

// GetSrvKeyspaceRequest is the payload to GetSrvKeyspace.
type GetSrvKeyspaceRequest struct {
	// keyspace name to fetch.
	Keyspace             string   `protobuf:"bytes,1,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetSrvKeyspaceRequest) Reset()         { *m = GetSrvKeyspaceRequest{} }
func (m *GetSrvKeyspaceRequest) String() string { return proto.CompactTextString(m) }
func (*GetSrvKeyspaceRequest) ProtoMessage()    {}
func (*GetSrvKeyspaceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{41}
}
func (m *GetSrvKeyspaceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSrvKeyspaceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSrvKeyspaceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSrvKeyspaceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSrvKeyspaceRequest.Merge(m, src)
}
func (m *GetSrvKeyspaceRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *GetSrvKeyspaceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSrvKeyspaceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetSrvKeyspaceRequest proto.InternalMessageInfo

func (m *GetSrvKeyspaceRequest) GetKeyspace() string {
	if m != nil {
		return m.Keyspace
	}
	return ""
}

// GetSrvKeyspaceResponse is the returned value from GetSrvKeyspace.
type GetSrvKeyspaceResponse struct {
	// srv_keyspace is the topology object for the SrvKeyspace.
	SrvKeyspace          *topodata.SrvKeyspace `protobuf:"bytes,1,opt,name=srv_keyspace,json=srvKeyspace,proto3" json:"srv_keyspace,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *GetSrvKeyspaceResponse) Reset()         { *m = GetSrvKeyspaceResponse{} }
func (m *GetSrvKeyspaceResponse) String() string { return proto.CompactTextString(m) }
func (*GetSrvKeyspaceResponse) ProtoMessage()    {}
func (*GetSrvKeyspaceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{42}
}
func (m *GetSrvKeyspaceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSrvKeyspaceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSrvKeyspaceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSrvKeyspaceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSrvKeyspaceResponse.Merge(m, src)
}
func (m *GetSrvKeyspaceResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *GetSrvKeyspaceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSrvKeyspaceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetSrvKeyspaceResponse proto.InternalMessageInfo

func (m *GetSrvKeyspaceResponse) GetSrvKeyspace() *topodata.SrvKeyspace {
	if m != nil {
		return m.SrvKeyspace
	}
	return nil
}

// VStreamRequest is the payload for VStream.
type VStreamRequest struct {
	CallerId   *vtrpc.CallerID     `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"caller_id,omitempty"`
	TabletType topodata.TabletType `protobuf:"varint,2,opt,name=tablet_type,json=tabletType,proto3,enum=topodata.TabletType" json:"tablet_type,omitempty"`
	// position specifies the starting point of the bin log positions
	// as well as the keyspace-shards to pull events from.
	// position is of the form 'ks1:0@MySQL56/<mysql_pos>|ks2:-80@MySQL56/<mysql_pos>'.
	Vgtid                *binlogdata.VGtid  `protobuf:"bytes,3,opt,name=vgtid,proto3" json:"vgtid,omitempty"`
	Filter               *binlogdata.Filter `protobuf:"bytes,4,opt,name=filter,proto3" json:"filter,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *VStreamRequest) Reset()         { *m = VStreamRequest{} }
func (m *VStreamRequest) String() string { return proto.CompactTextString(m) }
func (*VStreamRequest) ProtoMessage()    {}
func (*VStreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{43}
}
func (m *VStreamRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VStreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VStreamRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VStreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VStreamRequest.Merge(m, src)
}
func (m *VStreamRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *VStreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VStreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VStreamRequest proto.InternalMessageInfo

func (m *VStreamRequest) GetCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.CallerId
	}
	return nil
}

func (m *VStreamRequest) GetTabletType() topodata.TabletType {
	if m != nil {
		return m.TabletType
	}
	return topodata.TabletType_UNKNOWN
}

func (m *VStreamRequest) GetVgtid() *binlogdata.VGtid {
	if m != nil {
		return m.Vgtid
	}
	return nil
}

func (m *VStreamRequest) GetFilter() *binlogdata.Filter {
	if m != nil {
		return m.Filter
	}
	return nil
}

// VStreamResponse is streamed by VStream.
type VStreamResponse struct {
	Events               []*binlogdata.VEvent `protobuf:"bytes,1,rep,name=events,proto3" json:"events,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *VStreamResponse) Reset()         { *m = VStreamResponse{} }
func (m *VStreamResponse) String() string { return proto.CompactTextString(m) }
func (*VStreamResponse) ProtoMessage()    {}
func (*VStreamResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{44}
}
func (m *VStreamResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VStreamResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VStreamResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VStreamResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VStreamResponse.Merge(m, src)
}
func (m *VStreamResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *VStreamResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VStreamResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VStreamResponse proto.InternalMessageInfo

func (m *VStreamResponse) GetEvents() []*binlogdata.VEvent {
	if m != nil {
		return m.Events
	}
	return nil
}

// UpdateStreamRequest is the payload to UpdateStream.
type UpdateStreamRequest struct {
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id,json=callerId,proto3" json:"caller_id,omitempty"`
	// keyspace to target the query to.
	Keyspace string `protobuf:"bytes,2,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	// shard to target the query to, for unsharded keyspaces.
	Shard string `protobuf:"bytes,3,opt,name=shard,proto3" json:"shard,omitempty"`
	// KeyRange to target the query to, for sharded keyspaces.
	KeyRange *topodata.KeyRange `protobuf:"bytes,4,opt,name=key_range,json=keyRange,proto3" json:"key_range,omitempty"`
	// tablet_type is the type of tablets that this request is targeted to.
	TabletType topodata.TabletType `protobuf:"varint,5,opt,name=tablet_type,json=tabletType,proto3,enum=topodata.TabletType" json:"tablet_type,omitempty"`
	// timestamp is the timestamp to start the stream from.  It is
	// unused is event is set, and we are only streaming from the shard
	// described by event.shard.
	Timestamp int64 `protobuf:"varint,6,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// event is the event to start the stream from.
	// Note it is only used if we are streaming from exactly the same shard
	// as this event was coming from. Otherwise we can't use this event,
	// and will use the timestamp as a starting point.
	Event                *query.EventToken `protobuf:"bytes,7,opt,name=event,proto3" json:"event,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *UpdateStreamRequest) Reset()         { *m = UpdateStreamRequest{} }
func (m *UpdateStreamRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateStreamRequest) ProtoMessage()    {}
func (*UpdateStreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{45}
}
func (m *UpdateStreamRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateStreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateStreamRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateStreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateStreamRequest.Merge(m, src)
}
func (m *UpdateStreamRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UpdateStreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateStreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateStreamRequest proto.InternalMessageInfo

func (m *UpdateStreamRequest) GetCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.CallerId
	}
	return nil
}

func (m *UpdateStreamRequest) GetKeyspace() string {
	if m != nil {
		return m.Keyspace
	}
	return ""
}

func (m *UpdateStreamRequest) GetShard() string {
	if m != nil {
		return m.Shard
	}
	return ""
}

func (m *UpdateStreamRequest) GetKeyRange() *topodata.KeyRange {
	if m != nil {
		return m.KeyRange
	}
	return nil
}

func (m *UpdateStreamRequest) GetTabletType() topodata.TabletType {
	if m != nil {
		return m.TabletType
	}
	return topodata.TabletType_UNKNOWN
}

func (m *UpdateStreamRequest) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *UpdateStreamRequest) GetEvent() *query.EventToken {
	if m != nil {
		return m.Event
	}
	return nil
}

// UpdateStreamResponse is streamed by UpdateStream.
type UpdateStreamResponse struct {
	// event is one event from the stream.
	Event *query.StreamEvent `protobuf:"bytes,1,opt,name=event,proto3" json:"event,omitempty"`
	// resume_timestamp is the timestamp to resume streaming from if the
	// client is interrupted. If the Update Stream only goes to one
	// shard, this is equal to event.timestamp. If the Update Stream
	// goes to multiple shards and aggregates, this is the minimum value
	// of the current timestamp for all shards.
	ResumeTimestamp      int64    `protobuf:"varint,2,opt,name=resume_timestamp,json=resumeTimestamp,proto3" json:"resume_timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateStreamResponse) Reset()         { *m = UpdateStreamResponse{} }
func (m *UpdateStreamResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateStreamResponse) ProtoMessage()    {}
func (*UpdateStreamResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aab96496ceaf1ebb, []int{46}
}
func (m *UpdateStreamResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateStreamResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateStreamResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateStreamResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateStreamResponse.Merge(m, src)
}
func (m *UpdateStreamResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UpdateStreamResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateStreamResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateStreamResponse proto.InternalMessageInfo

func (m *UpdateStreamResponse) GetEvent() *query.StreamEvent {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *UpdateStreamResponse) GetResumeTimestamp() int64 {
	if m != nil {
		return m.ResumeTimestamp
	}
	return 0
}

func init() {
	proto.RegisterEnum("vtgate.TransactionMode", TransactionMode_name, TransactionMode_value)
	proto.RegisterEnum("vtgate.CommitOrder", CommitOrder_name, CommitOrder_value)
	proto.RegisterType((*Session)(nil), "vtgate.Session")
	proto.RegisterType((*Session_ShardSession)(nil), "vtgate.Session.ShardSession")
	proto.RegisterType((*ExecuteRequest)(nil), "vtgate.ExecuteRequest")
	proto.RegisterType((*ExecuteResponse)(nil), "vtgate.ExecuteResponse")
	proto.RegisterType((*ExecuteShardsRequest)(nil), "vtgate.ExecuteShardsRequest")
	proto.RegisterType((*ExecuteShardsResponse)(nil), "vtgate.ExecuteShardsResponse")
	proto.RegisterType((*ExecuteKeyspaceIdsRequest)(nil), "vtgate.ExecuteKeyspaceIdsRequest")
	proto.RegisterType((*ExecuteKeyspaceIdsResponse)(nil), "vtgate.ExecuteKeyspaceIdsResponse")
	proto.RegisterType((*ExecuteKeyRangesRequest)(nil), "vtgate.ExecuteKeyRangesRequest")
	proto.RegisterType((*ExecuteKeyRangesResponse)(nil), "vtgate.ExecuteKeyRangesResponse")
	proto.RegisterType((*ExecuteEntityIdsRequest)(nil), "vtgate.ExecuteEntityIdsRequest")
	proto.RegisterType((*ExecuteEntityIdsRequest_EntityId)(nil), "vtgate.ExecuteEntityIdsRequest.EntityId")
	proto.RegisterType((*ExecuteEntityIdsResponse)(nil), "vtgate.ExecuteEntityIdsResponse")
	proto.RegisterType((*ExecuteBatchRequest)(nil), "vtgate.ExecuteBatchRequest")
	proto.RegisterType((*ExecuteBatchResponse)(nil), "vtgate.ExecuteBatchResponse")
	proto.RegisterType((*BoundShardQuery)(nil), "vtgate.BoundShardQuery")
	proto.RegisterType((*ExecuteBatchShardsRequest)(nil), "vtgate.ExecuteBatchShardsRequest")
	proto.RegisterType((*ExecuteBatchShardsResponse)(nil), "vtgate.ExecuteBatchShardsResponse")
	proto.RegisterType((*BoundKeyspaceIdQuery)(nil), "vtgate.BoundKeyspaceIdQuery")
	proto.RegisterType((*ExecuteBatchKeyspaceIdsRequest)(nil), "vtgate.ExecuteBatchKeyspaceIdsRequest")
	proto.RegisterType((*ExecuteBatchKeyspaceIdsResponse)(nil), "vtgate.ExecuteBatchKeyspaceIdsResponse")
	proto.RegisterType((*StreamExecuteRequest)(nil), "vtgate.StreamExecuteRequest")
	proto.RegisterType((*StreamExecuteResponse)(nil), "vtgate.StreamExecuteResponse")
	proto.RegisterType((*StreamExecuteShardsRequest)(nil), "vtgate.StreamExecuteShardsRequest")
	proto.RegisterType((*StreamExecuteShardsResponse)(nil), "vtgate.StreamExecuteShardsResponse")
	proto.RegisterType((*StreamExecuteKeyspaceIdsRequest)(nil), "vtgate.StreamExecuteKeyspaceIdsRequest")
	proto.RegisterType((*StreamExecuteKeyspaceIdsResponse)(nil), "vtgate.StreamExecuteKeyspaceIdsResponse")
	proto.RegisterType((*StreamExecuteKeyRangesRequest)(nil), "vtgate.StreamExecuteKeyRangesRequest")
	proto.RegisterType((*StreamExecuteKeyRangesResponse)(nil), "vtgate.StreamExecuteKeyRangesResponse")
	proto.RegisterType((*BeginRequest)(nil), "vtgate.BeginRequest")
	proto.RegisterType((*BeginResponse)(nil), "vtgate.BeginResponse")
	proto.RegisterType((*CommitRequest)(nil), "vtgate.CommitRequest")
	proto.RegisterType((*CommitResponse)(nil), "vtgate.CommitResponse")
	proto.RegisterType((*RollbackRequest)(nil), "vtgate.RollbackRequest")
	proto.RegisterType((*RollbackResponse)(nil), "vtgate.RollbackResponse")
	proto.RegisterType((*ResolveTransactionRequest)(nil), "vtgate.ResolveTransactionRequest")
	proto.RegisterType((*MessageStreamRequest)(nil), "vtgate.MessageStreamRequest")
	proto.RegisterType((*MessageAckRequest)(nil), "vtgate.MessageAckRequest")
	proto.RegisterType((*IdKeyspaceId)(nil), "vtgate.IdKeyspaceId")
	proto.RegisterType((*MessageAckKeyspaceIdsRequest)(nil), "vtgate.MessageAckKeyspaceIdsRequest")
	proto.RegisterType((*ResolveTransactionResponse)(nil), "vtgate.ResolveTransactionResponse")
	proto.RegisterType((*SplitQueryRequest)(nil), "vtgate.SplitQueryRequest")
	proto.RegisterType((*SplitQueryResponse)(nil), "vtgate.SplitQueryResponse")
	proto.RegisterType((*SplitQueryResponse_KeyRangePart)(nil), "vtgate.SplitQueryResponse.KeyRangePart")
	proto.RegisterType((*SplitQueryResponse_ShardPart)(nil), "vtgate.SplitQueryResponse.ShardPart")
	proto.RegisterType((*SplitQueryResponse_Part)(nil), "vtgate.SplitQueryResponse.Part")
	proto.RegisterType((*GetSrvKeyspaceRequest)(nil), "vtgate.GetSrvKeyspaceRequest")
	proto.RegisterType((*GetSrvKeyspaceResponse)(nil), "vtgate.GetSrvKeyspaceResponse")
	proto.RegisterType((*VStreamRequest)(nil), "vtgate.VStreamRequest")
	proto.RegisterType((*VStreamResponse)(nil), "vtgate.VStreamResponse")
	proto.RegisterType((*UpdateStreamRequest)(nil), "vtgate.UpdateStreamRequest")
	proto.RegisterType((*UpdateStreamResponse)(nil), "vtgate.UpdateStreamResponse")
}

func init() { proto.RegisterFile("vtgate.proto", fileDescriptor_aab96496ceaf1ebb) }

var fileDescriptor_aab96496ceaf1ebb = []byte{
	// 2054 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x5a, 0x5b, 0x8f, 0x1b, 0x49,
	0x15, 0xde, 0xee, 0xf6, 0xf5, 0xf8, 0x9a, 0xca, 0x24, 0xf1, 0x7a, 0x87, 0x99, 0xd9, 0x5e, 0x46,
	0xf1, 0x66, 0x23, 0x0f, 0xeb, 0xe5, 0x26, 0xb4, 0x68, 0x99, 0x71, 0x66, 0x23, 0x6b, 0x33, 0x17,
	0xca, 0xce, 0x04, 0x10, 0xab, 0x56, 0x8f, 0x5d, 0x38, 0xcd, 0xd8, 0xdd, 0xde, 0xae, 0xb2, 0xc3,
	0xf0, 0x80, 0xf6, 0x1f, 0xac, 0x78, 0x40, 0x42, 0x2b, 0x24, 0x40, 0x42, 0xe2, 0x89, 0x57, 0x24,
	0xe0, 0x85, 0x37, 0x10, 0x2f, 0xc0, 0x13, 0x8f, 0x48, 0xe1, 0x07, 0x20, 0xf1, 0x0b, 0x50, 0x57,
	0x55, 0x5f, 0xdc, 0x73, 0xf3, 0x78, 0x32, 0x91, 0xf3, 0x62, 0x75, 0xd5, 0x39, 0x55, 0x75, 0xce,
	0x77, 0xbe, 0x3a, 0x75, 0xba, 0xdc, 0x90, 0x9f, 0xb0, 0xbe, 0xc9, 0x48, 0x7d, 0xe4, 0x3a, 0xcc,
	0x41, 0x29, 0xd1, 0xaa, 0x96, 0x0f, 0x2d, 0x7b, 0xe0, 0xf4, 0x7b, 0x26, 0x33, 0x85, 0xa4, 0x9a,
	0xfb, 0x64, 0x4c, 0xdc, 0x63, 0xd9, 0x28, 0x32, 0x67, 0xe4, 0x44, 0x85, 0x13, 0xe6, 0x8e, 0xba,
	0xa2, 0xa1, 0xff, 0x3b, 0x01, 0xe9, 0x36, 0xa1, 0xd4, 0x72, 0x6c, 0xb4, 0x0e, 0x45, 0xcb, 0x36,
	0x98, 0x6b, 0xda, 0xd4, 0xec, 0x32, 0xcb, 0xb1, 0x2b, 0xca, 0x9a, 0x52, 0xcb, 0xe0, 0x82, 0x65,
	0x77, 0xc2, 0x4e, 0xd4, 0x84, 0x22, 0x7d, 0x6a, 0xba, 0x3d, 0x83, 0x8a, 0x71, 0xb4, 0xa2, 0xae,
	0x69, 0xb5, 0x5c, 0x63, 0xb9, 0x2e, 0xad, 0x93, 0xf3, 0xd5, 0xdb, 0x9e, 0x96, 0x6c, 0xe0, 0x02,
	0x8d, 0xb4, 0x28, 0x7a, 0x03, 0xb2, 0xd4, 0xb2, 0xfb, 0x03, 0x62, 0xf4, 0x0e, 0x2b, 0x1a, 0x5f,
	0x26, 0x23, 0x3a, 0x1e, 0x1c, 0xa2, 0x15, 0x00, 0x73, 0xcc, 0x9c, 0xae, 0x33, 0x1c, 0x5a, 0xac,
	0x92, 0xe0, 0xd2, 0x48, 0x0f, 0x7a, 0x0b, 0x0a, 0xcc, 0x74, 0xfb, 0x84, 0x19, 0x94, 0xb9, 0x96,
	0xdd, 0xaf, 0x24, 0xd7, 0x94, 0x5a, 0x16, 0xe7, 0x45, 0x67, 0x9b, 0xf7, 0xa1, 0x0d, 0x48, 0x3b,
	0x23, 0xc6, 0xed, 0x4b, 0xad, 0x29, 0xb5, 0x5c, 0xe3, 0x56, 0x5d, 0xa0, 0xb2, 0xfd, 0x23, 0xd2,
	0x1d, 0x33, 0xb2, 0x27, 0x84, 0xd8, 0xd7, 0x42, 0x5b, 0x50, 0x8e, 0xf8, 0x6e, 0x0c, 0x9d, 0x1e,
	0xa9, 0xa4, 0xd7, 0x94, 0x5a, 0xb1, 0x71, 0xc7, 0xf7, 0x2c, 0x02, 0xc3, 0x8e, 0xd3, 0x23, 0xb8,
	0xc4, 0xa6, 0x3b, 0xd0, 0x06, 0x64, 0x9e, 0x99, 0xae, 0x6d, 0xd9, 0x7d, 0x5a, 0xc9, 0x70, 0x54,
	0x6e, 0xca, 0x55, 0xbf, 0xed, 0xfd, 0x3e, 0x11, 0x32, 0x1c, 0x28, 0xa1, 0x0f, 0x20, 0x3f, 0x72,
	0x49, 0x08, 0x65, 0x76, 0x06, 0x28, 0x73, 0x23, 0x97, 0x04, 0x40, 0x6e, 0x42, 0x61, 0xe4, 0x50,
	0x16, 0xce, 0x00, 0x33, 0xcc, 0x90, 0xf7, 0x86, 0xf8, 0x53, 0x54, 0xbf, 0x0f, 0xf9, 0xa8, 0x14,
	0xad, 0x43, 0x4a, 0x20, 0xc9, 0xe3, 0x9f, 0x6b, 0x14, 0xa4, 0x0b, 0x1d, 0xde, 0x89, 0xa5, 0xd0,
	0xa3, 0x4b, 0x14, 0x2f, 0xab, 0x57, 0x51, 0xd7, 0x94, 0x9a, 0x86, 0x0b, 0x91, 0xde, 0x56, 0x4f,
	0xff, 0xbb, 0x0a, 0x45, 0x09, 0x39, 0x26, 0x9f, 0x8c, 0x09, 0x65, 0xe8, 0x3e, 0x64, 0xbb, 0xe6,
	0x60, 0x40, 0x5c, 0x6f, 0x90, 0x58, 0xa3, 0x54, 0x17, 0xac, 0x6c, 0xf2, 0xfe, 0xd6, 0x03, 0x9c,
	0x11, 0x1a, 0xad, 0x1e, 0x7a, 0x1b, 0xd2, 0xd2, 0x39, 0xbe, 0x80, 0xd0, 0x8d, 0xfa, 0x86, 0x7d,
	0x39, 0xba, 0x0b, 0x49, 0x6e, 0x2a, 0x67, 0x54, 0xae, 0x71, 0x43, 0x1a, 0xbe, 0xe5, 0x8c, 0xed,
	0x1e, 0x0f, 0x00, 0x16, 0x72, 0xf4, 0x15, 0xc8, 0x31, 0xf3, 0x70, 0x40, 0x98, 0xc1, 0x8e, 0x47,
	0x84, 0x53, 0xac, 0xd8, 0x58, 0xaa, 0x07, 0x3b, 0xa5, 0xc3, 0x85, 0x9d, 0xe3, 0x11, 0xc1, 0xc0,
	0x82, 0x67, 0x74, 0x1f, 0x90, 0xed, 0x30, 0x23, 0xb6, 0x4b, 0x92, 0x9c, 0xa0, 0x65, 0xdb, 0x61,
	0xad, 0xa9, 0x8d, 0xb2, 0x0e, 0xc5, 0x23, 0x72, 0x4c, 0x47, 0x66, 0x97, 0x18, 0x9c, 0xfd, 0x9c,
	0x88, 0x59, 0x5c, 0xf0, 0x7b, 0x39, 0xea, 0x51, 0xa2, 0xa6, 0x67, 0x21, 0xaa, 0xfe, 0x99, 0x02,
	0xa5, 0x00, 0x51, 0x3a, 0x72, 0x6c, 0x4a, 0xd0, 0x3a, 0x24, 0x89, 0xeb, 0x3a, 0x6e, 0x0c, 0x4e,
	0xbc, 0xdf, 0xdc, 0xf6, 0xba, 0xb1, 0x90, 0x5e, 0x06, 0xcb, 0x7b, 0x90, 0x72, 0x09, 0x1d, 0x0f,
	0x98, 0x04, 0x13, 0x45, 0x89, 0x8c, 0xb9, 0x04, 0x4b, 0x0d, 0xfd, 0xb9, 0x0a, 0x4b, 0xd2, 0x22,
	0xee, 0x13, 0x5d, 0x9c, 0x48, 0x57, 0x21, 0xe3, 0xc3, 0xcd, 0xc3, 0x9c, 0xc5, 0x41, 0x1b, 0xdd,
	0x86, 0x14, 0x8f, 0x0b, 0xad, 0x24, 0xd7, 0xb4, 0x5a, 0x16, 0xcb, 0x56, 0x9c, 0x1d, 0xa9, 0x2b,
	0xb1, 0x23, 0x7d, 0x06, 0x3b, 0x22, 0x61, 0xcf, 0xcc, 0x14, 0xf6, 0x9f, 0x29, 0x70, 0x2b, 0x06,
	0xf2, 0x42, 0x04, 0xff, 0x7f, 0x2a, 0xbc, 0x2e, 0xed, 0xfa, 0x48, 0x22, 0xdb, 0x7a, 0x55, 0x18,
	0xf0, 0x26, 0xe4, 0x83, 0x2d, 0x6a, 0x49, 0x1e, 0xe4, 0x71, 0xee, 0x28, 0xf4, 0x63, 0x41, 0xc9,
	0xf0, 0xb9, 0x02, 0xd5, 0xd3, 0x40, 0x5f, 0x08, 0x46, 0x7c, 0xaa, 0xc1, 0x9d, 0xd0, 0x38, 0x6c,
	0xda, 0x7d, 0xf2, 0x8a, 0xf0, 0xe1, 0x5d, 0x80, 0x23, 0x72, 0x6c, 0xb8, 0xdc, 0x64, 0xce, 0x06,
	0xcf, 0xd3, 0x20, 0xd6, 0xbe, 0x37, 0x38, 0x7b, 0xe4, 0xfb, 0xb5, 0xa0, 0xfc, 0xf8, 0xb9, 0x02,
	0x95, 0x93, 0x21, 0x58, 0x08, 0x76, 0xfc, 0x21, 0x11, 0xb0, 0x63, 0xdb, 0x66, 0x16, 0x3b, 0x7e,
	0x65, 0xb2, 0xc5, 0x7d, 0x40, 0x84, 0x5b, 0x6c, 0x74, 0x9d, 0xc1, 0x78, 0x68, 0x1b, 0xb6, 0x39,
	0x24, 0xb2, 0xf8, 0x2c, 0x0b, 0x49, 0x93, 0x0b, 0x76, 0xcd, 0x21, 0x41, 0xdf, 0x81, 0x9b, 0x52,
	0x7b, 0x2a, 0xc5, 0xa4, 0x38, 0xa9, 0x6a, 0xbe, 0xa5, 0x67, 0x20, 0x51, 0xf7, 0x3b, 0xf0, 0x0d,
	0x31, 0xc9, 0x47, 0x67, 0xa7, 0xa4, 0xf4, 0x95, 0x28, 0x97, 0xb9, 0x98, 0x72, 0xd9, 0x59, 0x28,
	0x57, 0x3d, 0x84, 0x8c, 0x6f, 0x34, 0x5a, 0x85, 0x04, 0x37, 0x4d, 0xe1, 0xa6, 0xe5, 0xfc, 0x02,
	0xd2, 0xb3, 0x88, 0x0b, 0xd0, 0x12, 0x24, 0x27, 0xe6, 0x60, 0x4c, 0x78, 0xe0, 0xf2, 0x58, 0x34,
	0xd0, 0x2a, 0xe4, 0x22, 0x58, 0xf1, 0x58, 0xe5, 0x31, 0x84, 0xd9, 0x38, 0x4a, 0xeb, 0x08, 0x62,
	0x0b, 0x41, 0xeb, 0x7f, 0xaa, 0x70, 0x53, 0x9a, 0xb6, 0x65, 0xb2, 0xee, 0xd3, 0x6b, 0xa7, 0xf4,
	0x3b, 0x90, 0xf6, 0xac, 0xb1, 0x08, 0xad, 0x68, 0x9c, 0x53, 0xa7, 0x90, 0xda, 0xd7, 0x98, 0xb7,
	0xe0, 0x5d, 0x87, 0xa2, 0x49, 0x4f, 0x29, 0x76, 0x0b, 0x26, 0x7d, 0x19, 0x95, 0xee, 0xe7, 0x4a,
	0x50, 0x57, 0x4a, 0x4c, 0xaf, 0x2d, 0xd4, 0x5f, 0x82, 0xb4, 0x08, 0xa4, 0x8f, 0xe6, 0x6d, 0x69,
	0x9b, 0x08, 0xf3, 0x13, 0x8b, 0x3d, 0x15, 0x53, 0xfb, 0x6a, 0xba, 0x0d, 0x25, 0x8e, 0x34, 0xf7,
	0x8d, 0xc3, 0x1d, 0x66, 0x19, 0xe5, 0x12, 0x59, 0x46, 0x3d, 0xb3, 0x2a, 0xd5, 0xa2, 0x55, 0xa9,
	0xfe, 0xfb, 0xb0, 0xce, 0xe2, 0x60, 0xbc, 0xa4, 0x4a, 0xfb, 0xdd, 0x38, 0xcd, 0x82, 0xb7, 0xe1,
	0x98, 0xf7, 0x2f, 0x8b, 0x6c, 0x97, 0x7d, 0xb1, 0xd7, 0x7f, 0x11, 0xd6, 0x4a, 0x53, 0xc0, 0x5d,
	0x1b, 0x97, 0xee, 0xc7, 0xb9, 0x74, 0x5a, 0xde, 0x08, 0x78, 0xf4, 0x13, 0x58, 0xe2, 0x48, 0x86,
	0x19, 0xfe, 0x05, 0x92, 0x29, 0x5e, 0xe0, 0x6a, 0x27, 0x0a, 0x5c, 0xfd, 0xcf, 0x2a, 0xac, 0x44,
	0xe1, 0x79, 0x99, 0x45, 0xfc, 0x57, 0xe3, 0xe4, 0x5a, 0x9e, 0x22, 0x57, 0x0c, 0x92, 0x85, 0x65,
	0xd8, 0xaf, 0x15, 0x58, 0x3d, 0x13, 0xc2, 0x05, 0xa1, 0xd9, 0x6f, 0x55, 0x58, 0x6a, 0x33, 0x97,
	0x98, 0xc3, 0x2b, 0xdd, 0xc6, 0x04, 0xac, 0x54, 0x2f, 0x77, 0xc5, 0xa2, 0xcd, 0x1e, 0xa2, 0xd8,
	0x51, 0x92, 0xb8, 0xe0, 0x28, 0x49, 0xce, 0x74, 0xbb, 0x17, 0xc1, 0x35, 0x75, 0x3e, 0xae, 0x7a,
	0x13, 0x6e, 0xc5, 0x80, 0x92, 0x21, 0x0c, 0xcb, 0x01, 0xe5, 0xc2, 0x72, 0xe0, 0x33, 0x15, 0xaa,
	0x53, 0xb3, 0x5c, 0x25, 0x5d, 0xcf, 0x0c, 0x7a, 0x34, 0x15, 0x68, 0x67, 0x9e, 0x2b, 0x89, 0xf3,
	0x6e, 0x3b, 0x92, 0x33, 0x06, 0xea, 0xd2, 0x9b, 0xa4, 0x05, 0x6f, 0x9c, 0x0a, 0xc8, 0x1c, 0xe0,
	0xfe, 0x52, 0x85, 0xd5, 0xa9, 0xb9, 0xae, 0x9c, 0xb3, 0x5e, 0x08, 0xc2, 0xf1, 0x64, 0x9b, 0xb8,
	0xf0, 0x36, 0xe1, 0xda, 0xc0, 0xde, 0x85, 0xb5, 0xb3, 0x01, 0x9a, 0x03, 0xf1, 0xdf, 0xa9, 0xf0,
	0x85, 0xf8, 0x84, 0x57, 0x79, 0xb1, 0x7f, 0x21, 0x78, 0x4f, 0xbf, 0xad, 0x27, 0xe6, 0x78, 0x5b,
	0xbf, 0x36, 0xfc, 0x1f, 0xc1, 0xca, 0x59, 0x70, 0xcd, 0x81, 0xfe, 0x77, 0x21, 0xbf, 0x45, 0xfa,
	0x96, 0x3d, 0x1f, 0xd6, 0x53, 0xff, 0xb5, 0xa8, 0xd3, 0xff, 0xb5, 0xe8, 0xdf, 0x80, 0x82, 0x9c,
	0x5a, 0xda, 0x15, 0x49, 0x94, 0xca, 0x05, 0x89, 0xf2, 0x53, 0x05, 0x0a, 0x4d, 0xfe, 0x97, 0xcc,
	0xb5, 0x17, 0x0a, 0xb7, 0x21, 0x65, 0x32, 0x67, 0x68, 0x75, 0xe5, 0x9f, 0x45, 0xb2, 0xa5, 0x97,
	0xa1, 0xe8, 0x5b, 0x20, 0xec, 0xd7, 0x7f, 0x08, 0x25, 0xec, 0x0c, 0x06, 0x87, 0x66, 0xf7, 0xe8,
	0xba, 0xad, 0xd2, 0x11, 0x94, 0xc3, 0xb5, 0xe4, 0xfa, 0x1f, 0xc3, 0xeb, 0x98, 0x50, 0x67, 0x30,
	0x21, 0x91, 0x92, 0x62, 0x3e, 0x4b, 0x10, 0x24, 0x7a, 0x4c, 0xfe, 0xaf, 0x92, 0xc5, 0xfc, 0x59,
	0xff, 0x93, 0x02, 0x4b, 0x3b, 0x84, 0x52, 0xb3, 0x4f, 0x04, 0xc1, 0xe6, 0x9b, 0xfa, 0xbc, 0x9a,
	0x71, 0x09, 0x92, 0xe2, 0xe4, 0x15, 0xfb, 0x4d, 0x34, 0xd0, 0x06, 0x64, 0x83, 0xcd, 0xc6, 0xcf,
	0xe4, 0xd3, 0xf7, 0x5a, 0xc6, 0xdf, 0x6b, 0x9e, 0xf5, 0x91, 0xfb, 0x11, 0xfe, 0xac, 0xff, 0x54,
	0x81, 0x1b, 0xd2, 0xfa, 0xcd, 0x79, 0xe3, 0x73, 0x9e, 0xe9, 0xfe, 0x9a, 0x5a, 0xb8, 0x26, 0x5a,
	0x01, 0xcd, 0x4f, 0xc6, 0xb9, 0x46, 0x5e, 0xee, 0xb2, 0x03, 0x73, 0x30, 0x26, 0xd8, 0x13, 0xe8,
	0x3b, 0x90, 0x6f, 0x45, 0x2a, 0x4d, 0xb4, 0x0c, 0x6a, 0x60, 0xc6, 0xb4, 0xba, 0x6a, 0xf5, 0xe2,
	0x57, 0x14, 0xea, 0x89, 0x2b, 0x8a, 0x3f, 0x2a, 0xb0, 0x1c, 0xba, 0x78, 0xe5, 0x83, 0xe9, 0xb2,
	0xde, 0xbe, 0x0f, 0x25, 0xab, 0x67, 0x9c, 0x38, 0x86, 0x72, 0x8d, 0x25, 0x9f, 0xc5, 0x51, 0x67,
	0x71, 0xc1, 0x8a, 0xb4, 0xa8, 0xbe, 0x0c, 0xd5, 0xd3, 0xc8, 0x2b, 0xa9, 0xfd, 0x5f, 0x15, 0x6e,
	0xb4, 0x47, 0x03, 0x8b, 0xc9, 0x1c, 0xf5, 0xa2, 0xfd, 0x99, 0xf9, 0x92, 0xee, 0x4d, 0xc8, 0x53,
	0xcf, 0x0e, 0x79, 0x0f, 0x27, 0x0b, 0x9a, 0x1c, 0xef, 0x13, 0x37, 0x70, 0x5e, 0x9c, 0x7c, 0x95,
	0xb1, 0xcd, 0x38, 0x09, 0x35, 0x0c, 0x52, 0x63, 0x6c, 0x33, 0xf4, 0x65, 0xb8, 0x63, 0x8f, 0x87,
	0x86, 0xeb, 0x3c, 0xa3, 0xc6, 0x88, 0xb8, 0x06, 0x9f, 0xd9, 0x18, 0x99, 0x2e, 0xe3, 0x29, 0x5e,
	0xc3, 0x37, 0xed, 0xf1, 0x10, 0x3b, 0xcf, 0xe8, 0x3e, 0x71, 0xf9, 0xe2, 0xfb, 0xa6, 0xcb, 0xd0,
	0xb7, 0x20, 0x6b, 0x0e, 0xfa, 0x8e, 0x6b, 0xb1, 0xa7, 0x43, 0x79, 0xf1, 0xa6, 0x4b, 0x33, 0x4f,
	0x20, 0x53, 0xdf, 0xf4, 0x35, 0x71, 0x38, 0x08, 0xbd, 0x03, 0x68, 0x4c, 0x89, 0x21, 0x8c, 0x13,
	0x8b, 0x4e, 0x1a, 0xf2, 0x16, 0xae, 0x34, 0xa6, 0x24, 0x9c, 0xe6, 0xa0, 0xa1, 0xff, 0x45, 0x03,
	0x14, 0x9d, 0x57, 0xe6, 0xe8, 0xaf, 0x41, 0x8a, 0x8f, 0xa7, 0x15, 0x85, 0xc7, 0x76, 0x35, 0xc8,
	0x50, 0x27, 0x74, 0xeb, 0x9e, 0xd9, 0x58, 0xaa, 0x57, 0x3f, 0x86, 0xbc, 0xbf, 0x53, 0xb9, 0x3b,
	0xd1, 0x68, 0x28, 0xe7, 0x9e, 0xae, 0xea, 0x0c, 0xa7, 0x6b, 0xf5, 0x03, 0xc8, 0xf2, 0xaa, 0xee,
	0xc2, 0xb9, 0xc3, 0x5a, 0x54, 0x8d, 0xd6, 0xa2, 0xd5, 0x7f, 0x29, 0x90, 0xe0, 0x83, 0x67, 0x7e,
	0xf9, 0xdd, 0xe1, 0xef, 0x0b, 0xc2, 0x4a, 0x11, 0x3d, 0x91, 0xb4, 0xef, 0x9e, 0x03, 0x49, 0x14,
	0x02, 0x9c, 0x3f, 0x8a, 0x02, 0xd2, 0x04, 0x10, 0x1f, 0x37, 0xf0, 0xa9, 0x04, 0x0f, 0xbf, 0x78,
	0xce, 0x54, 0x81, 0xbb, 0x38, 0x4b, 0x03, 0xcf, 0x11, 0x24, 0xa8, 0xf5, 0x63, 0x91, 0x25, 0x35,
	0xcc, 0x9f, 0xf5, 0xf7, 0xe0, 0xd6, 0x43, 0xc2, 0xda, 0xee, 0xc4, 0xdf, 0x6e, 0xfe, 0xf6, 0x39,
	0x07, 0x26, 0x1d, 0xc3, 0xed, 0xf8, 0x20, 0xc9, 0x80, 0xaf, 0x43, 0x9e, 0xba, 0x13, 0x63, 0x6a,
	0xa4, 0x57, 0x95, 0x04, 0xe1, 0x89, 0x0e, 0xca, 0xd1, 0xb0, 0xa1, 0xff, 0x4d, 0x81, 0xe2, 0xc1,
	0x55, 0x8e, 0x8e, 0x58, 0x09, 0xa5, 0xce, 0x58, 0x42, 0xdd, 0x85, 0xe4, 0xa4, 0xcf, 0xe4, 0xad,
	0xae, 0x17, 0xd1, 0xc8, 0x57, 0x2b, 0x07, 0x0f, 0x99, 0xd5, 0xc3, 0x42, 0xee, 0x15, 0x46, 0x3f,
	0xb0, 0x06, 0x8c, 0xb8, 0xc1, 0x29, 0x13, 0xd1, 0xfc, 0x90, 0x4b, 0xb0, 0xd4, 0xd0, 0xbf, 0x09,
	0xa5, 0xc0, 0x97, 0xb0, 0xae, 0x22, 0x13, 0x62, 0x07, 0x7b, 0x63, 0x6a, 0xf8, 0xc1, 0xb6, 0x27,
	0xc2, 0x52, 0x43, 0xff, 0x8d, 0x0a, 0x37, 0x1f, 0x8f, 0x7a, 0x26, 0x5b, 0xf4, 0xb3, 0x74, 0xce,
	0xb2, 0x75, 0x19, 0xb2, 0xcc, 0x1a, 0x12, 0xca, 0xcc, 0xe1, 0x48, 0x66, 0xb5, 0xb0, 0xc3, 0x8b,
	0x08, 0xc7, 0x41, 0x5e, 0xc6, 0xfa, 0x7b, 0x8c, 0x43, 0xd4, 0x71, 0x8e, 0x88, 0x8d, 0x85, 0x5c,
	0x3f, 0x82, 0xa5, 0x69, 0x94, 0x24, 0xd4, 0x35, 0x7f, 0x82, 0xe9, 0x0a, 0x56, 0x16, 0xbe, 0x1c,
	0x69, 0xa1, 0x80, 0xde, 0x86, 0xb2, 0x57, 0xca, 0x0e, 0x89, 0x11, 0xda, 0x23, 0xbe, 0x16, 0x29,
	0x89, 0xfe, 0x8e, 0xdf, 0x7d, 0xef, 0x01, 0x94, 0x62, 0x9f, 0xd9, 0xa0, 0x12, 0xe4, 0x1e, 0xef,
	0xb6, 0xf7, 0xb7, 0x9b, 0xad, 0x0f, 0x5b, 0xdb, 0x0f, 0xca, 0xaf, 0x21, 0x80, 0x54, 0xbb, 0xb5,
	0xfb, 0xf0, 0xd1, 0x76, 0x59, 0x41, 0x59, 0x48, 0xee, 0x3c, 0x7e, 0xd4, 0x69, 0x95, 0x55, 0xef,
	0xb1, 0xf3, 0x64, 0x6f, 0xbf, 0x59, 0xd6, 0xee, 0xbd, 0x0f, 0x39, 0x51, 0x17, 0xee, 0xb9, 0x3d,
	0xe2, 0x7a, 0x03, 0x76, 0xf7, 0xf0, 0xce, 0xe6, 0xa3, 0xf2, 0x6b, 0x28, 0x0d, 0xda, 0x3e, 0xf6,
	0x46, 0x66, 0x20, 0xb1, 0xbf, 0xd7, 0xee, 0x94, 0x55, 0x54, 0x04, 0xd8, 0x7c, 0xdc, 0xd9, 0x6b,
	0xee, 0xed, 0xec, 0xb4, 0x3a, 0x65, 0x6d, 0x6b, 0xeb, 0xaf, 0xcf, 0x57, 0x94, 0x7f, 0x3c, 0x5f,
	0x51, 0x7e, 0xf5, 0x9f, 0x15, 0x05, 0x4a, 0x96, 0x53, 0x9f, 0x58, 0x8c, 0x50, 0x2a, 0x3e, 0x9a,
	0xfa, 0xde, 0x5b, 0xb2, 0x65, 0x39, 0x1b, 0xe2, 0x69, 0xa3, 0xef, 0x6c, 0x4c, 0xd8, 0x06, 0x97,
	0x6e, 0x88, 0x64, 0x71, 0x98, 0xe2, 0xad, 0xf7, 0xfe, 0x1f, 0x00, 0x00, 0xff, 0xff, 0x92, 0xe3,
	0x87, 0x6b, 0xb4, 0x25, 0x00, 0x00,
}

func (m *Session) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Session) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InTransaction {
		dAtA[i] = 0x8
		i++
		if m.InTransaction {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ShardSessions) > 0 {
		for _, msg := range m.ShardSessions {
			dAtA[i] = 0x12
			i++
			i = encodeVarintVtgate(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.SingleDb {
		dAtA[i] = 0x18
		i++
		if m.SingleDb {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Autocommit {
		dAtA[i] = 0x20
		i++
		if m.Autocommit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.TargetString) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(len(m.TargetString)))
		i += copy(dAtA[i:], m.TargetString)
	}
	if m.Options != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Options.ProtoSize()))
		n1, err1 := m.Options.MarshalTo(dAtA[i:])
		if err1 != nil {
			return 0, err1
		}
		i += n1
	}
	if m.TransactionMode != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.TransactionMode))
	}
	if len(m.Warnings) > 0 {
		for _, msg := range m.Warnings {
			dAtA[i] = 0x42
			i++
			i = encodeVarintVtgate(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PreSessions) > 0 {
		for _, msg := range m.PreSessions {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintVtgate(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PostSessions) > 0 {
		for _, msg := range m.PostSessions {
			dAtA[i] = 0x52
			i++
			i = encodeVarintVtgate(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Session_ShardSession) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Session_ShardSession) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Target != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Target.ProtoSize()))
		n2, err2 := m.Target.MarshalTo(dAtA[i:])
		if err2 != nil {
			return 0, err2
		}
		i += n2
	}
	if m.TransactionId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.TransactionId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExecuteRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CallerId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.CallerId.ProtoSize()))
		n3, err3 := m.CallerId.MarshalTo(dAtA[i:])
		if err3 != nil {
			return 0, err3
		}
		i += n3
	}
	if m.Session != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Session.ProtoSize()))
		n4, err4 := m.Session.MarshalTo(dAtA[i:])
		if err4 != nil {
			return 0, err4
		}
		i += n4
	}
	if m.Query != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Query.ProtoSize()))
		n5, err5 := m.Query.MarshalTo(dAtA[i:])
		if err5 != nil {
			return 0, err5
		}
		i += n5
	}
	if m.TabletType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.TabletType))
	}
	if m.NotInTransaction {
		dAtA[i] = 0x28
		i++
		if m.NotInTransaction {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.KeyspaceShard) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(len(m.KeyspaceShard)))
		i += copy(dAtA[i:], m.KeyspaceShard)
	}
	if m.Options != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Options.ProtoSize()))
		n6, err6 := m.Options.MarshalTo(dAtA[i:])
		if err6 != nil {
			return 0, err6
		}
		i += n6
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExecuteResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Error.ProtoSize()))
		n7, err7 := m.Error.MarshalTo(dAtA[i:])
		if err7 != nil {
			return 0, err7
		}
		i += n7
	}
	if m.Session != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Session.ProtoSize()))
		n8, err8 := m.Session.MarshalTo(dAtA[i:])
		if err8 != nil {
			return 0, err8
		}
		i += n8
	}
	if m.Result != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Result.ProtoSize()))
		n9, err9 := m.Result.MarshalTo(dAtA[i:])
		if err9 != nil {
			return 0, err9
		}
		i += n9
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExecuteShardsRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteShardsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CallerId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.CallerId.ProtoSize()))
		n10, err10 := m.CallerId.MarshalTo(dAtA[i:])
		if err10 != nil {
			return 0, err10
		}
		i += n10
	}
	if m.Session != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Session.ProtoSize()))
		n11, err11 := m.Session.MarshalTo(dAtA[i:])
		if err11 != nil {
			return 0, err11
		}
		i += n11
	}
	if m.Query != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Query.ProtoSize()))
		n12, err12 := m.Query.MarshalTo(dAtA[i:])
		if err12 != nil {
			return 0, err12
		}
		i += n12
	}
	if len(m.Keyspace) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(len(m.Keyspace)))
		i += copy(dAtA[i:], m.Keyspace)
	}
	if len(m.Shards) > 0 {
		for _, s := range m.Shards {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.TabletType != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.TabletType))
	}
	if m.NotInTransaction {
		dAtA[i] = 0x38
		i++
		if m.NotInTransaction {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Options != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Options.ProtoSize()))
		n13, err13 := m.Options.MarshalTo(dAtA[i:])
		if err13 != nil {
			return 0, err13
		}
		i += n13
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExecuteShardsResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteShardsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Error.ProtoSize()))
		n14, err14 := m.Error.MarshalTo(dAtA[i:])
		if err14 != nil {
			return 0, err14
		}
		i += n14
	}
	if m.Session != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Session.ProtoSize()))
		n15, err15 := m.Session.MarshalTo(dAtA[i:])
		if err15 != nil {
			return 0, err15
		}
		i += n15
	}
	if m.Result != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Result.ProtoSize()))
		n16, err16 := m.Result.MarshalTo(dAtA[i:])
		if err16 != nil {
			return 0, err16
		}
		i += n16
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExecuteKeyspaceIdsRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteKeyspaceIdsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CallerId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.CallerId.ProtoSize()))
		n17, err17 := m.CallerId.MarshalTo(dAtA[i:])
		if err17 != nil {
			return 0, err17
		}
		i += n17
	}
	if m.Session != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Session.ProtoSize()))
		n18, err18 := m.Session.MarshalTo(dAtA[i:])
		if err18 != nil {
			return 0, err18
		}
		i += n18
	}
	if m.Query != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Query.ProtoSize()))
		n19, err19 := m.Query.MarshalTo(dAtA[i:])
		if err19 != nil {
			return 0, err19
		}
		i += n19
	}
	if len(m.Keyspace) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(len(m.Keyspace)))
		i += copy(dAtA[i:], m.Keyspace)
	}
	if len(m.KeyspaceIds) > 0 {
		for _, b := range m.KeyspaceIds {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintVtgate(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.TabletType != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.TabletType))
	}
	if m.NotInTransaction {
		dAtA[i] = 0x38
		i++
		if m.NotInTransaction {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Options != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Options.ProtoSize()))
		n20, err20 := m.Options.MarshalTo(dAtA[i:])
		if err20 != nil {
			return 0, err20
		}
		i += n20
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExecuteKeyspaceIdsResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteKeyspaceIdsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Error.ProtoSize()))
		n21, err21 := m.Error.MarshalTo(dAtA[i:])
		if err21 != nil {
			return 0, err21
		}
		i += n21
	}
	if m.Session != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Session.ProtoSize()))
		n22, err22 := m.Session.MarshalTo(dAtA[i:])
		if err22 != nil {
			return 0, err22
		}
		i += n22
	}
	if m.Result != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Result.ProtoSize()))
		n23, err23 := m.Result.MarshalTo(dAtA[i:])
		if err23 != nil {
			return 0, err23
		}
		i += n23
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExecuteKeyRangesRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteKeyRangesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CallerId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.CallerId.ProtoSize()))
		n24, err24 := m.CallerId.MarshalTo(dAtA[i:])
		if err24 != nil {
			return 0, err24
		}
		i += n24
	}
	if m.Session != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Session.ProtoSize()))
		n25, err25 := m.Session.MarshalTo(dAtA[i:])
		if err25 != nil {
			return 0, err25
		}
		i += n25
	}
	if m.Query != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Query.ProtoSize()))
		n26, err26 := m.Query.MarshalTo(dAtA[i:])
		if err26 != nil {
			return 0, err26
		}
		i += n26
	}
	if len(m.Keyspace) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(len(m.Keyspace)))
		i += copy(dAtA[i:], m.Keyspace)
	}
	if len(m.KeyRanges) > 0 {
		for _, msg := range m.KeyRanges {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintVtgate(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.TabletType != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.TabletType))
	}
	if m.NotInTransaction {
		dAtA[i] = 0x38
		i++
		if m.NotInTransaction {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Options != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Options.ProtoSize()))
		n27, err27 := m.Options.MarshalTo(dAtA[i:])
		if err27 != nil {
			return 0, err27
		}
		i += n27
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExecuteKeyRangesResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteKeyRangesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Error.ProtoSize()))
		n28, err28 := m.Error.MarshalTo(dAtA[i:])
		if err28 != nil {
			return 0, err28
		}
		i += n28
	}
	if m.Session != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Session.ProtoSize()))
		n29, err29 := m.Session.MarshalTo(dAtA[i:])
		if err29 != nil {
			return 0, err29
		}
		i += n29
	}
	if m.Result != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Result.ProtoSize()))
		n30, err30 := m.Result.MarshalTo(dAtA[i:])
		if err30 != nil {
			return 0, err30
		}
		i += n30
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExecuteEntityIdsRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteEntityIdsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CallerId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.CallerId.ProtoSize()))
		n31, err31 := m.CallerId.MarshalTo(dAtA[i:])
		if err31 != nil {
			return 0, err31
		}
		i += n31
	}
	if m.Session != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Session.ProtoSize()))
		n32, err32 := m.Session.MarshalTo(dAtA[i:])
		if err32 != nil {
			return 0, err32
		}
		i += n32
	}
	if m.Query != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Query.ProtoSize()))
		n33, err33 := m.Query.MarshalTo(dAtA[i:])
		if err33 != nil {
			return 0, err33
		}
		i += n33
	}
	if len(m.Keyspace) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(len(m.Keyspace)))
		i += copy(dAtA[i:], m.Keyspace)
	}
	if len(m.EntityColumnName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(len(m.EntityColumnName)))
		i += copy(dAtA[i:], m.EntityColumnName)
	}
	if len(m.EntityKeyspaceIds) > 0 {
		for _, msg := range m.EntityKeyspaceIds {
			dAtA[i] = 0x32
			i++
			i = encodeVarintVtgate(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.TabletType != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.TabletType))
	}
	if m.NotInTransaction {
		dAtA[i] = 0x40
		i++
		if m.NotInTransaction {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Options != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Options.ProtoSize()))
		n34, err34 := m.Options.MarshalTo(dAtA[i:])
		if err34 != nil {
			return 0, err34
		}
		i += n34
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExecuteEntityIdsRequest_EntityId) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteEntityIdsRequest_EntityId) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Type))
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if len(m.KeyspaceId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(len(m.KeyspaceId)))
		i += copy(dAtA[i:], m.KeyspaceId)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExecuteEntityIdsResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteEntityIdsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Error.ProtoSize()))
		n35, err35 := m.Error.MarshalTo(dAtA[i:])
		if err35 != nil {
			return 0, err35
		}
		i += n35
	}
	if m.Session != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Session.ProtoSize()))
		n36, err36 := m.Session.MarshalTo(dAtA[i:])
		if err36 != nil {
			return 0, err36
		}
		i += n36
	}
	if m.Result != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Result.ProtoSize()))
		n37, err37 := m.Result.MarshalTo(dAtA[i:])
		if err37 != nil {
			return 0, err37
		}
		i += n37
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExecuteBatchRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteBatchRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CallerId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.CallerId.ProtoSize()))
		n38, err38 := m.CallerId.MarshalTo(dAtA[i:])
		if err38 != nil {
			return 0, err38
		}
		i += n38
	}
	if m.Session != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Session.ProtoSize()))
		n39, err39 := m.Session.MarshalTo(dAtA[i:])
		if err39 != nil {
			return 0, err39
		}
		i += n39
	}
	if len(m.Queries) > 0 {
		for _, msg := range m.Queries {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintVtgate(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.TabletType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.TabletType))
	}
	if m.AsTransaction {
		dAtA[i] = 0x28
		i++
		if m.AsTransaction {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.KeyspaceShard) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(len(m.KeyspaceShard)))
		i += copy(dAtA[i:], m.KeyspaceShard)
	}
	if m.Options != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Options.ProtoSize()))
		n40, err40 := m.Options.MarshalTo(dAtA[i:])
		if err40 != nil {
			return 0, err40
		}
		i += n40
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExecuteBatchResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteBatchResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Error.ProtoSize()))
		n41, err41 := m.Error.MarshalTo(dAtA[i:])
		if err41 != nil {
			return 0, err41
		}
		i += n41
	}
	if m.Session != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Session.ProtoSize()))
		n42, err42 := m.Session.MarshalTo(dAtA[i:])
		if err42 != nil {
			return 0, err42
		}
		i += n42
	}
	if len(m.Results) > 0 {
		for _, msg := range m.Results {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintVtgate(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BoundShardQuery) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BoundShardQuery) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Query != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Query.ProtoSize()))
		n43, err43 := m.Query.MarshalTo(dAtA[i:])
		if err43 != nil {
			return 0, err43
		}
		i += n43
	}
	if len(m.Keyspace) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(len(m.Keyspace)))
		i += copy(dAtA[i:], m.Keyspace)
	}
	if len(m.Shards) > 0 {
		for _, s := range m.Shards {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExecuteBatchShardsRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteBatchShardsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CallerId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.CallerId.ProtoSize()))
		n44, err44 := m.CallerId.MarshalTo(dAtA[i:])
		if err44 != nil {
			return 0, err44
		}
		i += n44
	}
	if m.Session != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Session.ProtoSize()))
		n45, err45 := m.Session.MarshalTo(dAtA[i:])
		if err45 != nil {
			return 0, err45
		}
		i += n45
	}
	if len(m.Queries) > 0 {
		for _, msg := range m.Queries {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintVtgate(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.TabletType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.TabletType))
	}
	if m.AsTransaction {
		dAtA[i] = 0x28
		i++
		if m.AsTransaction {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Options != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Options.ProtoSize()))
		n46, err46 := m.Options.MarshalTo(dAtA[i:])
		if err46 != nil {
			return 0, err46
		}
		i += n46
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExecuteBatchShardsResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteBatchShardsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Error.ProtoSize()))
		n47, err47 := m.Error.MarshalTo(dAtA[i:])
		if err47 != nil {
			return 0, err47
		}
		i += n47
	}
	if m.Session != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Session.ProtoSize()))
		n48, err48 := m.Session.MarshalTo(dAtA[i:])
		if err48 != nil {
			return 0, err48
		}
		i += n48
	}
	if len(m.Results) > 0 {
		for _, msg := range m.Results {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintVtgate(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BoundKeyspaceIdQuery) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BoundKeyspaceIdQuery) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Query != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Query.ProtoSize()))
		n49, err49 := m.Query.MarshalTo(dAtA[i:])
		if err49 != nil {
			return 0, err49
		}
		i += n49
	}
	if len(m.Keyspace) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(len(m.Keyspace)))
		i += copy(dAtA[i:], m.Keyspace)
	}
	if len(m.KeyspaceIds) > 0 {
		for _, b := range m.KeyspaceIds {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintVtgate(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExecuteBatchKeyspaceIdsRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteBatchKeyspaceIdsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CallerId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.CallerId.ProtoSize()))
		n50, err50 := m.CallerId.MarshalTo(dAtA[i:])
		if err50 != nil {
			return 0, err50
		}
		i += n50
	}
	if m.Session != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Session.ProtoSize()))
		n51, err51 := m.Session.MarshalTo(dAtA[i:])
		if err51 != nil {
			return 0, err51
		}
		i += n51
	}
	if len(m.Queries) > 0 {
		for _, msg := range m.Queries {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintVtgate(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.TabletType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.TabletType))
	}
	if m.AsTransaction {
		dAtA[i] = 0x28
		i++
		if m.AsTransaction {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Options != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Options.ProtoSize()))
		n52, err52 := m.Options.MarshalTo(dAtA[i:])
		if err52 != nil {
			return 0, err52
		}
		i += n52
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExecuteBatchKeyspaceIdsResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteBatchKeyspaceIdsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Error.ProtoSize()))
		n53, err53 := m.Error.MarshalTo(dAtA[i:])
		if err53 != nil {
			return 0, err53
		}
		i += n53
	}
	if m.Session != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Session.ProtoSize()))
		n54, err54 := m.Session.MarshalTo(dAtA[i:])
		if err54 != nil {
			return 0, err54
		}
		i += n54
	}
	if len(m.Results) > 0 {
		for _, msg := range m.Results {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintVtgate(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StreamExecuteRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamExecuteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CallerId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.CallerId.ProtoSize()))
		n55, err55 := m.CallerId.MarshalTo(dAtA[i:])
		if err55 != nil {
			return 0, err55
		}
		i += n55
	}
	if m.Query != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Query.ProtoSize()))
		n56, err56 := m.Query.MarshalTo(dAtA[i:])
		if err56 != nil {
			return 0, err56
		}
		i += n56
	}
	if m.TabletType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.TabletType))
	}
	if len(m.KeyspaceShard) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(len(m.KeyspaceShard)))
		i += copy(dAtA[i:], m.KeyspaceShard)
	}
	if m.Options != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Options.ProtoSize()))
		n57, err57 := m.Options.MarshalTo(dAtA[i:])
		if err57 != nil {
			return 0, err57
		}
		i += n57
	}
	if m.Session != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Session.ProtoSize()))
		n58, err58 := m.Session.MarshalTo(dAtA[i:])
		if err58 != nil {
			return 0, err58
		}
		i += n58
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StreamExecuteResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamExecuteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Result.ProtoSize()))
		n59, err59 := m.Result.MarshalTo(dAtA[i:])
		if err59 != nil {
			return 0, err59
		}
		i += n59
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StreamExecuteShardsRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamExecuteShardsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CallerId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.CallerId.ProtoSize()))
		n60, err60 := m.CallerId.MarshalTo(dAtA[i:])
		if err60 != nil {
			return 0, err60
		}
		i += n60
	}
	if m.Query != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Query.ProtoSize()))
		n61, err61 := m.Query.MarshalTo(dAtA[i:])
		if err61 != nil {
			return 0, err61
		}
		i += n61
	}
	if len(m.Keyspace) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(len(m.Keyspace)))
		i += copy(dAtA[i:], m.Keyspace)
	}
	if len(m.Shards) > 0 {
		for _, s := range m.Shards {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.TabletType != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.TabletType))
	}
	if m.Options != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Options.ProtoSize()))
		n62, err62 := m.Options.MarshalTo(dAtA[i:])
		if err62 != nil {
			return 0, err62
		}
		i += n62
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StreamExecuteShardsResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamExecuteShardsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Result.ProtoSize()))
		n63, err63 := m.Result.MarshalTo(dAtA[i:])
		if err63 != nil {
			return 0, err63
		}
		i += n63
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StreamExecuteKeyspaceIdsRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamExecuteKeyspaceIdsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CallerId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.CallerId.ProtoSize()))
		n64, err64 := m.CallerId.MarshalTo(dAtA[i:])
		if err64 != nil {
			return 0, err64
		}
		i += n64
	}
	if m.Query != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Query.ProtoSize()))
		n65, err65 := m.Query.MarshalTo(dAtA[i:])
		if err65 != nil {
			return 0, err65
		}
		i += n65
	}
	if len(m.Keyspace) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(len(m.Keyspace)))
		i += copy(dAtA[i:], m.Keyspace)
	}
	if len(m.KeyspaceIds) > 0 {
		for _, b := range m.KeyspaceIds {
			dAtA[i] = 0x22
			i++
			i = encodeVarintVtgate(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.TabletType != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.TabletType))
	}
	if m.Options != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Options.ProtoSize()))
		n66, err66 := m.Options.MarshalTo(dAtA[i:])
		if err66 != nil {
			return 0, err66
		}
		i += n66
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StreamExecuteKeyspaceIdsResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamExecuteKeyspaceIdsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Result.ProtoSize()))
		n67, err67 := m.Result.MarshalTo(dAtA[i:])
		if err67 != nil {
			return 0, err67
		}
		i += n67
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StreamExecuteKeyRangesRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamExecuteKeyRangesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CallerId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.CallerId.ProtoSize()))
		n68, err68 := m.CallerId.MarshalTo(dAtA[i:])
		if err68 != nil {
			return 0, err68
		}
		i += n68
	}
	if m.Query != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Query.ProtoSize()))
		n69, err69 := m.Query.MarshalTo(dAtA[i:])
		if err69 != nil {
			return 0, err69
		}
		i += n69
	}
	if len(m.Keyspace) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(len(m.Keyspace)))
		i += copy(dAtA[i:], m.Keyspace)
	}
	if len(m.KeyRanges) > 0 {
		for _, msg := range m.KeyRanges {
			dAtA[i] = 0x22
			i++
			i = encodeVarintVtgate(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.TabletType != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.TabletType))
	}
	if m.Options != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Options.ProtoSize()))
		n70, err70 := m.Options.MarshalTo(dAtA[i:])
		if err70 != nil {
			return 0, err70
		}
		i += n70
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StreamExecuteKeyRangesResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamExecuteKeyRangesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Result.ProtoSize()))
		n71, err71 := m.Result.MarshalTo(dAtA[i:])
		if err71 != nil {
			return 0, err71
		}
		i += n71
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BeginRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BeginRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CallerId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.CallerId.ProtoSize()))
		n72, err72 := m.CallerId.MarshalTo(dAtA[i:])
		if err72 != nil {
			return 0, err72
		}
		i += n72
	}
	if m.SingleDb {
		dAtA[i] = 0x10
		i++
		if m.SingleDb {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BeginResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BeginResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Session != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Session.ProtoSize()))
		n73, err73 := m.Session.MarshalTo(dAtA[i:])
		if err73 != nil {
			return 0, err73
		}
		i += n73
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommitRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CallerId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.CallerId.ProtoSize()))
		n74, err74 := m.CallerId.MarshalTo(dAtA[i:])
		if err74 != nil {
			return 0, err74
		}
		i += n74
	}
	if m.Session != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Session.ProtoSize()))
		n75, err75 := m.Session.MarshalTo(dAtA[i:])
		if err75 != nil {
			return 0, err75
		}
		i += n75
	}
	if m.Atomic {
		dAtA[i] = 0x18
		i++
		if m.Atomic {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommitResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RollbackRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RollbackRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CallerId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.CallerId.ProtoSize()))
		n76, err76 := m.CallerId.MarshalTo(dAtA[i:])
		if err76 != nil {
			return 0, err76
		}
		i += n76
	}
	if m.Session != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Session.ProtoSize()))
		n77, err77 := m.Session.MarshalTo(dAtA[i:])
		if err77 != nil {
			return 0, err77
		}
		i += n77
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RollbackResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RollbackResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ResolveTransactionRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResolveTransactionRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CallerId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.CallerId.ProtoSize()))
		n78, err78 := m.CallerId.MarshalTo(dAtA[i:])
		if err78 != nil {
			return 0, err78
		}
		i += n78
	}
	if len(m.Dtid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(len(m.Dtid)))
		i += copy(dAtA[i:], m.Dtid)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MessageStreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageStreamRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CallerId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.CallerId.ProtoSize()))
		n79, err79 := m.CallerId.MarshalTo(dAtA[i:])
		if err79 != nil {
			return 0, err79
		}
		i += n79
	}
	if len(m.Keyspace) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(len(m.Keyspace)))
		i += copy(dAtA[i:], m.Keyspace)
	}
	if len(m.Shard) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(len(m.Shard)))
		i += copy(dAtA[i:], m.Shard)
	}
	if m.KeyRange != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.KeyRange.ProtoSize()))
		n80, err80 := m.KeyRange.MarshalTo(dAtA[i:])
		if err80 != nil {
			return 0, err80
		}
		i += n80
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MessageAckRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageAckRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CallerId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.CallerId.ProtoSize()))
		n81, err81 := m.CallerId.MarshalTo(dAtA[i:])
		if err81 != nil {
			return 0, err81
		}
		i += n81
	}
	if len(m.Keyspace) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(len(m.Keyspace)))
		i += copy(dAtA[i:], m.Keyspace)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Ids) > 0 {
		for _, msg := range m.Ids {
			dAtA[i] = 0x22
			i++
			i = encodeVarintVtgate(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *IdKeyspaceId) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IdKeyspaceId) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Id.ProtoSize()))
		n82, err82 := m.Id.MarshalTo(dAtA[i:])
		if err82 != nil {
			return 0, err82
		}
		i += n82
	}
	if len(m.KeyspaceId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(len(m.KeyspaceId)))
		i += copy(dAtA[i:], m.KeyspaceId)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MessageAckKeyspaceIdsRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageAckKeyspaceIdsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CallerId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.CallerId.ProtoSize()))
		n83, err83 := m.CallerId.MarshalTo(dAtA[i:])
		if err83 != nil {
			return 0, err83
		}
		i += n83
	}
	if len(m.Keyspace) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(len(m.Keyspace)))
		i += copy(dAtA[i:], m.Keyspace)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.IdKeyspaceIds) > 0 {
		for _, msg := range m.IdKeyspaceIds {
			dAtA[i] = 0x22
			i++
			i = encodeVarintVtgate(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ResolveTransactionResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResolveTransactionResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SplitQueryRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitQueryRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CallerId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.CallerId.ProtoSize()))
		n84, err84 := m.CallerId.MarshalTo(dAtA[i:])
		if err84 != nil {
			return 0, err84
		}
		i += n84
	}
	if len(m.Keyspace) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(len(m.Keyspace)))
		i += copy(dAtA[i:], m.Keyspace)
	}
	if m.Query != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Query.ProtoSize()))
		n85, err85 := m.Query.MarshalTo(dAtA[i:])
		if err85 != nil {
			return 0, err85
		}
		i += n85
	}
	if len(m.SplitColumn) > 0 {
		for _, s := range m.SplitColumn {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.SplitCount != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.SplitCount))
	}
	if m.NumRowsPerQueryPart != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.NumRowsPerQueryPart))
	}
	if m.Algorithm != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Algorithm))
	}
	if m.UseSplitQueryV2 {
		dAtA[i] = 0x40
		i++
		if m.UseSplitQueryV2 {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SplitQueryResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitQueryResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Splits) > 0 {
		for _, msg := range m.Splits {
			dAtA[i] = 0xa
			i++
			i = encodeVarintVtgate(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SplitQueryResponse_KeyRangePart) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitQueryResponse_KeyRangePart) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Keyspace) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(len(m.Keyspace)))
		i += copy(dAtA[i:], m.Keyspace)
	}
	if len(m.KeyRanges) > 0 {
		for _, msg := range m.KeyRanges {
			dAtA[i] = 0x12
			i++
			i = encodeVarintVtgate(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SplitQueryResponse_ShardPart) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitQueryResponse_ShardPart) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Keyspace) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(len(m.Keyspace)))
		i += copy(dAtA[i:], m.Keyspace)
	}
	if len(m.Shards) > 0 {
		for _, s := range m.Shards {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SplitQueryResponse_Part) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitQueryResponse_Part) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Query != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Query.ProtoSize()))
		n86, err86 := m.Query.MarshalTo(dAtA[i:])
		if err86 != nil {
			return 0, err86
		}
		i += n86
	}
	if m.KeyRangePart != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.KeyRangePart.ProtoSize()))
		n87, err87 := m.KeyRangePart.MarshalTo(dAtA[i:])
		if err87 != nil {
			return 0, err87
		}
		i += n87
	}
	if m.ShardPart != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.ShardPart.ProtoSize()))
		n88, err88 := m.ShardPart.MarshalTo(dAtA[i:])
		if err88 != nil {
			return 0, err88
		}
		i += n88
	}
	if m.Size != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Size))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetSrvKeyspaceRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSrvKeyspaceRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Keyspace) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(len(m.Keyspace)))
		i += copy(dAtA[i:], m.Keyspace)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetSrvKeyspaceResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSrvKeyspaceResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SrvKeyspace != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.SrvKeyspace.ProtoSize()))
		n89, err89 := m.SrvKeyspace.MarshalTo(dAtA[i:])
		if err89 != nil {
			return 0, err89
		}
		i += n89
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VStreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VStreamRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CallerId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.CallerId.ProtoSize()))
		n90, err90 := m.CallerId.MarshalTo(dAtA[i:])
		if err90 != nil {
			return 0, err90
		}
		i += n90
	}
	if m.TabletType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.TabletType))
	}
	if m.Vgtid != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Vgtid.ProtoSize()))
		n91, err91 := m.Vgtid.MarshalTo(dAtA[i:])
		if err91 != nil {
			return 0, err91
		}
		i += n91
	}
	if m.Filter != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Filter.ProtoSize()))
		n92, err92 := m.Filter.MarshalTo(dAtA[i:])
		if err92 != nil {
			return 0, err92
		}
		i += n92
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VStreamResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VStreamResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, msg := range m.Events {
			dAtA[i] = 0xa
			i++
			i = encodeVarintVtgate(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateStreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateStreamRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CallerId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.CallerId.ProtoSize()))
		n93, err93 := m.CallerId.MarshalTo(dAtA[i:])
		if err93 != nil {
			return 0, err93
		}
		i += n93
	}
	if len(m.Keyspace) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(len(m.Keyspace)))
		i += copy(dAtA[i:], m.Keyspace)
	}
	if len(m.Shard) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(len(m.Shard)))
		i += copy(dAtA[i:], m.Shard)
	}
	if m.KeyRange != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.KeyRange.ProtoSize()))
		n94, err94 := m.KeyRange.MarshalTo(dAtA[i:])
		if err94 != nil {
			return 0, err94
		}
		i += n94
	}
	if m.TabletType != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.TabletType))
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Timestamp))
	}
	if m.Event != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Event.ProtoSize()))
		n95, err95 := m.Event.MarshalTo(dAtA[i:])
		if err95 != nil {
			return 0, err95
		}
		i += n95
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateStreamResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateStreamResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Event != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.Event.ProtoSize()))
		n96, err96 := m.Event.MarshalTo(dAtA[i:])
		if err96 != nil {
			return 0, err96
		}
		i += n96
	}
	if m.ResumeTimestamp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintVtgate(dAtA, i, uint64(m.ResumeTimestamp))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintVtgate(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Session) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InTransaction {
		n += 2
	}
	if len(m.ShardSessions) > 0 {
		for _, e := range m.ShardSessions {
			l = e.ProtoSize()
			n += 1 + l + sovVtgate(uint64(l))
		}
	}
	if m.SingleDb {
		n += 2
	}
	if m.Autocommit {
		n += 2
	}
	l = len(m.TargetString)
	if l > 0 {
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Options != nil {
		l = m.Options.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.TransactionMode != 0 {
		n += 1 + sovVtgate(uint64(m.TransactionMode))
	}
	if len(m.Warnings) > 0 {
		for _, e := range m.Warnings {
			l = e.ProtoSize()
			n += 1 + l + sovVtgate(uint64(l))
		}
	}
	if len(m.PreSessions) > 0 {
		for _, e := range m.PreSessions {
			l = e.ProtoSize()
			n += 1 + l + sovVtgate(uint64(l))
		}
	}
	if len(m.PostSessions) > 0 {
		for _, e := range m.PostSessions {
			l = e.ProtoSize()
			n += 1 + l + sovVtgate(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Session_ShardSession) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Target != nil {
		l = m.Target.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.TransactionId != 0 {
		n += 1 + sovVtgate(uint64(m.TransactionId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExecuteRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Query != nil {
		l = m.Query.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.TabletType != 0 {
		n += 1 + sovVtgate(uint64(m.TabletType))
	}
	if m.NotInTransaction {
		n += 2
	}
	l = len(m.KeyspaceShard)
	if l > 0 {
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Options != nil {
		l = m.Options.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExecuteResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Result != nil {
		l = m.Result.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExecuteShardsRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Query != nil {
		l = m.Query.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + sovVtgate(uint64(l))
	}
	if len(m.Shards) > 0 {
		for _, s := range m.Shards {
			l = len(s)
			n += 1 + l + sovVtgate(uint64(l))
		}
	}
	if m.TabletType != 0 {
		n += 1 + sovVtgate(uint64(m.TabletType))
	}
	if m.NotInTransaction {
		n += 2
	}
	if m.Options != nil {
		l = m.Options.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExecuteShardsResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Result != nil {
		l = m.Result.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExecuteKeyspaceIdsRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Query != nil {
		l = m.Query.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + sovVtgate(uint64(l))
	}
	if len(m.KeyspaceIds) > 0 {
		for _, b := range m.KeyspaceIds {
			l = len(b)
			n += 1 + l + sovVtgate(uint64(l))
		}
	}
	if m.TabletType != 0 {
		n += 1 + sovVtgate(uint64(m.TabletType))
	}
	if m.NotInTransaction {
		n += 2
	}
	if m.Options != nil {
		l = m.Options.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExecuteKeyspaceIdsResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Result != nil {
		l = m.Result.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExecuteKeyRangesRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Query != nil {
		l = m.Query.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + sovVtgate(uint64(l))
	}
	if len(m.KeyRanges) > 0 {
		for _, e := range m.KeyRanges {
			l = e.ProtoSize()
			n += 1 + l + sovVtgate(uint64(l))
		}
	}
	if m.TabletType != 0 {
		n += 1 + sovVtgate(uint64(m.TabletType))
	}
	if m.NotInTransaction {
		n += 2
	}
	if m.Options != nil {
		l = m.Options.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExecuteKeyRangesResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Result != nil {
		l = m.Result.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExecuteEntityIdsRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Query != nil {
		l = m.Query.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + sovVtgate(uint64(l))
	}
	l = len(m.EntityColumnName)
	if l > 0 {
		n += 1 + l + sovVtgate(uint64(l))
	}
	if len(m.EntityKeyspaceIds) > 0 {
		for _, e := range m.EntityKeyspaceIds {
			l = e.ProtoSize()
			n += 1 + l + sovVtgate(uint64(l))
		}
	}
	if m.TabletType != 0 {
		n += 1 + sovVtgate(uint64(m.TabletType))
	}
	if m.NotInTransaction {
		n += 2
	}
	if m.Options != nil {
		l = m.Options.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExecuteEntityIdsRequest_EntityId) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovVtgate(uint64(m.Type))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovVtgate(uint64(l))
	}
	l = len(m.KeyspaceId)
	if l > 0 {
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExecuteEntityIdsResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Result != nil {
		l = m.Result.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExecuteBatchRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if len(m.Queries) > 0 {
		for _, e := range m.Queries {
			l = e.ProtoSize()
			n += 1 + l + sovVtgate(uint64(l))
		}
	}
	if m.TabletType != 0 {
		n += 1 + sovVtgate(uint64(m.TabletType))
	}
	if m.AsTransaction {
		n += 2
	}
	l = len(m.KeyspaceShard)
	if l > 0 {
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Options != nil {
		l = m.Options.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExecuteBatchResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if len(m.Results) > 0 {
		for _, e := range m.Results {
			l = e.ProtoSize()
			n += 1 + l + sovVtgate(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BoundShardQuery) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Query != nil {
		l = m.Query.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + sovVtgate(uint64(l))
	}
	if len(m.Shards) > 0 {
		for _, s := range m.Shards {
			l = len(s)
			n += 1 + l + sovVtgate(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExecuteBatchShardsRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if len(m.Queries) > 0 {
		for _, e := range m.Queries {
			l = e.ProtoSize()
			n += 1 + l + sovVtgate(uint64(l))
		}
	}
	if m.TabletType != 0 {
		n += 1 + sovVtgate(uint64(m.TabletType))
	}
	if m.AsTransaction {
		n += 2
	}
	if m.Options != nil {
		l = m.Options.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExecuteBatchShardsResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if len(m.Results) > 0 {
		for _, e := range m.Results {
			l = e.ProtoSize()
			n += 1 + l + sovVtgate(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BoundKeyspaceIdQuery) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Query != nil {
		l = m.Query.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + sovVtgate(uint64(l))
	}
	if len(m.KeyspaceIds) > 0 {
		for _, b := range m.KeyspaceIds {
			l = len(b)
			n += 1 + l + sovVtgate(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExecuteBatchKeyspaceIdsRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if len(m.Queries) > 0 {
		for _, e := range m.Queries {
			l = e.ProtoSize()
			n += 1 + l + sovVtgate(uint64(l))
		}
	}
	if m.TabletType != 0 {
		n += 1 + sovVtgate(uint64(m.TabletType))
	}
	if m.AsTransaction {
		n += 2
	}
	if m.Options != nil {
		l = m.Options.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExecuteBatchKeyspaceIdsResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if len(m.Results) > 0 {
		for _, e := range m.Results {
			l = e.ProtoSize()
			n += 1 + l + sovVtgate(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StreamExecuteRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Query != nil {
		l = m.Query.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.TabletType != 0 {
		n += 1 + sovVtgate(uint64(m.TabletType))
	}
	l = len(m.KeyspaceShard)
	if l > 0 {
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Options != nil {
		l = m.Options.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StreamExecuteResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StreamExecuteShardsRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Query != nil {
		l = m.Query.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + sovVtgate(uint64(l))
	}
	if len(m.Shards) > 0 {
		for _, s := range m.Shards {
			l = len(s)
			n += 1 + l + sovVtgate(uint64(l))
		}
	}
	if m.TabletType != 0 {
		n += 1 + sovVtgate(uint64(m.TabletType))
	}
	if m.Options != nil {
		l = m.Options.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StreamExecuteShardsResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StreamExecuteKeyspaceIdsRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Query != nil {
		l = m.Query.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + sovVtgate(uint64(l))
	}
	if len(m.KeyspaceIds) > 0 {
		for _, b := range m.KeyspaceIds {
			l = len(b)
			n += 1 + l + sovVtgate(uint64(l))
		}
	}
	if m.TabletType != 0 {
		n += 1 + sovVtgate(uint64(m.TabletType))
	}
	if m.Options != nil {
		l = m.Options.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StreamExecuteKeyspaceIdsResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StreamExecuteKeyRangesRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Query != nil {
		l = m.Query.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + sovVtgate(uint64(l))
	}
	if len(m.KeyRanges) > 0 {
		for _, e := range m.KeyRanges {
			l = e.ProtoSize()
			n += 1 + l + sovVtgate(uint64(l))
		}
	}
	if m.TabletType != 0 {
		n += 1 + sovVtgate(uint64(m.TabletType))
	}
	if m.Options != nil {
		l = m.Options.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StreamExecuteKeyRangesResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BeginRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.SingleDb {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BeginResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Session != nil {
		l = m.Session.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommitRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Atomic {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommitResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RollbackRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Session != nil {
		l = m.Session.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RollbackResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResolveTransactionRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	l = len(m.Dtid)
	if l > 0 {
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageStreamRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + sovVtgate(uint64(l))
	}
	l = len(m.Shard)
	if l > 0 {
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.KeyRange != nil {
		l = m.KeyRange.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageAckRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + sovVtgate(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovVtgate(uint64(l))
	}
	if len(m.Ids) > 0 {
		for _, e := range m.Ids {
			l = e.ProtoSize()
			n += 1 + l + sovVtgate(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IdKeyspaceId) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = m.Id.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	l = len(m.KeyspaceId)
	if l > 0 {
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageAckKeyspaceIdsRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + sovVtgate(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovVtgate(uint64(l))
	}
	if len(m.IdKeyspaceIds) > 0 {
		for _, e := range m.IdKeyspaceIds {
			l = e.ProtoSize()
			n += 1 + l + sovVtgate(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResolveTransactionResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SplitQueryRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Query != nil {
		l = m.Query.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if len(m.SplitColumn) > 0 {
		for _, s := range m.SplitColumn {
			l = len(s)
			n += 1 + l + sovVtgate(uint64(l))
		}
	}
	if m.SplitCount != 0 {
		n += 1 + sovVtgate(uint64(m.SplitCount))
	}
	if m.NumRowsPerQueryPart != 0 {
		n += 1 + sovVtgate(uint64(m.NumRowsPerQueryPart))
	}
	if m.Algorithm != 0 {
		n += 1 + sovVtgate(uint64(m.Algorithm))
	}
	if m.UseSplitQueryV2 {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SplitQueryResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Splits) > 0 {
		for _, e := range m.Splits {
			l = e.ProtoSize()
			n += 1 + l + sovVtgate(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SplitQueryResponse_KeyRangePart) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + sovVtgate(uint64(l))
	}
	if len(m.KeyRanges) > 0 {
		for _, e := range m.KeyRanges {
			l = e.ProtoSize()
			n += 1 + l + sovVtgate(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SplitQueryResponse_ShardPart) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + sovVtgate(uint64(l))
	}
	if len(m.Shards) > 0 {
		for _, s := range m.Shards {
			l = len(s)
			n += 1 + l + sovVtgate(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SplitQueryResponse_Part) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Query != nil {
		l = m.Query.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.KeyRangePart != nil {
		l = m.KeyRangePart.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.ShardPart != nil {
		l = m.ShardPart.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Size != 0 {
		n += 1 + sovVtgate(uint64(m.Size))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetSrvKeyspaceRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetSrvKeyspaceResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrvKeyspace != nil {
		l = m.SrvKeyspace.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VStreamRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.TabletType != 0 {
		n += 1 + sovVtgate(uint64(m.TabletType))
	}
	if m.Vgtid != nil {
		l = m.Vgtid.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.Filter != nil {
		l = m.Filter.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VStreamResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.ProtoSize()
			n += 1 + l + sovVtgate(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateStreamRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CallerId != nil {
		l = m.CallerId.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + sovVtgate(uint64(l))
	}
	l = len(m.Shard)
	if l > 0 {
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.KeyRange != nil {
		l = m.KeyRange.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.TabletType != 0 {
		n += 1 + sovVtgate(uint64(m.TabletType))
	}
	if m.Timestamp != 0 {
		n += 1 + sovVtgate(uint64(m.Timestamp))
	}
	if m.Event != nil {
		l = m.Event.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateStreamResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Event != nil {
		l = m.Event.ProtoSize()
		n += 1 + l + sovVtgate(uint64(l))
	}
	if m.ResumeTimestamp != 0 {
		n += 1 + sovVtgate(uint64(m.ResumeTimestamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovVtgate(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozVtgate(x uint64) (n int) {
	return sovVtgate(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Session) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Session: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Session: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InTransaction", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InTransaction = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardSessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardSessions = append(m.ShardSessions, &Session_ShardSession{})
			if err := m.ShardSessions[len(m.ShardSessions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SingleDb", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SingleDb = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Autocommit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Autocommit = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetString = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &query.ExecuteOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionMode", wireType)
			}
			m.TransactionMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransactionMode |= TransactionMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Warnings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Warnings = append(m.Warnings, &query.QueryWarning{})
			if err := m.Warnings[len(m.Warnings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreSessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreSessions = append(m.PreSessions, &Session_ShardSession{})
			if err := m.PreSessions[len(m.PreSessions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostSessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PostSessions = append(m.PostSessions, &Session_ShardSession{})
			if err := m.PostSessions[len(m.PostSessions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Session_ShardSession) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardSession: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardSession: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &query.Target{}
			}
			if err := m.Target.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionId", wireType)
			}
			m.TransactionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransactionId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Query == nil {
				m.Query = &query.BoundQuery{}
			}
			if err := m.Query.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabletType", wireType)
			}
			m.TabletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabletType |= topodata.TabletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotInTransaction", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotInTransaction = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyspaceShard", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyspaceShard = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &query.ExecuteOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &vtrpc.RPCError{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &query.QueryResult{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteShardsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteShardsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteShardsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Query == nil {
				m.Query = &query.BoundQuery{}
			}
			if err := m.Query.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shards", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shards = append(m.Shards, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabletType", wireType)
			}
			m.TabletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabletType |= topodata.TabletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotInTransaction", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotInTransaction = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &query.ExecuteOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteShardsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteShardsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteShardsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &vtrpc.RPCError{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &query.QueryResult{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteKeyspaceIdsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteKeyspaceIdsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteKeyspaceIdsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Query == nil {
				m.Query = &query.BoundQuery{}
			}
			if err := m.Query.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyspaceIds", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyspaceIds = append(m.KeyspaceIds, make([]byte, postIndex-iNdEx))
			copy(m.KeyspaceIds[len(m.KeyspaceIds)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabletType", wireType)
			}
			m.TabletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabletType |= topodata.TabletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotInTransaction", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotInTransaction = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &query.ExecuteOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteKeyspaceIdsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteKeyspaceIdsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteKeyspaceIdsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &vtrpc.RPCError{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &query.QueryResult{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteKeyRangesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteKeyRangesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteKeyRangesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Query == nil {
				m.Query = &query.BoundQuery{}
			}
			if err := m.Query.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyRanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyRanges = append(m.KeyRanges, &topodata.KeyRange{})
			if err := m.KeyRanges[len(m.KeyRanges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabletType", wireType)
			}
			m.TabletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabletType |= topodata.TabletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotInTransaction", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotInTransaction = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &query.ExecuteOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteKeyRangesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteKeyRangesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteKeyRangesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &vtrpc.RPCError{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &query.QueryResult{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteEntityIdsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteEntityIdsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteEntityIdsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Query == nil {
				m.Query = &query.BoundQuery{}
			}
			if err := m.Query.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityColumnName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntityColumnName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityKeyspaceIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntityKeyspaceIds = append(m.EntityKeyspaceIds, &ExecuteEntityIdsRequest_EntityId{})
			if err := m.EntityKeyspaceIds[len(m.EntityKeyspaceIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabletType", wireType)
			}
			m.TabletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabletType |= topodata.TabletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotInTransaction", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotInTransaction = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &query.ExecuteOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteEntityIdsRequest_EntityId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntityId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntityId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= query.Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyspaceId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyspaceId = append(m.KeyspaceId[:0], dAtA[iNdEx:postIndex]...)
			if m.KeyspaceId == nil {
				m.KeyspaceId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteEntityIdsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteEntityIdsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteEntityIdsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &vtrpc.RPCError{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &query.QueryResult{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteBatchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteBatchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteBatchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Queries = append(m.Queries, &query.BoundQuery{})
			if err := m.Queries[len(m.Queries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabletType", wireType)
			}
			m.TabletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabletType |= topodata.TabletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsTransaction", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AsTransaction = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyspaceShard", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyspaceShard = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &query.ExecuteOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteBatchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteBatchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteBatchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &vtrpc.RPCError{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Results = append(m.Results, &query.ResultWithError{})
			if err := m.Results[len(m.Results)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BoundShardQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BoundShardQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BoundShardQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Query == nil {
				m.Query = &query.BoundQuery{}
			}
			if err := m.Query.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shards", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shards = append(m.Shards, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteBatchShardsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteBatchShardsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteBatchShardsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Queries = append(m.Queries, &BoundShardQuery{})
			if err := m.Queries[len(m.Queries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabletType", wireType)
			}
			m.TabletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabletType |= topodata.TabletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsTransaction", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AsTransaction = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &query.ExecuteOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteBatchShardsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteBatchShardsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteBatchShardsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &vtrpc.RPCError{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Results = append(m.Results, &query.QueryResult{})
			if err := m.Results[len(m.Results)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BoundKeyspaceIdQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BoundKeyspaceIdQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BoundKeyspaceIdQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Query == nil {
				m.Query = &query.BoundQuery{}
			}
			if err := m.Query.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyspaceIds", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyspaceIds = append(m.KeyspaceIds, make([]byte, postIndex-iNdEx))
			copy(m.KeyspaceIds[len(m.KeyspaceIds)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteBatchKeyspaceIdsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteBatchKeyspaceIdsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteBatchKeyspaceIdsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Queries = append(m.Queries, &BoundKeyspaceIdQuery{})
			if err := m.Queries[len(m.Queries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabletType", wireType)
			}
			m.TabletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabletType |= topodata.TabletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsTransaction", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AsTransaction = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &query.ExecuteOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteBatchKeyspaceIdsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteBatchKeyspaceIdsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteBatchKeyspaceIdsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &vtrpc.RPCError{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Results = append(m.Results, &query.QueryResult{})
			if err := m.Results[len(m.Results)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamExecuteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamExecuteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamExecuteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Query == nil {
				m.Query = &query.BoundQuery{}
			}
			if err := m.Query.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabletType", wireType)
			}
			m.TabletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabletType |= topodata.TabletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyspaceShard", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyspaceShard = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &query.ExecuteOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamExecuteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamExecuteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamExecuteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &query.QueryResult{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamExecuteShardsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamExecuteShardsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamExecuteShardsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Query == nil {
				m.Query = &query.BoundQuery{}
			}
			if err := m.Query.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shards", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shards = append(m.Shards, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabletType", wireType)
			}
			m.TabletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabletType |= topodata.TabletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &query.ExecuteOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamExecuteShardsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamExecuteShardsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamExecuteShardsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &query.QueryResult{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamExecuteKeyspaceIdsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamExecuteKeyspaceIdsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamExecuteKeyspaceIdsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Query == nil {
				m.Query = &query.BoundQuery{}
			}
			if err := m.Query.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyspaceIds", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyspaceIds = append(m.KeyspaceIds, make([]byte, postIndex-iNdEx))
			copy(m.KeyspaceIds[len(m.KeyspaceIds)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabletType", wireType)
			}
			m.TabletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabletType |= topodata.TabletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &query.ExecuteOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamExecuteKeyspaceIdsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamExecuteKeyspaceIdsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamExecuteKeyspaceIdsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &query.QueryResult{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamExecuteKeyRangesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamExecuteKeyRangesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamExecuteKeyRangesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Query == nil {
				m.Query = &query.BoundQuery{}
			}
			if err := m.Query.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyRanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyRanges = append(m.KeyRanges, &topodata.KeyRange{})
			if err := m.KeyRanges[len(m.KeyRanges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabletType", wireType)
			}
			m.TabletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabletType |= topodata.TabletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &query.ExecuteOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamExecuteKeyRangesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamExecuteKeyRangesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamExecuteKeyRangesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &query.QueryResult{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BeginRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BeginRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BeginRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SingleDb", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SingleDb = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BeginResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BeginResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BeginResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Atomic", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Atomic = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RollbackRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RollbackRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RollbackRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RollbackResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RollbackResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RollbackResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResolveTransactionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResolveTransactionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResolveTransactionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dtid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dtid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageStreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageStreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageStreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shard = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyRange == nil {
				m.KeyRange = &topodata.KeyRange{}
			}
			if err := m.KeyRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageAckRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageAckRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageAckRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ids = append(m.Ids, &query.Value{})
			if err := m.Ids[len(m.Ids)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IdKeyspaceId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IdKeyspaceId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IdKeyspaceId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &query.Value{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyspaceId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyspaceId = append(m.KeyspaceId[:0], dAtA[iNdEx:postIndex]...)
			if m.KeyspaceId == nil {
				m.KeyspaceId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageAckKeyspaceIdsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageAckKeyspaceIdsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageAckKeyspaceIdsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdKeyspaceIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IdKeyspaceIds = append(m.IdKeyspaceIds, &IdKeyspaceId{})
			if err := m.IdKeyspaceIds[len(m.IdKeyspaceIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResolveTransactionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResolveTransactionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResolveTransactionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitQueryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SplitQueryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SplitQueryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Query == nil {
				m.Query = &query.BoundQuery{}
			}
			if err := m.Query.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitColumn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SplitColumn = append(m.SplitColumn, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitCount", wireType)
			}
			m.SplitCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SplitCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumRowsPerQueryPart", wireType)
			}
			m.NumRowsPerQueryPart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumRowsPerQueryPart |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algorithm", wireType)
			}
			m.Algorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Algorithm |= query.SplitQueryRequest_Algorithm(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseSplitQueryV2", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseSplitQueryV2 = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitQueryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SplitQueryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SplitQueryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Splits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Splits = append(m.Splits, &SplitQueryResponse_Part{})
			if err := m.Splits[len(m.Splits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitQueryResponse_KeyRangePart) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyRangePart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyRangePart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyRanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyRanges = append(m.KeyRanges, &topodata.KeyRange{})
			if err := m.KeyRanges[len(m.KeyRanges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitQueryResponse_ShardPart) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardPart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardPart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shards", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shards = append(m.Shards, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitQueryResponse_Part) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Part: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Part: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Query == nil {
				m.Query = &query.BoundQuery{}
			}
			if err := m.Query.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyRangePart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyRangePart == nil {
				m.KeyRangePart = &SplitQueryResponse_KeyRangePart{}
			}
			if err := m.KeyRangePart.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardPart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardPart == nil {
				m.ShardPart = &SplitQueryResponse_ShardPart{}
			}
			if err := m.ShardPart.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size", wireType)
			}
			m.Size = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSrvKeyspaceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSrvKeyspaceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSrvKeyspaceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSrvKeyspaceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSrvKeyspaceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSrvKeyspaceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrvKeyspace", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrvKeyspace == nil {
				m.SrvKeyspace = &topodata.SrvKeyspace{}
			}
			if err := m.SrvKeyspace.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VStreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VStreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VStreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabletType", wireType)
			}
			m.TabletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabletType |= topodata.TabletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vgtid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vgtid == nil {
				m.Vgtid = &binlogdata.VGtid{}
			}
			if err := m.Vgtid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = &binlogdata.Filter{}
			}
			if err := m.Filter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VStreamResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VStreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VStreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &binlogdata.VEvent{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateStreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateStreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateStreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallerId == nil {
				m.CallerId = &vtrpc.CallerID{}
			}
			if err := m.CallerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shard = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyRange == nil {
				m.KeyRange = &topodata.KeyRange{}
			}
			if err := m.KeyRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabletType", wireType)
			}
			m.TabletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabletType |= topodata.TabletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Event == nil {
				m.Event = &query.EventToken{}
			}
			if err := m.Event.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateStreamResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateStreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateStreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVtgate
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVtgate
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Event == nil {
				m.Event = &query.StreamEvent{}
			}
			if err := m.Event.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResumeTimestamp", wireType)
			}
			m.ResumeTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResumeTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVtgate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVtgate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipVtgate(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowVtgate
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVtgate
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthVtgate
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthVtgate
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowVtgate
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipVtgate(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthVtgate
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthVtgate = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowVtgate   = fmt.Errorf("proto: integer overflow")
)
