// Code generated by protoc-gen-go.
// source: vtgate.proto
// DO NOT EDIT!

/*
Package vtgate is a generated protocol buffer package.

It is generated from these files:
	vtgate.proto

It has these top-level messages:
	Session
	ExecuteRequest
	ExecuteResponse
	ExecuteShardsRequest
	ExecuteShardsResponse
	ExecuteKeyspaceIdsRequest
	ExecuteKeyspaceIdsResponse
	ExecuteKeyRangesRequest
	ExecuteKeyRangesResponse
	ExecuteEntityIdsRequest
	ExecuteEntityIdsResponse
	BoundShardQuery
	ExecuteBatchShardsRequest
	ExecuteBatchShardsResponse
	BoundKeyspaceIdQuery
	ExecuteBatchKeyspaceIdsRequest
	ExecuteBatchKeyspaceIdsResponse
	StreamExecuteRequest
	StreamExecuteResponse
	StreamExecuteShardsRequest
	StreamExecuteShardsResponse
	StreamExecuteKeyspaceIdsRequest
	StreamExecuteKeyspaceIdsResponse
	StreamExecuteKeyRangesRequest
	StreamExecuteKeyRangesResponse
	BeginRequest
	BeginResponse
	CommitRequest
	CommitResponse
	RollbackRequest
	RollbackResponse
	SplitQueryRequest
	SplitQueryResponse
	GetSrvKeyspaceRequest
	GetSrvKeyspaceResponse
*/
package vtgate

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import query "github.com/youtube/vitess/go/vt/proto/query"
import topodata "github.com/youtube/vitess/go/vt/proto/topodata"
import vtrpc "github.com/youtube/vitess/go/vt/proto/vtrpc"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Session objects are session cookies and are invalidated on
// use. Query results will contain updated session values.
// Their content should be opaque to the user.
type Session struct {
	InTransaction bool                    `protobuf:"varint,1,opt,name=in_transaction" json:"in_transaction,omitempty"`
	ShardSessions []*Session_ShardSession `protobuf:"bytes,2,rep,name=shard_sessions" json:"shard_sessions,omitempty"`
}

func (m *Session) Reset()                    { *m = Session{} }
func (m *Session) String() string            { return proto.CompactTextString(m) }
func (*Session) ProtoMessage()               {}
func (*Session) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Session) GetShardSessions() []*Session_ShardSession {
	if m != nil {
		return m.ShardSessions
	}
	return nil
}

type Session_ShardSession struct {
	Target        *query.Target `protobuf:"bytes,1,opt,name=target" json:"target,omitempty"`
	TransactionId int64         `protobuf:"varint,2,opt,name=transaction_id" json:"transaction_id,omitempty"`
}

func (m *Session_ShardSession) Reset()                    { *m = Session_ShardSession{} }
func (m *Session_ShardSession) String() string            { return proto.CompactTextString(m) }
func (*Session_ShardSession) ProtoMessage()               {}
func (*Session_ShardSession) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

func (m *Session_ShardSession) GetTarget() *query.Target {
	if m != nil {
		return m.Target
	}
	return nil
}

// ExecuteRequest is the payload to Execute.
type ExecuteRequest struct {
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id" json:"caller_id,omitempty"`
	// session carries the current transaction data. It is returned by Begin.
	// Do not fill it in if outside of a transaction.
	Session *Session `protobuf:"bytes,2,opt,name=session" json:"session,omitempty"`
	// query is the query and bind variables to execute.
	Query *query.BoundQuery `protobuf:"bytes,3,opt,name=query" json:"query,omitempty"`
	// tablet_type is the type of tablets that this query is targeted to.
	TabletType topodata.TabletType `protobuf:"varint,4,opt,name=tablet_type,enum=topodata.TabletType" json:"tablet_type,omitempty"`
	// not_in_transaction is deprecated and should not be used.
	NotInTransaction bool `protobuf:"varint,5,opt,name=not_in_transaction" json:"not_in_transaction,omitempty"`
}

func (m *ExecuteRequest) Reset()                    { *m = ExecuteRequest{} }
func (m *ExecuteRequest) String() string            { return proto.CompactTextString(m) }
func (*ExecuteRequest) ProtoMessage()               {}
func (*ExecuteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ExecuteRequest) GetCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.CallerId
	}
	return nil
}

func (m *ExecuteRequest) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *ExecuteRequest) GetQuery() *query.BoundQuery {
	if m != nil {
		return m.Query
	}
	return nil
}

// ExecuteResponse is the returned value from Execute.
type ExecuteResponse struct {
	// error contains an application level error if necessary. Note the
	// session may have changed, even when an error is returned (for
	// instance if a database integrity error happened).
	Error *vtrpc.RPCError `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
	// session is the updated session information (only returned inside a transaction).
	Session *Session `protobuf:"bytes,2,opt,name=session" json:"session,omitempty"`
	// result contains the query result, only set if error is unset.
	Result *query.QueryResult `protobuf:"bytes,3,opt,name=result" json:"result,omitempty"`
}

func (m *ExecuteResponse) Reset()                    { *m = ExecuteResponse{} }
func (m *ExecuteResponse) String() string            { return proto.CompactTextString(m) }
func (*ExecuteResponse) ProtoMessage()               {}
func (*ExecuteResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ExecuteResponse) GetError() *vtrpc.RPCError {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *ExecuteResponse) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *ExecuteResponse) GetResult() *query.QueryResult {
	if m != nil {
		return m.Result
	}
	return nil
}

// ExecuteShardsRequest is the payload to ExecuteShards.
type ExecuteShardsRequest struct {
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id" json:"caller_id,omitempty"`
	// session carries the current transaction data. It is returned by Begin.
	// Do not fill it in if outside of a transaction.
	Session *Session `protobuf:"bytes,2,opt,name=session" json:"session,omitempty"`
	// query is the query and bind variables to execute.
	Query *query.BoundQuery `protobuf:"bytes,3,opt,name=query" json:"query,omitempty"`
	// keyspace to target the query to.
	Keyspace string `protobuf:"bytes,4,opt,name=keyspace" json:"keyspace,omitempty"`
	// shards to target the query to. A DML can only target one shard.
	Shards []string `protobuf:"bytes,5,rep,name=shards" json:"shards,omitempty"`
	// tablet_type is the type of tablets that this query is targeted to.
	TabletType topodata.TabletType `protobuf:"varint,6,opt,name=tablet_type,enum=topodata.TabletType" json:"tablet_type,omitempty"`
	// not_in_transaction is deprecated and should not be used.
	NotInTransaction bool `protobuf:"varint,7,opt,name=not_in_transaction" json:"not_in_transaction,omitempty"`
}

func (m *ExecuteShardsRequest) Reset()                    { *m = ExecuteShardsRequest{} }
func (m *ExecuteShardsRequest) String() string            { return proto.CompactTextString(m) }
func (*ExecuteShardsRequest) ProtoMessage()               {}
func (*ExecuteShardsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *ExecuteShardsRequest) GetCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.CallerId
	}
	return nil
}

func (m *ExecuteShardsRequest) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *ExecuteShardsRequest) GetQuery() *query.BoundQuery {
	if m != nil {
		return m.Query
	}
	return nil
}

// ExecuteShardsResponse is the returned value from ExecuteShards.
type ExecuteShardsResponse struct {
	// error contains an application level error if necessary. Note the
	// session may have changed, even when an error is returned (for
	// instance if a database integrity error happened).
	Error *vtrpc.RPCError `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
	// session is the updated session information (only returned inside a transaction).
	Session *Session `protobuf:"bytes,2,opt,name=session" json:"session,omitempty"`
	// result contains the query result, only set if error is unset.
	Result *query.QueryResult `protobuf:"bytes,3,opt,name=result" json:"result,omitempty"`
}

func (m *ExecuteShardsResponse) Reset()                    { *m = ExecuteShardsResponse{} }
func (m *ExecuteShardsResponse) String() string            { return proto.CompactTextString(m) }
func (*ExecuteShardsResponse) ProtoMessage()               {}
func (*ExecuteShardsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *ExecuteShardsResponse) GetError() *vtrpc.RPCError {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *ExecuteShardsResponse) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *ExecuteShardsResponse) GetResult() *query.QueryResult {
	if m != nil {
		return m.Result
	}
	return nil
}

// ExecuteKeyspaceIdsRequest is the payload to ExecuteKeyspaceIds.
type ExecuteKeyspaceIdsRequest struct {
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id" json:"caller_id,omitempty"`
	// session carries the current transaction data. It is returned by Begin.
	// Do not fill it in if outside of a transaction.
	Session *Session `protobuf:"bytes,2,opt,name=session" json:"session,omitempty"`
	// query is the query and bind variables to execute.
	Query *query.BoundQuery `protobuf:"bytes,3,opt,name=query" json:"query,omitempty"`
	// keyspace to target the query to.
	Keyspace string `protobuf:"bytes,4,opt,name=keyspace" json:"keyspace,omitempty"`
	// keyspace_ids contains the list of keyspace_ids affected by this query.
	// Will be used to find the shards to send the query to.
	KeyspaceIds [][]byte `protobuf:"bytes,5,rep,name=keyspace_ids,proto3" json:"keyspace_ids,omitempty"`
	// tablet_type is the type of tablets that this query is targeted to.
	TabletType topodata.TabletType `protobuf:"varint,6,opt,name=tablet_type,enum=topodata.TabletType" json:"tablet_type,omitempty"`
	// not_in_transaction is deprecated and should not be used.
	NotInTransaction bool `protobuf:"varint,7,opt,name=not_in_transaction" json:"not_in_transaction,omitempty"`
}

func (m *ExecuteKeyspaceIdsRequest) Reset()                    { *m = ExecuteKeyspaceIdsRequest{} }
func (m *ExecuteKeyspaceIdsRequest) String() string            { return proto.CompactTextString(m) }
func (*ExecuteKeyspaceIdsRequest) ProtoMessage()               {}
func (*ExecuteKeyspaceIdsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *ExecuteKeyspaceIdsRequest) GetCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.CallerId
	}
	return nil
}

func (m *ExecuteKeyspaceIdsRequest) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *ExecuteKeyspaceIdsRequest) GetQuery() *query.BoundQuery {
	if m != nil {
		return m.Query
	}
	return nil
}

// ExecuteKeyspaceIdsResponse is the returned value from ExecuteKeyspaceIds.
type ExecuteKeyspaceIdsResponse struct {
	// error contains an application level error if necessary. Note the
	// session may have changed, even when an error is returned (for
	// instance if a database integrity error happened).
	Error *vtrpc.RPCError `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
	// session is the updated session information (only returned inside a transaction).
	Session *Session `protobuf:"bytes,2,opt,name=session" json:"session,omitempty"`
	// result contains the query result, only set if error is unset.
	Result *query.QueryResult `protobuf:"bytes,3,opt,name=result" json:"result,omitempty"`
}

func (m *ExecuteKeyspaceIdsResponse) Reset()                    { *m = ExecuteKeyspaceIdsResponse{} }
func (m *ExecuteKeyspaceIdsResponse) String() string            { return proto.CompactTextString(m) }
func (*ExecuteKeyspaceIdsResponse) ProtoMessage()               {}
func (*ExecuteKeyspaceIdsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *ExecuteKeyspaceIdsResponse) GetError() *vtrpc.RPCError {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *ExecuteKeyspaceIdsResponse) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *ExecuteKeyspaceIdsResponse) GetResult() *query.QueryResult {
	if m != nil {
		return m.Result
	}
	return nil
}

// ExecuteKeyRangesRequest is the payload to ExecuteKeyRanges.
type ExecuteKeyRangesRequest struct {
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id" json:"caller_id,omitempty"`
	// session carries the current transaction data. It is returned by Begin.
	// Do not fill it in if outside of a transaction.
	Session *Session `protobuf:"bytes,2,opt,name=session" json:"session,omitempty"`
	// query is the query and bind variables to execute.
	Query *query.BoundQuery `protobuf:"bytes,3,opt,name=query" json:"query,omitempty"`
	// keyspace to target the query to
	Keyspace string `protobuf:"bytes,4,opt,name=keyspace" json:"keyspace,omitempty"`
	// key_ranges contains the list of key ranges affected by this query.
	// Will be used to find the shards to send the query to.
	KeyRanges []*topodata.KeyRange `protobuf:"bytes,5,rep,name=key_ranges" json:"key_ranges,omitempty"`
	// tablet_type is the type of tablets that this query is targeted to.
	TabletType topodata.TabletType `protobuf:"varint,6,opt,name=tablet_type,enum=topodata.TabletType" json:"tablet_type,omitempty"`
	// not_in_transaction is deprecated and should not be used.
	NotInTransaction bool `protobuf:"varint,7,opt,name=not_in_transaction" json:"not_in_transaction,omitempty"`
}

func (m *ExecuteKeyRangesRequest) Reset()                    { *m = ExecuteKeyRangesRequest{} }
func (m *ExecuteKeyRangesRequest) String() string            { return proto.CompactTextString(m) }
func (*ExecuteKeyRangesRequest) ProtoMessage()               {}
func (*ExecuteKeyRangesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *ExecuteKeyRangesRequest) GetCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.CallerId
	}
	return nil
}

func (m *ExecuteKeyRangesRequest) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *ExecuteKeyRangesRequest) GetQuery() *query.BoundQuery {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *ExecuteKeyRangesRequest) GetKeyRanges() []*topodata.KeyRange {
	if m != nil {
		return m.KeyRanges
	}
	return nil
}

// ExecuteKeyRangesResponse is the returned value from ExecuteKeyRanges.
type ExecuteKeyRangesResponse struct {
	// error contains an application level error if necessary. Note the
	// session may have changed, even when an error is returned (for
	// instance if a database integrity error happened).
	Error *vtrpc.RPCError `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
	// session is the updated session information (only returned inside a transaction).
	Session *Session `protobuf:"bytes,2,opt,name=session" json:"session,omitempty"`
	// result contains the query result, only set if error is unset.
	Result *query.QueryResult `protobuf:"bytes,3,opt,name=result" json:"result,omitempty"`
}

func (m *ExecuteKeyRangesResponse) Reset()                    { *m = ExecuteKeyRangesResponse{} }
func (m *ExecuteKeyRangesResponse) String() string            { return proto.CompactTextString(m) }
func (*ExecuteKeyRangesResponse) ProtoMessage()               {}
func (*ExecuteKeyRangesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *ExecuteKeyRangesResponse) GetError() *vtrpc.RPCError {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *ExecuteKeyRangesResponse) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *ExecuteKeyRangesResponse) GetResult() *query.QueryResult {
	if m != nil {
		return m.Result
	}
	return nil
}

// ExecuteEntityIdsRequest is the payload to ExecuteEntityIds.
type ExecuteEntityIdsRequest struct {
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id" json:"caller_id,omitempty"`
	// session carries the current transaction data. It is returned by Begin.
	// Do not fill it in if outside of a transaction.
	Session *Session `protobuf:"bytes,2,opt,name=session" json:"session,omitempty"`
	// query is the query and bind variables to execute.
	Query *query.BoundQuery `protobuf:"bytes,3,opt,name=query" json:"query,omitempty"`
	// keyspace to target the query to.
	Keyspace string `protobuf:"bytes,4,opt,name=keyspace" json:"keyspace,omitempty"`
	// entity_column_name is the column name to use.
	EntityColumnName string `protobuf:"bytes,5,opt,name=entity_column_name" json:"entity_column_name,omitempty"`
	// entity_keyspace_ids are pairs of entity_column_name values
	// associated with its corresponding keyspace_id.
	EntityKeyspaceIds []*ExecuteEntityIdsRequest_EntityId `protobuf:"bytes,6,rep,name=entity_keyspace_ids" json:"entity_keyspace_ids,omitempty"`
	// tablet_type is the type of tablets that this query is targeted to.
	TabletType topodata.TabletType `protobuf:"varint,7,opt,name=tablet_type,enum=topodata.TabletType" json:"tablet_type,omitempty"`
	// not_in_transaction is deprecated and should not be used.
	NotInTransaction bool `protobuf:"varint,8,opt,name=not_in_transaction" json:"not_in_transaction,omitempty"`
}

func (m *ExecuteEntityIdsRequest) Reset()                    { *m = ExecuteEntityIdsRequest{} }
func (m *ExecuteEntityIdsRequest) String() string            { return proto.CompactTextString(m) }
func (*ExecuteEntityIdsRequest) ProtoMessage()               {}
func (*ExecuteEntityIdsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *ExecuteEntityIdsRequest) GetCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.CallerId
	}
	return nil
}

func (m *ExecuteEntityIdsRequest) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *ExecuteEntityIdsRequest) GetQuery() *query.BoundQuery {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *ExecuteEntityIdsRequest) GetEntityKeyspaceIds() []*ExecuteEntityIdsRequest_EntityId {
	if m != nil {
		return m.EntityKeyspaceIds
	}
	return nil
}

type ExecuteEntityIdsRequest_EntityId struct {
	// xid_type is the type of the entity's value. Can be NULL.
	XidType query.Type `protobuf:"varint,1,opt,name=xid_type,enum=query.Type" json:"xid_type,omitempty"`
	// xid_value is the value for the entity. Not set if xid_type is NULL.
	XidValue []byte `protobuf:"bytes,2,opt,name=xid_value,proto3" json:"xid_value,omitempty"`
	// keyspace_id is the associated keyspace_id for the entity.
	KeyspaceId []byte `protobuf:"bytes,3,opt,name=keyspace_id,proto3" json:"keyspace_id,omitempty"`
}

func (m *ExecuteEntityIdsRequest_EntityId) Reset()         { *m = ExecuteEntityIdsRequest_EntityId{} }
func (m *ExecuteEntityIdsRequest_EntityId) String() string { return proto.CompactTextString(m) }
func (*ExecuteEntityIdsRequest_EntityId) ProtoMessage()    {}
func (*ExecuteEntityIdsRequest_EntityId) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{9, 0}
}

// ExecuteEntityIdsResponse is the returned value from ExecuteEntityIds.
type ExecuteEntityIdsResponse struct {
	// error contains an application level error if necessary. Note the
	// session may have changed, even when an error is returned (for
	// instance if a database integrity error happened).
	Error *vtrpc.RPCError `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
	// session is the updated session information (only returned inside a transaction).
	Session *Session `protobuf:"bytes,2,opt,name=session" json:"session,omitempty"`
	// result contains the query result, only set if error is unset.
	Result *query.QueryResult `protobuf:"bytes,3,opt,name=result" json:"result,omitempty"`
}

func (m *ExecuteEntityIdsResponse) Reset()                    { *m = ExecuteEntityIdsResponse{} }
func (m *ExecuteEntityIdsResponse) String() string            { return proto.CompactTextString(m) }
func (*ExecuteEntityIdsResponse) ProtoMessage()               {}
func (*ExecuteEntityIdsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *ExecuteEntityIdsResponse) GetError() *vtrpc.RPCError {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *ExecuteEntityIdsResponse) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *ExecuteEntityIdsResponse) GetResult() *query.QueryResult {
	if m != nil {
		return m.Result
	}
	return nil
}

// BoundShardQuery represents a single query request for the
// specified list of shards. This is used in a list for
// ExecuteBatchShardsRequest.
type BoundShardQuery struct {
	// query is the query and bind variables to execute.
	Query *query.BoundQuery `protobuf:"bytes,1,opt,name=query" json:"query,omitempty"`
	// keyspace to target the query to.
	Keyspace string `protobuf:"bytes,2,opt,name=keyspace" json:"keyspace,omitempty"`
	// shards to target the query to. A DML can only target one shard.
	Shards []string `protobuf:"bytes,3,rep,name=shards" json:"shards,omitempty"`
}

func (m *BoundShardQuery) Reset()                    { *m = BoundShardQuery{} }
func (m *BoundShardQuery) String() string            { return proto.CompactTextString(m) }
func (*BoundShardQuery) ProtoMessage()               {}
func (*BoundShardQuery) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *BoundShardQuery) GetQuery() *query.BoundQuery {
	if m != nil {
		return m.Query
	}
	return nil
}

// ExecuteBatchShardsRequest is the payload to ExecuteBatchShards
type ExecuteBatchShardsRequest struct {
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id" json:"caller_id,omitempty"`
	// session carries the current transaction data. It is returned by Begin.
	// Do not fill it in if outside of a transaction.
	Session *Session `protobuf:"bytes,2,opt,name=session" json:"session,omitempty"`
	// queries carries all the queries to execute.
	Queries []*BoundShardQuery `protobuf:"bytes,3,rep,name=queries" json:"queries,omitempty"`
	// tablet_type is the type of tablets that this query is targeted to.
	TabletType topodata.TabletType `protobuf:"varint,4,opt,name=tablet_type,enum=topodata.TabletType" json:"tablet_type,omitempty"`
	// as_transaction will execute the queries in this batch in a single transaction per shard, created for this purpose.
	// (this can be seen as adding a 'begin' before and 'commit' after the queries).
	// Only makes sense if tablet_type is master. If set, the Session is ignored.
	AsTransaction bool `protobuf:"varint,5,opt,name=as_transaction" json:"as_transaction,omitempty"`
}

func (m *ExecuteBatchShardsRequest) Reset()                    { *m = ExecuteBatchShardsRequest{} }
func (m *ExecuteBatchShardsRequest) String() string            { return proto.CompactTextString(m) }
func (*ExecuteBatchShardsRequest) ProtoMessage()               {}
func (*ExecuteBatchShardsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *ExecuteBatchShardsRequest) GetCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.CallerId
	}
	return nil
}

func (m *ExecuteBatchShardsRequest) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *ExecuteBatchShardsRequest) GetQueries() []*BoundShardQuery {
	if m != nil {
		return m.Queries
	}
	return nil
}

// ExecuteBatchShardsResponse is the returned value from ExecuteBatchShards.
type ExecuteBatchShardsResponse struct {
	// error contains an application level error if necessary. Note the
	// session may have changed, even when an error is returned (for
	// instance if a database integrity error happened).
	Error *vtrpc.RPCError `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
	// session is the updated session information (only returned inside a transaction).
	Session *Session `protobuf:"bytes,2,opt,name=session" json:"session,omitempty"`
	// result contains the query result, only set if error is unset.
	Results []*query.QueryResult `protobuf:"bytes,3,rep,name=results" json:"results,omitempty"`
}

func (m *ExecuteBatchShardsResponse) Reset()                    { *m = ExecuteBatchShardsResponse{} }
func (m *ExecuteBatchShardsResponse) String() string            { return proto.CompactTextString(m) }
func (*ExecuteBatchShardsResponse) ProtoMessage()               {}
func (*ExecuteBatchShardsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *ExecuteBatchShardsResponse) GetError() *vtrpc.RPCError {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *ExecuteBatchShardsResponse) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *ExecuteBatchShardsResponse) GetResults() []*query.QueryResult {
	if m != nil {
		return m.Results
	}
	return nil
}

// BoundKeyspaceIdQuery represents a single query request for the
// specified list of keyspace ids. This is used in a list for
// ExecuteBatchKeyspaceIdsRequest.
type BoundKeyspaceIdQuery struct {
	// query is the query and bind variables to execute.
	Query *query.BoundQuery `protobuf:"bytes,1,opt,name=query" json:"query,omitempty"`
	// keyspace to target the query to.
	Keyspace string `protobuf:"bytes,2,opt,name=keyspace" json:"keyspace,omitempty"`
	// keyspace_ids contains the list of keyspace_ids affected by this query.
	// Will be used to find the shards to send the query to.
	KeyspaceIds [][]byte `protobuf:"bytes,3,rep,name=keyspace_ids,proto3" json:"keyspace_ids,omitempty"`
}

func (m *BoundKeyspaceIdQuery) Reset()                    { *m = BoundKeyspaceIdQuery{} }
func (m *BoundKeyspaceIdQuery) String() string            { return proto.CompactTextString(m) }
func (*BoundKeyspaceIdQuery) ProtoMessage()               {}
func (*BoundKeyspaceIdQuery) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *BoundKeyspaceIdQuery) GetQuery() *query.BoundQuery {
	if m != nil {
		return m.Query
	}
	return nil
}

// ExecuteBatchKeyspaceIdsRequest is the payload to ExecuteBatchKeyspaceId.
type ExecuteBatchKeyspaceIdsRequest struct {
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id" json:"caller_id,omitempty"`
	// session carries the current transaction data. It is returned by Begin.
	// Do not fill it in if outside of a transaction.
	Session *Session                `protobuf:"bytes,2,opt,name=session" json:"session,omitempty"`
	Queries []*BoundKeyspaceIdQuery `protobuf:"bytes,3,rep,name=queries" json:"queries,omitempty"`
	// tablet_type is the type of tablets that this query is targeted to.
	TabletType topodata.TabletType `protobuf:"varint,4,opt,name=tablet_type,enum=topodata.TabletType" json:"tablet_type,omitempty"`
	// as_transaction will execute the queries in this batch in a single transaction per shard, created for this purpose.
	// (this can be seen as adding a 'begin' before and 'commit' after the queries).
	// Only makes sense if tablet_type is master. If set, the Session is ignored.
	AsTransaction bool `protobuf:"varint,5,opt,name=as_transaction" json:"as_transaction,omitempty"`
}

func (m *ExecuteBatchKeyspaceIdsRequest) Reset()                    { *m = ExecuteBatchKeyspaceIdsRequest{} }
func (m *ExecuteBatchKeyspaceIdsRequest) String() string            { return proto.CompactTextString(m) }
func (*ExecuteBatchKeyspaceIdsRequest) ProtoMessage()               {}
func (*ExecuteBatchKeyspaceIdsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *ExecuteBatchKeyspaceIdsRequest) GetCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.CallerId
	}
	return nil
}

func (m *ExecuteBatchKeyspaceIdsRequest) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *ExecuteBatchKeyspaceIdsRequest) GetQueries() []*BoundKeyspaceIdQuery {
	if m != nil {
		return m.Queries
	}
	return nil
}

// ExecuteBatchKeyspaceIdsResponse is the returned value from ExecuteBatchKeyspaceId.
type ExecuteBatchKeyspaceIdsResponse struct {
	// error contains an application level error if necessary. Note the
	// session may have changed, even when an error is returned (for
	// instance if a database integrity error happened).
	Error *vtrpc.RPCError `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
	// session is the updated session information (only returned inside a transaction).
	Session *Session `protobuf:"bytes,2,opt,name=session" json:"session,omitempty"`
	// result contains the query result, only set if error is unset.
	Results []*query.QueryResult `protobuf:"bytes,3,rep,name=results" json:"results,omitempty"`
}

func (m *ExecuteBatchKeyspaceIdsResponse) Reset()         { *m = ExecuteBatchKeyspaceIdsResponse{} }
func (m *ExecuteBatchKeyspaceIdsResponse) String() string { return proto.CompactTextString(m) }
func (*ExecuteBatchKeyspaceIdsResponse) ProtoMessage()    {}
func (*ExecuteBatchKeyspaceIdsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{16}
}

func (m *ExecuteBatchKeyspaceIdsResponse) GetError() *vtrpc.RPCError {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *ExecuteBatchKeyspaceIdsResponse) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *ExecuteBatchKeyspaceIdsResponse) GetResults() []*query.QueryResult {
	if m != nil {
		return m.Results
	}
	return nil
}

// StreamExecuteRequest is the payload to StreamExecute.
type StreamExecuteRequest struct {
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id" json:"caller_id,omitempty"`
	// query is the query and bind variables to execute.
	Query *query.BoundQuery `protobuf:"bytes,2,opt,name=query" json:"query,omitempty"`
	// tablet_type is the type of tablets that this query is targeted to.
	TabletType topodata.TabletType `protobuf:"varint,3,opt,name=tablet_type,enum=topodata.TabletType" json:"tablet_type,omitempty"`
}

func (m *StreamExecuteRequest) Reset()                    { *m = StreamExecuteRequest{} }
func (m *StreamExecuteRequest) String() string            { return proto.CompactTextString(m) }
func (*StreamExecuteRequest) ProtoMessage()               {}
func (*StreamExecuteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *StreamExecuteRequest) GetCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.CallerId
	}
	return nil
}

func (m *StreamExecuteRequest) GetQuery() *query.BoundQuery {
	if m != nil {
		return m.Query
	}
	return nil
}

// StreamExecuteResponse is the returned value from StreamExecute.
type StreamExecuteResponse struct {
	// result contains the result data.
	// The first value contains only Fields information.
	// The next values contain the actual rows, a few values per result.
	Result *query.QueryResult `protobuf:"bytes,1,opt,name=result" json:"result,omitempty"`
}

func (m *StreamExecuteResponse) Reset()                    { *m = StreamExecuteResponse{} }
func (m *StreamExecuteResponse) String() string            { return proto.CompactTextString(m) }
func (*StreamExecuteResponse) ProtoMessage()               {}
func (*StreamExecuteResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *StreamExecuteResponse) GetResult() *query.QueryResult {
	if m != nil {
		return m.Result
	}
	return nil
}

// StreamExecuteShardsRequest is the payload to StreamExecuteShards.
type StreamExecuteShardsRequest struct {
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id" json:"caller_id,omitempty"`
	// query is the query and bind variables to execute.
	Query *query.BoundQuery `protobuf:"bytes,2,opt,name=query" json:"query,omitempty"`
	// keyspace to target the query to.
	Keyspace string `protobuf:"bytes,3,opt,name=keyspace" json:"keyspace,omitempty"`
	// shards to target the query to.
	Shards []string `protobuf:"bytes,4,rep,name=shards" json:"shards,omitempty"`
	// tablet_type is the type of tablets that this query is targeted to.
	TabletType topodata.TabletType `protobuf:"varint,5,opt,name=tablet_type,enum=topodata.TabletType" json:"tablet_type,omitempty"`
}

func (m *StreamExecuteShardsRequest) Reset()                    { *m = StreamExecuteShardsRequest{} }
func (m *StreamExecuteShardsRequest) String() string            { return proto.CompactTextString(m) }
func (*StreamExecuteShardsRequest) ProtoMessage()               {}
func (*StreamExecuteShardsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *StreamExecuteShardsRequest) GetCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.CallerId
	}
	return nil
}

func (m *StreamExecuteShardsRequest) GetQuery() *query.BoundQuery {
	if m != nil {
		return m.Query
	}
	return nil
}

// StreamExecuteShardsResponse is the returned value from StreamExecuteShards.
type StreamExecuteShardsResponse struct {
	// result contains the result data.
	// The first value contains only Fields information.
	// The next values contain the actual rows, a few values per result.
	Result *query.QueryResult `protobuf:"bytes,1,opt,name=result" json:"result,omitempty"`
}

func (m *StreamExecuteShardsResponse) Reset()                    { *m = StreamExecuteShardsResponse{} }
func (m *StreamExecuteShardsResponse) String() string            { return proto.CompactTextString(m) }
func (*StreamExecuteShardsResponse) ProtoMessage()               {}
func (*StreamExecuteShardsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *StreamExecuteShardsResponse) GetResult() *query.QueryResult {
	if m != nil {
		return m.Result
	}
	return nil
}

// StreamExecuteKeyspaceIdsRequest is the payload to StreamExecuteKeyspaceIds.
type StreamExecuteKeyspaceIdsRequest struct {
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id" json:"caller_id,omitempty"`
	// query is the query and bind variables to execute.
	Query *query.BoundQuery `protobuf:"bytes,2,opt,name=query" json:"query,omitempty"`
	// keyspace to target the query to.
	Keyspace string `protobuf:"bytes,3,opt,name=keyspace" json:"keyspace,omitempty"`
	// keyspace_ids contains the list of keyspace_ids affected by this query.
	// Will be used to find the shards to send the query to.
	KeyspaceIds [][]byte `protobuf:"bytes,4,rep,name=keyspace_ids,proto3" json:"keyspace_ids,omitempty"`
	// tablet_type is the type of tablets that this query is targeted to.
	TabletType topodata.TabletType `protobuf:"varint,5,opt,name=tablet_type,enum=topodata.TabletType" json:"tablet_type,omitempty"`
}

func (m *StreamExecuteKeyspaceIdsRequest) Reset()         { *m = StreamExecuteKeyspaceIdsRequest{} }
func (m *StreamExecuteKeyspaceIdsRequest) String() string { return proto.CompactTextString(m) }
func (*StreamExecuteKeyspaceIdsRequest) ProtoMessage()    {}
func (*StreamExecuteKeyspaceIdsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{21}
}

func (m *StreamExecuteKeyspaceIdsRequest) GetCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.CallerId
	}
	return nil
}

func (m *StreamExecuteKeyspaceIdsRequest) GetQuery() *query.BoundQuery {
	if m != nil {
		return m.Query
	}
	return nil
}

// StreamExecuteKeyspaceIdsResponse is the returned value from StreamExecuteKeyspaceIds.
type StreamExecuteKeyspaceIdsResponse struct {
	// result contains the result data.
	// The first value contains only Fields information.
	// The next values contain the actual rows, a few values per result.
	Result *query.QueryResult `protobuf:"bytes,1,opt,name=result" json:"result,omitempty"`
}

func (m *StreamExecuteKeyspaceIdsResponse) Reset()         { *m = StreamExecuteKeyspaceIdsResponse{} }
func (m *StreamExecuteKeyspaceIdsResponse) String() string { return proto.CompactTextString(m) }
func (*StreamExecuteKeyspaceIdsResponse) ProtoMessage()    {}
func (*StreamExecuteKeyspaceIdsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{22}
}

func (m *StreamExecuteKeyspaceIdsResponse) GetResult() *query.QueryResult {
	if m != nil {
		return m.Result
	}
	return nil
}

// StreamExecuteKeyRangesRequest is the payload to StreamExecuteKeyRanges.
type StreamExecuteKeyRangesRequest struct {
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id" json:"caller_id,omitempty"`
	// query is the query and bind variables to execute.
	Query *query.BoundQuery `protobuf:"bytes,2,opt,name=query" json:"query,omitempty"`
	// keyspace to target the query to.
	Keyspace string `protobuf:"bytes,3,opt,name=keyspace" json:"keyspace,omitempty"`
	// key_ranges contains the list of key ranges affected by this query.
	// Will be used to find the shards to send the query to.
	KeyRanges []*topodata.KeyRange `protobuf:"bytes,4,rep,name=key_ranges" json:"key_ranges,omitempty"`
	// tablet_type is the type of tablets that this query is targeted to.
	TabletType topodata.TabletType `protobuf:"varint,5,opt,name=tablet_type,enum=topodata.TabletType" json:"tablet_type,omitempty"`
}

func (m *StreamExecuteKeyRangesRequest) Reset()                    { *m = StreamExecuteKeyRangesRequest{} }
func (m *StreamExecuteKeyRangesRequest) String() string            { return proto.CompactTextString(m) }
func (*StreamExecuteKeyRangesRequest) ProtoMessage()               {}
func (*StreamExecuteKeyRangesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *StreamExecuteKeyRangesRequest) GetCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.CallerId
	}
	return nil
}

func (m *StreamExecuteKeyRangesRequest) GetQuery() *query.BoundQuery {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *StreamExecuteKeyRangesRequest) GetKeyRanges() []*topodata.KeyRange {
	if m != nil {
		return m.KeyRanges
	}
	return nil
}

// StreamExecuteKeyRangesResponse is the returned value from StreamExecuteKeyRanges.
type StreamExecuteKeyRangesResponse struct {
	// result contains the result data.
	// The first value contains only Fields information.
	// The next values contain the actual rows, a few values per result.
	Result *query.QueryResult `protobuf:"bytes,1,opt,name=result" json:"result,omitempty"`
}

func (m *StreamExecuteKeyRangesResponse) Reset()                    { *m = StreamExecuteKeyRangesResponse{} }
func (m *StreamExecuteKeyRangesResponse) String() string            { return proto.CompactTextString(m) }
func (*StreamExecuteKeyRangesResponse) ProtoMessage()               {}
func (*StreamExecuteKeyRangesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *StreamExecuteKeyRangesResponse) GetResult() *query.QueryResult {
	if m != nil {
		return m.Result
	}
	return nil
}

// BeginRequest is the payload to Begin.
type BeginRequest struct {
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id" json:"caller_id,omitempty"`
}

func (m *BeginRequest) Reset()                    { *m = BeginRequest{} }
func (m *BeginRequest) String() string            { return proto.CompactTextString(m) }
func (*BeginRequest) ProtoMessage()               {}
func (*BeginRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *BeginRequest) GetCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.CallerId
	}
	return nil
}

// BeginResponse is the returned value from Begin.
type BeginResponse struct {
	// session is the initial session information to use for subsequent queries.
	Session *Session `protobuf:"bytes,1,opt,name=session" json:"session,omitempty"`
}

func (m *BeginResponse) Reset()                    { *m = BeginResponse{} }
func (m *BeginResponse) String() string            { return proto.CompactTextString(m) }
func (*BeginResponse) ProtoMessage()               {}
func (*BeginResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *BeginResponse) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

// CommitRequest is the payload to Commit.
type CommitRequest struct {
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id" json:"caller_id,omitempty"`
	// session carries the current transaction data to commit.
	Session *Session `protobuf:"bytes,2,opt,name=session" json:"session,omitempty"`
}

func (m *CommitRequest) Reset()                    { *m = CommitRequest{} }
func (m *CommitRequest) String() string            { return proto.CompactTextString(m) }
func (*CommitRequest) ProtoMessage()               {}
func (*CommitRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

func (m *CommitRequest) GetCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.CallerId
	}
	return nil
}

func (m *CommitRequest) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

// CommitResponse is the returned value from Commit.
type CommitResponse struct {
}

func (m *CommitResponse) Reset()                    { *m = CommitResponse{} }
func (m *CommitResponse) String() string            { return proto.CompactTextString(m) }
func (*CommitResponse) ProtoMessage()               {}
func (*CommitResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

// RollbackRequest is the payload to Rollback.
type RollbackRequest struct {
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id" json:"caller_id,omitempty"`
	// session carries the current transaction data to rollback.
	Session *Session `protobuf:"bytes,2,opt,name=session" json:"session,omitempty"`
}

func (m *RollbackRequest) Reset()                    { *m = RollbackRequest{} }
func (m *RollbackRequest) String() string            { return proto.CompactTextString(m) }
func (*RollbackRequest) ProtoMessage()               {}
func (*RollbackRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func (m *RollbackRequest) GetCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.CallerId
	}
	return nil
}

func (m *RollbackRequest) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

// RollbackResponse is the returned value from Rollback.
type RollbackResponse struct {
}

func (m *RollbackResponse) Reset()                    { *m = RollbackResponse{} }
func (m *RollbackResponse) String() string            { return proto.CompactTextString(m) }
func (*RollbackResponse) ProtoMessage()               {}
func (*RollbackResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

// SplitQueryRequest is the payload to SplitQuery.
type SplitQueryRequest struct {
	// caller_id identifies the caller. This is the effective caller ID,
	// set by the application to further identify the caller.
	CallerId *vtrpc.CallerID `protobuf:"bytes,1,opt,name=caller_id" json:"caller_id,omitempty"`
	// keyspace to target the query to.
	Keyspace string `protobuf:"bytes,2,opt,name=keyspace" json:"keyspace,omitempty"`
	// query is the query and bind variables to produce splits for.
	Query *query.BoundQuery `protobuf:"bytes,3,opt,name=query" json:"query,omitempty"`
	// split_column is an optional hint on the column to use to split the query.
	SplitColumn string `protobuf:"bytes,4,opt,name=split_column" json:"split_column,omitempty"`
	// split_count describes how many splits we want for this query.
	SplitCount int64 `protobuf:"varint,5,opt,name=split_count" json:"split_count,omitempty"`
}

func (m *SplitQueryRequest) Reset()                    { *m = SplitQueryRequest{} }
func (m *SplitQueryRequest) String() string            { return proto.CompactTextString(m) }
func (*SplitQueryRequest) ProtoMessage()               {}
func (*SplitQueryRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{31} }

func (m *SplitQueryRequest) GetCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.CallerId
	}
	return nil
}

func (m *SplitQueryRequest) GetQuery() *query.BoundQuery {
	if m != nil {
		return m.Query
	}
	return nil
}

// SplitQueryResponse is the returned value from SplitQuery.
type SplitQueryResponse struct {
	// splits contains the queries to run to fetch the entire data set.
	Splits []*SplitQueryResponse_Part `protobuf:"bytes,1,rep,name=splits" json:"splits,omitempty"`
}

func (m *SplitQueryResponse) Reset()                    { *m = SplitQueryResponse{} }
func (m *SplitQueryResponse) String() string            { return proto.CompactTextString(m) }
func (*SplitQueryResponse) ProtoMessage()               {}
func (*SplitQueryResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32} }

func (m *SplitQueryResponse) GetSplits() []*SplitQueryResponse_Part {
	if m != nil {
		return m.Splits
	}
	return nil
}

type SplitQueryResponse_KeyRangePart struct {
	// keyspace to target the query to.
	Keyspace string `protobuf:"bytes,1,opt,name=keyspace" json:"keyspace,omitempty"`
	// key ranges to target the query to.
	KeyRanges []*topodata.KeyRange `protobuf:"bytes,2,rep,name=key_ranges" json:"key_ranges,omitempty"`
}

func (m *SplitQueryResponse_KeyRangePart) Reset()         { *m = SplitQueryResponse_KeyRangePart{} }
func (m *SplitQueryResponse_KeyRangePart) String() string { return proto.CompactTextString(m) }
func (*SplitQueryResponse_KeyRangePart) ProtoMessage()    {}
func (*SplitQueryResponse_KeyRangePart) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{32, 0}
}

func (m *SplitQueryResponse_KeyRangePart) GetKeyRanges() []*topodata.KeyRange {
	if m != nil {
		return m.KeyRanges
	}
	return nil
}

type SplitQueryResponse_ShardPart struct {
	// keyspace to target the query to.
	Keyspace string `protobuf:"bytes,1,opt,name=keyspace" json:"keyspace,omitempty"`
	// shards to target the query to.
	Shards []string `protobuf:"bytes,2,rep,name=shards" json:"shards,omitempty"`
}

func (m *SplitQueryResponse_ShardPart) Reset()         { *m = SplitQueryResponse_ShardPart{} }
func (m *SplitQueryResponse_ShardPart) String() string { return proto.CompactTextString(m) }
func (*SplitQueryResponse_ShardPart) ProtoMessage()    {}
func (*SplitQueryResponse_ShardPart) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{32, 1}
}

type SplitQueryResponse_Part struct {
	// query is the query and bind variables to execute.
	Query *query.BoundQuery `protobuf:"bytes,1,opt,name=query" json:"query,omitempty"`
	// key_range_part is set if the query should be executed by ExecuteKeyRanges.
	KeyRangePart *SplitQueryResponse_KeyRangePart `protobuf:"bytes,2,opt,name=key_range_part" json:"key_range_part,omitempty"`
	// shard_part is set if the query should be executed by ExecuteShards.
	ShardPart *SplitQueryResponse_ShardPart `protobuf:"bytes,3,opt,name=shard_part" json:"shard_part,omitempty"`
	// size is the approximate number of rows this query will return.
	Size int64 `protobuf:"varint,4,opt,name=size" json:"size,omitempty"`
}

func (m *SplitQueryResponse_Part) Reset()                    { *m = SplitQueryResponse_Part{} }
func (m *SplitQueryResponse_Part) String() string            { return proto.CompactTextString(m) }
func (*SplitQueryResponse_Part) ProtoMessage()               {}
func (*SplitQueryResponse_Part) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32, 2} }

func (m *SplitQueryResponse_Part) GetQuery() *query.BoundQuery {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *SplitQueryResponse_Part) GetKeyRangePart() *SplitQueryResponse_KeyRangePart {
	if m != nil {
		return m.KeyRangePart
	}
	return nil
}

func (m *SplitQueryResponse_Part) GetShardPart() *SplitQueryResponse_ShardPart {
	if m != nil {
		return m.ShardPart
	}
	return nil
}

// GetSrvKeyspaceRequest is the payload to GetSrvKeyspace.
type GetSrvKeyspaceRequest struct {
	// keyspace name to fetch.
	Keyspace string `protobuf:"bytes,1,opt,name=keyspace" json:"keyspace,omitempty"`
}

func (m *GetSrvKeyspaceRequest) Reset()                    { *m = GetSrvKeyspaceRequest{} }
func (m *GetSrvKeyspaceRequest) String() string            { return proto.CompactTextString(m) }
func (*GetSrvKeyspaceRequest) ProtoMessage()               {}
func (*GetSrvKeyspaceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33} }

// GetSrvKeyspaceResponse is the returned value from GetSrvKeyspace.
type GetSrvKeyspaceResponse struct {
	// srv_keyspace is the topology object for the SrvKeyspace.
	SrvKeyspace *topodata.SrvKeyspace `protobuf:"bytes,1,opt,name=srv_keyspace" json:"srv_keyspace,omitempty"`
}

func (m *GetSrvKeyspaceResponse) Reset()                    { *m = GetSrvKeyspaceResponse{} }
func (m *GetSrvKeyspaceResponse) String() string            { return proto.CompactTextString(m) }
func (*GetSrvKeyspaceResponse) ProtoMessage()               {}
func (*GetSrvKeyspaceResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{34} }

func (m *GetSrvKeyspaceResponse) GetSrvKeyspace() *topodata.SrvKeyspace {
	if m != nil {
		return m.SrvKeyspace
	}
	return nil
}

func init() {
	proto.RegisterType((*Session)(nil), "vtgate.Session")
	proto.RegisterType((*Session_ShardSession)(nil), "vtgate.Session.ShardSession")
	proto.RegisterType((*ExecuteRequest)(nil), "vtgate.ExecuteRequest")
	proto.RegisterType((*ExecuteResponse)(nil), "vtgate.ExecuteResponse")
	proto.RegisterType((*ExecuteShardsRequest)(nil), "vtgate.ExecuteShardsRequest")
	proto.RegisterType((*ExecuteShardsResponse)(nil), "vtgate.ExecuteShardsResponse")
	proto.RegisterType((*ExecuteKeyspaceIdsRequest)(nil), "vtgate.ExecuteKeyspaceIdsRequest")
	proto.RegisterType((*ExecuteKeyspaceIdsResponse)(nil), "vtgate.ExecuteKeyspaceIdsResponse")
	proto.RegisterType((*ExecuteKeyRangesRequest)(nil), "vtgate.ExecuteKeyRangesRequest")
	proto.RegisterType((*ExecuteKeyRangesResponse)(nil), "vtgate.ExecuteKeyRangesResponse")
	proto.RegisterType((*ExecuteEntityIdsRequest)(nil), "vtgate.ExecuteEntityIdsRequest")
	proto.RegisterType((*ExecuteEntityIdsRequest_EntityId)(nil), "vtgate.ExecuteEntityIdsRequest.EntityId")
	proto.RegisterType((*ExecuteEntityIdsResponse)(nil), "vtgate.ExecuteEntityIdsResponse")
	proto.RegisterType((*BoundShardQuery)(nil), "vtgate.BoundShardQuery")
	proto.RegisterType((*ExecuteBatchShardsRequest)(nil), "vtgate.ExecuteBatchShardsRequest")
	proto.RegisterType((*ExecuteBatchShardsResponse)(nil), "vtgate.ExecuteBatchShardsResponse")
	proto.RegisterType((*BoundKeyspaceIdQuery)(nil), "vtgate.BoundKeyspaceIdQuery")
	proto.RegisterType((*ExecuteBatchKeyspaceIdsRequest)(nil), "vtgate.ExecuteBatchKeyspaceIdsRequest")
	proto.RegisterType((*ExecuteBatchKeyspaceIdsResponse)(nil), "vtgate.ExecuteBatchKeyspaceIdsResponse")
	proto.RegisterType((*StreamExecuteRequest)(nil), "vtgate.StreamExecuteRequest")
	proto.RegisterType((*StreamExecuteResponse)(nil), "vtgate.StreamExecuteResponse")
	proto.RegisterType((*StreamExecuteShardsRequest)(nil), "vtgate.StreamExecuteShardsRequest")
	proto.RegisterType((*StreamExecuteShardsResponse)(nil), "vtgate.StreamExecuteShardsResponse")
	proto.RegisterType((*StreamExecuteKeyspaceIdsRequest)(nil), "vtgate.StreamExecuteKeyspaceIdsRequest")
	proto.RegisterType((*StreamExecuteKeyspaceIdsResponse)(nil), "vtgate.StreamExecuteKeyspaceIdsResponse")
	proto.RegisterType((*StreamExecuteKeyRangesRequest)(nil), "vtgate.StreamExecuteKeyRangesRequest")
	proto.RegisterType((*StreamExecuteKeyRangesResponse)(nil), "vtgate.StreamExecuteKeyRangesResponse")
	proto.RegisterType((*BeginRequest)(nil), "vtgate.BeginRequest")
	proto.RegisterType((*BeginResponse)(nil), "vtgate.BeginResponse")
	proto.RegisterType((*CommitRequest)(nil), "vtgate.CommitRequest")
	proto.RegisterType((*CommitResponse)(nil), "vtgate.CommitResponse")
	proto.RegisterType((*RollbackRequest)(nil), "vtgate.RollbackRequest")
	proto.RegisterType((*RollbackResponse)(nil), "vtgate.RollbackResponse")
	proto.RegisterType((*SplitQueryRequest)(nil), "vtgate.SplitQueryRequest")
	proto.RegisterType((*SplitQueryResponse)(nil), "vtgate.SplitQueryResponse")
	proto.RegisterType((*SplitQueryResponse_KeyRangePart)(nil), "vtgate.SplitQueryResponse.KeyRangePart")
	proto.RegisterType((*SplitQueryResponse_ShardPart)(nil), "vtgate.SplitQueryResponse.ShardPart")
	proto.RegisterType((*SplitQueryResponse_Part)(nil), "vtgate.SplitQueryResponse.Part")
	proto.RegisterType((*GetSrvKeyspaceRequest)(nil), "vtgate.GetSrvKeyspaceRequest")
	proto.RegisterType((*GetSrvKeyspaceResponse)(nil), "vtgate.GetSrvKeyspaceResponse")
}

var fileDescriptor0 = []byte{
	// 1088 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xcc, 0x58, 0x4f, 0x6f, 0xe3, 0x44,
	0x14, 0xd7, 0xc4, 0x69, 0xd2, 0xbc, 0xb8, 0x69, 0xeb, 0x6d, 0x77, 0x83, 0xd9, 0x76, 0x2b, 0x83,
	0x20, 0x2b, 0xb4, 0x46, 0x04, 0x0e, 0x48, 0x1c, 0x10, 0xed, 0x06, 0x58, 0x71, 0xd9, 0x4d, 0x8a,
	0x38, 0x9a, 0x69, 0x32, 0xea, 0x5a, 0x9b, 0xd8, 0xc1, 0x9e, 0x84, 0x0d, 0x12, 0x12, 0x5a, 0x0e,
	0x70, 0xe4, 0xc4, 0x91, 0xaf, 0x80, 0xb8, 0x72, 0xe1, 0xce, 0x81, 0x33, 0xdf, 0x80, 0xfb, 0x7e,
	0x02, 0xe6, 0x9f, 0xe3, 0x3f, 0x4d, 0xd2, 0x38, 0xca, 0x46, 0x3d, 0xb5, 0x1e, 0xcf, 0xbc, 0xf7,
	0xfb, 0xf3, 0xfc, 0xe6, 0x29, 0xa0, 0x8f, 0xe9, 0x25, 0xa6, 0xc4, 0x1e, 0x06, 0x3e, 0xf5, 0x8d,
	0x92, 0x7c, 0x32, 0xab, 0xdf, 0x8c, 0x48, 0x30, 0x91, 0x8b, 0x66, 0x8d, 0xfa, 0x43, 0xbf, 0x87,
	0x29, 0x56, 0xcf, 0xd5, 0x31, 0x0d, 0x86, 0x5d, 0xf9, 0x60, 0xfd, 0x86, 0xa0, 0xdc, 0x21, 0x61,
	0xe8, 0xfa, 0x9e, 0x71, 0x1b, 0x6a, 0xae, 0xe7, 0xd0, 0x00, 0x7b, 0x21, 0xee, 0x52, 0xb6, 0x52,
	0x47, 0x27, 0xa8, 0xb1, 0x6d, 0x7c, 0x00, 0xb5, 0xf0, 0x29, 0x0e, 0x7a, 0x4e, 0x28, 0x37, 0x86,
	0xf5, 0xc2, 0x89, 0xd6, 0xa8, 0x36, 0xef, 0xda, 0x2a, 0xb9, 0x0a, 0x60, 0x77, 0xf8, 0x2e, 0xf5,
	0x60, 0xb6, 0x40, 0x4f, 0x3e, 0x1b, 0x47, 0x50, 0xa2, 0x38, 0xb8, 0x24, 0x54, 0x44, 0xad, 0x36,
	0x77, 0x6c, 0x09, 0xf2, 0x5c, 0x2c, 0xf2, 0xe4, 0x89, 0xcc, 0x8e, 0xdb, 0x63, 0x49, 0x50, 0x43,
	0xb3, 0xfe, 0x42, 0x50, 0x6b, 0x3d, 0x27, 0xdd, 0x11, 0x25, 0x6d, 0xc2, 0x4e, 0x84, 0xd4, 0xb0,
	0xa0, 0xd2, 0xc5, 0xfd, 0x3e, 0x09, 0xf8, 0x2e, 0x19, 0x6c, 0xd7, 0x96, 0xa4, 0xce, 0xc4, 0xfa,
	0xa3, 0x87, 0xc6, 0x09, 0x94, 0x15, 0x5a, 0x11, 0x47, 0xee, 0x48, 0x82, 0x65, 0x3b, 0xb6, 0x04,
	0x80, 0xba, 0x26, 0xde, 0xef, 0x2b, 0x38, 0xa7, 0xfe, 0xc8, 0xeb, 0x3d, 0xe1, 0xff, 0x1a, 0xf7,
	0xa1, 0x4a, 0xf1, 0x45, 0x9f, 0x50, 0x87, 0x4e, 0x86, 0xa4, 0x5e, 0x64, 0xfb, 0x6a, 0xcd, 0x03,
	0x7b, 0x2a, 0xe7, 0xb9, 0x78, 0x79, 0xce, 0xde, 0x19, 0x26, 0x18, 0x9e, 0x4f, 0x9d, 0x8c, 0x7c,
	0x5b, 0x5c, 0x3e, 0xeb, 0x5b, 0xd8, 0x9d, 0x12, 0x08, 0x87, 0x4c, 0x3e, 0x62, 0x1c, 0xc3, 0x16,
	0x09, 0x02, 0x3f, 0xc8, 0xa0, 0x6f, 0x3f, 0x3e, 0x6b, 0xf1, 0xe5, 0x25, 0xd0, 0x5b, 0x50, 0x0a,
	0x48, 0x38, 0xea, 0x53, 0x05, 0xdf, 0x50, 0xf0, 0x05, 0xf2, 0xb6, 0x78, 0x63, 0xfd, 0x87, 0xe0,
	0x40, 0x65, 0x16, 0x4e, 0x84, 0x9b, 0x16, 0x70, 0x0f, 0xb6, 0x9f, 0x91, 0x49, 0x38, 0xc4, 0x5d,
	0xa9, 0x5e, 0xc5, 0xa8, 0x41, 0x49, 0x94, 0x52, 0xc8, 0xb4, 0xd1, 0xd8, 0x73, 0x46, 0xe2, 0x52,
	0x6e, 0x89, 0xcb, 0x42, 0xe2, 0xef, 0xe1, 0x30, 0x43, 0x74, 0xa3, 0x42, 0xbf, 0x44, 0xf0, 0x9a,
	0xca, 0xff, 0x85, 0xe2, 0xfb, 0xe8, 0x26, 0xa8, 0x7d, 0x00, 0x7a, 0xb4, 0xc2, 0x72, 0x4b, 0xcd,
	0xf5, 0x75, 0x69, 0xfe, 0x02, 0x81, 0x39, 0x8b, 0xf4, 0x46, 0x95, 0x7f, 0x51, 0x80, 0x3b, 0x31,
	0x88, 0x36, 0xf6, 0x2e, 0xc9, 0x0d, 0xd0, 0xfd, 0x2d, 0x00, 0xb6, 0xe2, 0x04, 0x02, 0x8e, 0x50,
	0x9d, 0xa3, 0x9f, 0x0a, 0x1c, 0x21, 0x5d, 0x97, 0x13, 0x3f, 0x20, 0xa8, 0x5f, 0x15, 0x61, 0xa3,
	0x3e, 0xfc, 0xa2, 0x4d, 0x7d, 0x68, 0x79, 0xd4, 0xa5, 0x93, 0x1b, 0x51, 0xff, 0x4c, 0x34, 0x22,
	0xd0, 0x38, 0x5d, 0xbf, 0x3f, 0x1a, 0x78, 0x8e, 0x87, 0x07, 0x44, 0x74, 0xe5, 0x8a, 0xd1, 0x82,
	0x5b, 0xea, 0x5d, 0xea, 0x13, 0x29, 0x09, 0xb3, 0x1a, 0x51, 0xf6, 0x39, 0x9c, 0xec, 0x68, 0x21,
	0x6b, 0x61, 0x39, 0xb7, 0x85, 0xdb, 0xdc, 0x42, 0xf3, 0x09, 0x6c, 0x4f, 0x43, 0x1e, 0xc1, 0xf6,
	0x73, 0xb7, 0x27, 0xe3, 0x21, 0x11, 0xaf, 0x1a, 0x5d, 0x95, 0x3c, 0xcc, 0x3e, 0x54, 0xf8, 0xeb,
	0x31, 0xee, 0x8f, 0x88, 0x10, 0x4b, 0x37, 0x6e, 0x41, 0x35, 0x41, 0x42, 0x28, 0xa4, 0x27, 0xab,
	0x22, 0x01, 0x7f, 0xa3, 0x55, 0xf1, 0x25, 0xec, 0x0a, 0x7f, 0x44, 0x53, 0x96, 0x26, 0x4d, 0x6d,
	0x44, 0xcb, 0xd8, 0x58, 0xc8, 0x5c, 0x1a, 0x1a, 0xbf, 0x34, 0xac, 0x7f, 0xe2, 0x76, 0x7b, 0x8a,
	0x69, 0xf7, 0xe9, 0xab, 0xb8, 0xdc, 0x1a, 0x50, 0xe6, 0xc8, 0x5c, 0x22, 0x93, 0x56, 0x9b, 0x77,
	0xa2, 0x1d, 0x59, 0x46, 0x39, 0xa6, 0x04, 0x36, 0xe3, 0xe0, 0x70, 0xc6, 0x84, 0xf0, 0x63, 0xdc,
	0x4a, 0x53, 0x84, 0xd6, 0x66, 0xd6, 0x1b, 0x50, 0x96, 0x66, 0x45, 0x6c, 0x66, 0xb9, 0xf5, 0x35,
	0x1c, 0x08, 0x6e, 0x71, 0x37, 0x5f, 0xdd, 0xb2, 0xec, 0xcd, 0xc3, 0xb3, 0xea, 0xd6, 0xbf, 0x08,
	0x8e, 0x93, 0x3c, 0x5f, 0xd9, 0x65, 0xf9, 0x20, 0xeb, 0xde, 0xdd, 0x94, 0x7b, 0x59, 0x86, 0x6b,
	0xb0, 0xf0, 0x67, 0x04, 0xf7, 0xe6, 0x52, 0xdb, 0xac, 0x8f, 0x3f, 0xb1, 0xb1, 0xaf, 0x43, 0x03,
	0x82, 0x07, 0x2b, 0xcd, 0xcd, 0xca, 0xec, 0xc2, 0x92, 0x53, 0xb1, 0x36, 0x5f, 0x2c, 0xeb, 0x23,
	0x38, 0xcc, 0x00, 0x51, 0x4a, 0xc4, 0xcd, 0x03, 0xcd, 0x6d, 0x1e, 0xbf, 0xb3, 0x8f, 0x22, 0x75,
	0x7a, 0x95, 0xcf, 0xfc, 0x3a, 0x32, 0xc9, 0xca, 0xd5, 0x32, 0xcd, 0xa6, 0x38, 0x6b, 0x42, 0xdd,
	0x5a, 0x40, 0xf7, 0x13, 0x78, 0x7d, 0x26, 0xe0, 0x1c, 0xa4, 0xff, 0x64, 0x65, 0x94, 0x8a, 0xb1,
	0xf2, 0x27, 0x92, 0x9f, 0x79, 0xf6, 0x9b, 0x2d, 0xce, 0x9a, 0x16, 0x17, 0xf1, 0xff, 0x14, 0x4e,
	0xe6, 0x63, 0xcf, 0x21, 0xc2, 0xdf, 0x08, 0x8e, 0xb2, 0x81, 0x56, 0x19, 0xed, 0xf2, 0x4b, 0x90,
	0x1e, 0xdc, 0x8a, 0xcb, 0x0e, 0x6e, 0x8b, 0x44, 0x79, 0x08, 0xc7, 0xf3, 0xb8, 0xe4, 0x90, 0xa4,
	0x09, 0xfa, 0x29, 0xb9, 0x74, 0xbd, 0x1c, 0x02, 0x58, 0xef, 0xc1, 0x8e, 0x3a, 0xa3, 0x12, 0x25,
	0xfa, 0x0b, 0x9a, 0xd9, 0x5f, 0xd8, 0x85, 0xbd, 0x73, 0xe6, 0x0f, 0x06, 0x2e, 0x5d, 0x6b, 0x3b,
	0xb6, 0xf6, 0xa0, 0x16, 0x85, 0x95, 0x50, 0xac, 0xaf, 0x60, 0xb7, 0xed, 0xf7, 0xfb, 0x17, 0xb8,
	0xfb, 0x6c, 0xbd, 0xa9, 0x0c, 0xd8, 0x8b, 0x03, 0xab, 0x64, 0xbf, 0x22, 0xd8, 0xef, 0x0c, 0xfb,
	0x2e, 0x55, 0x8a, 0x2e, 0x9f, 0xef, 0xea, 0xc5, 0x76, 0xfd, 0x18, 0xca, 0x3e, 0xa3, 0x90, 0x27,
	0x53, 0x33, 0xa7, 0x1a, 0x45, 0xd9, 0x88, 0x16, 0xad, 0x8e, 0x3c, 0x2a, 0x2a, 0x46, 0xb3, 0x5e,
	0x16, 0xc0, 0x48, 0x02, 0x53, 0x3e, 0xbd, 0xcb, 0x5a, 0x10, 0x5f, 0x0d, 0x19, 0x2c, 0x5e, 0x81,
	0xf7, 0xa6, 0x24, 0xaf, 0xec, 0xb5, 0x1f, 0xe3, 0x80, 0x9a, 0x9f, 0x83, 0x1e, 0x95, 0x15, 0x7f,
	0x4e, 0xc1, 0x46, 0x33, 0x0a, 0xbb, 0x30, 0xaf, 0xb0, 0xcd, 0x07, 0x50, 0x11, 0x5d, 0x6b, 0x4e,
	0x98, 0xb8, 0x39, 0xf2, 0x10, 0x15, 0xf3, 0x0f, 0x04, 0x45, 0xb1, 0xf5, 0xfa, 0x19, 0xe1, 0x63,
	0xa8, 0x4d, 0x11, 0x38, 0x43, 0x76, 0x46, 0x39, 0xf8, 0xf6, 0x02, 0x72, 0x29, 0x52, 0x1f, 0x02,
	0xc8, 0x5f, 0xa1, 0xc4, 0x61, 0x29, 0xff, 0x9b, 0x0b, 0x0e, 0xc7, 0x3c, 0x74, 0x28, 0x86, 0xee,
	0x77, 0xf2, 0x5e, 0xd7, 0xac, 0xfb, 0x70, 0xf8, 0x19, 0xa1, 0x9d, 0x60, 0x1c, 0xb5, 0xa7, 0xa8,
	0x20, 0xae, 0xd0, 0xb5, 0x5a, 0x70, 0x3b, 0xbb, 0x55, 0x59, 0xf4, 0x0e, 0x33, 0x39, 0x18, 0x3b,
	0xa9, 0xfd, 0xd5, 0xe6, 0x61, 0xac, 0x68, 0xe2, 0xd0, 0xa9, 0x09, 0xf5, 0xae, 0x3f, 0xb0, 0x27,
	0xfe, 0x88, 0x8e, 0x2e, 0x88, 0x3d, 0x76, 0x29, 0x2b, 0x56, 0xf9, 0xfb, 0xdb, 0x45, 0x49, 0xfc,
	0x79, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xcd, 0x1e, 0x62, 0xc0, 0xc8, 0x13, 0x00, 0x00,
}
