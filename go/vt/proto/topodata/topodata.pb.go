//
//Copyright 2019 The Vitess Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// This file contains the Vitess topology related data structures.
// Very few of these structures are exchanged over the wire (only
// TabletType and KeyRange), but they are all used by the topology
// service.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v3.21.3
// source: topodata.proto

package topodata

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
	vttime "vitess.io/vitess/go/vt/proto/vttime"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// KeyspaceType describes the type of the keyspace
type KeyspaceType int32

const (
	// NORMAL is the default value
	KeyspaceType_NORMAL KeyspaceType = 0
	// SNAPSHOT is when we are creating a snapshot keyspace
	KeyspaceType_SNAPSHOT KeyspaceType = 1
)

// Enum value maps for KeyspaceType.
var (
	KeyspaceType_name = map[int32]string{
		0: "NORMAL",
		1: "SNAPSHOT",
	}
	KeyspaceType_value = map[string]int32{
		"NORMAL":   0,
		"SNAPSHOT": 1,
	}
)

func (x KeyspaceType) Enum() *KeyspaceType {
	p := new(KeyspaceType)
	*p = x
	return p
}

func (x KeyspaceType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (KeyspaceType) Descriptor() protoreflect.EnumDescriptor {
	return file_topodata_proto_enumTypes[0].Descriptor()
}

func (KeyspaceType) Type() protoreflect.EnumType {
	return &file_topodata_proto_enumTypes[0]
}

func (x KeyspaceType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use KeyspaceType.Descriptor instead.
func (KeyspaceType) EnumDescriptor() ([]byte, []int) {
	return file_topodata_proto_rawDescGZIP(), []int{0}
}

// TabletType represents the type of a given tablet.
type TabletType int32

const (
	// UNKNOWN is not a valid value.
	TabletType_UNKNOWN TabletType = 0
	// PRIMARY is the primary server for the shard. Only PRIMARY allows DMLs.
	TabletType_PRIMARY TabletType = 1
	// DEPRECATED
	TabletType_MASTER TabletType = 1
	// REPLICA replicates from primary. It is used to serve live traffic.
	// A REPLICA can be promoted to PRIMARY. A demoted PRIMARY will go to REPLICA.
	TabletType_REPLICA TabletType = 2
	// RDONLY (old name) / BATCH (new name) is used to serve traffic for
	// long-running jobs. It is a separate type from REPLICA so
	// long-running queries don't affect web-like traffic.
	TabletType_RDONLY TabletType = 3
	TabletType_BATCH  TabletType = 3
	// SPARE is a type of servers that cannot serve queries, but is available
	// in case an extra server is needed.
	TabletType_SPARE TabletType = 4
	// EXPERIMENTAL is like SPARE, except it can serve queries. This
	// type can be used for usages not planned by Vitess, like online
	// export to another storage engine.
	TabletType_EXPERIMENTAL TabletType = 5
	// BACKUP is the type a server goes to when taking a backup. No queries
	// can be served in BACKUP mode.
	TabletType_BACKUP TabletType = 6
	// RESTORE is the type a server uses when restoring a backup, at
	// startup time.  No queries can be served in RESTORE mode.
	TabletType_RESTORE TabletType = 7
	// DRAINED is the type a server goes into when used by Vitess tools
	// to perform an offline action. It is a serving type (as
	// the tools processes may need to run queries), but it's not used
	// to route queries from Vitess users. In this state,
	// this tablet is dedicated to the process that uses it.
	TabletType_DRAINED TabletType = 8
)

// Enum value maps for TabletType.
var (
	TabletType_name = map[int32]string{
		0: "UNKNOWN",
		1: "PRIMARY",
		// Duplicate value: 1: "MASTER",
		2: "REPLICA",
		3: "RDONLY",
		// Duplicate value: 3: "BATCH",
		4: "SPARE",
		5: "EXPERIMENTAL",
		6: "BACKUP",
		7: "RESTORE",
		8: "DRAINED",
	}
	TabletType_value = map[string]int32{
		"UNKNOWN":      0,
		"PRIMARY":      1,
		"MASTER":       1,
		"REPLICA":      2,
		"RDONLY":       3,
		"BATCH":        3,
		"SPARE":        4,
		"EXPERIMENTAL": 5,
		"BACKUP":       6,
		"RESTORE":      7,
		"DRAINED":      8,
	}
)

func (x TabletType) Enum() *TabletType {
	p := new(TabletType)
	*p = x
	return p
}

func (x TabletType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TabletType) Descriptor() protoreflect.EnumDescriptor {
	return file_topodata_proto_enumTypes[1].Descriptor()
}

func (TabletType) Type() protoreflect.EnumType {
	return &file_topodata_proto_enumTypes[1]
}

func (x TabletType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TabletType.Descriptor instead.
func (TabletType) EnumDescriptor() ([]byte, []int) {
	return file_topodata_proto_rawDescGZIP(), []int{1}
}

type ShardReplicationError_Type int32

const (
	// UNKNOWN is not a valid value.
	ShardReplicationError_UNKNOWN ShardReplicationError_Type = 0
	// NOT_FOUND occurs when a tablet is in the ShardReplication record
	// but does not exist in the topology.
	ShardReplicationError_NOT_FOUND ShardReplicationError_Type = 1
	// TOPOLOGY_MISMATCH occurs when a tablet is in the replication graph and
	// exists in the topology, but at least one of the Keyspace, Shard, or Cell
	// fields for that tablet does not match the ShardReplication record.
	ShardReplicationError_TOPOLOGY_MISMATCH ShardReplicationError_Type = 2
)

// Enum value maps for ShardReplicationError_Type.
var (
	ShardReplicationError_Type_name = map[int32]string{
		0: "UNKNOWN",
		1: "NOT_FOUND",
		2: "TOPOLOGY_MISMATCH",
	}
	ShardReplicationError_Type_value = map[string]int32{
		"UNKNOWN":           0,
		"NOT_FOUND":         1,
		"TOPOLOGY_MISMATCH": 2,
	}
)

func (x ShardReplicationError_Type) Enum() *ShardReplicationError_Type {
	p := new(ShardReplicationError_Type)
	*p = x
	return p
}

func (x ShardReplicationError_Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ShardReplicationError_Type) Descriptor() protoreflect.EnumDescriptor {
	return file_topodata_proto_enumTypes[2].Descriptor()
}

func (ShardReplicationError_Type) Type() protoreflect.EnumType {
	return &file_topodata_proto_enumTypes[2]
}

func (x ShardReplicationError_Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ShardReplicationError_Type.Descriptor instead.
func (ShardReplicationError_Type) EnumDescriptor() ([]byte, []int) {
	return file_topodata_proto_rawDescGZIP(), []int{6, 0}
}

// KeyRange describes a range of sharding keys, when range-based
// sharding is used.
type KeyRange struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Start         []byte                 `protobuf:"bytes,1,opt,name=start,proto3" json:"start,omitempty"`
	End           []byte                 `protobuf:"bytes,2,opt,name=end,proto3" json:"end,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KeyRange) Reset() {
	*x = KeyRange{}
	mi := &file_topodata_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KeyRange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KeyRange) ProtoMessage() {}

func (x *KeyRange) ProtoReflect() protoreflect.Message {
	mi := &file_topodata_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KeyRange.ProtoReflect.Descriptor instead.
func (*KeyRange) Descriptor() ([]byte, []int) {
	return file_topodata_proto_rawDescGZIP(), []int{0}
}

func (x *KeyRange) GetStart() []byte {
	if x != nil {
		return x.Start
	}
	return nil
}

func (x *KeyRange) GetEnd() []byte {
	if x != nil {
		return x.End
	}
	return nil
}

// TabletAlias is a globally unique tablet identifier.
type TabletAlias struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// cell is the cell (or datacenter) the tablet is in
	Cell string `protobuf:"bytes,1,opt,name=cell,proto3" json:"cell,omitempty"`
	// uid is a unique id for this tablet within the shard
	// (this is the MySQL server id as well).
	Uid           uint32 `protobuf:"varint,2,opt,name=uid,proto3" json:"uid,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TabletAlias) Reset() {
	*x = TabletAlias{}
	mi := &file_topodata_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TabletAlias) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TabletAlias) ProtoMessage() {}

func (x *TabletAlias) ProtoReflect() protoreflect.Message {
	mi := &file_topodata_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TabletAlias.ProtoReflect.Descriptor instead.
func (*TabletAlias) Descriptor() ([]byte, []int) {
	return file_topodata_proto_rawDescGZIP(), []int{1}
}

func (x *TabletAlias) GetCell() string {
	if x != nil {
		return x.Cell
	}
	return ""
}

func (x *TabletAlias) GetUid() uint32 {
	if x != nil {
		return x.Uid
	}
	return 0
}

// Tablet represents information about a running instance of vttablet.
type Tablet struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// alias is the unique name of the tablet.
	Alias *TabletAlias `protobuf:"bytes,1,opt,name=alias,proto3" json:"alias,omitempty"`
	// Fully qualified domain name of the host.
	Hostname string `protobuf:"bytes,2,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// Map of named ports. Normally this should include vt and grpc.
	// Going forward, the mysql port will be stored in mysql_port
	// instead of here.
	// For accessing mysql port, use topoproto.MysqlPort to fetch, and
	// topoproto.SetMysqlPort to set. These wrappers will ensure
	// legacy behavior is supported.
	PortMap map[string]int32 `protobuf:"bytes,4,rep,name=port_map,json=portMap,proto3" json:"port_map,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	// Keyspace name.
	Keyspace string `protobuf:"bytes,5,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	// Shard name. If range based sharding is used, it should match
	// key_range.
	Shard string `protobuf:"bytes,6,opt,name=shard,proto3" json:"shard,omitempty"`
	// If range based sharding is used, range for the tablet's shard.
	KeyRange *KeyRange `protobuf:"bytes,7,opt,name=key_range,json=keyRange,proto3" json:"key_range,omitempty"`
	// type is the current type of the tablet.
	Type TabletType `protobuf:"varint,8,opt,name=type,proto3,enum=topodata.TabletType" json:"type,omitempty"`
	// It this is set, it is used as the database name instead of the
	// normal "vt_" + keyspace.
	DbNameOverride string `protobuf:"bytes,9,opt,name=db_name_override,json=dbNameOverride,proto3" json:"db_name_override,omitempty"`
	// tablet tags
	Tags map[string]string `protobuf:"bytes,10,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// MySQL hostname.
	MysqlHostname string `protobuf:"bytes,12,opt,name=mysql_hostname,json=mysqlHostname,proto3" json:"mysql_hostname,omitempty"`
	// MySQL port. Use topoproto.MysqlPort and topoproto.SetMysqlPort
	// to access this variable. The functions provide support
	// for legacy behavior.
	MysqlPort int32 `protobuf:"varint,13,opt,name=mysql_port,json=mysqlPort,proto3" json:"mysql_port,omitempty"`
	// primary_term_start_time is the time (in UTC) at which the current term of
	// the current tablet began as primary. If this tablet is not currently the
	// primary, this value is ignored.
	//
	// A new primary term begins any time an authoritative decision is communicated
	// about which tablet should be the primary, such as via Vitess
	// replication-management commands like PlannedReparentShard,
	// EmergencyReparentShard, and TabletExternallyReparented.
	PrimaryTermStartTime *vttime.Time `protobuf:"bytes,14,opt,name=primary_term_start_time,json=primaryTermStartTime,proto3" json:"primary_term_start_time,omitempty"`
	// default_conn_collation is the default connection collation used by this tablet.
	DefaultConnCollation uint32 `protobuf:"varint,16,opt,name=default_conn_collation,json=defaultConnCollation,proto3" json:"default_conn_collation,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *Tablet) Reset() {
	*x = Tablet{}
	mi := &file_topodata_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Tablet) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Tablet) ProtoMessage() {}

func (x *Tablet) ProtoReflect() protoreflect.Message {
	mi := &file_topodata_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Tablet.ProtoReflect.Descriptor instead.
func (*Tablet) Descriptor() ([]byte, []int) {
	return file_topodata_proto_rawDescGZIP(), []int{2}
}

func (x *Tablet) GetAlias() *TabletAlias {
	if x != nil {
		return x.Alias
	}
	return nil
}

func (x *Tablet) GetHostname() string {
	if x != nil {
		return x.Hostname
	}
	return ""
}

func (x *Tablet) GetPortMap() map[string]int32 {
	if x != nil {
		return x.PortMap
	}
	return nil
}

func (x *Tablet) GetKeyspace() string {
	if x != nil {
		return x.Keyspace
	}
	return ""
}

func (x *Tablet) GetShard() string {
	if x != nil {
		return x.Shard
	}
	return ""
}

func (x *Tablet) GetKeyRange() *KeyRange {
	if x != nil {
		return x.KeyRange
	}
	return nil
}

func (x *Tablet) GetType() TabletType {
	if x != nil {
		return x.Type
	}
	return TabletType_UNKNOWN
}

func (x *Tablet) GetDbNameOverride() string {
	if x != nil {
		return x.DbNameOverride
	}
	return ""
}

func (x *Tablet) GetTags() map[string]string {
	if x != nil {
		return x.Tags
	}
	return nil
}

func (x *Tablet) GetMysqlHostname() string {
	if x != nil {
		return x.MysqlHostname
	}
	return ""
}

func (x *Tablet) GetMysqlPort() int32 {
	if x != nil {
		return x.MysqlPort
	}
	return 0
}

func (x *Tablet) GetPrimaryTermStartTime() *vttime.Time {
	if x != nil {
		return x.PrimaryTermStartTime
	}
	return nil
}

func (x *Tablet) GetDefaultConnCollation() uint32 {
	if x != nil {
		return x.DefaultConnCollation
	}
	return 0
}

// A Shard contains data about a subset of the data whithin a keyspace.
type Shard struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// primary_alias is the tablet alias of the primary for the shard.
	// If it is unset, then there is no primary in this shard yet.
	// No lock is necessary to update this field, when for instance
	// TabletExternallyReparented updates this. However, we lock the
	// shard for reparenting operations (InitShardPrimary,
	// PlannedReparentShard,EmergencyReparentShard), to guarantee
	// exclusive operation.
	PrimaryAlias *TabletAlias `protobuf:"bytes,1,opt,name=primary_alias,json=primaryAlias,proto3" json:"primary_alias,omitempty"`
	// primary_term_start_time is the time (in UTC) at which the current term of
	// the primary specified in primary_alias began.
	//
	// A new primary term begins any time an authoritative decision is communicated
	// about which tablet should be the primary, such as via Vitess
	// replication-management commands like PlannedReparentShard,
	// EmergencyReparentShard, and TabletExternallyReparented.
	//
	// The primary_alias should only ever be changed if the new primary's term began
	// at a later time than this. Note that a new term can start for the tablet
	// that is already the primary. In that case, the primary_term_start_time would
	// be increased without changing the primary_alias.
	PrimaryTermStartTime *vttime.Time `protobuf:"bytes,8,opt,name=primary_term_start_time,json=primaryTermStartTime,proto3" json:"primary_term_start_time,omitempty"`
	// key_range is the KeyRange for this shard. It can be unset if:
	// - we are not using range-based sharding in this shard.
	// - the shard covers the entire keyrange.
	// This must match the shard name based on our other conventions, but
	// helpful to have it decomposed here.
	// Once set at creation time, it is never changed.
	KeyRange *KeyRange `protobuf:"bytes,2,opt,name=key_range,json=keyRange,proto3" json:"key_range,omitempty"`
	// SourceShards is the list of shards we're replicating from,
	// using filtered replication.
	// The keyspace lock is always taken when changing this.
	SourceShards []*Shard_SourceShard `protobuf:"bytes,4,rep,name=source_shards,json=sourceShards,proto3" json:"source_shards,omitempty"`
	// tablet_controls has at most one entry per TabletType.
	// The keyspace lock is always taken when changing this.
	TabletControls []*Shard_TabletControl `protobuf:"bytes,6,rep,name=tablet_controls,json=tabletControls,proto3" json:"tablet_controls,omitempty"`
	// is_primary_serving sets whether this shard primary is serving traffic or not.
	// The keyspace lock is always taken when changing this.
	IsPrimaryServing bool `protobuf:"varint,7,opt,name=is_primary_serving,json=isPrimaryServing,proto3" json:"is_primary_serving,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *Shard) Reset() {
	*x = Shard{}
	mi := &file_topodata_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Shard) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Shard) ProtoMessage() {}

func (x *Shard) ProtoReflect() protoreflect.Message {
	mi := &file_topodata_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Shard.ProtoReflect.Descriptor instead.
func (*Shard) Descriptor() ([]byte, []int) {
	return file_topodata_proto_rawDescGZIP(), []int{3}
}

func (x *Shard) GetPrimaryAlias() *TabletAlias {
	if x != nil {
		return x.PrimaryAlias
	}
	return nil
}

func (x *Shard) GetPrimaryTermStartTime() *vttime.Time {
	if x != nil {
		return x.PrimaryTermStartTime
	}
	return nil
}

func (x *Shard) GetKeyRange() *KeyRange {
	if x != nil {
		return x.KeyRange
	}
	return nil
}

func (x *Shard) GetSourceShards() []*Shard_SourceShard {
	if x != nil {
		return x.SourceShards
	}
	return nil
}

func (x *Shard) GetTabletControls() []*Shard_TabletControl {
	if x != nil {
		return x.TabletControls
	}
	return nil
}

func (x *Shard) GetIsPrimaryServing() bool {
	if x != nil {
		return x.IsPrimaryServing
	}
	return false
}

// A Keyspace contains data about a keyspace.
type Keyspace struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// keyspace_type will determine how this keyspace is treated by
	// vtgate / vschema. Normal keyspaces are routable by
	// any query. Snapshot keyspaces are only accessible
	// by explicit addresssing or by calling "use keyspace" first
	KeyspaceType KeyspaceType `protobuf:"varint,5,opt,name=keyspace_type,json=keyspaceType,proto3,enum=topodata.KeyspaceType" json:"keyspace_type,omitempty"`
	// base_keyspace is the base keyspace from which a snapshot
	// keyspace is created. empty for normal keyspaces
	BaseKeyspace string `protobuf:"bytes,6,opt,name=base_keyspace,json=baseKeyspace,proto3" json:"base_keyspace,omitempty"`
	// snapshot_time (in UTC) is a property of snapshot
	// keyspaces which tells us what point in time
	// the snapshot is of
	SnapshotTime *vttime.Time `protobuf:"bytes,7,opt,name=snapshot_time,json=snapshotTime,proto3" json:"snapshot_time,omitempty"`
	// DurabilityPolicy is the durability policy to be
	// used for the keyspace.
	DurabilityPolicy string `protobuf:"bytes,8,opt,name=durability_policy,json=durabilityPolicy,proto3" json:"durability_policy,omitempty"`
	// ThrottlerConfig has the configuration for the tablet
	// server's lag throttler, and applies to the entire
	// keyspace, across all shards and tablets.
	ThrottlerConfig *ThrottlerConfig `protobuf:"bytes,9,opt,name=throttler_config,json=throttlerConfig,proto3" json:"throttler_config,omitempty"`
	// SidecarDBName is the name of the Vitess sidecar database
	// used for various system metadata that is stored in each
	// tablet's mysqld instance.
	SidecarDbName string `protobuf:"bytes,10,opt,name=sidecar_db_name,json=sidecarDbName,proto3" json:"sidecar_db_name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Keyspace) Reset() {
	*x = Keyspace{}
	mi := &file_topodata_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Keyspace) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Keyspace) ProtoMessage() {}

func (x *Keyspace) ProtoReflect() protoreflect.Message {
	mi := &file_topodata_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Keyspace.ProtoReflect.Descriptor instead.
func (*Keyspace) Descriptor() ([]byte, []int) {
	return file_topodata_proto_rawDescGZIP(), []int{4}
}

func (x *Keyspace) GetKeyspaceType() KeyspaceType {
	if x != nil {
		return x.KeyspaceType
	}
	return KeyspaceType_NORMAL
}

func (x *Keyspace) GetBaseKeyspace() string {
	if x != nil {
		return x.BaseKeyspace
	}
	return ""
}

func (x *Keyspace) GetSnapshotTime() *vttime.Time {
	if x != nil {
		return x.SnapshotTime
	}
	return nil
}

func (x *Keyspace) GetDurabilityPolicy() string {
	if x != nil {
		return x.DurabilityPolicy
	}
	return ""
}

func (x *Keyspace) GetThrottlerConfig() *ThrottlerConfig {
	if x != nil {
		return x.ThrottlerConfig
	}
	return nil
}

func (x *Keyspace) GetSidecarDbName() string {
	if x != nil {
		return x.SidecarDbName
	}
	return ""
}

// ShardReplication describes the MySQL replication relationships
// whithin a cell.
type ShardReplication struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Note there can be only one Node in this array
	// for a given tablet.
	Nodes         []*ShardReplication_Node `protobuf:"bytes,1,rep,name=nodes,proto3" json:"nodes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ShardReplication) Reset() {
	*x = ShardReplication{}
	mi := &file_topodata_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ShardReplication) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ShardReplication) ProtoMessage() {}

func (x *ShardReplication) ProtoReflect() protoreflect.Message {
	mi := &file_topodata_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ShardReplication.ProtoReflect.Descriptor instead.
func (*ShardReplication) Descriptor() ([]byte, []int) {
	return file_topodata_proto_rawDescGZIP(), []int{5}
}

func (x *ShardReplication) GetNodes() []*ShardReplication_Node {
	if x != nil {
		return x.Nodes
	}
	return nil
}

// ShardReplicationError describes the error being fixed by
// ShardReplicationFix.
type ShardReplicationError struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Type is the category of problem being fixed.
	Type ShardReplicationError_Type `protobuf:"varint,1,opt,name=type,proto3,enum=topodata.ShardReplicationError_Type" json:"type,omitempty"`
	// TabletAlias is the tablet record that has the problem.
	TabletAlias   *TabletAlias `protobuf:"bytes,2,opt,name=tablet_alias,json=tabletAlias,proto3" json:"tablet_alias,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ShardReplicationError) Reset() {
	*x = ShardReplicationError{}
	mi := &file_topodata_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ShardReplicationError) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ShardReplicationError) ProtoMessage() {}

func (x *ShardReplicationError) ProtoReflect() protoreflect.Message {
	mi := &file_topodata_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ShardReplicationError.ProtoReflect.Descriptor instead.
func (*ShardReplicationError) Descriptor() ([]byte, []int) {
	return file_topodata_proto_rawDescGZIP(), []int{6}
}

func (x *ShardReplicationError) GetType() ShardReplicationError_Type {
	if x != nil {
		return x.Type
	}
	return ShardReplicationError_UNKNOWN
}

func (x *ShardReplicationError) GetTabletAlias() *TabletAlias {
	if x != nil {
		return x.TabletAlias
	}
	return nil
}

// ShardReference is used as a pointer from a SrvKeyspace to a Shard
type ShardReference struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Copied from Shard.
	Name          string    `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	KeyRange      *KeyRange `protobuf:"bytes,2,opt,name=key_range,json=keyRange,proto3" json:"key_range,omitempty"` // Disable query serving in this shard
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ShardReference) Reset() {
	*x = ShardReference{}
	mi := &file_topodata_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ShardReference) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ShardReference) ProtoMessage() {}

func (x *ShardReference) ProtoReflect() protoreflect.Message {
	mi := &file_topodata_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ShardReference.ProtoReflect.Descriptor instead.
func (*ShardReference) Descriptor() ([]byte, []int) {
	return file_topodata_proto_rawDescGZIP(), []int{7}
}

func (x *ShardReference) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ShardReference) GetKeyRange() *KeyRange {
	if x != nil {
		return x.KeyRange
	}
	return nil
}

// ShardTabletControl is used as a pointer from a SrvKeyspace to a Shard
type ShardTabletControl struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Copied from Shard.
	Name     string    `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	KeyRange *KeyRange `protobuf:"bytes,2,opt,name=key_range,json=keyRange,proto3" json:"key_range,omitempty"`
	// Disable query serving in this shard
	QueryServiceDisabled bool `protobuf:"varint,3,opt,name=query_service_disabled,json=queryServiceDisabled,proto3" json:"query_service_disabled,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *ShardTabletControl) Reset() {
	*x = ShardTabletControl{}
	mi := &file_topodata_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ShardTabletControl) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ShardTabletControl) ProtoMessage() {}

func (x *ShardTabletControl) ProtoReflect() protoreflect.Message {
	mi := &file_topodata_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ShardTabletControl.ProtoReflect.Descriptor instead.
func (*ShardTabletControl) Descriptor() ([]byte, []int) {
	return file_topodata_proto_rawDescGZIP(), []int{8}
}

func (x *ShardTabletControl) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ShardTabletControl) GetKeyRange() *KeyRange {
	if x != nil {
		return x.KeyRange
	}
	return nil
}

func (x *ShardTabletControl) GetQueryServiceDisabled() bool {
	if x != nil {
		return x.QueryServiceDisabled
	}
	return false
}

// ThrottledAppRule defines an app-specific throttling rule, with expiration.
type ThrottledAppRule struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Name of the app to be throttled, e.g. "vreplication" or "online-ddl"
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Ratio defines how much the app should be throttled, range [0.0...1.0]. 1.0 means fully throttled. 0.0 means not throttled at all.
	// Negative values are reserved for a future implementation.
	Ratio float64 `protobuf:"fixed64,2,opt,name=ratio,proto3" json:"ratio,omitempty"`
	// ExpiresAt is the time at which the rule expires.
	ExpiresAt *vttime.Time `protobuf:"bytes,3,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
	// Exempt indicates the app should never be throttled, even if the throttler is, in general, throttling other apps.
	Exempt        bool `protobuf:"varint,4,opt,name=exempt,proto3" json:"exempt,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ThrottledAppRule) Reset() {
	*x = ThrottledAppRule{}
	mi := &file_topodata_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ThrottledAppRule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ThrottledAppRule) ProtoMessage() {}

func (x *ThrottledAppRule) ProtoReflect() protoreflect.Message {
	mi := &file_topodata_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ThrottledAppRule.ProtoReflect.Descriptor instead.
func (*ThrottledAppRule) Descriptor() ([]byte, []int) {
	return file_topodata_proto_rawDescGZIP(), []int{9}
}

func (x *ThrottledAppRule) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ThrottledAppRule) GetRatio() float64 {
	if x != nil {
		return x.Ratio
	}
	return 0
}

func (x *ThrottledAppRule) GetExpiresAt() *vttime.Time {
	if x != nil {
		return x.ExpiresAt
	}
	return nil
}

func (x *ThrottledAppRule) GetExempt() bool {
	if x != nil {
		return x.Exempt
	}
	return false
}

type ThrottlerConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Enabled indicates that the throttler is actually checking state for
	// requests. When disabled, it automatically returns 200 OK for all
	// checks.
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Threshold is the threshold for either the default check (heartbeat
	// lag) or custom check.
	Threshold float64 `protobuf:"fixed64,2,opt,name=threshold,proto3" json:"threshold,omitempty"`
	// CustomQuery is an optional query that overrides the default check
	// query.
	CustomQuery string `protobuf:"bytes,3,opt,name=custom_query,json=customQuery,proto3" json:"custom_query,omitempty"`
	// CheckAsCheckSelf indicates whether a throttler /check request
	// should behave like a /check-self.
	CheckAsCheckSelf bool `protobuf:"varint,4,opt,name=check_as_check_self,json=checkAsCheckSelf,proto3" json:"check_as_check_self,omitempty"`
	// ThrottledApps is a map of rules for app-specific throttling
	ThrottledApps map[string]*ThrottledAppRule `protobuf:"bytes,5,rep,name=throttled_apps,json=throttledApps,proto3" json:"throttled_apps,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// AppCheckedMetrics maps app names to the list of metrics that should be checked for that app
	AppCheckedMetrics map[string]*ThrottlerConfig_MetricNames `protobuf:"bytes,6,rep,name=app_checked_metrics,json=appCheckedMetrics,proto3" json:"app_checked_metrics,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// MetricThresholds maps metric names to the threshold values that should be used for that metric
	MetricThresholds map[string]float64 `protobuf:"bytes,7,rep,name=metric_thresholds,json=metricThresholds,proto3" json:"metric_thresholds,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"fixed64,2,opt,name=value"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *ThrottlerConfig) Reset() {
	*x = ThrottlerConfig{}
	mi := &file_topodata_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ThrottlerConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ThrottlerConfig) ProtoMessage() {}

func (x *ThrottlerConfig) ProtoReflect() protoreflect.Message {
	mi := &file_topodata_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ThrottlerConfig.ProtoReflect.Descriptor instead.
func (*ThrottlerConfig) Descriptor() ([]byte, []int) {
	return file_topodata_proto_rawDescGZIP(), []int{10}
}

func (x *ThrottlerConfig) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *ThrottlerConfig) GetThreshold() float64 {
	if x != nil {
		return x.Threshold
	}
	return 0
}

func (x *ThrottlerConfig) GetCustomQuery() string {
	if x != nil {
		return x.CustomQuery
	}
	return ""
}

func (x *ThrottlerConfig) GetCheckAsCheckSelf() bool {
	if x != nil {
		return x.CheckAsCheckSelf
	}
	return false
}

func (x *ThrottlerConfig) GetThrottledApps() map[string]*ThrottledAppRule {
	if x != nil {
		return x.ThrottledApps
	}
	return nil
}

func (x *ThrottlerConfig) GetAppCheckedMetrics() map[string]*ThrottlerConfig_MetricNames {
	if x != nil {
		return x.AppCheckedMetrics
	}
	return nil
}

func (x *ThrottlerConfig) GetMetricThresholds() map[string]float64 {
	if x != nil {
		return x.MetricThresholds
	}
	return nil
}

// SrvKeyspace is a rollup node for the keyspace itself.
type SrvKeyspace struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The partitions this keyspace is serving, per tablet type.
	Partitions []*SrvKeyspace_KeyspacePartition `protobuf:"bytes,1,rep,name=partitions,proto3" json:"partitions,omitempty"`
	// ThrottlerConfig has the configuration for the tablet server's
	// lag throttler, and applies to the entire keyspace, across all
	// shards and tablets. This is copied from the global keyspace
	// object.
	ThrottlerConfig *ThrottlerConfig `protobuf:"bytes,6,opt,name=throttler_config,json=throttlerConfig,proto3" json:"throttler_config,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *SrvKeyspace) Reset() {
	*x = SrvKeyspace{}
	mi := &file_topodata_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SrvKeyspace) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SrvKeyspace) ProtoMessage() {}

func (x *SrvKeyspace) ProtoReflect() protoreflect.Message {
	mi := &file_topodata_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SrvKeyspace.ProtoReflect.Descriptor instead.
func (*SrvKeyspace) Descriptor() ([]byte, []int) {
	return file_topodata_proto_rawDescGZIP(), []int{11}
}

func (x *SrvKeyspace) GetPartitions() []*SrvKeyspace_KeyspacePartition {
	if x != nil {
		return x.Partitions
	}
	return nil
}

func (x *SrvKeyspace) GetThrottlerConfig() *ThrottlerConfig {
	if x != nil {
		return x.ThrottlerConfig
	}
	return nil
}

// CellInfo contains information about a cell. CellInfo objects are
// stored in the global topology server, and describe how to reach
// local topology servers.
type CellInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// ServerAddress contains the address of the server for the cell.
	// The syntax of this field is topology implementation specific.
	// For instance, for Zookeeper, it is a comma-separated list of
	// server addresses.
	ServerAddress string `protobuf:"bytes,1,opt,name=server_address,json=serverAddress,proto3" json:"server_address,omitempty"`
	// Root is the path to store data in. It is only used when talking
	// to server_address.
	Root          string `protobuf:"bytes,2,opt,name=root,proto3" json:"root,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CellInfo) Reset() {
	*x = CellInfo{}
	mi := &file_topodata_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CellInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CellInfo) ProtoMessage() {}

func (x *CellInfo) ProtoReflect() protoreflect.Message {
	mi := &file_topodata_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CellInfo.ProtoReflect.Descriptor instead.
func (*CellInfo) Descriptor() ([]byte, []int) {
	return file_topodata_proto_rawDescGZIP(), []int{12}
}

func (x *CellInfo) GetServerAddress() string {
	if x != nil {
		return x.ServerAddress
	}
	return ""
}

func (x *CellInfo) GetRoot() string {
	if x != nil {
		return x.Root
	}
	return ""
}

// CellsAlias
type CellsAlias struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Cells that map to this alias
	Cells         []string `protobuf:"bytes,2,rep,name=cells,proto3" json:"cells,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CellsAlias) Reset() {
	*x = CellsAlias{}
	mi := &file_topodata_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CellsAlias) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CellsAlias) ProtoMessage() {}

func (x *CellsAlias) ProtoReflect() protoreflect.Message {
	mi := &file_topodata_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CellsAlias.ProtoReflect.Descriptor instead.
func (*CellsAlias) Descriptor() ([]byte, []int) {
	return file_topodata_proto_rawDescGZIP(), []int{13}
}

func (x *CellsAlias) GetCells() []string {
	if x != nil {
		return x.Cells
	}
	return nil
}

type TopoConfig struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TopoType      string                 `protobuf:"bytes,1,opt,name=topo_type,json=topoType,proto3" json:"topo_type,omitempty"`
	Server        string                 `protobuf:"bytes,2,opt,name=server,proto3" json:"server,omitempty"`
	Root          string                 `protobuf:"bytes,3,opt,name=root,proto3" json:"root,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TopoConfig) Reset() {
	*x = TopoConfig{}
	mi := &file_topodata_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TopoConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TopoConfig) ProtoMessage() {}

func (x *TopoConfig) ProtoReflect() protoreflect.Message {
	mi := &file_topodata_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TopoConfig.ProtoReflect.Descriptor instead.
func (*TopoConfig) Descriptor() ([]byte, []int) {
	return file_topodata_proto_rawDescGZIP(), []int{14}
}

func (x *TopoConfig) GetTopoType() string {
	if x != nil {
		return x.TopoType
	}
	return ""
}

func (x *TopoConfig) GetServer() string {
	if x != nil {
		return x.Server
	}
	return ""
}

func (x *TopoConfig) GetRoot() string {
	if x != nil {
		return x.Root
	}
	return ""
}

type ExternalVitessCluster struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TopoConfig    *TopoConfig            `protobuf:"bytes,1,opt,name=topo_config,json=topoConfig,proto3" json:"topo_config,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExternalVitessCluster) Reset() {
	*x = ExternalVitessCluster{}
	mi := &file_topodata_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExternalVitessCluster) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExternalVitessCluster) ProtoMessage() {}

func (x *ExternalVitessCluster) ProtoReflect() protoreflect.Message {
	mi := &file_topodata_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExternalVitessCluster.ProtoReflect.Descriptor instead.
func (*ExternalVitessCluster) Descriptor() ([]byte, []int) {
	return file_topodata_proto_rawDescGZIP(), []int{15}
}

func (x *ExternalVitessCluster) GetTopoConfig() *TopoConfig {
	if x != nil {
		return x.TopoConfig
	}
	return nil
}

// ExternalClusters
type ExternalClusters struct {
	state         protoimpl.MessageState   `protogen:"open.v1"`
	VitessCluster []*ExternalVitessCluster `protobuf:"bytes,1,rep,name=vitess_cluster,json=vitessCluster,proto3" json:"vitess_cluster,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExternalClusters) Reset() {
	*x = ExternalClusters{}
	mi := &file_topodata_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExternalClusters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExternalClusters) ProtoMessage() {}

func (x *ExternalClusters) ProtoReflect() protoreflect.Message {
	mi := &file_topodata_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExternalClusters.ProtoReflect.Descriptor instead.
func (*ExternalClusters) Descriptor() ([]byte, []int) {
	return file_topodata_proto_rawDescGZIP(), []int{16}
}

func (x *ExternalClusters) GetVitessCluster() []*ExternalVitessCluster {
	if x != nil {
		return x.VitessCluster
	}
	return nil
}

// SourceShard represents a data source for filtered replication
// across shards. When this is used in a destination shard, the primary
// of that shard will run filtered replication.
type Shard_SourceShard struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Uid is the unique ID for this SourceShard object.
	Uid int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	// the source keyspace
	Keyspace string `protobuf:"bytes,2,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	// the source shard
	Shard string `protobuf:"bytes,3,opt,name=shard,proto3" json:"shard,omitempty"`
	// the source shard keyrange
	KeyRange *KeyRange `protobuf:"bytes,4,opt,name=key_range,json=keyRange,proto3" json:"key_range,omitempty"`
	// the source table list to replicate
	Tables        []string `protobuf:"bytes,5,rep,name=tables,proto3" json:"tables,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Shard_SourceShard) Reset() {
	*x = Shard_SourceShard{}
	mi := &file_topodata_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Shard_SourceShard) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Shard_SourceShard) ProtoMessage() {}

func (x *Shard_SourceShard) ProtoReflect() protoreflect.Message {
	mi := &file_topodata_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Shard_SourceShard.ProtoReflect.Descriptor instead.
func (*Shard_SourceShard) Descriptor() ([]byte, []int) {
	return file_topodata_proto_rawDescGZIP(), []int{3, 0}
}

func (x *Shard_SourceShard) GetUid() int32 {
	if x != nil {
		return x.Uid
	}
	return 0
}

func (x *Shard_SourceShard) GetKeyspace() string {
	if x != nil {
		return x.Keyspace
	}
	return ""
}

func (x *Shard_SourceShard) GetShard() string {
	if x != nil {
		return x.Shard
	}
	return ""
}

func (x *Shard_SourceShard) GetKeyRange() *KeyRange {
	if x != nil {
		return x.KeyRange
	}
	return nil
}

func (x *Shard_SourceShard) GetTables() []string {
	if x != nil {
		return x.Tables
	}
	return nil
}

// TabletControl controls tablet's behavior
type Shard_TabletControl struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// which tablet type is affected
	TabletType   TabletType `protobuf:"varint,1,opt,name=tablet_type,json=tabletType,proto3,enum=topodata.TabletType" json:"tablet_type,omitempty"`
	Cells        []string   `protobuf:"bytes,2,rep,name=cells,proto3" json:"cells,omitempty"`
	DeniedTables []string   `protobuf:"bytes,4,rep,name=denied_tables,json=deniedTables,proto3" json:"denied_tables,omitempty"`
	// frozen is set if we've started failing over traffic for
	// the primary. If set, this record should not be removed.
	Frozen        bool `protobuf:"varint,5,opt,name=frozen,proto3" json:"frozen,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Shard_TabletControl) Reset() {
	*x = Shard_TabletControl{}
	mi := &file_topodata_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Shard_TabletControl) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Shard_TabletControl) ProtoMessage() {}

func (x *Shard_TabletControl) ProtoReflect() protoreflect.Message {
	mi := &file_topodata_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Shard_TabletControl.ProtoReflect.Descriptor instead.
func (*Shard_TabletControl) Descriptor() ([]byte, []int) {
	return file_topodata_proto_rawDescGZIP(), []int{3, 1}
}

func (x *Shard_TabletControl) GetTabletType() TabletType {
	if x != nil {
		return x.TabletType
	}
	return TabletType_UNKNOWN
}

func (x *Shard_TabletControl) GetCells() []string {
	if x != nil {
		return x.Cells
	}
	return nil
}

func (x *Shard_TabletControl) GetDeniedTables() []string {
	if x != nil {
		return x.DeniedTables
	}
	return nil
}

func (x *Shard_TabletControl) GetFrozen() bool {
	if x != nil {
		return x.Frozen
	}
	return false
}

// Node describes a tablet instance within the cell
type ShardReplication_Node struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TabletAlias   *TabletAlias           `protobuf:"bytes,1,opt,name=tablet_alias,json=tabletAlias,proto3" json:"tablet_alias,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ShardReplication_Node) Reset() {
	*x = ShardReplication_Node{}
	mi := &file_topodata_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ShardReplication_Node) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ShardReplication_Node) ProtoMessage() {}

func (x *ShardReplication_Node) ProtoReflect() protoreflect.Message {
	mi := &file_topodata_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ShardReplication_Node.ProtoReflect.Descriptor instead.
func (*ShardReplication_Node) Descriptor() ([]byte, []int) {
	return file_topodata_proto_rawDescGZIP(), []int{5, 0}
}

func (x *ShardReplication_Node) GetTabletAlias() *TabletAlias {
	if x != nil {
		return x.TabletAlias
	}
	return nil
}

type ThrottlerConfig_MetricNames struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Names         []string               `protobuf:"bytes,1,rep,name=names,proto3" json:"names,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ThrottlerConfig_MetricNames) Reset() {
	*x = ThrottlerConfig_MetricNames{}
	mi := &file_topodata_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ThrottlerConfig_MetricNames) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ThrottlerConfig_MetricNames) ProtoMessage() {}

func (x *ThrottlerConfig_MetricNames) ProtoReflect() protoreflect.Message {
	mi := &file_topodata_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ThrottlerConfig_MetricNames.ProtoReflect.Descriptor instead.
func (*ThrottlerConfig_MetricNames) Descriptor() ([]byte, []int) {
	return file_topodata_proto_rawDescGZIP(), []int{10, 1}
}

func (x *ThrottlerConfig_MetricNames) GetNames() []string {
	if x != nil {
		return x.Names
	}
	return nil
}

type SrvKeyspace_KeyspacePartition struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The type this partition applies to.
	ServedType TabletType `protobuf:"varint,1,opt,name=served_type,json=servedType,proto3,enum=topodata.TabletType" json:"served_type,omitempty"`
	// List of non-overlapping continuous shards sorted by range.
	ShardReferences []*ShardReference `protobuf:"bytes,2,rep,name=shard_references,json=shardReferences,proto3" json:"shard_references,omitempty"`
	// List of shard tablet controls
	ShardTabletControls []*ShardTabletControl `protobuf:"bytes,3,rep,name=shard_tablet_controls,json=shardTabletControls,proto3" json:"shard_tablet_controls,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *SrvKeyspace_KeyspacePartition) Reset() {
	*x = SrvKeyspace_KeyspacePartition{}
	mi := &file_topodata_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SrvKeyspace_KeyspacePartition) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SrvKeyspace_KeyspacePartition) ProtoMessage() {}

func (x *SrvKeyspace_KeyspacePartition) ProtoReflect() protoreflect.Message {
	mi := &file_topodata_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SrvKeyspace_KeyspacePartition.ProtoReflect.Descriptor instead.
func (*SrvKeyspace_KeyspacePartition) Descriptor() ([]byte, []int) {
	return file_topodata_proto_rawDescGZIP(), []int{11, 0}
}

func (x *SrvKeyspace_KeyspacePartition) GetServedType() TabletType {
	if x != nil {
		return x.ServedType
	}
	return TabletType_UNKNOWN
}

func (x *SrvKeyspace_KeyspacePartition) GetShardReferences() []*ShardReference {
	if x != nil {
		return x.ShardReferences
	}
	return nil
}

func (x *SrvKeyspace_KeyspacePartition) GetShardTabletControls() []*ShardTabletControl {
	if x != nil {
		return x.ShardTabletControls
	}
	return nil
}

var File_topodata_proto protoreflect.FileDescriptor

const file_topodata_proto_rawDesc = "" +
	"\n" +
	"\x0etopodata.proto\x12\btopodata\x1a\fvttime.proto\"2\n" +
	"\bKeyRange\x12\x14\n" +
	"\x05start\x18\x01 \x01(\fR\x05start\x12\x10\n" +
	"\x03end\x18\x02 \x01(\fR\x03end\"3\n" +
	"\vTabletAlias\x12\x12\n" +
	"\x04cell\x18\x01 \x01(\tR\x04cell\x12\x10\n" +
	"\x03uid\x18\x02 \x01(\rR\x03uid\"\xba\x05\n" +
	"\x06Tablet\x12+\n" +
	"\x05alias\x18\x01 \x01(\v2\x15.topodata.TabletAliasR\x05alias\x12\x1a\n" +
	"\bhostname\x18\x02 \x01(\tR\bhostname\x128\n" +
	"\bport_map\x18\x04 \x03(\v2\x1d.topodata.Tablet.PortMapEntryR\aportMap\x12\x1a\n" +
	"\bkeyspace\x18\x05 \x01(\tR\bkeyspace\x12\x14\n" +
	"\x05shard\x18\x06 \x01(\tR\x05shard\x12/\n" +
	"\tkey_range\x18\a \x01(\v2\x12.topodata.KeyRangeR\bkeyRange\x12(\n" +
	"\x04type\x18\b \x01(\x0e2\x14.topodata.TabletTypeR\x04type\x12(\n" +
	"\x10db_name_override\x18\t \x01(\tR\x0edbNameOverride\x12.\n" +
	"\x04tags\x18\n" +
	" \x03(\v2\x1a.topodata.Tablet.TagsEntryR\x04tags\x12%\n" +
	"\x0emysql_hostname\x18\f \x01(\tR\rmysqlHostname\x12\x1d\n" +
	"\n" +
	"mysql_port\x18\r \x01(\x05R\tmysqlPort\x12C\n" +
	"\x17primary_term_start_time\x18\x0e \x01(\v2\f.vttime.TimeR\x14primaryTermStartTime\x124\n" +
	"\x16default_conn_collation\x18\x10 \x01(\rR\x14defaultConnCollation\x1a:\n" +
	"\fPortMapEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\x05R\x05value:\x028\x01\x1a7\n" +
	"\tTagsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01J\x04\b\x03\x10\x04J\x04\b\v\x10\fJ\x04\b\x0f\x10\x10\"\xbc\x05\n" +
	"\x05Shard\x12:\n" +
	"\rprimary_alias\x18\x01 \x01(\v2\x15.topodata.TabletAliasR\fprimaryAlias\x12C\n" +
	"\x17primary_term_start_time\x18\b \x01(\v2\f.vttime.TimeR\x14primaryTermStartTime\x12/\n" +
	"\tkey_range\x18\x02 \x01(\v2\x12.topodata.KeyRangeR\bkeyRange\x12@\n" +
	"\rsource_shards\x18\x04 \x03(\v2\x1b.topodata.Shard.SourceShardR\fsourceShards\x12F\n" +
	"\x0ftablet_controls\x18\x06 \x03(\v2\x1d.topodata.Shard.TabletControlR\x0etabletControls\x12,\n" +
	"\x12is_primary_serving\x18\a \x01(\bR\x10isPrimaryServing\x1a\x9a\x01\n" +
	"\vSourceShard\x12\x10\n" +
	"\x03uid\x18\x01 \x01(\x05R\x03uid\x12\x1a\n" +
	"\bkeyspace\x18\x02 \x01(\tR\bkeyspace\x12\x14\n" +
	"\x05shard\x18\x03 \x01(\tR\x05shard\x12/\n" +
	"\tkey_range\x18\x04 \x01(\v2\x12.topodata.KeyRangeR\bkeyRange\x12\x16\n" +
	"\x06tables\x18\x05 \x03(\tR\x06tables\x1a\x9f\x01\n" +
	"\rTabletControl\x125\n" +
	"\vtablet_type\x18\x01 \x01(\x0e2\x14.topodata.TabletTypeR\n" +
	"tabletType\x12\x14\n" +
	"\x05cells\x18\x02 \x03(\tR\x05cells\x12#\n" +
	"\rdenied_tables\x18\x04 \x03(\tR\fdeniedTables\x12\x16\n" +
	"\x06frozen\x18\x05 \x01(\bR\x06frozenJ\x04\b\x03\x10\x04J\x04\b\x03\x10\x04J\x04\b\x05\x10\x06\"\xd2\x02\n" +
	"\bKeyspace\x12;\n" +
	"\rkeyspace_type\x18\x05 \x01(\x0e2\x16.topodata.KeyspaceTypeR\fkeyspaceType\x12#\n" +
	"\rbase_keyspace\x18\x06 \x01(\tR\fbaseKeyspace\x121\n" +
	"\rsnapshot_time\x18\a \x01(\v2\f.vttime.TimeR\fsnapshotTime\x12+\n" +
	"\x11durability_policy\x18\b \x01(\tR\x10durabilityPolicy\x12D\n" +
	"\x10throttler_config\x18\t \x01(\v2\x19.topodata.ThrottlerConfigR\x0fthrottlerConfig\x12&\n" +
	"\x0fsidecar_db_name\x18\n" +
	" \x01(\tR\rsidecarDbNameJ\x04\b\x01\x10\x02J\x04\b\x02\x10\x03J\x04\b\x03\x10\x04J\x04\b\x04\x10\x05\"\x8b\x01\n" +
	"\x10ShardReplication\x125\n" +
	"\x05nodes\x18\x01 \x03(\v2\x1f.topodata.ShardReplication.NodeR\x05nodes\x1a@\n" +
	"\x04Node\x128\n" +
	"\ftablet_alias\x18\x01 \x01(\v2\x15.topodata.TabletAliasR\vtabletAlias\"\xc6\x01\n" +
	"\x15ShardReplicationError\x128\n" +
	"\x04type\x18\x01 \x01(\x0e2$.topodata.ShardReplicationError.TypeR\x04type\x128\n" +
	"\ftablet_alias\x18\x02 \x01(\v2\x15.topodata.TabletAliasR\vtabletAlias\"9\n" +
	"\x04Type\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\r\n" +
	"\tNOT_FOUND\x10\x01\x12\x15\n" +
	"\x11TOPOLOGY_MISMATCH\x10\x02\"U\n" +
	"\x0eShardReference\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12/\n" +
	"\tkey_range\x18\x02 \x01(\v2\x12.topodata.KeyRangeR\bkeyRange\"\x8f\x01\n" +
	"\x12ShardTabletControl\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12/\n" +
	"\tkey_range\x18\x02 \x01(\v2\x12.topodata.KeyRangeR\bkeyRange\x124\n" +
	"\x16query_service_disabled\x18\x03 \x01(\bR\x14queryServiceDisabled\"\x81\x01\n" +
	"\x10ThrottledAppRule\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x14\n" +
	"\x05ratio\x18\x02 \x01(\x01R\x05ratio\x12+\n" +
	"\n" +
	"expires_at\x18\x03 \x01(\v2\f.vttime.TimeR\texpiresAt\x12\x16\n" +
	"\x06exempt\x18\x04 \x01(\bR\x06exempt\"\xe5\x05\n" +
	"\x0fThrottlerConfig\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x12\x1c\n" +
	"\tthreshold\x18\x02 \x01(\x01R\tthreshold\x12!\n" +
	"\fcustom_query\x18\x03 \x01(\tR\vcustomQuery\x12-\n" +
	"\x13check_as_check_self\x18\x04 \x01(\bR\x10checkAsCheckSelf\x12S\n" +
	"\x0ethrottled_apps\x18\x05 \x03(\v2,.topodata.ThrottlerConfig.ThrottledAppsEntryR\rthrottledApps\x12`\n" +
	"\x13app_checked_metrics\x18\x06 \x03(\v20.topodata.ThrottlerConfig.AppCheckedMetricsEntryR\x11appCheckedMetrics\x12\\\n" +
	"\x11metric_thresholds\x18\a \x03(\v2/.topodata.ThrottlerConfig.MetricThresholdsEntryR\x10metricThresholds\x1a\\\n" +
	"\x12ThrottledAppsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x120\n" +
	"\x05value\x18\x02 \x01(\v2\x1a.topodata.ThrottledAppRuleR\x05value:\x028\x01\x1a#\n" +
	"\vMetricNames\x12\x14\n" +
	"\x05names\x18\x01 \x03(\tR\x05names\x1ak\n" +
	"\x16AppCheckedMetricsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12;\n" +
	"\x05value\x18\x02 \x01(\v2%.topodata.ThrottlerConfig.MetricNamesR\x05value:\x028\x01\x1aC\n" +
	"\x15MetricThresholdsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\x01R\x05value:\x028\x01\"\x98\x03\n" +
	"\vSrvKeyspace\x12G\n" +
	"\n" +
	"partitions\x18\x01 \x03(\v2'.topodata.SrvKeyspace.KeyspacePartitionR\n" +
	"partitions\x12D\n" +
	"\x10throttler_config\x18\x06 \x01(\v2\x19.topodata.ThrottlerConfigR\x0fthrottlerConfig\x1a\xe1\x01\n" +
	"\x11KeyspacePartition\x125\n" +
	"\vserved_type\x18\x01 \x01(\x0e2\x14.topodata.TabletTypeR\n" +
	"servedType\x12C\n" +
	"\x10shard_references\x18\x02 \x03(\v2\x18.topodata.ShardReferenceR\x0fshardReferences\x12P\n" +
	"\x15shard_tablet_controls\x18\x03 \x03(\v2\x1c.topodata.ShardTabletControlR\x13shardTabletControlsJ\x04\b\x02\x10\x03J\x04\b\x03\x10\x04J\x04\b\x04\x10\x05J\x04\b\x05\x10\x06\"K\n" +
	"\bCellInfo\x12%\n" +
	"\x0eserver_address\x18\x01 \x01(\tR\rserverAddress\x12\x12\n" +
	"\x04root\x18\x02 \x01(\tR\x04rootJ\x04\b\x03\x10\x04\"\"\n" +
	"\n" +
	"CellsAlias\x12\x14\n" +
	"\x05cells\x18\x02 \x03(\tR\x05cells\"U\n" +
	"\n" +
	"TopoConfig\x12\x1b\n" +
	"\ttopo_type\x18\x01 \x01(\tR\btopoType\x12\x16\n" +
	"\x06server\x18\x02 \x01(\tR\x06server\x12\x12\n" +
	"\x04root\x18\x03 \x01(\tR\x04root\"N\n" +
	"\x15ExternalVitessCluster\x125\n" +
	"\vtopo_config\x18\x01 \x01(\v2\x14.topodata.TopoConfigR\n" +
	"topoConfig\"Z\n" +
	"\x10ExternalClusters\x12F\n" +
	"\x0evitess_cluster\x18\x01 \x03(\v2\x1f.topodata.ExternalVitessClusterR\rvitessCluster*(\n" +
	"\fKeyspaceType\x12\n" +
	"\n" +
	"\x06NORMAL\x10\x00\x12\f\n" +
	"\bSNAPSHOT\x10\x01*\x9d\x01\n" +
	"\n" +
	"TabletType\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\v\n" +
	"\aPRIMARY\x10\x01\x12\n" +
	"\n" +
	"\x06MASTER\x10\x01\x12\v\n" +
	"\aREPLICA\x10\x02\x12\n" +
	"\n" +
	"\x06RDONLY\x10\x03\x12\t\n" +
	"\x05BATCH\x10\x03\x12\t\n" +
	"\x05SPARE\x10\x04\x12\x10\n" +
	"\fEXPERIMENTAL\x10\x05\x12\n" +
	"\n" +
	"\x06BACKUP\x10\x06\x12\v\n" +
	"\aRESTORE\x10\a\x12\v\n" +
	"\aDRAINED\x10\b\x1a\x02\x10\x01B8\n" +
	"\x0fio.vitess.protoZ%vitess.io/vitess/go/vt/proto/topodatab\x06proto3"

var (
	file_topodata_proto_rawDescOnce sync.Once
	file_topodata_proto_rawDescData []byte
)

func file_topodata_proto_rawDescGZIP() []byte {
	file_topodata_proto_rawDescOnce.Do(func() {
		file_topodata_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_topodata_proto_rawDesc), len(file_topodata_proto_rawDesc)))
	})
	return file_topodata_proto_rawDescData
}

var file_topodata_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_topodata_proto_msgTypes = make([]protoimpl.MessageInfo, 27)
var file_topodata_proto_goTypes = []any{
	(KeyspaceType)(0),                     // 0: topodata.KeyspaceType
	(TabletType)(0),                       // 1: topodata.TabletType
	(ShardReplicationError_Type)(0),       // 2: topodata.ShardReplicationError.Type
	(*KeyRange)(nil),                      // 3: topodata.KeyRange
	(*TabletAlias)(nil),                   // 4: topodata.TabletAlias
	(*Tablet)(nil),                        // 5: topodata.Tablet
	(*Shard)(nil),                         // 6: topodata.Shard
	(*Keyspace)(nil),                      // 7: topodata.Keyspace
	(*ShardReplication)(nil),              // 8: topodata.ShardReplication
	(*ShardReplicationError)(nil),         // 9: topodata.ShardReplicationError
	(*ShardReference)(nil),                // 10: topodata.ShardReference
	(*ShardTabletControl)(nil),            // 11: topodata.ShardTabletControl
	(*ThrottledAppRule)(nil),              // 12: topodata.ThrottledAppRule
	(*ThrottlerConfig)(nil),               // 13: topodata.ThrottlerConfig
	(*SrvKeyspace)(nil),                   // 14: topodata.SrvKeyspace
	(*CellInfo)(nil),                      // 15: topodata.CellInfo
	(*CellsAlias)(nil),                    // 16: topodata.CellsAlias
	(*TopoConfig)(nil),                    // 17: topodata.TopoConfig
	(*ExternalVitessCluster)(nil),         // 18: topodata.ExternalVitessCluster
	(*ExternalClusters)(nil),              // 19: topodata.ExternalClusters
	nil,                                   // 20: topodata.Tablet.PortMapEntry
	nil,                                   // 21: topodata.Tablet.TagsEntry
	(*Shard_SourceShard)(nil),             // 22: topodata.Shard.SourceShard
	(*Shard_TabletControl)(nil),           // 23: topodata.Shard.TabletControl
	(*ShardReplication_Node)(nil),         // 24: topodata.ShardReplication.Node
	nil,                                   // 25: topodata.ThrottlerConfig.ThrottledAppsEntry
	(*ThrottlerConfig_MetricNames)(nil),   // 26: topodata.ThrottlerConfig.MetricNames
	nil,                                   // 27: topodata.ThrottlerConfig.AppCheckedMetricsEntry
	nil,                                   // 28: topodata.ThrottlerConfig.MetricThresholdsEntry
	(*SrvKeyspace_KeyspacePartition)(nil), // 29: topodata.SrvKeyspace.KeyspacePartition
	(*vttime.Time)(nil),                   // 30: vttime.Time
}
var file_topodata_proto_depIdxs = []int32{
	4,  // 0: topodata.Tablet.alias:type_name -> topodata.TabletAlias
	20, // 1: topodata.Tablet.port_map:type_name -> topodata.Tablet.PortMapEntry
	3,  // 2: topodata.Tablet.key_range:type_name -> topodata.KeyRange
	1,  // 3: topodata.Tablet.type:type_name -> topodata.TabletType
	21, // 4: topodata.Tablet.tags:type_name -> topodata.Tablet.TagsEntry
	30, // 5: topodata.Tablet.primary_term_start_time:type_name -> vttime.Time
	4,  // 6: topodata.Shard.primary_alias:type_name -> topodata.TabletAlias
	30, // 7: topodata.Shard.primary_term_start_time:type_name -> vttime.Time
	3,  // 8: topodata.Shard.key_range:type_name -> topodata.KeyRange
	22, // 9: topodata.Shard.source_shards:type_name -> topodata.Shard.SourceShard
	23, // 10: topodata.Shard.tablet_controls:type_name -> topodata.Shard.TabletControl
	0,  // 11: topodata.Keyspace.keyspace_type:type_name -> topodata.KeyspaceType
	30, // 12: topodata.Keyspace.snapshot_time:type_name -> vttime.Time
	13, // 13: topodata.Keyspace.throttler_config:type_name -> topodata.ThrottlerConfig
	24, // 14: topodata.ShardReplication.nodes:type_name -> topodata.ShardReplication.Node
	2,  // 15: topodata.ShardReplicationError.type:type_name -> topodata.ShardReplicationError.Type
	4,  // 16: topodata.ShardReplicationError.tablet_alias:type_name -> topodata.TabletAlias
	3,  // 17: topodata.ShardReference.key_range:type_name -> topodata.KeyRange
	3,  // 18: topodata.ShardTabletControl.key_range:type_name -> topodata.KeyRange
	30, // 19: topodata.ThrottledAppRule.expires_at:type_name -> vttime.Time
	25, // 20: topodata.ThrottlerConfig.throttled_apps:type_name -> topodata.ThrottlerConfig.ThrottledAppsEntry
	27, // 21: topodata.ThrottlerConfig.app_checked_metrics:type_name -> topodata.ThrottlerConfig.AppCheckedMetricsEntry
	28, // 22: topodata.ThrottlerConfig.metric_thresholds:type_name -> topodata.ThrottlerConfig.MetricThresholdsEntry
	29, // 23: topodata.SrvKeyspace.partitions:type_name -> topodata.SrvKeyspace.KeyspacePartition
	13, // 24: topodata.SrvKeyspace.throttler_config:type_name -> topodata.ThrottlerConfig
	17, // 25: topodata.ExternalVitessCluster.topo_config:type_name -> topodata.TopoConfig
	18, // 26: topodata.ExternalClusters.vitess_cluster:type_name -> topodata.ExternalVitessCluster
	3,  // 27: topodata.Shard.SourceShard.key_range:type_name -> topodata.KeyRange
	1,  // 28: topodata.Shard.TabletControl.tablet_type:type_name -> topodata.TabletType
	4,  // 29: topodata.ShardReplication.Node.tablet_alias:type_name -> topodata.TabletAlias
	12, // 30: topodata.ThrottlerConfig.ThrottledAppsEntry.value:type_name -> topodata.ThrottledAppRule
	26, // 31: topodata.ThrottlerConfig.AppCheckedMetricsEntry.value:type_name -> topodata.ThrottlerConfig.MetricNames
	1,  // 32: topodata.SrvKeyspace.KeyspacePartition.served_type:type_name -> topodata.TabletType
	10, // 33: topodata.SrvKeyspace.KeyspacePartition.shard_references:type_name -> topodata.ShardReference
	11, // 34: topodata.SrvKeyspace.KeyspacePartition.shard_tablet_controls:type_name -> topodata.ShardTabletControl
	35, // [35:35] is the sub-list for method output_type
	35, // [35:35] is the sub-list for method input_type
	35, // [35:35] is the sub-list for extension type_name
	35, // [35:35] is the sub-list for extension extendee
	0,  // [0:35] is the sub-list for field type_name
}

func init() { file_topodata_proto_init() }
func file_topodata_proto_init() {
	if File_topodata_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_topodata_proto_rawDesc), len(file_topodata_proto_rawDesc)),
			NumEnums:      3,
			NumMessages:   27,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_topodata_proto_goTypes,
		DependencyIndexes: file_topodata_proto_depIdxs,
		EnumInfos:         file_topodata_proto_enumTypes,
		MessageInfos:      file_topodata_proto_msgTypes,
	}.Build()
	File_topodata_proto = out.File
	file_topodata_proto_goTypes = nil
	file_topodata_proto_depIdxs = nil
}
