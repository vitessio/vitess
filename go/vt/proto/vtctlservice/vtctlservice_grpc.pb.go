// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package vtctlservice

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	vtctldata "vitess.io/vitess/go/vt/proto/vtctldata"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// VtctlClient is the client API for Vtctl service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VtctlClient interface {
	ExecuteVtctlCommand(ctx context.Context, in *vtctldata.ExecuteVtctlCommandRequest, opts ...grpc.CallOption) (Vtctl_ExecuteVtctlCommandClient, error)
}

type vtctlClient struct {
	cc grpc.ClientConnInterface
}

func NewVtctlClient(cc grpc.ClientConnInterface) VtctlClient {
	return &vtctlClient{cc}
}

func (c *vtctlClient) ExecuteVtctlCommand(ctx context.Context, in *vtctldata.ExecuteVtctlCommandRequest, opts ...grpc.CallOption) (Vtctl_ExecuteVtctlCommandClient, error) {
	stream, err := c.cc.NewStream(ctx, &Vtctl_ServiceDesc.Streams[0], "/vtctlservice.Vtctl/ExecuteVtctlCommand", opts...)
	if err != nil {
		return nil, err
	}
	x := &vtctlExecuteVtctlCommandClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Vtctl_ExecuteVtctlCommandClient interface {
	Recv() (*vtctldata.ExecuteVtctlCommandResponse, error)
	grpc.ClientStream
}

type vtctlExecuteVtctlCommandClient struct {
	grpc.ClientStream
}

func (x *vtctlExecuteVtctlCommandClient) Recv() (*vtctldata.ExecuteVtctlCommandResponse, error) {
	m := new(vtctldata.ExecuteVtctlCommandResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// VtctlServer is the server API for Vtctl service.
// All implementations must embed UnimplementedVtctlServer
// for forward compatibility
type VtctlServer interface {
	ExecuteVtctlCommand(*vtctldata.ExecuteVtctlCommandRequest, Vtctl_ExecuteVtctlCommandServer) error
	mustEmbedUnimplementedVtctlServer()
}

// UnimplementedVtctlServer must be embedded to have forward compatible implementations.
type UnimplementedVtctlServer struct {
}

func (UnimplementedVtctlServer) ExecuteVtctlCommand(*vtctldata.ExecuteVtctlCommandRequest, Vtctl_ExecuteVtctlCommandServer) error {
	return status.Errorf(codes.Unimplemented, "method ExecuteVtctlCommand not implemented")
}
func (UnimplementedVtctlServer) mustEmbedUnimplementedVtctlServer() {}

// UnsafeVtctlServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VtctlServer will
// result in compilation errors.
type UnsafeVtctlServer interface {
	mustEmbedUnimplementedVtctlServer()
}

func RegisterVtctlServer(s grpc.ServiceRegistrar, srv VtctlServer) {
	s.RegisterService(&Vtctl_ServiceDesc, srv)
}

func _Vtctl_ExecuteVtctlCommand_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(vtctldata.ExecuteVtctlCommandRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VtctlServer).ExecuteVtctlCommand(m, &vtctlExecuteVtctlCommandServer{stream})
}

type Vtctl_ExecuteVtctlCommandServer interface {
	Send(*vtctldata.ExecuteVtctlCommandResponse) error
	grpc.ServerStream
}

type vtctlExecuteVtctlCommandServer struct {
	grpc.ServerStream
}

func (x *vtctlExecuteVtctlCommandServer) Send(m *vtctldata.ExecuteVtctlCommandResponse) error {
	return x.ServerStream.SendMsg(m)
}

// Vtctl_ServiceDesc is the grpc.ServiceDesc for Vtctl service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Vtctl_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "vtctlservice.Vtctl",
	HandlerType: (*VtctlServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ExecuteVtctlCommand",
			Handler:       _Vtctl_ExecuteVtctlCommand_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "vtctlservice.proto",
}

// VtctldClient is the client API for Vtctld service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VtctldClient interface {
	// AddCellInfo registers a local topology service in a new cell by creating
	// the CellInfo with the provided parameters.
	AddCellInfo(ctx context.Context, in *vtctldata.AddCellInfoRequest, opts ...grpc.CallOption) (*vtctldata.AddCellInfoResponse, error)
	// AddCellsAlias defines a group of cells that can be referenced by a single
	// name (the alias).
	//
	// When routing query traffic, replica/rdonly traffic can be routed across
	// cells within the group (alias). Only primary traffic can be routed across
	// cells not in the same group (alias).
	AddCellsAlias(ctx context.Context, in *vtctldata.AddCellsAliasRequest, opts ...grpc.CallOption) (*vtctldata.AddCellsAliasResponse, error)
	// ApplyRoutingRules applies the VSchema routing rules.
	ApplyRoutingRules(ctx context.Context, in *vtctldata.ApplyRoutingRulesRequest, opts ...grpc.CallOption) (*vtctldata.ApplyRoutingRulesResponse, error)
	// ApplyVSchema applies a vschema to a keyspace.
	ApplyVSchema(ctx context.Context, in *vtctldata.ApplyVSchemaRequest, opts ...grpc.CallOption) (*vtctldata.ApplyVSchemaResponse, error)
	// ChangeTabletType changes the db type for the specified tablet, if possible.
	// This is used primarily to arrange replicas, and it will not convert a
	// primary. For that, use InitShardPrimary.
	//
	// NOTE: This command automatically updates the serving graph.
	ChangeTabletType(ctx context.Context, in *vtctldata.ChangeTabletTypeRequest, opts ...grpc.CallOption) (*vtctldata.ChangeTabletTypeResponse, error)
	// CreateKeyspace creates the specified keyspace in the topology. For a
	// SNAPSHOT keyspace, the request must specify the name of a base keyspace,
	// as well as a snapshot time.
	CreateKeyspace(ctx context.Context, in *vtctldata.CreateKeyspaceRequest, opts ...grpc.CallOption) (*vtctldata.CreateKeyspaceResponse, error)
	// CreateShard creates the specified shard in the topology.
	CreateShard(ctx context.Context, in *vtctldata.CreateShardRequest, opts ...grpc.CallOption) (*vtctldata.CreateShardResponse, error)
	// DeleteCellInfo deletes the CellInfo for the provided cell. The cell cannot
	// be referenced by any Shard record in the topology.
	DeleteCellInfo(ctx context.Context, in *vtctldata.DeleteCellInfoRequest, opts ...grpc.CallOption) (*vtctldata.DeleteCellInfoResponse, error)
	// DeleteCellsAlias deletes the CellsAlias for the provided alias.
	DeleteCellsAlias(ctx context.Context, in *vtctldata.DeleteCellsAliasRequest, opts ...grpc.CallOption) (*vtctldata.DeleteCellsAliasResponse, error)
	// DeleteKeyspace deletes the specified keyspace from the topology. In
	// recursive mode, it also recursively deletes all shards in the keyspace.
	// Otherwise, the keyspace must be empty (have no shards), or DeleteKeyspace
	// returns an error.
	DeleteKeyspace(ctx context.Context, in *vtctldata.DeleteKeyspaceRequest, opts ...grpc.CallOption) (*vtctldata.DeleteKeyspaceResponse, error)
	// DeleteShards deletes the specified shards from the topology. In recursive
	// mode, it also deletes all tablets belonging to the shard. Otherwise, the
	// shard must be empty (have no tablets) or DeleteShards returns an error for
	// that shard.
	DeleteShards(ctx context.Context, in *vtctldata.DeleteShardsRequest, opts ...grpc.CallOption) (*vtctldata.DeleteShardsResponse, error)
	// DeleteTablets deletes one or more tablets from the topology.
	DeleteTablets(ctx context.Context, in *vtctldata.DeleteTabletsRequest, opts ...grpc.CallOption) (*vtctldata.DeleteTabletsResponse, error)
	// EmergencyReparentShard reparents the shard to the new primary. It assumes
	// the old primary is dead or otherwise not responding.
	EmergencyReparentShard(ctx context.Context, in *vtctldata.EmergencyReparentShardRequest, opts ...grpc.CallOption) (*vtctldata.EmergencyReparentShardResponse, error)
	// FindAllShardsInKeyspace returns a map of shard names to shard references
	// for a given keyspace.
	FindAllShardsInKeyspace(ctx context.Context, in *vtctldata.FindAllShardsInKeyspaceRequest, opts ...grpc.CallOption) (*vtctldata.FindAllShardsInKeyspaceResponse, error)
	// GetBackups returns all the backups for a shard.
	GetBackups(ctx context.Context, in *vtctldata.GetBackupsRequest, opts ...grpc.CallOption) (*vtctldata.GetBackupsResponse, error)
	// GetCellInfo returns the information for a cell.
	GetCellInfo(ctx context.Context, in *vtctldata.GetCellInfoRequest, opts ...grpc.CallOption) (*vtctldata.GetCellInfoResponse, error)
	// GetCellInfoNames returns all the cells for which we have a CellInfo object,
	// meaning we have a topology service registered.
	GetCellInfoNames(ctx context.Context, in *vtctldata.GetCellInfoNamesRequest, opts ...grpc.CallOption) (*vtctldata.GetCellInfoNamesResponse, error)
	// GetCellsAliases returns a mapping of cell alias to cells identified by that
	// alias.
	GetCellsAliases(ctx context.Context, in *vtctldata.GetCellsAliasesRequest, opts ...grpc.CallOption) (*vtctldata.GetCellsAliasesResponse, error)
	// GetKeyspace reads the given keyspace from the topo and returns it.
	GetKeyspace(ctx context.Context, in *vtctldata.GetKeyspaceRequest, opts ...grpc.CallOption) (*vtctldata.GetKeyspaceResponse, error)
	// GetKeyspaces returns the keyspace struct of all keyspaces in the topo.
	GetKeyspaces(ctx context.Context, in *vtctldata.GetKeyspacesRequest, opts ...grpc.CallOption) (*vtctldata.GetKeyspacesResponse, error)
	// GetRoutingRules returns the VSchema routing rules.
	GetRoutingRules(ctx context.Context, in *vtctldata.GetRoutingRulesRequest, opts ...grpc.CallOption) (*vtctldata.GetRoutingRulesResponse, error)
	// GetSchema returns the schema for a tablet, or just the schema for the
	// specified tables in that tablet.
	GetSchema(ctx context.Context, in *vtctldata.GetSchemaRequest, opts ...grpc.CallOption) (*vtctldata.GetSchemaResponse, error)
	// GetShard returns information about a shard in the topology.
	GetShard(ctx context.Context, in *vtctldata.GetShardRequest, opts ...grpc.CallOption) (*vtctldata.GetShardResponse, error)
	// GetSrvKeyspaces returns the SrvKeyspaces for a keyspace in one or more
	// cells.
	GetSrvKeyspaces(ctx context.Context, in *vtctldata.GetSrvKeyspacesRequest, opts ...grpc.CallOption) (*vtctldata.GetSrvKeyspacesResponse, error)
	// GetSrvVSchema returns the SrvVSchema for a cell.
	GetSrvVSchema(ctx context.Context, in *vtctldata.GetSrvVSchemaRequest, opts ...grpc.CallOption) (*vtctldata.GetSrvVSchemaResponse, error)
	// GetSrvVSchemas returns a mapping from cell name to SrvVSchema for all cells,
	// optionally filtered by cell name.
	GetSrvVSchemas(ctx context.Context, in *vtctldata.GetSrvVSchemasRequest, opts ...grpc.CallOption) (*vtctldata.GetSrvVSchemasResponse, error)
	// GetTablet returns information about a tablet.
	GetTablet(ctx context.Context, in *vtctldata.GetTabletRequest, opts ...grpc.CallOption) (*vtctldata.GetTabletResponse, error)
	// GetTablets returns tablets, optionally filtered by keyspace and shard.
	GetTablets(ctx context.Context, in *vtctldata.GetTabletsRequest, opts ...grpc.CallOption) (*vtctldata.GetTabletsResponse, error)
	// GetVSchema returns the vschema for a keyspace.
	GetVSchema(ctx context.Context, in *vtctldata.GetVSchemaRequest, opts ...grpc.CallOption) (*vtctldata.GetVSchemaResponse, error)
	// GetWorkflows returns a list of workflows for the given keyspace.
	GetWorkflows(ctx context.Context, in *vtctldata.GetWorkflowsRequest, opts ...grpc.CallOption) (*vtctldata.GetWorkflowsResponse, error)
	// InitShardPrimary sets the initial primary for a shard. Will make all other
	// tablets in the shard replicas of the provided primary.
	//
	// WARNING: This could cause data loss on an already replicating shard.
	// PlannedReparentShard or EmergencyReparentShard should be used in those
	// cases instead.
	InitShardPrimary(ctx context.Context, in *vtctldata.InitShardPrimaryRequest, opts ...grpc.CallOption) (*vtctldata.InitShardPrimaryResponse, error)
	// PlannedReparentShard reparents the shard to the new primary, or away from
	// an old primary. Both the old and new primaries need to be reachable and
	// running.
	//
	// **NOTE**: The vtctld will not consider any replicas outside the cell the
	// current shard primary is in for promotion unless NewPrimary is explicitly
	// provided in the request.
	PlannedReparentShard(ctx context.Context, in *vtctldata.PlannedReparentShardRequest, opts ...grpc.CallOption) (*vtctldata.PlannedReparentShardResponse, error)
	// RebuildVSchemaGraph rebuilds the per-cell SrvVSchema from the global
	// VSchema objects in the provided cells (or all cells in the topo none
	// provided).
	RebuildVSchemaGraph(ctx context.Context, in *vtctldata.RebuildVSchemaGraphRequest, opts ...grpc.CallOption) (*vtctldata.RebuildVSchemaGraphResponse, error)
	// RefreshState reloads the tablet record on the specified tablet.
	RefreshState(ctx context.Context, in *vtctldata.RefreshStateRequest, opts ...grpc.CallOption) (*vtctldata.RefreshStateResponse, error)
	// RefreshStateByShard calls RefreshState on all the tablets in the given shard.
	RefreshStateByShard(ctx context.Context, in *vtctldata.RefreshStateByShardRequest, opts ...grpc.CallOption) (*vtctldata.RefreshStateByShardResponse, error)
	// RemoveKeyspaceCell removes the specified cell from the Cells list for all
	// shards in the specified keyspace, as well as from the SrvKeyspace for that
	// keyspace in that cell.
	RemoveKeyspaceCell(ctx context.Context, in *vtctldata.RemoveKeyspaceCellRequest, opts ...grpc.CallOption) (*vtctldata.RemoveKeyspaceCellResponse, error)
	// RemoveShardCell removes the specified cell from the specified shard's Cells
	// list.
	RemoveShardCell(ctx context.Context, in *vtctldata.RemoveShardCellRequest, opts ...grpc.CallOption) (*vtctldata.RemoveShardCellResponse, error)
	// ReparentTablet reparents a tablet to the current primary in the shard. This
	// only works if the current replica position matches the last known reparent
	// action.
	ReparentTablet(ctx context.Context, in *vtctldata.ReparentTabletRequest, opts ...grpc.CallOption) (*vtctldata.ReparentTabletResponse, error)
	// ShardReplicationPositions returns the replication position of each tablet
	// in a shard. This RPC makes a best-effort to return partial results. For
	// example, if one tablet in the shard graph is unreachable, then
	// ShardReplicationPositions will return non-error, and include valid results
	// for the reachable tablets.
	ShardReplicationPositions(ctx context.Context, in *vtctldata.ShardReplicationPositionsRequest, opts ...grpc.CallOption) (*vtctldata.ShardReplicationPositionsResponse, error)
	// TabletExternallyReparented changes metadata in the topology server to
	// acknowledge a shard primary change performed by an external tool (e.g.
	// orchestrator).
	//
	// See the Reparenting guide for more information:
	// https://vitess.io/docs/user-guides/configuration-advanced/reparenting/#external-reparenting.
	TabletExternallyReparented(ctx context.Context, in *vtctldata.TabletExternallyReparentedRequest, opts ...grpc.CallOption) (*vtctldata.TabletExternallyReparentedResponse, error)
	// UpdateCellInfo updates the content of a CellInfo with the provided
	// parameters. Empty values are ignored. If the cell does not exist, the
	// CellInfo will be created.
	UpdateCellInfo(ctx context.Context, in *vtctldata.UpdateCellInfoRequest, opts ...grpc.CallOption) (*vtctldata.UpdateCellInfoResponse, error)
	// UpdateCellsAlias updates the content of a CellsAlias with the provided
	// parameters. Empty values are ignored. If the alias does not exist, the
	// CellsAlias will be created.
	UpdateCellsAlias(ctx context.Context, in *vtctldata.UpdateCellsAliasRequest, opts ...grpc.CallOption) (*vtctldata.UpdateCellsAliasResponse, error)
}

type vtctldClient struct {
	cc grpc.ClientConnInterface
}

func NewVtctldClient(cc grpc.ClientConnInterface) VtctldClient {
	return &vtctldClient{cc}
}

func (c *vtctldClient) AddCellInfo(ctx context.Context, in *vtctldata.AddCellInfoRequest, opts ...grpc.CallOption) (*vtctldata.AddCellInfoResponse, error) {
	out := new(vtctldata.AddCellInfoResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/AddCellInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) AddCellsAlias(ctx context.Context, in *vtctldata.AddCellsAliasRequest, opts ...grpc.CallOption) (*vtctldata.AddCellsAliasResponse, error) {
	out := new(vtctldata.AddCellsAliasResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/AddCellsAlias", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) ApplyRoutingRules(ctx context.Context, in *vtctldata.ApplyRoutingRulesRequest, opts ...grpc.CallOption) (*vtctldata.ApplyRoutingRulesResponse, error) {
	out := new(vtctldata.ApplyRoutingRulesResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/ApplyRoutingRules", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) ApplyVSchema(ctx context.Context, in *vtctldata.ApplyVSchemaRequest, opts ...grpc.CallOption) (*vtctldata.ApplyVSchemaResponse, error) {
	out := new(vtctldata.ApplyVSchemaResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/ApplyVSchema", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) ChangeTabletType(ctx context.Context, in *vtctldata.ChangeTabletTypeRequest, opts ...grpc.CallOption) (*vtctldata.ChangeTabletTypeResponse, error) {
	out := new(vtctldata.ChangeTabletTypeResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/ChangeTabletType", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) CreateKeyspace(ctx context.Context, in *vtctldata.CreateKeyspaceRequest, opts ...grpc.CallOption) (*vtctldata.CreateKeyspaceResponse, error) {
	out := new(vtctldata.CreateKeyspaceResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/CreateKeyspace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) CreateShard(ctx context.Context, in *vtctldata.CreateShardRequest, opts ...grpc.CallOption) (*vtctldata.CreateShardResponse, error) {
	out := new(vtctldata.CreateShardResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/CreateShard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) DeleteCellInfo(ctx context.Context, in *vtctldata.DeleteCellInfoRequest, opts ...grpc.CallOption) (*vtctldata.DeleteCellInfoResponse, error) {
	out := new(vtctldata.DeleteCellInfoResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/DeleteCellInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) DeleteCellsAlias(ctx context.Context, in *vtctldata.DeleteCellsAliasRequest, opts ...grpc.CallOption) (*vtctldata.DeleteCellsAliasResponse, error) {
	out := new(vtctldata.DeleteCellsAliasResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/DeleteCellsAlias", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) DeleteKeyspace(ctx context.Context, in *vtctldata.DeleteKeyspaceRequest, opts ...grpc.CallOption) (*vtctldata.DeleteKeyspaceResponse, error) {
	out := new(vtctldata.DeleteKeyspaceResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/DeleteKeyspace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) DeleteShards(ctx context.Context, in *vtctldata.DeleteShardsRequest, opts ...grpc.CallOption) (*vtctldata.DeleteShardsResponse, error) {
	out := new(vtctldata.DeleteShardsResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/DeleteShards", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) DeleteTablets(ctx context.Context, in *vtctldata.DeleteTabletsRequest, opts ...grpc.CallOption) (*vtctldata.DeleteTabletsResponse, error) {
	out := new(vtctldata.DeleteTabletsResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/DeleteTablets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) EmergencyReparentShard(ctx context.Context, in *vtctldata.EmergencyReparentShardRequest, opts ...grpc.CallOption) (*vtctldata.EmergencyReparentShardResponse, error) {
	out := new(vtctldata.EmergencyReparentShardResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/EmergencyReparentShard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) FindAllShardsInKeyspace(ctx context.Context, in *vtctldata.FindAllShardsInKeyspaceRequest, opts ...grpc.CallOption) (*vtctldata.FindAllShardsInKeyspaceResponse, error) {
	out := new(vtctldata.FindAllShardsInKeyspaceResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/FindAllShardsInKeyspace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetBackups(ctx context.Context, in *vtctldata.GetBackupsRequest, opts ...grpc.CallOption) (*vtctldata.GetBackupsResponse, error) {
	out := new(vtctldata.GetBackupsResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetBackups", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetCellInfo(ctx context.Context, in *vtctldata.GetCellInfoRequest, opts ...grpc.CallOption) (*vtctldata.GetCellInfoResponse, error) {
	out := new(vtctldata.GetCellInfoResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetCellInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetCellInfoNames(ctx context.Context, in *vtctldata.GetCellInfoNamesRequest, opts ...grpc.CallOption) (*vtctldata.GetCellInfoNamesResponse, error) {
	out := new(vtctldata.GetCellInfoNamesResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetCellInfoNames", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetCellsAliases(ctx context.Context, in *vtctldata.GetCellsAliasesRequest, opts ...grpc.CallOption) (*vtctldata.GetCellsAliasesResponse, error) {
	out := new(vtctldata.GetCellsAliasesResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetCellsAliases", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetKeyspace(ctx context.Context, in *vtctldata.GetKeyspaceRequest, opts ...grpc.CallOption) (*vtctldata.GetKeyspaceResponse, error) {
	out := new(vtctldata.GetKeyspaceResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetKeyspace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetKeyspaces(ctx context.Context, in *vtctldata.GetKeyspacesRequest, opts ...grpc.CallOption) (*vtctldata.GetKeyspacesResponse, error) {
	out := new(vtctldata.GetKeyspacesResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetKeyspaces", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetRoutingRules(ctx context.Context, in *vtctldata.GetRoutingRulesRequest, opts ...grpc.CallOption) (*vtctldata.GetRoutingRulesResponse, error) {
	out := new(vtctldata.GetRoutingRulesResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetRoutingRules", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetSchema(ctx context.Context, in *vtctldata.GetSchemaRequest, opts ...grpc.CallOption) (*vtctldata.GetSchemaResponse, error) {
	out := new(vtctldata.GetSchemaResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetSchema", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetShard(ctx context.Context, in *vtctldata.GetShardRequest, opts ...grpc.CallOption) (*vtctldata.GetShardResponse, error) {
	out := new(vtctldata.GetShardResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetShard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetSrvKeyspaces(ctx context.Context, in *vtctldata.GetSrvKeyspacesRequest, opts ...grpc.CallOption) (*vtctldata.GetSrvKeyspacesResponse, error) {
	out := new(vtctldata.GetSrvKeyspacesResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetSrvKeyspaces", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetSrvVSchema(ctx context.Context, in *vtctldata.GetSrvVSchemaRequest, opts ...grpc.CallOption) (*vtctldata.GetSrvVSchemaResponse, error) {
	out := new(vtctldata.GetSrvVSchemaResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetSrvVSchema", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetSrvVSchemas(ctx context.Context, in *vtctldata.GetSrvVSchemasRequest, opts ...grpc.CallOption) (*vtctldata.GetSrvVSchemasResponse, error) {
	out := new(vtctldata.GetSrvVSchemasResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetSrvVSchemas", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetTablet(ctx context.Context, in *vtctldata.GetTabletRequest, opts ...grpc.CallOption) (*vtctldata.GetTabletResponse, error) {
	out := new(vtctldata.GetTabletResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetTablet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetTablets(ctx context.Context, in *vtctldata.GetTabletsRequest, opts ...grpc.CallOption) (*vtctldata.GetTabletsResponse, error) {
	out := new(vtctldata.GetTabletsResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetTablets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetVSchema(ctx context.Context, in *vtctldata.GetVSchemaRequest, opts ...grpc.CallOption) (*vtctldata.GetVSchemaResponse, error) {
	out := new(vtctldata.GetVSchemaResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetVSchema", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetWorkflows(ctx context.Context, in *vtctldata.GetWorkflowsRequest, opts ...grpc.CallOption) (*vtctldata.GetWorkflowsResponse, error) {
	out := new(vtctldata.GetWorkflowsResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetWorkflows", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) InitShardPrimary(ctx context.Context, in *vtctldata.InitShardPrimaryRequest, opts ...grpc.CallOption) (*vtctldata.InitShardPrimaryResponse, error) {
	out := new(vtctldata.InitShardPrimaryResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/InitShardPrimary", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) PlannedReparentShard(ctx context.Context, in *vtctldata.PlannedReparentShardRequest, opts ...grpc.CallOption) (*vtctldata.PlannedReparentShardResponse, error) {
	out := new(vtctldata.PlannedReparentShardResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/PlannedReparentShard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) RebuildVSchemaGraph(ctx context.Context, in *vtctldata.RebuildVSchemaGraphRequest, opts ...grpc.CallOption) (*vtctldata.RebuildVSchemaGraphResponse, error) {
	out := new(vtctldata.RebuildVSchemaGraphResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/RebuildVSchemaGraph", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) RefreshState(ctx context.Context, in *vtctldata.RefreshStateRequest, opts ...grpc.CallOption) (*vtctldata.RefreshStateResponse, error) {
	out := new(vtctldata.RefreshStateResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/RefreshState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) RefreshStateByShard(ctx context.Context, in *vtctldata.RefreshStateByShardRequest, opts ...grpc.CallOption) (*vtctldata.RefreshStateByShardResponse, error) {
	out := new(vtctldata.RefreshStateByShardResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/RefreshStateByShard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) RemoveKeyspaceCell(ctx context.Context, in *vtctldata.RemoveKeyspaceCellRequest, opts ...grpc.CallOption) (*vtctldata.RemoveKeyspaceCellResponse, error) {
	out := new(vtctldata.RemoveKeyspaceCellResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/RemoveKeyspaceCell", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) RemoveShardCell(ctx context.Context, in *vtctldata.RemoveShardCellRequest, opts ...grpc.CallOption) (*vtctldata.RemoveShardCellResponse, error) {
	out := new(vtctldata.RemoveShardCellResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/RemoveShardCell", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) ReparentTablet(ctx context.Context, in *vtctldata.ReparentTabletRequest, opts ...grpc.CallOption) (*vtctldata.ReparentTabletResponse, error) {
	out := new(vtctldata.ReparentTabletResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/ReparentTablet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) ShardReplicationPositions(ctx context.Context, in *vtctldata.ShardReplicationPositionsRequest, opts ...grpc.CallOption) (*vtctldata.ShardReplicationPositionsResponse, error) {
	out := new(vtctldata.ShardReplicationPositionsResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/ShardReplicationPositions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) TabletExternallyReparented(ctx context.Context, in *vtctldata.TabletExternallyReparentedRequest, opts ...grpc.CallOption) (*vtctldata.TabletExternallyReparentedResponse, error) {
	out := new(vtctldata.TabletExternallyReparentedResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/TabletExternallyReparented", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) UpdateCellInfo(ctx context.Context, in *vtctldata.UpdateCellInfoRequest, opts ...grpc.CallOption) (*vtctldata.UpdateCellInfoResponse, error) {
	out := new(vtctldata.UpdateCellInfoResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/UpdateCellInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) UpdateCellsAlias(ctx context.Context, in *vtctldata.UpdateCellsAliasRequest, opts ...grpc.CallOption) (*vtctldata.UpdateCellsAliasResponse, error) {
	out := new(vtctldata.UpdateCellsAliasResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/UpdateCellsAlias", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VtctldServer is the server API for Vtctld service.
// All implementations must embed UnimplementedVtctldServer
// for forward compatibility
type VtctldServer interface {
	// AddCellInfo registers a local topology service in a new cell by creating
	// the CellInfo with the provided parameters.
	AddCellInfo(context.Context, *vtctldata.AddCellInfoRequest) (*vtctldata.AddCellInfoResponse, error)
	// AddCellsAlias defines a group of cells that can be referenced by a single
	// name (the alias).
	//
	// When routing query traffic, replica/rdonly traffic can be routed across
	// cells within the group (alias). Only primary traffic can be routed across
	// cells not in the same group (alias).
	AddCellsAlias(context.Context, *vtctldata.AddCellsAliasRequest) (*vtctldata.AddCellsAliasResponse, error)
	// ApplyRoutingRules applies the VSchema routing rules.
	ApplyRoutingRules(context.Context, *vtctldata.ApplyRoutingRulesRequest) (*vtctldata.ApplyRoutingRulesResponse, error)
	// ApplyVSchema applies a vschema to a keyspace.
	ApplyVSchema(context.Context, *vtctldata.ApplyVSchemaRequest) (*vtctldata.ApplyVSchemaResponse, error)
	// ChangeTabletType changes the db type for the specified tablet, if possible.
	// This is used primarily to arrange replicas, and it will not convert a
	// primary. For that, use InitShardPrimary.
	//
	// NOTE: This command automatically updates the serving graph.
	ChangeTabletType(context.Context, *vtctldata.ChangeTabletTypeRequest) (*vtctldata.ChangeTabletTypeResponse, error)
	// CreateKeyspace creates the specified keyspace in the topology. For a
	// SNAPSHOT keyspace, the request must specify the name of a base keyspace,
	// as well as a snapshot time.
	CreateKeyspace(context.Context, *vtctldata.CreateKeyspaceRequest) (*vtctldata.CreateKeyspaceResponse, error)
	// CreateShard creates the specified shard in the topology.
	CreateShard(context.Context, *vtctldata.CreateShardRequest) (*vtctldata.CreateShardResponse, error)
	// DeleteCellInfo deletes the CellInfo for the provided cell. The cell cannot
	// be referenced by any Shard record in the topology.
	DeleteCellInfo(context.Context, *vtctldata.DeleteCellInfoRequest) (*vtctldata.DeleteCellInfoResponse, error)
	// DeleteCellsAlias deletes the CellsAlias for the provided alias.
	DeleteCellsAlias(context.Context, *vtctldata.DeleteCellsAliasRequest) (*vtctldata.DeleteCellsAliasResponse, error)
	// DeleteKeyspace deletes the specified keyspace from the topology. In
	// recursive mode, it also recursively deletes all shards in the keyspace.
	// Otherwise, the keyspace must be empty (have no shards), or DeleteKeyspace
	// returns an error.
	DeleteKeyspace(context.Context, *vtctldata.DeleteKeyspaceRequest) (*vtctldata.DeleteKeyspaceResponse, error)
	// DeleteShards deletes the specified shards from the topology. In recursive
	// mode, it also deletes all tablets belonging to the shard. Otherwise, the
	// shard must be empty (have no tablets) or DeleteShards returns an error for
	// that shard.
	DeleteShards(context.Context, *vtctldata.DeleteShardsRequest) (*vtctldata.DeleteShardsResponse, error)
	// DeleteTablets deletes one or more tablets from the topology.
	DeleteTablets(context.Context, *vtctldata.DeleteTabletsRequest) (*vtctldata.DeleteTabletsResponse, error)
	// EmergencyReparentShard reparents the shard to the new primary. It assumes
	// the old primary is dead or otherwise not responding.
	EmergencyReparentShard(context.Context, *vtctldata.EmergencyReparentShardRequest) (*vtctldata.EmergencyReparentShardResponse, error)
	// FindAllShardsInKeyspace returns a map of shard names to shard references
	// for a given keyspace.
	FindAllShardsInKeyspace(context.Context, *vtctldata.FindAllShardsInKeyspaceRequest) (*vtctldata.FindAllShardsInKeyspaceResponse, error)
	// GetBackups returns all the backups for a shard.
	GetBackups(context.Context, *vtctldata.GetBackupsRequest) (*vtctldata.GetBackupsResponse, error)
	// GetCellInfo returns the information for a cell.
	GetCellInfo(context.Context, *vtctldata.GetCellInfoRequest) (*vtctldata.GetCellInfoResponse, error)
	// GetCellInfoNames returns all the cells for which we have a CellInfo object,
	// meaning we have a topology service registered.
	GetCellInfoNames(context.Context, *vtctldata.GetCellInfoNamesRequest) (*vtctldata.GetCellInfoNamesResponse, error)
	// GetCellsAliases returns a mapping of cell alias to cells identified by that
	// alias.
	GetCellsAliases(context.Context, *vtctldata.GetCellsAliasesRequest) (*vtctldata.GetCellsAliasesResponse, error)
	// GetKeyspace reads the given keyspace from the topo and returns it.
	GetKeyspace(context.Context, *vtctldata.GetKeyspaceRequest) (*vtctldata.GetKeyspaceResponse, error)
	// GetKeyspaces returns the keyspace struct of all keyspaces in the topo.
	GetKeyspaces(context.Context, *vtctldata.GetKeyspacesRequest) (*vtctldata.GetKeyspacesResponse, error)
	// GetRoutingRules returns the VSchema routing rules.
	GetRoutingRules(context.Context, *vtctldata.GetRoutingRulesRequest) (*vtctldata.GetRoutingRulesResponse, error)
	// GetSchema returns the schema for a tablet, or just the schema for the
	// specified tables in that tablet.
	GetSchema(context.Context, *vtctldata.GetSchemaRequest) (*vtctldata.GetSchemaResponse, error)
	// GetShard returns information about a shard in the topology.
	GetShard(context.Context, *vtctldata.GetShardRequest) (*vtctldata.GetShardResponse, error)
	// GetSrvKeyspaces returns the SrvKeyspaces for a keyspace in one or more
	// cells.
	GetSrvKeyspaces(context.Context, *vtctldata.GetSrvKeyspacesRequest) (*vtctldata.GetSrvKeyspacesResponse, error)
	// GetSrvVSchema returns the SrvVSchema for a cell.
	GetSrvVSchema(context.Context, *vtctldata.GetSrvVSchemaRequest) (*vtctldata.GetSrvVSchemaResponse, error)
	// GetSrvVSchemas returns a mapping from cell name to SrvVSchema for all cells,
	// optionally filtered by cell name.
	GetSrvVSchemas(context.Context, *vtctldata.GetSrvVSchemasRequest) (*vtctldata.GetSrvVSchemasResponse, error)
	// GetTablet returns information about a tablet.
	GetTablet(context.Context, *vtctldata.GetTabletRequest) (*vtctldata.GetTabletResponse, error)
	// GetTablets returns tablets, optionally filtered by keyspace and shard.
	GetTablets(context.Context, *vtctldata.GetTabletsRequest) (*vtctldata.GetTabletsResponse, error)
	// GetVSchema returns the vschema for a keyspace.
	GetVSchema(context.Context, *vtctldata.GetVSchemaRequest) (*vtctldata.GetVSchemaResponse, error)
	// GetWorkflows returns a list of workflows for the given keyspace.
	GetWorkflows(context.Context, *vtctldata.GetWorkflowsRequest) (*vtctldata.GetWorkflowsResponse, error)
	// InitShardPrimary sets the initial primary for a shard. Will make all other
	// tablets in the shard replicas of the provided primary.
	//
	// WARNING: This could cause data loss on an already replicating shard.
	// PlannedReparentShard or EmergencyReparentShard should be used in those
	// cases instead.
	InitShardPrimary(context.Context, *vtctldata.InitShardPrimaryRequest) (*vtctldata.InitShardPrimaryResponse, error)
	// PlannedReparentShard reparents the shard to the new primary, or away from
	// an old primary. Both the old and new primaries need to be reachable and
	// running.
	//
	// **NOTE**: The vtctld will not consider any replicas outside the cell the
	// current shard primary is in for promotion unless NewPrimary is explicitly
	// provided in the request.
	PlannedReparentShard(context.Context, *vtctldata.PlannedReparentShardRequest) (*vtctldata.PlannedReparentShardResponse, error)
	// RebuildVSchemaGraph rebuilds the per-cell SrvVSchema from the global
	// VSchema objects in the provided cells (or all cells in the topo none
	// provided).
	RebuildVSchemaGraph(context.Context, *vtctldata.RebuildVSchemaGraphRequest) (*vtctldata.RebuildVSchemaGraphResponse, error)
	// RefreshState reloads the tablet record on the specified tablet.
	RefreshState(context.Context, *vtctldata.RefreshStateRequest) (*vtctldata.RefreshStateResponse, error)
	// RefreshStateByShard calls RefreshState on all the tablets in the given shard.
	RefreshStateByShard(context.Context, *vtctldata.RefreshStateByShardRequest) (*vtctldata.RefreshStateByShardResponse, error)
	// RemoveKeyspaceCell removes the specified cell from the Cells list for all
	// shards in the specified keyspace, as well as from the SrvKeyspace for that
	// keyspace in that cell.
	RemoveKeyspaceCell(context.Context, *vtctldata.RemoveKeyspaceCellRequest) (*vtctldata.RemoveKeyspaceCellResponse, error)
	// RemoveShardCell removes the specified cell from the specified shard's Cells
	// list.
	RemoveShardCell(context.Context, *vtctldata.RemoveShardCellRequest) (*vtctldata.RemoveShardCellResponse, error)
	// ReparentTablet reparents a tablet to the current primary in the shard. This
	// only works if the current replica position matches the last known reparent
	// action.
	ReparentTablet(context.Context, *vtctldata.ReparentTabletRequest) (*vtctldata.ReparentTabletResponse, error)
	// ShardReplicationPositions returns the replication position of each tablet
	// in a shard. This RPC makes a best-effort to return partial results. For
	// example, if one tablet in the shard graph is unreachable, then
	// ShardReplicationPositions will return non-error, and include valid results
	// for the reachable tablets.
	ShardReplicationPositions(context.Context, *vtctldata.ShardReplicationPositionsRequest) (*vtctldata.ShardReplicationPositionsResponse, error)
	// TabletExternallyReparented changes metadata in the topology server to
	// acknowledge a shard primary change performed by an external tool (e.g.
	// orchestrator).
	//
	// See the Reparenting guide for more information:
	// https://vitess.io/docs/user-guides/configuration-advanced/reparenting/#external-reparenting.
	TabletExternallyReparented(context.Context, *vtctldata.TabletExternallyReparentedRequest) (*vtctldata.TabletExternallyReparentedResponse, error)
	// UpdateCellInfo updates the content of a CellInfo with the provided
	// parameters. Empty values are ignored. If the cell does not exist, the
	// CellInfo will be created.
	UpdateCellInfo(context.Context, *vtctldata.UpdateCellInfoRequest) (*vtctldata.UpdateCellInfoResponse, error)
	// UpdateCellsAlias updates the content of a CellsAlias with the provided
	// parameters. Empty values are ignored. If the alias does not exist, the
	// CellsAlias will be created.
	UpdateCellsAlias(context.Context, *vtctldata.UpdateCellsAliasRequest) (*vtctldata.UpdateCellsAliasResponse, error)
	mustEmbedUnimplementedVtctldServer()
}

// UnimplementedVtctldServer must be embedded to have forward compatible implementations.
type UnimplementedVtctldServer struct {
}

func (UnimplementedVtctldServer) AddCellInfo(context.Context, *vtctldata.AddCellInfoRequest) (*vtctldata.AddCellInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddCellInfo not implemented")
}
func (UnimplementedVtctldServer) AddCellsAlias(context.Context, *vtctldata.AddCellsAliasRequest) (*vtctldata.AddCellsAliasResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddCellsAlias not implemented")
}
func (UnimplementedVtctldServer) ApplyRoutingRules(context.Context, *vtctldata.ApplyRoutingRulesRequest) (*vtctldata.ApplyRoutingRulesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyRoutingRules not implemented")
}
func (UnimplementedVtctldServer) ApplyVSchema(context.Context, *vtctldata.ApplyVSchemaRequest) (*vtctldata.ApplyVSchemaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyVSchema not implemented")
}
func (UnimplementedVtctldServer) ChangeTabletType(context.Context, *vtctldata.ChangeTabletTypeRequest) (*vtctldata.ChangeTabletTypeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangeTabletType not implemented")
}
func (UnimplementedVtctldServer) CreateKeyspace(context.Context, *vtctldata.CreateKeyspaceRequest) (*vtctldata.CreateKeyspaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateKeyspace not implemented")
}
func (UnimplementedVtctldServer) CreateShard(context.Context, *vtctldata.CreateShardRequest) (*vtctldata.CreateShardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateShard not implemented")
}
func (UnimplementedVtctldServer) DeleteCellInfo(context.Context, *vtctldata.DeleteCellInfoRequest) (*vtctldata.DeleteCellInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCellInfo not implemented")
}
func (UnimplementedVtctldServer) DeleteCellsAlias(context.Context, *vtctldata.DeleteCellsAliasRequest) (*vtctldata.DeleteCellsAliasResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCellsAlias not implemented")
}
func (UnimplementedVtctldServer) DeleteKeyspace(context.Context, *vtctldata.DeleteKeyspaceRequest) (*vtctldata.DeleteKeyspaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteKeyspace not implemented")
}
func (UnimplementedVtctldServer) DeleteShards(context.Context, *vtctldata.DeleteShardsRequest) (*vtctldata.DeleteShardsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteShards not implemented")
}
func (UnimplementedVtctldServer) DeleteTablets(context.Context, *vtctldata.DeleteTabletsRequest) (*vtctldata.DeleteTabletsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTablets not implemented")
}
func (UnimplementedVtctldServer) EmergencyReparentShard(context.Context, *vtctldata.EmergencyReparentShardRequest) (*vtctldata.EmergencyReparentShardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EmergencyReparentShard not implemented")
}
func (UnimplementedVtctldServer) FindAllShardsInKeyspace(context.Context, *vtctldata.FindAllShardsInKeyspaceRequest) (*vtctldata.FindAllShardsInKeyspaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindAllShardsInKeyspace not implemented")
}
func (UnimplementedVtctldServer) GetBackups(context.Context, *vtctldata.GetBackupsRequest) (*vtctldata.GetBackupsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBackups not implemented")
}
func (UnimplementedVtctldServer) GetCellInfo(context.Context, *vtctldata.GetCellInfoRequest) (*vtctldata.GetCellInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCellInfo not implemented")
}
func (UnimplementedVtctldServer) GetCellInfoNames(context.Context, *vtctldata.GetCellInfoNamesRequest) (*vtctldata.GetCellInfoNamesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCellInfoNames not implemented")
}
func (UnimplementedVtctldServer) GetCellsAliases(context.Context, *vtctldata.GetCellsAliasesRequest) (*vtctldata.GetCellsAliasesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCellsAliases not implemented")
}
func (UnimplementedVtctldServer) GetKeyspace(context.Context, *vtctldata.GetKeyspaceRequest) (*vtctldata.GetKeyspaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetKeyspace not implemented")
}
func (UnimplementedVtctldServer) GetKeyspaces(context.Context, *vtctldata.GetKeyspacesRequest) (*vtctldata.GetKeyspacesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetKeyspaces not implemented")
}
func (UnimplementedVtctldServer) GetRoutingRules(context.Context, *vtctldata.GetRoutingRulesRequest) (*vtctldata.GetRoutingRulesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRoutingRules not implemented")
}
func (UnimplementedVtctldServer) GetSchema(context.Context, *vtctldata.GetSchemaRequest) (*vtctldata.GetSchemaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSchema not implemented")
}
func (UnimplementedVtctldServer) GetShard(context.Context, *vtctldata.GetShardRequest) (*vtctldata.GetShardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetShard not implemented")
}
func (UnimplementedVtctldServer) GetSrvKeyspaces(context.Context, *vtctldata.GetSrvKeyspacesRequest) (*vtctldata.GetSrvKeyspacesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSrvKeyspaces not implemented")
}
func (UnimplementedVtctldServer) GetSrvVSchema(context.Context, *vtctldata.GetSrvVSchemaRequest) (*vtctldata.GetSrvVSchemaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSrvVSchema not implemented")
}
func (UnimplementedVtctldServer) GetSrvVSchemas(context.Context, *vtctldata.GetSrvVSchemasRequest) (*vtctldata.GetSrvVSchemasResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSrvVSchemas not implemented")
}
func (UnimplementedVtctldServer) GetTablet(context.Context, *vtctldata.GetTabletRequest) (*vtctldata.GetTabletResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTablet not implemented")
}
func (UnimplementedVtctldServer) GetTablets(context.Context, *vtctldata.GetTabletsRequest) (*vtctldata.GetTabletsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTablets not implemented")
}
func (UnimplementedVtctldServer) GetVSchema(context.Context, *vtctldata.GetVSchemaRequest) (*vtctldata.GetVSchemaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVSchema not implemented")
}
func (UnimplementedVtctldServer) GetWorkflows(context.Context, *vtctldata.GetWorkflowsRequest) (*vtctldata.GetWorkflowsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWorkflows not implemented")
}
func (UnimplementedVtctldServer) InitShardPrimary(context.Context, *vtctldata.InitShardPrimaryRequest) (*vtctldata.InitShardPrimaryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitShardPrimary not implemented")
}
func (UnimplementedVtctldServer) PlannedReparentShard(context.Context, *vtctldata.PlannedReparentShardRequest) (*vtctldata.PlannedReparentShardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PlannedReparentShard not implemented")
}
func (UnimplementedVtctldServer) RebuildVSchemaGraph(context.Context, *vtctldata.RebuildVSchemaGraphRequest) (*vtctldata.RebuildVSchemaGraphResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RebuildVSchemaGraph not implemented")
}
func (UnimplementedVtctldServer) RefreshState(context.Context, *vtctldata.RefreshStateRequest) (*vtctldata.RefreshStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RefreshState not implemented")
}
func (UnimplementedVtctldServer) RefreshStateByShard(context.Context, *vtctldata.RefreshStateByShardRequest) (*vtctldata.RefreshStateByShardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RefreshStateByShard not implemented")
}
func (UnimplementedVtctldServer) RemoveKeyspaceCell(context.Context, *vtctldata.RemoveKeyspaceCellRequest) (*vtctldata.RemoveKeyspaceCellResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveKeyspaceCell not implemented")
}
func (UnimplementedVtctldServer) RemoveShardCell(context.Context, *vtctldata.RemoveShardCellRequest) (*vtctldata.RemoveShardCellResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveShardCell not implemented")
}
func (UnimplementedVtctldServer) ReparentTablet(context.Context, *vtctldata.ReparentTabletRequest) (*vtctldata.ReparentTabletResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReparentTablet not implemented")
}
func (UnimplementedVtctldServer) ShardReplicationPositions(context.Context, *vtctldata.ShardReplicationPositionsRequest) (*vtctldata.ShardReplicationPositionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShardReplicationPositions not implemented")
}
func (UnimplementedVtctldServer) TabletExternallyReparented(context.Context, *vtctldata.TabletExternallyReparentedRequest) (*vtctldata.TabletExternallyReparentedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TabletExternallyReparented not implemented")
}
func (UnimplementedVtctldServer) UpdateCellInfo(context.Context, *vtctldata.UpdateCellInfoRequest) (*vtctldata.UpdateCellInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCellInfo not implemented")
}
func (UnimplementedVtctldServer) UpdateCellsAlias(context.Context, *vtctldata.UpdateCellsAliasRequest) (*vtctldata.UpdateCellsAliasResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCellsAlias not implemented")
}
func (UnimplementedVtctldServer) mustEmbedUnimplementedVtctldServer() {}

// UnsafeVtctldServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VtctldServer will
// result in compilation errors.
type UnsafeVtctldServer interface {
	mustEmbedUnimplementedVtctldServer()
}

func RegisterVtctldServer(s grpc.ServiceRegistrar, srv VtctldServer) {
	s.RegisterService(&Vtctld_ServiceDesc, srv)
}

func _Vtctld_AddCellInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.AddCellInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).AddCellInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/AddCellInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).AddCellInfo(ctx, req.(*vtctldata.AddCellInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_AddCellsAlias_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.AddCellsAliasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).AddCellsAlias(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/AddCellsAlias",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).AddCellsAlias(ctx, req.(*vtctldata.AddCellsAliasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_ApplyRoutingRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.ApplyRoutingRulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).ApplyRoutingRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/ApplyRoutingRules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).ApplyRoutingRules(ctx, req.(*vtctldata.ApplyRoutingRulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_ApplyVSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.ApplyVSchemaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).ApplyVSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/ApplyVSchema",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).ApplyVSchema(ctx, req.(*vtctldata.ApplyVSchemaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_ChangeTabletType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.ChangeTabletTypeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).ChangeTabletType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/ChangeTabletType",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).ChangeTabletType(ctx, req.(*vtctldata.ChangeTabletTypeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_CreateKeyspace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.CreateKeyspaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).CreateKeyspace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/CreateKeyspace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).CreateKeyspace(ctx, req.(*vtctldata.CreateKeyspaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_CreateShard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.CreateShardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).CreateShard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/CreateShard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).CreateShard(ctx, req.(*vtctldata.CreateShardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_DeleteCellInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.DeleteCellInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).DeleteCellInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/DeleteCellInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).DeleteCellInfo(ctx, req.(*vtctldata.DeleteCellInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_DeleteCellsAlias_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.DeleteCellsAliasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).DeleteCellsAlias(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/DeleteCellsAlias",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).DeleteCellsAlias(ctx, req.(*vtctldata.DeleteCellsAliasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_DeleteKeyspace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.DeleteKeyspaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).DeleteKeyspace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/DeleteKeyspace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).DeleteKeyspace(ctx, req.(*vtctldata.DeleteKeyspaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_DeleteShards_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.DeleteShardsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).DeleteShards(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/DeleteShards",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).DeleteShards(ctx, req.(*vtctldata.DeleteShardsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_DeleteTablets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.DeleteTabletsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).DeleteTablets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/DeleteTablets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).DeleteTablets(ctx, req.(*vtctldata.DeleteTabletsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_EmergencyReparentShard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.EmergencyReparentShardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).EmergencyReparentShard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/EmergencyReparentShard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).EmergencyReparentShard(ctx, req.(*vtctldata.EmergencyReparentShardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_FindAllShardsInKeyspace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.FindAllShardsInKeyspaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).FindAllShardsInKeyspace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/FindAllShardsInKeyspace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).FindAllShardsInKeyspace(ctx, req.(*vtctldata.FindAllShardsInKeyspaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetBackups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetBackupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetBackups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetBackups",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetBackups(ctx, req.(*vtctldata.GetBackupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetCellInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetCellInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetCellInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetCellInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetCellInfo(ctx, req.(*vtctldata.GetCellInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetCellInfoNames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetCellInfoNamesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetCellInfoNames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetCellInfoNames",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetCellInfoNames(ctx, req.(*vtctldata.GetCellInfoNamesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetCellsAliases_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetCellsAliasesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetCellsAliases(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetCellsAliases",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetCellsAliases(ctx, req.(*vtctldata.GetCellsAliasesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetKeyspace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetKeyspaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetKeyspace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetKeyspace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetKeyspace(ctx, req.(*vtctldata.GetKeyspaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetKeyspaces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetKeyspacesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetKeyspaces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetKeyspaces",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetKeyspaces(ctx, req.(*vtctldata.GetKeyspacesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetRoutingRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetRoutingRulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetRoutingRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetRoutingRules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetRoutingRules(ctx, req.(*vtctldata.GetRoutingRulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetSchemaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetSchema",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetSchema(ctx, req.(*vtctldata.GetSchemaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetShard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetShardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetShard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetShard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetShard(ctx, req.(*vtctldata.GetShardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetSrvKeyspaces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetSrvKeyspacesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetSrvKeyspaces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetSrvKeyspaces",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetSrvKeyspaces(ctx, req.(*vtctldata.GetSrvKeyspacesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetSrvVSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetSrvVSchemaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetSrvVSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetSrvVSchema",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetSrvVSchema(ctx, req.(*vtctldata.GetSrvVSchemaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetSrvVSchemas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetSrvVSchemasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetSrvVSchemas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetSrvVSchemas",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetSrvVSchemas(ctx, req.(*vtctldata.GetSrvVSchemasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetTablet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetTabletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetTablet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetTablet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetTablet(ctx, req.(*vtctldata.GetTabletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetTablets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetTabletsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetTablets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetTablets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetTablets(ctx, req.(*vtctldata.GetTabletsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetVSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetVSchemaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetVSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetVSchema",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetVSchema(ctx, req.(*vtctldata.GetVSchemaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetWorkflows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetWorkflowsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetWorkflows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetWorkflows",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetWorkflows(ctx, req.(*vtctldata.GetWorkflowsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_InitShardPrimary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.InitShardPrimaryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).InitShardPrimary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/InitShardPrimary",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).InitShardPrimary(ctx, req.(*vtctldata.InitShardPrimaryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_PlannedReparentShard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.PlannedReparentShardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).PlannedReparentShard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/PlannedReparentShard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).PlannedReparentShard(ctx, req.(*vtctldata.PlannedReparentShardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_RebuildVSchemaGraph_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.RebuildVSchemaGraphRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).RebuildVSchemaGraph(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/RebuildVSchemaGraph",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).RebuildVSchemaGraph(ctx, req.(*vtctldata.RebuildVSchemaGraphRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_RefreshState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.RefreshStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).RefreshState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/RefreshState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).RefreshState(ctx, req.(*vtctldata.RefreshStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_RefreshStateByShard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.RefreshStateByShardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).RefreshStateByShard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/RefreshStateByShard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).RefreshStateByShard(ctx, req.(*vtctldata.RefreshStateByShardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_RemoveKeyspaceCell_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.RemoveKeyspaceCellRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).RemoveKeyspaceCell(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/RemoveKeyspaceCell",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).RemoveKeyspaceCell(ctx, req.(*vtctldata.RemoveKeyspaceCellRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_RemoveShardCell_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.RemoveShardCellRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).RemoveShardCell(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/RemoveShardCell",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).RemoveShardCell(ctx, req.(*vtctldata.RemoveShardCellRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_ReparentTablet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.ReparentTabletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).ReparentTablet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/ReparentTablet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).ReparentTablet(ctx, req.(*vtctldata.ReparentTabletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_ShardReplicationPositions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.ShardReplicationPositionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).ShardReplicationPositions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/ShardReplicationPositions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).ShardReplicationPositions(ctx, req.(*vtctldata.ShardReplicationPositionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_TabletExternallyReparented_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.TabletExternallyReparentedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).TabletExternallyReparented(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/TabletExternallyReparented",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).TabletExternallyReparented(ctx, req.(*vtctldata.TabletExternallyReparentedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_UpdateCellInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.UpdateCellInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).UpdateCellInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/UpdateCellInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).UpdateCellInfo(ctx, req.(*vtctldata.UpdateCellInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_UpdateCellsAlias_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.UpdateCellsAliasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).UpdateCellsAlias(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/UpdateCellsAlias",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).UpdateCellsAlias(ctx, req.(*vtctldata.UpdateCellsAliasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Vtctld_ServiceDesc is the grpc.ServiceDesc for Vtctld service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Vtctld_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "vtctlservice.Vtctld",
	HandlerType: (*VtctldServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddCellInfo",
			Handler:    _Vtctld_AddCellInfo_Handler,
		},
		{
			MethodName: "AddCellsAlias",
			Handler:    _Vtctld_AddCellsAlias_Handler,
		},
		{
			MethodName: "ApplyRoutingRules",
			Handler:    _Vtctld_ApplyRoutingRules_Handler,
		},
		{
			MethodName: "ApplyVSchema",
			Handler:    _Vtctld_ApplyVSchema_Handler,
		},
		{
			MethodName: "ChangeTabletType",
			Handler:    _Vtctld_ChangeTabletType_Handler,
		},
		{
			MethodName: "CreateKeyspace",
			Handler:    _Vtctld_CreateKeyspace_Handler,
		},
		{
			MethodName: "CreateShard",
			Handler:    _Vtctld_CreateShard_Handler,
		},
		{
			MethodName: "DeleteCellInfo",
			Handler:    _Vtctld_DeleteCellInfo_Handler,
		},
		{
			MethodName: "DeleteCellsAlias",
			Handler:    _Vtctld_DeleteCellsAlias_Handler,
		},
		{
			MethodName: "DeleteKeyspace",
			Handler:    _Vtctld_DeleteKeyspace_Handler,
		},
		{
			MethodName: "DeleteShards",
			Handler:    _Vtctld_DeleteShards_Handler,
		},
		{
			MethodName: "DeleteTablets",
			Handler:    _Vtctld_DeleteTablets_Handler,
		},
		{
			MethodName: "EmergencyReparentShard",
			Handler:    _Vtctld_EmergencyReparentShard_Handler,
		},
		{
			MethodName: "FindAllShardsInKeyspace",
			Handler:    _Vtctld_FindAllShardsInKeyspace_Handler,
		},
		{
			MethodName: "GetBackups",
			Handler:    _Vtctld_GetBackups_Handler,
		},
		{
			MethodName: "GetCellInfo",
			Handler:    _Vtctld_GetCellInfo_Handler,
		},
		{
			MethodName: "GetCellInfoNames",
			Handler:    _Vtctld_GetCellInfoNames_Handler,
		},
		{
			MethodName: "GetCellsAliases",
			Handler:    _Vtctld_GetCellsAliases_Handler,
		},
		{
			MethodName: "GetKeyspace",
			Handler:    _Vtctld_GetKeyspace_Handler,
		},
		{
			MethodName: "GetKeyspaces",
			Handler:    _Vtctld_GetKeyspaces_Handler,
		},
		{
			MethodName: "GetRoutingRules",
			Handler:    _Vtctld_GetRoutingRules_Handler,
		},
		{
			MethodName: "GetSchema",
			Handler:    _Vtctld_GetSchema_Handler,
		},
		{
			MethodName: "GetShard",
			Handler:    _Vtctld_GetShard_Handler,
		},
		{
			MethodName: "GetSrvKeyspaces",
			Handler:    _Vtctld_GetSrvKeyspaces_Handler,
		},
		{
			MethodName: "GetSrvVSchema",
			Handler:    _Vtctld_GetSrvVSchema_Handler,
		},
		{
			MethodName: "GetSrvVSchemas",
			Handler:    _Vtctld_GetSrvVSchemas_Handler,
		},
		{
			MethodName: "GetTablet",
			Handler:    _Vtctld_GetTablet_Handler,
		},
		{
			MethodName: "GetTablets",
			Handler:    _Vtctld_GetTablets_Handler,
		},
		{
			MethodName: "GetVSchema",
			Handler:    _Vtctld_GetVSchema_Handler,
		},
		{
			MethodName: "GetWorkflows",
			Handler:    _Vtctld_GetWorkflows_Handler,
		},
		{
			MethodName: "InitShardPrimary",
			Handler:    _Vtctld_InitShardPrimary_Handler,
		},
		{
			MethodName: "PlannedReparentShard",
			Handler:    _Vtctld_PlannedReparentShard_Handler,
		},
		{
			MethodName: "RebuildVSchemaGraph",
			Handler:    _Vtctld_RebuildVSchemaGraph_Handler,
		},
		{
			MethodName: "RefreshState",
			Handler:    _Vtctld_RefreshState_Handler,
		},
		{
			MethodName: "RefreshStateByShard",
			Handler:    _Vtctld_RefreshStateByShard_Handler,
		},
		{
			MethodName: "RemoveKeyspaceCell",
			Handler:    _Vtctld_RemoveKeyspaceCell_Handler,
		},
		{
			MethodName: "RemoveShardCell",
			Handler:    _Vtctld_RemoveShardCell_Handler,
		},
		{
			MethodName: "ReparentTablet",
			Handler:    _Vtctld_ReparentTablet_Handler,
		},
		{
			MethodName: "ShardReplicationPositions",
			Handler:    _Vtctld_ShardReplicationPositions_Handler,
		},
		{
			MethodName: "TabletExternallyReparented",
			Handler:    _Vtctld_TabletExternallyReparented_Handler,
		},
		{
			MethodName: "UpdateCellInfo",
			Handler:    _Vtctld_UpdateCellInfo_Handler,
		},
		{
			MethodName: "UpdateCellsAlias",
			Handler:    _Vtctld_UpdateCellsAlias_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vtctlservice.proto",
}
