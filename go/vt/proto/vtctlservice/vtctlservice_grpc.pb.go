// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.3
// source: vtctlservice.proto

package vtctlservice

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	vtctldata "vitess.io/vitess/go/vt/proto/vtctldata"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// VtctlClient is the client API for Vtctl service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VtctlClient interface {
	ExecuteVtctlCommand(ctx context.Context, in *vtctldata.ExecuteVtctlCommandRequest, opts ...grpc.CallOption) (Vtctl_ExecuteVtctlCommandClient, error)
}

type vtctlClient struct {
	cc grpc.ClientConnInterface
}

func NewVtctlClient(cc grpc.ClientConnInterface) VtctlClient {
	return &vtctlClient{cc}
}

func (c *vtctlClient) ExecuteVtctlCommand(ctx context.Context, in *vtctldata.ExecuteVtctlCommandRequest, opts ...grpc.CallOption) (Vtctl_ExecuteVtctlCommandClient, error) {
	stream, err := c.cc.NewStream(ctx, &Vtctl_ServiceDesc.Streams[0], "/vtctlservice.Vtctl/ExecuteVtctlCommand", opts...)
	if err != nil {
		return nil, err
	}
	x := &vtctlExecuteVtctlCommandClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Vtctl_ExecuteVtctlCommandClient interface {
	Recv() (*vtctldata.ExecuteVtctlCommandResponse, error)
	grpc.ClientStream
}

type vtctlExecuteVtctlCommandClient struct {
	grpc.ClientStream
}

func (x *vtctlExecuteVtctlCommandClient) Recv() (*vtctldata.ExecuteVtctlCommandResponse, error) {
	m := new(vtctldata.ExecuteVtctlCommandResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// VtctlServer is the server API for Vtctl service.
// All implementations must embed UnimplementedVtctlServer
// for forward compatibility
type VtctlServer interface {
	ExecuteVtctlCommand(*vtctldata.ExecuteVtctlCommandRequest, Vtctl_ExecuteVtctlCommandServer) error
	mustEmbedUnimplementedVtctlServer()
}

// UnimplementedVtctlServer must be embedded to have forward compatible implementations.
type UnimplementedVtctlServer struct {
}

func (UnimplementedVtctlServer) ExecuteVtctlCommand(*vtctldata.ExecuteVtctlCommandRequest, Vtctl_ExecuteVtctlCommandServer) error {
	return status.Errorf(codes.Unimplemented, "method ExecuteVtctlCommand not implemented")
}
func (UnimplementedVtctlServer) mustEmbedUnimplementedVtctlServer() {}

// UnsafeVtctlServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VtctlServer will
// result in compilation errors.
type UnsafeVtctlServer interface {
	mustEmbedUnimplementedVtctlServer()
}

func RegisterVtctlServer(s grpc.ServiceRegistrar, srv VtctlServer) {
	s.RegisterService(&Vtctl_ServiceDesc, srv)
}

func _Vtctl_ExecuteVtctlCommand_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(vtctldata.ExecuteVtctlCommandRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VtctlServer).ExecuteVtctlCommand(m, &vtctlExecuteVtctlCommandServer{stream})
}

type Vtctl_ExecuteVtctlCommandServer interface {
	Send(*vtctldata.ExecuteVtctlCommandResponse) error
	grpc.ServerStream
}

type vtctlExecuteVtctlCommandServer struct {
	grpc.ServerStream
}

func (x *vtctlExecuteVtctlCommandServer) Send(m *vtctldata.ExecuteVtctlCommandResponse) error {
	return x.ServerStream.SendMsg(m)
}

// Vtctl_ServiceDesc is the grpc.ServiceDesc for Vtctl service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Vtctl_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "vtctlservice.Vtctl",
	HandlerType: (*VtctlServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ExecuteVtctlCommand",
			Handler:       _Vtctl_ExecuteVtctlCommand_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "vtctlservice.proto",
}

// VtctldClient is the client API for Vtctld service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VtctldClient interface {
	// AddCellInfo registers a local topology service in a new cell by creating
	// the CellInfo with the provided parameters.
	AddCellInfo(ctx context.Context, in *vtctldata.AddCellInfoRequest, opts ...grpc.CallOption) (*vtctldata.AddCellInfoResponse, error)
	// AddCellsAlias defines a group of cells that can be referenced by a single
	// name (the alias).
	//
	// When routing query traffic, replica/rdonly traffic can be routed across
	// cells within the group (alias). Only primary traffic can be routed across
	// cells not in the same group (alias).
	AddCellsAlias(ctx context.Context, in *vtctldata.AddCellsAliasRequest, opts ...grpc.CallOption) (*vtctldata.AddCellsAliasResponse, error)
	// ApplyRoutingRules applies the VSchema routing rules.
	ApplyRoutingRules(ctx context.Context, in *vtctldata.ApplyRoutingRulesRequest, opts ...grpc.CallOption) (*vtctldata.ApplyRoutingRulesResponse, error)
	// ApplySchema applies a schema to a keyspace.
	ApplySchema(ctx context.Context, in *vtctldata.ApplySchemaRequest, opts ...grpc.CallOption) (*vtctldata.ApplySchemaResponse, error)
	// ApplyShardRoutingRules applies the VSchema shard routing rules.
	ApplyShardRoutingRules(ctx context.Context, in *vtctldata.ApplyShardRoutingRulesRequest, opts ...grpc.CallOption) (*vtctldata.ApplyShardRoutingRulesResponse, error)
	// ApplyVSchema applies a vschema to a keyspace.
	ApplyVSchema(ctx context.Context, in *vtctldata.ApplyVSchemaRequest, opts ...grpc.CallOption) (*vtctldata.ApplyVSchemaResponse, error)
	// Backup uses the BackupEngine and BackupStorage services on the specified
	// tablet to create and store a new backup.
	Backup(ctx context.Context, in *vtctldata.BackupRequest, opts ...grpc.CallOption) (Vtctld_BackupClient, error)
	// BackupShard chooses a tablet in the shard and uses it to create a backup.
	BackupShard(ctx context.Context, in *vtctldata.BackupShardRequest, opts ...grpc.CallOption) (Vtctld_BackupShardClient, error)
	// ChangeTabletType changes the db type for the specified tablet, if possible.
	// This is used primarily to arrange replicas, and it will not convert a
	// primary. For that, use InitShardPrimary.
	//
	// NOTE: This command automatically updates the serving graph.
	ChangeTabletType(ctx context.Context, in *vtctldata.ChangeTabletTypeRequest, opts ...grpc.CallOption) (*vtctldata.ChangeTabletTypeResponse, error)
	// CreateKeyspace creates the specified keyspace in the topology. For a
	// SNAPSHOT keyspace, the request must specify the name of a base keyspace,
	// as well as a snapshot time.
	CreateKeyspace(ctx context.Context, in *vtctldata.CreateKeyspaceRequest, opts ...grpc.CallOption) (*vtctldata.CreateKeyspaceResponse, error)
	// CreateShard creates the specified shard in the topology.
	CreateShard(ctx context.Context, in *vtctldata.CreateShardRequest, opts ...grpc.CallOption) (*vtctldata.CreateShardResponse, error)
	// DeleteCellInfo deletes the CellInfo for the provided cell. The cell cannot
	// be referenced by any Shard record in the topology.
	DeleteCellInfo(ctx context.Context, in *vtctldata.DeleteCellInfoRequest, opts ...grpc.CallOption) (*vtctldata.DeleteCellInfoResponse, error)
	// DeleteCellsAlias deletes the CellsAlias for the provided alias.
	DeleteCellsAlias(ctx context.Context, in *vtctldata.DeleteCellsAliasRequest, opts ...grpc.CallOption) (*vtctldata.DeleteCellsAliasResponse, error)
	// DeleteKeyspace deletes the specified keyspace from the topology. In
	// recursive mode, it also recursively deletes all shards in the keyspace.
	// Otherwise, the keyspace must be empty (have no shards), or DeleteKeyspace
	// returns an error.
	DeleteKeyspace(ctx context.Context, in *vtctldata.DeleteKeyspaceRequest, opts ...grpc.CallOption) (*vtctldata.DeleteKeyspaceResponse, error)
	// DeleteShards deletes the specified shards from the topology. In recursive
	// mode, it also deletes all tablets belonging to the shard. Otherwise, the
	// shard must be empty (have no tablets) or DeleteShards returns an error for
	// that shard.
	DeleteShards(ctx context.Context, in *vtctldata.DeleteShardsRequest, opts ...grpc.CallOption) (*vtctldata.DeleteShardsResponse, error)
	// DeleteSrvVSchema deletes the SrvVSchema object in the specified cell.
	DeleteSrvVSchema(ctx context.Context, in *vtctldata.DeleteSrvVSchemaRequest, opts ...grpc.CallOption) (*vtctldata.DeleteSrvVSchemaResponse, error)
	// DeleteTablets deletes one or more tablets from the topology.
	DeleteTablets(ctx context.Context, in *vtctldata.DeleteTabletsRequest, opts ...grpc.CallOption) (*vtctldata.DeleteTabletsResponse, error)
	// EmergencyReparentShard reparents the shard to the new primary. It assumes
	// the old primary is dead or otherwise not responding.
	EmergencyReparentShard(ctx context.Context, in *vtctldata.EmergencyReparentShardRequest, opts ...grpc.CallOption) (*vtctldata.EmergencyReparentShardResponse, error)
	// ExecuteFetchAsApp executes a SQL query on the remote tablet as the App user.
	ExecuteFetchAsApp(ctx context.Context, in *vtctldata.ExecuteFetchAsAppRequest, opts ...grpc.CallOption) (*vtctldata.ExecuteFetchAsAppResponse, error)
	// ExecuteFetchAsDBA executes a SQL query on the remote tablet as the DBA user.
	ExecuteFetchAsDBA(ctx context.Context, in *vtctldata.ExecuteFetchAsDBARequest, opts ...grpc.CallOption) (*vtctldata.ExecuteFetchAsDBAResponse, error)
	// ExecuteHook runs the hook on the tablet.
	ExecuteHook(ctx context.Context, in *vtctldata.ExecuteHookRequest, opts ...grpc.CallOption) (*vtctldata.ExecuteHookResponse, error)
	// FindAllShardsInKeyspace returns a map of shard names to shard references
	// for a given keyspace.
	FindAllShardsInKeyspace(ctx context.Context, in *vtctldata.FindAllShardsInKeyspaceRequest, opts ...grpc.CallOption) (*vtctldata.FindAllShardsInKeyspaceResponse, error)
	// GetBackups returns all the backups for a shard.
	GetBackups(ctx context.Context, in *vtctldata.GetBackupsRequest, opts ...grpc.CallOption) (*vtctldata.GetBackupsResponse, error)
	// GetCellInfo returns the information for a cell.
	GetCellInfo(ctx context.Context, in *vtctldata.GetCellInfoRequest, opts ...grpc.CallOption) (*vtctldata.GetCellInfoResponse, error)
	// GetCellInfoNames returns all the cells for which we have a CellInfo object,
	// meaning we have a topology service registered.
	GetCellInfoNames(ctx context.Context, in *vtctldata.GetCellInfoNamesRequest, opts ...grpc.CallOption) (*vtctldata.GetCellInfoNamesResponse, error)
	// GetCellsAliases returns a mapping of cell alias to cells identified by that
	// alias.
	GetCellsAliases(ctx context.Context, in *vtctldata.GetCellsAliasesRequest, opts ...grpc.CallOption) (*vtctldata.GetCellsAliasesResponse, error)
	// GetFullStatus returns the full status of MySQL including the replication information, semi-sync information, GTID information among others
	GetFullStatus(ctx context.Context, in *vtctldata.GetFullStatusRequest, opts ...grpc.CallOption) (*vtctldata.GetFullStatusResponse, error)
	// GetKeyspace reads the given keyspace from the topo and returns it.
	GetKeyspace(ctx context.Context, in *vtctldata.GetKeyspaceRequest, opts ...grpc.CallOption) (*vtctldata.GetKeyspaceResponse, error)
	// GetKeyspaces returns the keyspace struct of all keyspaces in the topo.
	GetKeyspaces(ctx context.Context, in *vtctldata.GetKeyspacesRequest, opts ...grpc.CallOption) (*vtctldata.GetKeyspacesResponse, error)
	// GetPermissions returns the permissions set on the remote tablet.
	GetPermissions(ctx context.Context, in *vtctldata.GetPermissionsRequest, opts ...grpc.CallOption) (*vtctldata.GetPermissionsResponse, error)
	// GetRoutingRules returns the VSchema routing rules.
	GetRoutingRules(ctx context.Context, in *vtctldata.GetRoutingRulesRequest, opts ...grpc.CallOption) (*vtctldata.GetRoutingRulesResponse, error)
	// GetSchema returns the schema for a tablet, or just the schema for the
	// specified tables in that tablet.
	GetSchema(ctx context.Context, in *vtctldata.GetSchemaRequest, opts ...grpc.CallOption) (*vtctldata.GetSchemaResponse, error)
	// GetShard returns information about a shard in the topology.
	GetShard(ctx context.Context, in *vtctldata.GetShardRequest, opts ...grpc.CallOption) (*vtctldata.GetShardResponse, error)
	// GetShardRoutingRules returns the VSchema shard routing rules.
	GetShardRoutingRules(ctx context.Context, in *vtctldata.GetShardRoutingRulesRequest, opts ...grpc.CallOption) (*vtctldata.GetShardRoutingRulesResponse, error)
	// GetSrvKeyspaceNames returns a mapping of cell name to the keyspaces served
	// in that cell.
	GetSrvKeyspaceNames(ctx context.Context, in *vtctldata.GetSrvKeyspaceNamesRequest, opts ...grpc.CallOption) (*vtctldata.GetSrvKeyspaceNamesResponse, error)
	// GetSrvKeyspaces returns the SrvKeyspaces for a keyspace in one or more
	// cells.
	GetSrvKeyspaces(ctx context.Context, in *vtctldata.GetSrvKeyspacesRequest, opts ...grpc.CallOption) (*vtctldata.GetSrvKeyspacesResponse, error)
	// UpdateThrottlerConfig updates the tablet throttler configuration
	UpdateThrottlerConfig(ctx context.Context, in *vtctldata.UpdateThrottlerConfigRequest, opts ...grpc.CallOption) (*vtctldata.UpdateThrottlerConfigResponse, error)
	// GetSrvVSchema returns the SrvVSchema for a cell.
	GetSrvVSchema(ctx context.Context, in *vtctldata.GetSrvVSchemaRequest, opts ...grpc.CallOption) (*vtctldata.GetSrvVSchemaResponse, error)
	// GetSrvVSchemas returns a mapping from cell name to SrvVSchema for all cells,
	// optionally filtered by cell name.
	GetSrvVSchemas(ctx context.Context, in *vtctldata.GetSrvVSchemasRequest, opts ...grpc.CallOption) (*vtctldata.GetSrvVSchemasResponse, error)
	// GetTablet returns information about a tablet.
	GetTablet(ctx context.Context, in *vtctldata.GetTabletRequest, opts ...grpc.CallOption) (*vtctldata.GetTabletResponse, error)
	// GetTablets returns tablets, optionally filtered by keyspace and shard.
	GetTablets(ctx context.Context, in *vtctldata.GetTabletsRequest, opts ...grpc.CallOption) (*vtctldata.GetTabletsResponse, error)
	// GetTopologyPath returns the topology cell at a given path.
	GetTopologyPath(ctx context.Context, in *vtctldata.GetTopologyPathRequest, opts ...grpc.CallOption) (*vtctldata.GetTopologyPathResponse, error)
	// GetVersion returns the version of a tablet from its debug vars.
	GetVersion(ctx context.Context, in *vtctldata.GetVersionRequest, opts ...grpc.CallOption) (*vtctldata.GetVersionResponse, error)
	// GetVSchema returns the vschema for a keyspace.
	GetVSchema(ctx context.Context, in *vtctldata.GetVSchemaRequest, opts ...grpc.CallOption) (*vtctldata.GetVSchemaResponse, error)
	// GetWorkflows returns a list of workflows for the given keyspace.
	GetWorkflows(ctx context.Context, in *vtctldata.GetWorkflowsRequest, opts ...grpc.CallOption) (*vtctldata.GetWorkflowsResponse, error)
	// InitShardPrimary sets the initial primary for a shard. Will make all other
	// tablets in the shard replicas of the provided primary.
	//
	// WARNING: This could cause data loss on an already replicating shard.
	// PlannedReparentShard or EmergencyReparentShard should be used in those
	// cases instead.
	InitShardPrimary(ctx context.Context, in *vtctldata.InitShardPrimaryRequest, opts ...grpc.CallOption) (*vtctldata.InitShardPrimaryResponse, error)
	// PingTablet checks that the specified tablet is awake and responding to RPCs.
	// This command can be blocked by other in-flight operations.
	PingTablet(ctx context.Context, in *vtctldata.PingTabletRequest, opts ...grpc.CallOption) (*vtctldata.PingTabletResponse, error)
	// PlannedReparentShard reparents the shard to the new primary, or away from
	// an old primary. Both the old and new primaries need to be reachable and
	// running.
	//
	// **NOTE**: The vtctld will not consider any replicas outside the cell the
	// current shard primary is in for promotion unless NewPrimary is explicitly
	// provided in the request.
	PlannedReparentShard(ctx context.Context, in *vtctldata.PlannedReparentShardRequest, opts ...grpc.CallOption) (*vtctldata.PlannedReparentShardResponse, error)
	// RebuildKeyspaceGraph rebuilds the serving data for a keyspace.
	//
	// This may trigger an update to all connected clients.
	RebuildKeyspaceGraph(ctx context.Context, in *vtctldata.RebuildKeyspaceGraphRequest, opts ...grpc.CallOption) (*vtctldata.RebuildKeyspaceGraphResponse, error)
	// RebuildVSchemaGraph rebuilds the per-cell SrvVSchema from the global
	// VSchema objects in the provided cells (or all cells in the topo none
	// provided).
	RebuildVSchemaGraph(ctx context.Context, in *vtctldata.RebuildVSchemaGraphRequest, opts ...grpc.CallOption) (*vtctldata.RebuildVSchemaGraphResponse, error)
	// RefreshState reloads the tablet record on the specified tablet.
	RefreshState(ctx context.Context, in *vtctldata.RefreshStateRequest, opts ...grpc.CallOption) (*vtctldata.RefreshStateResponse, error)
	// RefreshStateByShard calls RefreshState on all the tablets in the given shard.
	RefreshStateByShard(ctx context.Context, in *vtctldata.RefreshStateByShardRequest, opts ...grpc.CallOption) (*vtctldata.RefreshStateByShardResponse, error)
	// ReloadSchema instructs the remote tablet to reload its schema.
	ReloadSchema(ctx context.Context, in *vtctldata.ReloadSchemaRequest, opts ...grpc.CallOption) (*vtctldata.ReloadSchemaResponse, error)
	// ReloadSchemaKeyspace reloads the schema on all tablets in a keyspace.
	ReloadSchemaKeyspace(ctx context.Context, in *vtctldata.ReloadSchemaKeyspaceRequest, opts ...grpc.CallOption) (*vtctldata.ReloadSchemaKeyspaceResponse, error)
	// ReloadSchemaShard reloads the schema on all tablets in a shard.
	//
	// In general, we don't always expect all replicas to be ready to reload, and
	// the periodic schema reload makes them self-healing anyway. So, we do this
	// on a best-effort basis, and log warnings for any tablets that fail to
	// reload within the context deadline.
	ReloadSchemaShard(ctx context.Context, in *vtctldata.ReloadSchemaShardRequest, opts ...grpc.CallOption) (*vtctldata.ReloadSchemaShardResponse, error)
	// RemoveBackup removes a backup from the BackupStorage used by vtctld.
	RemoveBackup(ctx context.Context, in *vtctldata.RemoveBackupRequest, opts ...grpc.CallOption) (*vtctldata.RemoveBackupResponse, error)
	// RemoveKeyspaceCell removes the specified cell from the Cells list for all
	// shards in the specified keyspace (by calling RemoveShardCell on every
	// shard). It also removes the SrvKeyspace for that keyspace in that cell.
	RemoveKeyspaceCell(ctx context.Context, in *vtctldata.RemoveKeyspaceCellRequest, opts ...grpc.CallOption) (*vtctldata.RemoveKeyspaceCellResponse, error)
	// RemoveShardCell removes the specified cell from the specified shard's Cells
	// list.
	RemoveShardCell(ctx context.Context, in *vtctldata.RemoveShardCellRequest, opts ...grpc.CallOption) (*vtctldata.RemoveShardCellResponse, error)
	// ReparentTablet reparents a tablet to the current primary in the shard. This
	// only works if the current replica position matches the last known reparent
	// action.
	ReparentTablet(ctx context.Context, in *vtctldata.ReparentTabletRequest, opts ...grpc.CallOption) (*vtctldata.ReparentTabletResponse, error)
	// RestoreFromBackup stops mysqld for the given tablet and restores a backup.
	RestoreFromBackup(ctx context.Context, in *vtctldata.RestoreFromBackupRequest, opts ...grpc.CallOption) (Vtctld_RestoreFromBackupClient, error)
	// RunHealthCheck runs a healthcheck on the remote tablet.
	RunHealthCheck(ctx context.Context, in *vtctldata.RunHealthCheckRequest, opts ...grpc.CallOption) (*vtctldata.RunHealthCheckResponse, error)
	// SetKeyspaceDurabilityPolicy updates the DurabilityPolicy for a keyspace.
	SetKeyspaceDurabilityPolicy(ctx context.Context, in *vtctldata.SetKeyspaceDurabilityPolicyRequest, opts ...grpc.CallOption) (*vtctldata.SetKeyspaceDurabilityPolicyResponse, error)
	// SetShardIsPrimaryServing adds or removes a shard from serving.
	//
	// This is meant as an emergency function. It does not rebuild any serving
	// graph (i.e. it does not run RebuildKeyspaceGraph).
	SetShardIsPrimaryServing(ctx context.Context, in *vtctldata.SetShardIsPrimaryServingRequest, opts ...grpc.CallOption) (*vtctldata.SetShardIsPrimaryServingResponse, error)
	// SetShardTabletControl updates the TabletControl topo record for a shard and
	// tablet type.
	//
	// This should only be used for an emergency fix, or after a finished
	// Reshard. See the documentation on SetShardTabletControlRequest for more
	// information about the different update modes.
	SetShardTabletControl(ctx context.Context, in *vtctldata.SetShardTabletControlRequest, opts ...grpc.CallOption) (*vtctldata.SetShardTabletControlResponse, error)
	// SetWritable sets a tablet as read-write (writable=true) or read-only (writable=false).
	SetWritable(ctx context.Context, in *vtctldata.SetWritableRequest, opts ...grpc.CallOption) (*vtctldata.SetWritableResponse, error)
	// ShardReplicationAdd adds an entry to a topodata.ShardReplication object.
	//
	// It is a low-level function and should generally not be called.
	ShardReplicationAdd(ctx context.Context, in *vtctldata.ShardReplicationAddRequest, opts ...grpc.CallOption) (*vtctldata.ShardReplicationAddResponse, error)
	// ShardReplicationFix walks the replication graph for a shard in a cell and
	// attempts to fix the first problem encountered, returning information about
	// the problem fixed, if any.
	ShardReplicationFix(ctx context.Context, in *vtctldata.ShardReplicationFixRequest, opts ...grpc.CallOption) (*vtctldata.ShardReplicationFixResponse, error)
	// ShardReplicationPositions returns the replication position of each tablet
	// in a shard. This RPC makes a best-effort to return partial results. For
	// example, if one tablet in the shard graph is unreachable, then
	// ShardReplicationPositions will return non-error, and include valid results
	// for the reachable tablets.
	ShardReplicationPositions(ctx context.Context, in *vtctldata.ShardReplicationPositionsRequest, opts ...grpc.CallOption) (*vtctldata.ShardReplicationPositionsResponse, error)
	// ShardReplicationRemove removes an entry from a topodata.ShardReplication
	// object.
	//
	// It is a low-level function and should generally not be called.
	ShardReplicationRemove(ctx context.Context, in *vtctldata.ShardReplicationRemoveRequest, opts ...grpc.CallOption) (*vtctldata.ShardReplicationRemoveResponse, error)
	// SleepTablet blocks the aciton queue on the specified tablet for the
	// specified duration.
	//
	// This is typically used for testing.
	SleepTablet(ctx context.Context, in *vtctldata.SleepTabletRequest, opts ...grpc.CallOption) (*vtctldata.SleepTabletResponse, error)
	// SourceShardAdd adds the SourceShard record with the provided index. This
	// should be used only as an emergency function.
	//
	// It does not call RefreshState for the shard primary.
	SourceShardAdd(ctx context.Context, in *vtctldata.SourceShardAddRequest, opts ...grpc.CallOption) (*vtctldata.SourceShardAddResponse, error)
	// SourceShardDelete deletes the SourceShard record with the provided index.
	// This should be used only as an emergency cleanup function.
	//
	// It does not call RefreshState for the shard primary.
	SourceShardDelete(ctx context.Context, in *vtctldata.SourceShardDeleteRequest, opts ...grpc.CallOption) (*vtctldata.SourceShardDeleteResponse, error)
	// StartReplication starts replication on the specified tablet.
	StartReplication(ctx context.Context, in *vtctldata.StartReplicationRequest, opts ...grpc.CallOption) (*vtctldata.StartReplicationResponse, error)
	// StopReplication stops replication on the specified tablet.
	StopReplication(ctx context.Context, in *vtctldata.StopReplicationRequest, opts ...grpc.CallOption) (*vtctldata.StopReplicationResponse, error)
	// TabletExternallyReparented changes metadata in the topology server to
	// acknowledge a shard primary change performed by an external tool (e.g.
	// orchestrator).
	//
	// See the Reparenting guide for more information:
	// https://vitess.io/docs/user-guides/configuration-advanced/reparenting/#external-reparenting.
	TabletExternallyReparented(ctx context.Context, in *vtctldata.TabletExternallyReparentedRequest, opts ...grpc.CallOption) (*vtctldata.TabletExternallyReparentedResponse, error)
	// UpdateCellInfo updates the content of a CellInfo with the provided
	// parameters. Empty values are ignored. If the cell does not exist, the
	// CellInfo will be created.
	UpdateCellInfo(ctx context.Context, in *vtctldata.UpdateCellInfoRequest, opts ...grpc.CallOption) (*vtctldata.UpdateCellInfoResponse, error)
	// UpdateCellsAlias updates the content of a CellsAlias with the provided
	// parameters. Empty values are ignored. If the alias does not exist, the
	// CellsAlias will be created.
	UpdateCellsAlias(ctx context.Context, in *vtctldata.UpdateCellsAliasRequest, opts ...grpc.CallOption) (*vtctldata.UpdateCellsAliasResponse, error)
	// Validate validates that all nodes from the global replication graph are
	// reachable, and that all tablets in discoverable cells are consistent.
	Validate(ctx context.Context, in *vtctldata.ValidateRequest, opts ...grpc.CallOption) (*vtctldata.ValidateResponse, error)
	// ValidateKeyspace validates that all nodes reachable from the specified
	// keyspace are consistent.
	ValidateKeyspace(ctx context.Context, in *vtctldata.ValidateKeyspaceRequest, opts ...grpc.CallOption) (*vtctldata.ValidateKeyspaceResponse, error)
	// ValidateSchemaKeyspace validates that the schema on the primary tablet for shard 0 matches the schema on all of the other tablets in the keyspace.
	ValidateSchemaKeyspace(ctx context.Context, in *vtctldata.ValidateSchemaKeyspaceRequest, opts ...grpc.CallOption) (*vtctldata.ValidateSchemaKeyspaceResponse, error)
	// ValidateShard validates that all nodes reachable from the specified shard
	// are consistent.
	ValidateShard(ctx context.Context, in *vtctldata.ValidateShardRequest, opts ...grpc.CallOption) (*vtctldata.ValidateShardResponse, error)
	// ValidateVersionKeyspace validates that the version on the primary of shard 0 matches all of the other tablets in the keyspace.
	ValidateVersionKeyspace(ctx context.Context, in *vtctldata.ValidateVersionKeyspaceRequest, opts ...grpc.CallOption) (*vtctldata.ValidateVersionKeyspaceResponse, error)
	// ValidateVersionShard validates that the version on the primary matches all of the replicas.
	ValidateVersionShard(ctx context.Context, in *vtctldata.ValidateVersionShardRequest, opts ...grpc.CallOption) (*vtctldata.ValidateVersionShardResponse, error)
	// ValidateVSchema compares the schema of each primary tablet in "keyspace/shards..." to the vschema and errs if there are differences.
	ValidateVSchema(ctx context.Context, in *vtctldata.ValidateVSchemaRequest, opts ...grpc.CallOption) (*vtctldata.ValidateVSchemaResponse, error)
	// WorkflowUpdate updates the configuration of a vreplication workflow
	// using the provided updated parameters.
	WorkflowUpdate(ctx context.Context, in *vtctldata.WorkflowUpdateRequest, opts ...grpc.CallOption) (*vtctldata.WorkflowUpdateResponse, error)
}

type vtctldClient struct {
	cc grpc.ClientConnInterface
}

func NewVtctldClient(cc grpc.ClientConnInterface) VtctldClient {
	return &vtctldClient{cc}
}

func (c *vtctldClient) AddCellInfo(ctx context.Context, in *vtctldata.AddCellInfoRequest, opts ...grpc.CallOption) (*vtctldata.AddCellInfoResponse, error) {
	out := new(vtctldata.AddCellInfoResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/AddCellInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) AddCellsAlias(ctx context.Context, in *vtctldata.AddCellsAliasRequest, opts ...grpc.CallOption) (*vtctldata.AddCellsAliasResponse, error) {
	out := new(vtctldata.AddCellsAliasResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/AddCellsAlias", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) ApplyRoutingRules(ctx context.Context, in *vtctldata.ApplyRoutingRulesRequest, opts ...grpc.CallOption) (*vtctldata.ApplyRoutingRulesResponse, error) {
	out := new(vtctldata.ApplyRoutingRulesResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/ApplyRoutingRules", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) ApplySchema(ctx context.Context, in *vtctldata.ApplySchemaRequest, opts ...grpc.CallOption) (*vtctldata.ApplySchemaResponse, error) {
	out := new(vtctldata.ApplySchemaResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/ApplySchema", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) ApplyShardRoutingRules(ctx context.Context, in *vtctldata.ApplyShardRoutingRulesRequest, opts ...grpc.CallOption) (*vtctldata.ApplyShardRoutingRulesResponse, error) {
	out := new(vtctldata.ApplyShardRoutingRulesResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/ApplyShardRoutingRules", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) ApplyVSchema(ctx context.Context, in *vtctldata.ApplyVSchemaRequest, opts ...grpc.CallOption) (*vtctldata.ApplyVSchemaResponse, error) {
	out := new(vtctldata.ApplyVSchemaResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/ApplyVSchema", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) Backup(ctx context.Context, in *vtctldata.BackupRequest, opts ...grpc.CallOption) (Vtctld_BackupClient, error) {
	stream, err := c.cc.NewStream(ctx, &Vtctld_ServiceDesc.Streams[0], "/vtctlservice.Vtctld/Backup", opts...)
	if err != nil {
		return nil, err
	}
	x := &vtctldBackupClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Vtctld_BackupClient interface {
	Recv() (*vtctldata.BackupResponse, error)
	grpc.ClientStream
}

type vtctldBackupClient struct {
	grpc.ClientStream
}

func (x *vtctldBackupClient) Recv() (*vtctldata.BackupResponse, error) {
	m := new(vtctldata.BackupResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *vtctldClient) BackupShard(ctx context.Context, in *vtctldata.BackupShardRequest, opts ...grpc.CallOption) (Vtctld_BackupShardClient, error) {
	stream, err := c.cc.NewStream(ctx, &Vtctld_ServiceDesc.Streams[1], "/vtctlservice.Vtctld/BackupShard", opts...)
	if err != nil {
		return nil, err
	}
	x := &vtctldBackupShardClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Vtctld_BackupShardClient interface {
	Recv() (*vtctldata.BackupResponse, error)
	grpc.ClientStream
}

type vtctldBackupShardClient struct {
	grpc.ClientStream
}

func (x *vtctldBackupShardClient) Recv() (*vtctldata.BackupResponse, error) {
	m := new(vtctldata.BackupResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *vtctldClient) ChangeTabletType(ctx context.Context, in *vtctldata.ChangeTabletTypeRequest, opts ...grpc.CallOption) (*vtctldata.ChangeTabletTypeResponse, error) {
	out := new(vtctldata.ChangeTabletTypeResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/ChangeTabletType", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) CreateKeyspace(ctx context.Context, in *vtctldata.CreateKeyspaceRequest, opts ...grpc.CallOption) (*vtctldata.CreateKeyspaceResponse, error) {
	out := new(vtctldata.CreateKeyspaceResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/CreateKeyspace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) CreateShard(ctx context.Context, in *vtctldata.CreateShardRequest, opts ...grpc.CallOption) (*vtctldata.CreateShardResponse, error) {
	out := new(vtctldata.CreateShardResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/CreateShard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) DeleteCellInfo(ctx context.Context, in *vtctldata.DeleteCellInfoRequest, opts ...grpc.CallOption) (*vtctldata.DeleteCellInfoResponse, error) {
	out := new(vtctldata.DeleteCellInfoResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/DeleteCellInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) DeleteCellsAlias(ctx context.Context, in *vtctldata.DeleteCellsAliasRequest, opts ...grpc.CallOption) (*vtctldata.DeleteCellsAliasResponse, error) {
	out := new(vtctldata.DeleteCellsAliasResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/DeleteCellsAlias", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) DeleteKeyspace(ctx context.Context, in *vtctldata.DeleteKeyspaceRequest, opts ...grpc.CallOption) (*vtctldata.DeleteKeyspaceResponse, error) {
	out := new(vtctldata.DeleteKeyspaceResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/DeleteKeyspace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) DeleteShards(ctx context.Context, in *vtctldata.DeleteShardsRequest, opts ...grpc.CallOption) (*vtctldata.DeleteShardsResponse, error) {
	out := new(vtctldata.DeleteShardsResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/DeleteShards", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) DeleteSrvVSchema(ctx context.Context, in *vtctldata.DeleteSrvVSchemaRequest, opts ...grpc.CallOption) (*vtctldata.DeleteSrvVSchemaResponse, error) {
	out := new(vtctldata.DeleteSrvVSchemaResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/DeleteSrvVSchema", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) DeleteTablets(ctx context.Context, in *vtctldata.DeleteTabletsRequest, opts ...grpc.CallOption) (*vtctldata.DeleteTabletsResponse, error) {
	out := new(vtctldata.DeleteTabletsResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/DeleteTablets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) EmergencyReparentShard(ctx context.Context, in *vtctldata.EmergencyReparentShardRequest, opts ...grpc.CallOption) (*vtctldata.EmergencyReparentShardResponse, error) {
	out := new(vtctldata.EmergencyReparentShardResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/EmergencyReparentShard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) ExecuteFetchAsApp(ctx context.Context, in *vtctldata.ExecuteFetchAsAppRequest, opts ...grpc.CallOption) (*vtctldata.ExecuteFetchAsAppResponse, error) {
	out := new(vtctldata.ExecuteFetchAsAppResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/ExecuteFetchAsApp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) ExecuteFetchAsDBA(ctx context.Context, in *vtctldata.ExecuteFetchAsDBARequest, opts ...grpc.CallOption) (*vtctldata.ExecuteFetchAsDBAResponse, error) {
	out := new(vtctldata.ExecuteFetchAsDBAResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/ExecuteFetchAsDBA", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) ExecuteHook(ctx context.Context, in *vtctldata.ExecuteHookRequest, opts ...grpc.CallOption) (*vtctldata.ExecuteHookResponse, error) {
	out := new(vtctldata.ExecuteHookResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/ExecuteHook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) FindAllShardsInKeyspace(ctx context.Context, in *vtctldata.FindAllShardsInKeyspaceRequest, opts ...grpc.CallOption) (*vtctldata.FindAllShardsInKeyspaceResponse, error) {
	out := new(vtctldata.FindAllShardsInKeyspaceResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/FindAllShardsInKeyspace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetBackups(ctx context.Context, in *vtctldata.GetBackupsRequest, opts ...grpc.CallOption) (*vtctldata.GetBackupsResponse, error) {
	out := new(vtctldata.GetBackupsResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetBackups", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetCellInfo(ctx context.Context, in *vtctldata.GetCellInfoRequest, opts ...grpc.CallOption) (*vtctldata.GetCellInfoResponse, error) {
	out := new(vtctldata.GetCellInfoResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetCellInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetCellInfoNames(ctx context.Context, in *vtctldata.GetCellInfoNamesRequest, opts ...grpc.CallOption) (*vtctldata.GetCellInfoNamesResponse, error) {
	out := new(vtctldata.GetCellInfoNamesResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetCellInfoNames", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetCellsAliases(ctx context.Context, in *vtctldata.GetCellsAliasesRequest, opts ...grpc.CallOption) (*vtctldata.GetCellsAliasesResponse, error) {
	out := new(vtctldata.GetCellsAliasesResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetCellsAliases", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetFullStatus(ctx context.Context, in *vtctldata.GetFullStatusRequest, opts ...grpc.CallOption) (*vtctldata.GetFullStatusResponse, error) {
	out := new(vtctldata.GetFullStatusResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetFullStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetKeyspace(ctx context.Context, in *vtctldata.GetKeyspaceRequest, opts ...grpc.CallOption) (*vtctldata.GetKeyspaceResponse, error) {
	out := new(vtctldata.GetKeyspaceResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetKeyspace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetKeyspaces(ctx context.Context, in *vtctldata.GetKeyspacesRequest, opts ...grpc.CallOption) (*vtctldata.GetKeyspacesResponse, error) {
	out := new(vtctldata.GetKeyspacesResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetKeyspaces", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetPermissions(ctx context.Context, in *vtctldata.GetPermissionsRequest, opts ...grpc.CallOption) (*vtctldata.GetPermissionsResponse, error) {
	out := new(vtctldata.GetPermissionsResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetPermissions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetRoutingRules(ctx context.Context, in *vtctldata.GetRoutingRulesRequest, opts ...grpc.CallOption) (*vtctldata.GetRoutingRulesResponse, error) {
	out := new(vtctldata.GetRoutingRulesResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetRoutingRules", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetSchema(ctx context.Context, in *vtctldata.GetSchemaRequest, opts ...grpc.CallOption) (*vtctldata.GetSchemaResponse, error) {
	out := new(vtctldata.GetSchemaResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetSchema", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetShard(ctx context.Context, in *vtctldata.GetShardRequest, opts ...grpc.CallOption) (*vtctldata.GetShardResponse, error) {
	out := new(vtctldata.GetShardResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetShard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetShardRoutingRules(ctx context.Context, in *vtctldata.GetShardRoutingRulesRequest, opts ...grpc.CallOption) (*vtctldata.GetShardRoutingRulesResponse, error) {
	out := new(vtctldata.GetShardRoutingRulesResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetShardRoutingRules", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetSrvKeyspaceNames(ctx context.Context, in *vtctldata.GetSrvKeyspaceNamesRequest, opts ...grpc.CallOption) (*vtctldata.GetSrvKeyspaceNamesResponse, error) {
	out := new(vtctldata.GetSrvKeyspaceNamesResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetSrvKeyspaceNames", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetSrvKeyspaces(ctx context.Context, in *vtctldata.GetSrvKeyspacesRequest, opts ...grpc.CallOption) (*vtctldata.GetSrvKeyspacesResponse, error) {
	out := new(vtctldata.GetSrvKeyspacesResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetSrvKeyspaces", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) UpdateThrottlerConfig(ctx context.Context, in *vtctldata.UpdateThrottlerConfigRequest, opts ...grpc.CallOption) (*vtctldata.UpdateThrottlerConfigResponse, error) {
	out := new(vtctldata.UpdateThrottlerConfigResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/UpdateThrottlerConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetSrvVSchema(ctx context.Context, in *vtctldata.GetSrvVSchemaRequest, opts ...grpc.CallOption) (*vtctldata.GetSrvVSchemaResponse, error) {
	out := new(vtctldata.GetSrvVSchemaResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetSrvVSchema", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetSrvVSchemas(ctx context.Context, in *vtctldata.GetSrvVSchemasRequest, opts ...grpc.CallOption) (*vtctldata.GetSrvVSchemasResponse, error) {
	out := new(vtctldata.GetSrvVSchemasResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetSrvVSchemas", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetTablet(ctx context.Context, in *vtctldata.GetTabletRequest, opts ...grpc.CallOption) (*vtctldata.GetTabletResponse, error) {
	out := new(vtctldata.GetTabletResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetTablet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetTablets(ctx context.Context, in *vtctldata.GetTabletsRequest, opts ...grpc.CallOption) (*vtctldata.GetTabletsResponse, error) {
	out := new(vtctldata.GetTabletsResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetTablets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetTopologyPath(ctx context.Context, in *vtctldata.GetTopologyPathRequest, opts ...grpc.CallOption) (*vtctldata.GetTopologyPathResponse, error) {
	out := new(vtctldata.GetTopologyPathResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetTopologyPath", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetVersion(ctx context.Context, in *vtctldata.GetVersionRequest, opts ...grpc.CallOption) (*vtctldata.GetVersionResponse, error) {
	out := new(vtctldata.GetVersionResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetVSchema(ctx context.Context, in *vtctldata.GetVSchemaRequest, opts ...grpc.CallOption) (*vtctldata.GetVSchemaResponse, error) {
	out := new(vtctldata.GetVSchemaResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetVSchema", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetWorkflows(ctx context.Context, in *vtctldata.GetWorkflowsRequest, opts ...grpc.CallOption) (*vtctldata.GetWorkflowsResponse, error) {
	out := new(vtctldata.GetWorkflowsResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetWorkflows", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) InitShardPrimary(ctx context.Context, in *vtctldata.InitShardPrimaryRequest, opts ...grpc.CallOption) (*vtctldata.InitShardPrimaryResponse, error) {
	out := new(vtctldata.InitShardPrimaryResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/InitShardPrimary", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) PingTablet(ctx context.Context, in *vtctldata.PingTabletRequest, opts ...grpc.CallOption) (*vtctldata.PingTabletResponse, error) {
	out := new(vtctldata.PingTabletResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/PingTablet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) PlannedReparentShard(ctx context.Context, in *vtctldata.PlannedReparentShardRequest, opts ...grpc.CallOption) (*vtctldata.PlannedReparentShardResponse, error) {
	out := new(vtctldata.PlannedReparentShardResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/PlannedReparentShard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) RebuildKeyspaceGraph(ctx context.Context, in *vtctldata.RebuildKeyspaceGraphRequest, opts ...grpc.CallOption) (*vtctldata.RebuildKeyspaceGraphResponse, error) {
	out := new(vtctldata.RebuildKeyspaceGraphResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/RebuildKeyspaceGraph", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) RebuildVSchemaGraph(ctx context.Context, in *vtctldata.RebuildVSchemaGraphRequest, opts ...grpc.CallOption) (*vtctldata.RebuildVSchemaGraphResponse, error) {
	out := new(vtctldata.RebuildVSchemaGraphResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/RebuildVSchemaGraph", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) RefreshState(ctx context.Context, in *vtctldata.RefreshStateRequest, opts ...grpc.CallOption) (*vtctldata.RefreshStateResponse, error) {
	out := new(vtctldata.RefreshStateResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/RefreshState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) RefreshStateByShard(ctx context.Context, in *vtctldata.RefreshStateByShardRequest, opts ...grpc.CallOption) (*vtctldata.RefreshStateByShardResponse, error) {
	out := new(vtctldata.RefreshStateByShardResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/RefreshStateByShard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) ReloadSchema(ctx context.Context, in *vtctldata.ReloadSchemaRequest, opts ...grpc.CallOption) (*vtctldata.ReloadSchemaResponse, error) {
	out := new(vtctldata.ReloadSchemaResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/ReloadSchema", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) ReloadSchemaKeyspace(ctx context.Context, in *vtctldata.ReloadSchemaKeyspaceRequest, opts ...grpc.CallOption) (*vtctldata.ReloadSchemaKeyspaceResponse, error) {
	out := new(vtctldata.ReloadSchemaKeyspaceResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/ReloadSchemaKeyspace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) ReloadSchemaShard(ctx context.Context, in *vtctldata.ReloadSchemaShardRequest, opts ...grpc.CallOption) (*vtctldata.ReloadSchemaShardResponse, error) {
	out := new(vtctldata.ReloadSchemaShardResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/ReloadSchemaShard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) RemoveBackup(ctx context.Context, in *vtctldata.RemoveBackupRequest, opts ...grpc.CallOption) (*vtctldata.RemoveBackupResponse, error) {
	out := new(vtctldata.RemoveBackupResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/RemoveBackup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) RemoveKeyspaceCell(ctx context.Context, in *vtctldata.RemoveKeyspaceCellRequest, opts ...grpc.CallOption) (*vtctldata.RemoveKeyspaceCellResponse, error) {
	out := new(vtctldata.RemoveKeyspaceCellResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/RemoveKeyspaceCell", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) RemoveShardCell(ctx context.Context, in *vtctldata.RemoveShardCellRequest, opts ...grpc.CallOption) (*vtctldata.RemoveShardCellResponse, error) {
	out := new(vtctldata.RemoveShardCellResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/RemoveShardCell", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) ReparentTablet(ctx context.Context, in *vtctldata.ReparentTabletRequest, opts ...grpc.CallOption) (*vtctldata.ReparentTabletResponse, error) {
	out := new(vtctldata.ReparentTabletResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/ReparentTablet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) RestoreFromBackup(ctx context.Context, in *vtctldata.RestoreFromBackupRequest, opts ...grpc.CallOption) (Vtctld_RestoreFromBackupClient, error) {
	stream, err := c.cc.NewStream(ctx, &Vtctld_ServiceDesc.Streams[2], "/vtctlservice.Vtctld/RestoreFromBackup", opts...)
	if err != nil {
		return nil, err
	}
	x := &vtctldRestoreFromBackupClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Vtctld_RestoreFromBackupClient interface {
	Recv() (*vtctldata.RestoreFromBackupResponse, error)
	grpc.ClientStream
}

type vtctldRestoreFromBackupClient struct {
	grpc.ClientStream
}

func (x *vtctldRestoreFromBackupClient) Recv() (*vtctldata.RestoreFromBackupResponse, error) {
	m := new(vtctldata.RestoreFromBackupResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *vtctldClient) RunHealthCheck(ctx context.Context, in *vtctldata.RunHealthCheckRequest, opts ...grpc.CallOption) (*vtctldata.RunHealthCheckResponse, error) {
	out := new(vtctldata.RunHealthCheckResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/RunHealthCheck", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) SetKeyspaceDurabilityPolicy(ctx context.Context, in *vtctldata.SetKeyspaceDurabilityPolicyRequest, opts ...grpc.CallOption) (*vtctldata.SetKeyspaceDurabilityPolicyResponse, error) {
	out := new(vtctldata.SetKeyspaceDurabilityPolicyResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/SetKeyspaceDurabilityPolicy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) SetShardIsPrimaryServing(ctx context.Context, in *vtctldata.SetShardIsPrimaryServingRequest, opts ...grpc.CallOption) (*vtctldata.SetShardIsPrimaryServingResponse, error) {
	out := new(vtctldata.SetShardIsPrimaryServingResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/SetShardIsPrimaryServing", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) SetShardTabletControl(ctx context.Context, in *vtctldata.SetShardTabletControlRequest, opts ...grpc.CallOption) (*vtctldata.SetShardTabletControlResponse, error) {
	out := new(vtctldata.SetShardTabletControlResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/SetShardTabletControl", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) SetWritable(ctx context.Context, in *vtctldata.SetWritableRequest, opts ...grpc.CallOption) (*vtctldata.SetWritableResponse, error) {
	out := new(vtctldata.SetWritableResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/SetWritable", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) ShardReplicationAdd(ctx context.Context, in *vtctldata.ShardReplicationAddRequest, opts ...grpc.CallOption) (*vtctldata.ShardReplicationAddResponse, error) {
	out := new(vtctldata.ShardReplicationAddResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/ShardReplicationAdd", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) ShardReplicationFix(ctx context.Context, in *vtctldata.ShardReplicationFixRequest, opts ...grpc.CallOption) (*vtctldata.ShardReplicationFixResponse, error) {
	out := new(vtctldata.ShardReplicationFixResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/ShardReplicationFix", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) ShardReplicationPositions(ctx context.Context, in *vtctldata.ShardReplicationPositionsRequest, opts ...grpc.CallOption) (*vtctldata.ShardReplicationPositionsResponse, error) {
	out := new(vtctldata.ShardReplicationPositionsResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/ShardReplicationPositions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) ShardReplicationRemove(ctx context.Context, in *vtctldata.ShardReplicationRemoveRequest, opts ...grpc.CallOption) (*vtctldata.ShardReplicationRemoveResponse, error) {
	out := new(vtctldata.ShardReplicationRemoveResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/ShardReplicationRemove", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) SleepTablet(ctx context.Context, in *vtctldata.SleepTabletRequest, opts ...grpc.CallOption) (*vtctldata.SleepTabletResponse, error) {
	out := new(vtctldata.SleepTabletResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/SleepTablet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) SourceShardAdd(ctx context.Context, in *vtctldata.SourceShardAddRequest, opts ...grpc.CallOption) (*vtctldata.SourceShardAddResponse, error) {
	out := new(vtctldata.SourceShardAddResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/SourceShardAdd", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) SourceShardDelete(ctx context.Context, in *vtctldata.SourceShardDeleteRequest, opts ...grpc.CallOption) (*vtctldata.SourceShardDeleteResponse, error) {
	out := new(vtctldata.SourceShardDeleteResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/SourceShardDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) StartReplication(ctx context.Context, in *vtctldata.StartReplicationRequest, opts ...grpc.CallOption) (*vtctldata.StartReplicationResponse, error) {
	out := new(vtctldata.StartReplicationResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/StartReplication", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) StopReplication(ctx context.Context, in *vtctldata.StopReplicationRequest, opts ...grpc.CallOption) (*vtctldata.StopReplicationResponse, error) {
	out := new(vtctldata.StopReplicationResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/StopReplication", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) TabletExternallyReparented(ctx context.Context, in *vtctldata.TabletExternallyReparentedRequest, opts ...grpc.CallOption) (*vtctldata.TabletExternallyReparentedResponse, error) {
	out := new(vtctldata.TabletExternallyReparentedResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/TabletExternallyReparented", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) UpdateCellInfo(ctx context.Context, in *vtctldata.UpdateCellInfoRequest, opts ...grpc.CallOption) (*vtctldata.UpdateCellInfoResponse, error) {
	out := new(vtctldata.UpdateCellInfoResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/UpdateCellInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) UpdateCellsAlias(ctx context.Context, in *vtctldata.UpdateCellsAliasRequest, opts ...grpc.CallOption) (*vtctldata.UpdateCellsAliasResponse, error) {
	out := new(vtctldata.UpdateCellsAliasResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/UpdateCellsAlias", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) Validate(ctx context.Context, in *vtctldata.ValidateRequest, opts ...grpc.CallOption) (*vtctldata.ValidateResponse, error) {
	out := new(vtctldata.ValidateResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/Validate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) ValidateKeyspace(ctx context.Context, in *vtctldata.ValidateKeyspaceRequest, opts ...grpc.CallOption) (*vtctldata.ValidateKeyspaceResponse, error) {
	out := new(vtctldata.ValidateKeyspaceResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/ValidateKeyspace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) ValidateSchemaKeyspace(ctx context.Context, in *vtctldata.ValidateSchemaKeyspaceRequest, opts ...grpc.CallOption) (*vtctldata.ValidateSchemaKeyspaceResponse, error) {
	out := new(vtctldata.ValidateSchemaKeyspaceResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/ValidateSchemaKeyspace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) ValidateShard(ctx context.Context, in *vtctldata.ValidateShardRequest, opts ...grpc.CallOption) (*vtctldata.ValidateShardResponse, error) {
	out := new(vtctldata.ValidateShardResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/ValidateShard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) ValidateVersionKeyspace(ctx context.Context, in *vtctldata.ValidateVersionKeyspaceRequest, opts ...grpc.CallOption) (*vtctldata.ValidateVersionKeyspaceResponse, error) {
	out := new(vtctldata.ValidateVersionKeyspaceResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/ValidateVersionKeyspace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) ValidateVersionShard(ctx context.Context, in *vtctldata.ValidateVersionShardRequest, opts ...grpc.CallOption) (*vtctldata.ValidateVersionShardResponse, error) {
	out := new(vtctldata.ValidateVersionShardResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/ValidateVersionShard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) ValidateVSchema(ctx context.Context, in *vtctldata.ValidateVSchemaRequest, opts ...grpc.CallOption) (*vtctldata.ValidateVSchemaResponse, error) {
	out := new(vtctldata.ValidateVSchemaResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/ValidateVSchema", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) WorkflowUpdate(ctx context.Context, in *vtctldata.WorkflowUpdateRequest, opts ...grpc.CallOption) (*vtctldata.WorkflowUpdateResponse, error) {
	out := new(vtctldata.WorkflowUpdateResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/WorkflowUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VtctldServer is the server API for Vtctld service.
// All implementations must embed UnimplementedVtctldServer
// for forward compatibility
type VtctldServer interface {
	// AddCellInfo registers a local topology service in a new cell by creating
	// the CellInfo with the provided parameters.
	AddCellInfo(context.Context, *vtctldata.AddCellInfoRequest) (*vtctldata.AddCellInfoResponse, error)
	// AddCellsAlias defines a group of cells that can be referenced by a single
	// name (the alias).
	//
	// When routing query traffic, replica/rdonly traffic can be routed across
	// cells within the group (alias). Only primary traffic can be routed across
	// cells not in the same group (alias).
	AddCellsAlias(context.Context, *vtctldata.AddCellsAliasRequest) (*vtctldata.AddCellsAliasResponse, error)
	// ApplyRoutingRules applies the VSchema routing rules.
	ApplyRoutingRules(context.Context, *vtctldata.ApplyRoutingRulesRequest) (*vtctldata.ApplyRoutingRulesResponse, error)
	// ApplySchema applies a schema to a keyspace.
	ApplySchema(context.Context, *vtctldata.ApplySchemaRequest) (*vtctldata.ApplySchemaResponse, error)
	// ApplyShardRoutingRules applies the VSchema shard routing rules.
	ApplyShardRoutingRules(context.Context, *vtctldata.ApplyShardRoutingRulesRequest) (*vtctldata.ApplyShardRoutingRulesResponse, error)
	// ApplyVSchema applies a vschema to a keyspace.
	ApplyVSchema(context.Context, *vtctldata.ApplyVSchemaRequest) (*vtctldata.ApplyVSchemaResponse, error)
	// Backup uses the BackupEngine and BackupStorage services on the specified
	// tablet to create and store a new backup.
	Backup(*vtctldata.BackupRequest, Vtctld_BackupServer) error
	// BackupShard chooses a tablet in the shard and uses it to create a backup.
	BackupShard(*vtctldata.BackupShardRequest, Vtctld_BackupShardServer) error
	// ChangeTabletType changes the db type for the specified tablet, if possible.
	// This is used primarily to arrange replicas, and it will not convert a
	// primary. For that, use InitShardPrimary.
	//
	// NOTE: This command automatically updates the serving graph.
	ChangeTabletType(context.Context, *vtctldata.ChangeTabletTypeRequest) (*vtctldata.ChangeTabletTypeResponse, error)
	// CreateKeyspace creates the specified keyspace in the topology. For a
	// SNAPSHOT keyspace, the request must specify the name of a base keyspace,
	// as well as a snapshot time.
	CreateKeyspace(context.Context, *vtctldata.CreateKeyspaceRequest) (*vtctldata.CreateKeyspaceResponse, error)
	// CreateShard creates the specified shard in the topology.
	CreateShard(context.Context, *vtctldata.CreateShardRequest) (*vtctldata.CreateShardResponse, error)
	// DeleteCellInfo deletes the CellInfo for the provided cell. The cell cannot
	// be referenced by any Shard record in the topology.
	DeleteCellInfo(context.Context, *vtctldata.DeleteCellInfoRequest) (*vtctldata.DeleteCellInfoResponse, error)
	// DeleteCellsAlias deletes the CellsAlias for the provided alias.
	DeleteCellsAlias(context.Context, *vtctldata.DeleteCellsAliasRequest) (*vtctldata.DeleteCellsAliasResponse, error)
	// DeleteKeyspace deletes the specified keyspace from the topology. In
	// recursive mode, it also recursively deletes all shards in the keyspace.
	// Otherwise, the keyspace must be empty (have no shards), or DeleteKeyspace
	// returns an error.
	DeleteKeyspace(context.Context, *vtctldata.DeleteKeyspaceRequest) (*vtctldata.DeleteKeyspaceResponse, error)
	// DeleteShards deletes the specified shards from the topology. In recursive
	// mode, it also deletes all tablets belonging to the shard. Otherwise, the
	// shard must be empty (have no tablets) or DeleteShards returns an error for
	// that shard.
	DeleteShards(context.Context, *vtctldata.DeleteShardsRequest) (*vtctldata.DeleteShardsResponse, error)
	// DeleteSrvVSchema deletes the SrvVSchema object in the specified cell.
	DeleteSrvVSchema(context.Context, *vtctldata.DeleteSrvVSchemaRequest) (*vtctldata.DeleteSrvVSchemaResponse, error)
	// DeleteTablets deletes one or more tablets from the topology.
	DeleteTablets(context.Context, *vtctldata.DeleteTabletsRequest) (*vtctldata.DeleteTabletsResponse, error)
	// EmergencyReparentShard reparents the shard to the new primary. It assumes
	// the old primary is dead or otherwise not responding.
	EmergencyReparentShard(context.Context, *vtctldata.EmergencyReparentShardRequest) (*vtctldata.EmergencyReparentShardResponse, error)
	// ExecuteFetchAsApp executes a SQL query on the remote tablet as the App user.
	ExecuteFetchAsApp(context.Context, *vtctldata.ExecuteFetchAsAppRequest) (*vtctldata.ExecuteFetchAsAppResponse, error)
	// ExecuteFetchAsDBA executes a SQL query on the remote tablet as the DBA user.
	ExecuteFetchAsDBA(context.Context, *vtctldata.ExecuteFetchAsDBARequest) (*vtctldata.ExecuteFetchAsDBAResponse, error)
	// ExecuteHook runs the hook on the tablet.
	ExecuteHook(context.Context, *vtctldata.ExecuteHookRequest) (*vtctldata.ExecuteHookResponse, error)
	// FindAllShardsInKeyspace returns a map of shard names to shard references
	// for a given keyspace.
	FindAllShardsInKeyspace(context.Context, *vtctldata.FindAllShardsInKeyspaceRequest) (*vtctldata.FindAllShardsInKeyspaceResponse, error)
	// GetBackups returns all the backups for a shard.
	GetBackups(context.Context, *vtctldata.GetBackupsRequest) (*vtctldata.GetBackupsResponse, error)
	// GetCellInfo returns the information for a cell.
	GetCellInfo(context.Context, *vtctldata.GetCellInfoRequest) (*vtctldata.GetCellInfoResponse, error)
	// GetCellInfoNames returns all the cells for which we have a CellInfo object,
	// meaning we have a topology service registered.
	GetCellInfoNames(context.Context, *vtctldata.GetCellInfoNamesRequest) (*vtctldata.GetCellInfoNamesResponse, error)
	// GetCellsAliases returns a mapping of cell alias to cells identified by that
	// alias.
	GetCellsAliases(context.Context, *vtctldata.GetCellsAliasesRequest) (*vtctldata.GetCellsAliasesResponse, error)
	// GetFullStatus returns the full status of MySQL including the replication information, semi-sync information, GTID information among others
	GetFullStatus(context.Context, *vtctldata.GetFullStatusRequest) (*vtctldata.GetFullStatusResponse, error)
	// GetKeyspace reads the given keyspace from the topo and returns it.
	GetKeyspace(context.Context, *vtctldata.GetKeyspaceRequest) (*vtctldata.GetKeyspaceResponse, error)
	// GetKeyspaces returns the keyspace struct of all keyspaces in the topo.
	GetKeyspaces(context.Context, *vtctldata.GetKeyspacesRequest) (*vtctldata.GetKeyspacesResponse, error)
	// GetPermissions returns the permissions set on the remote tablet.
	GetPermissions(context.Context, *vtctldata.GetPermissionsRequest) (*vtctldata.GetPermissionsResponse, error)
	// GetRoutingRules returns the VSchema routing rules.
	GetRoutingRules(context.Context, *vtctldata.GetRoutingRulesRequest) (*vtctldata.GetRoutingRulesResponse, error)
	// GetSchema returns the schema for a tablet, or just the schema for the
	// specified tables in that tablet.
	GetSchema(context.Context, *vtctldata.GetSchemaRequest) (*vtctldata.GetSchemaResponse, error)
	// GetShard returns information about a shard in the topology.
	GetShard(context.Context, *vtctldata.GetShardRequest) (*vtctldata.GetShardResponse, error)
	// GetShardRoutingRules returns the VSchema shard routing rules.
	GetShardRoutingRules(context.Context, *vtctldata.GetShardRoutingRulesRequest) (*vtctldata.GetShardRoutingRulesResponse, error)
	// GetSrvKeyspaceNames returns a mapping of cell name to the keyspaces served
	// in that cell.
	GetSrvKeyspaceNames(context.Context, *vtctldata.GetSrvKeyspaceNamesRequest) (*vtctldata.GetSrvKeyspaceNamesResponse, error)
	// GetSrvKeyspaces returns the SrvKeyspaces for a keyspace in one or more
	// cells.
	GetSrvKeyspaces(context.Context, *vtctldata.GetSrvKeyspacesRequest) (*vtctldata.GetSrvKeyspacesResponse, error)
	// UpdateThrottlerConfig updates the tablet throttler configuration
	UpdateThrottlerConfig(context.Context, *vtctldata.UpdateThrottlerConfigRequest) (*vtctldata.UpdateThrottlerConfigResponse, error)
	// GetSrvVSchema returns the SrvVSchema for a cell.
	GetSrvVSchema(context.Context, *vtctldata.GetSrvVSchemaRequest) (*vtctldata.GetSrvVSchemaResponse, error)
	// GetSrvVSchemas returns a mapping from cell name to SrvVSchema for all cells,
	// optionally filtered by cell name.
	GetSrvVSchemas(context.Context, *vtctldata.GetSrvVSchemasRequest) (*vtctldata.GetSrvVSchemasResponse, error)
	// GetTablet returns information about a tablet.
	GetTablet(context.Context, *vtctldata.GetTabletRequest) (*vtctldata.GetTabletResponse, error)
	// GetTablets returns tablets, optionally filtered by keyspace and shard.
	GetTablets(context.Context, *vtctldata.GetTabletsRequest) (*vtctldata.GetTabletsResponse, error)
	// GetTopologyPath returns the topology cell at a given path.
	GetTopologyPath(context.Context, *vtctldata.GetTopologyPathRequest) (*vtctldata.GetTopologyPathResponse, error)
	// GetVersion returns the version of a tablet from its debug vars.
	GetVersion(context.Context, *vtctldata.GetVersionRequest) (*vtctldata.GetVersionResponse, error)
	// GetVSchema returns the vschema for a keyspace.
	GetVSchema(context.Context, *vtctldata.GetVSchemaRequest) (*vtctldata.GetVSchemaResponse, error)
	// GetWorkflows returns a list of workflows for the given keyspace.
	GetWorkflows(context.Context, *vtctldata.GetWorkflowsRequest) (*vtctldata.GetWorkflowsResponse, error)
	// InitShardPrimary sets the initial primary for a shard. Will make all other
	// tablets in the shard replicas of the provided primary.
	//
	// WARNING: This could cause data loss on an already replicating shard.
	// PlannedReparentShard or EmergencyReparentShard should be used in those
	// cases instead.
	InitShardPrimary(context.Context, *vtctldata.InitShardPrimaryRequest) (*vtctldata.InitShardPrimaryResponse, error)
	// PingTablet checks that the specified tablet is awake and responding to RPCs.
	// This command can be blocked by other in-flight operations.
	PingTablet(context.Context, *vtctldata.PingTabletRequest) (*vtctldata.PingTabletResponse, error)
	// PlannedReparentShard reparents the shard to the new primary, or away from
	// an old primary. Both the old and new primaries need to be reachable and
	// running.
	//
	// **NOTE**: The vtctld will not consider any replicas outside the cell the
	// current shard primary is in for promotion unless NewPrimary is explicitly
	// provided in the request.
	PlannedReparentShard(context.Context, *vtctldata.PlannedReparentShardRequest) (*vtctldata.PlannedReparentShardResponse, error)
	// RebuildKeyspaceGraph rebuilds the serving data for a keyspace.
	//
	// This may trigger an update to all connected clients.
	RebuildKeyspaceGraph(context.Context, *vtctldata.RebuildKeyspaceGraphRequest) (*vtctldata.RebuildKeyspaceGraphResponse, error)
	// RebuildVSchemaGraph rebuilds the per-cell SrvVSchema from the global
	// VSchema objects in the provided cells (or all cells in the topo none
	// provided).
	RebuildVSchemaGraph(context.Context, *vtctldata.RebuildVSchemaGraphRequest) (*vtctldata.RebuildVSchemaGraphResponse, error)
	// RefreshState reloads the tablet record on the specified tablet.
	RefreshState(context.Context, *vtctldata.RefreshStateRequest) (*vtctldata.RefreshStateResponse, error)
	// RefreshStateByShard calls RefreshState on all the tablets in the given shard.
	RefreshStateByShard(context.Context, *vtctldata.RefreshStateByShardRequest) (*vtctldata.RefreshStateByShardResponse, error)
	// ReloadSchema instructs the remote tablet to reload its schema.
	ReloadSchema(context.Context, *vtctldata.ReloadSchemaRequest) (*vtctldata.ReloadSchemaResponse, error)
	// ReloadSchemaKeyspace reloads the schema on all tablets in a keyspace.
	ReloadSchemaKeyspace(context.Context, *vtctldata.ReloadSchemaKeyspaceRequest) (*vtctldata.ReloadSchemaKeyspaceResponse, error)
	// ReloadSchemaShard reloads the schema on all tablets in a shard.
	//
	// In general, we don't always expect all replicas to be ready to reload, and
	// the periodic schema reload makes them self-healing anyway. So, we do this
	// on a best-effort basis, and log warnings for any tablets that fail to
	// reload within the context deadline.
	ReloadSchemaShard(context.Context, *vtctldata.ReloadSchemaShardRequest) (*vtctldata.ReloadSchemaShardResponse, error)
	// RemoveBackup removes a backup from the BackupStorage used by vtctld.
	RemoveBackup(context.Context, *vtctldata.RemoveBackupRequest) (*vtctldata.RemoveBackupResponse, error)
	// RemoveKeyspaceCell removes the specified cell from the Cells list for all
	// shards in the specified keyspace (by calling RemoveShardCell on every
	// shard). It also removes the SrvKeyspace for that keyspace in that cell.
	RemoveKeyspaceCell(context.Context, *vtctldata.RemoveKeyspaceCellRequest) (*vtctldata.RemoveKeyspaceCellResponse, error)
	// RemoveShardCell removes the specified cell from the specified shard's Cells
	// list.
	RemoveShardCell(context.Context, *vtctldata.RemoveShardCellRequest) (*vtctldata.RemoveShardCellResponse, error)
	// ReparentTablet reparents a tablet to the current primary in the shard. This
	// only works if the current replica position matches the last known reparent
	// action.
	ReparentTablet(context.Context, *vtctldata.ReparentTabletRequest) (*vtctldata.ReparentTabletResponse, error)
	// RestoreFromBackup stops mysqld for the given tablet and restores a backup.
	RestoreFromBackup(*vtctldata.RestoreFromBackupRequest, Vtctld_RestoreFromBackupServer) error
	// RunHealthCheck runs a healthcheck on the remote tablet.
	RunHealthCheck(context.Context, *vtctldata.RunHealthCheckRequest) (*vtctldata.RunHealthCheckResponse, error)
	// SetKeyspaceDurabilityPolicy updates the DurabilityPolicy for a keyspace.
	SetKeyspaceDurabilityPolicy(context.Context, *vtctldata.SetKeyspaceDurabilityPolicyRequest) (*vtctldata.SetKeyspaceDurabilityPolicyResponse, error)
	// SetShardIsPrimaryServing adds or removes a shard from serving.
	//
	// This is meant as an emergency function. It does not rebuild any serving
	// graph (i.e. it does not run RebuildKeyspaceGraph).
	SetShardIsPrimaryServing(context.Context, *vtctldata.SetShardIsPrimaryServingRequest) (*vtctldata.SetShardIsPrimaryServingResponse, error)
	// SetShardTabletControl updates the TabletControl topo record for a shard and
	// tablet type.
	//
	// This should only be used for an emergency fix, or after a finished
	// Reshard. See the documentation on SetShardTabletControlRequest for more
	// information about the different update modes.
	SetShardTabletControl(context.Context, *vtctldata.SetShardTabletControlRequest) (*vtctldata.SetShardTabletControlResponse, error)
	// SetWritable sets a tablet as read-write (writable=true) or read-only (writable=false).
	SetWritable(context.Context, *vtctldata.SetWritableRequest) (*vtctldata.SetWritableResponse, error)
	// ShardReplicationAdd adds an entry to a topodata.ShardReplication object.
	//
	// It is a low-level function and should generally not be called.
	ShardReplicationAdd(context.Context, *vtctldata.ShardReplicationAddRequest) (*vtctldata.ShardReplicationAddResponse, error)
	// ShardReplicationFix walks the replication graph for a shard in a cell and
	// attempts to fix the first problem encountered, returning information about
	// the problem fixed, if any.
	ShardReplicationFix(context.Context, *vtctldata.ShardReplicationFixRequest) (*vtctldata.ShardReplicationFixResponse, error)
	// ShardReplicationPositions returns the replication position of each tablet
	// in a shard. This RPC makes a best-effort to return partial results. For
	// example, if one tablet in the shard graph is unreachable, then
	// ShardReplicationPositions will return non-error, and include valid results
	// for the reachable tablets.
	ShardReplicationPositions(context.Context, *vtctldata.ShardReplicationPositionsRequest) (*vtctldata.ShardReplicationPositionsResponse, error)
	// ShardReplicationRemove removes an entry from a topodata.ShardReplication
	// object.
	//
	// It is a low-level function and should generally not be called.
	ShardReplicationRemove(context.Context, *vtctldata.ShardReplicationRemoveRequest) (*vtctldata.ShardReplicationRemoveResponse, error)
	// SleepTablet blocks the aciton queue on the specified tablet for the
	// specified duration.
	//
	// This is typically used for testing.
	SleepTablet(context.Context, *vtctldata.SleepTabletRequest) (*vtctldata.SleepTabletResponse, error)
	// SourceShardAdd adds the SourceShard record with the provided index. This
	// should be used only as an emergency function.
	//
	// It does not call RefreshState for the shard primary.
	SourceShardAdd(context.Context, *vtctldata.SourceShardAddRequest) (*vtctldata.SourceShardAddResponse, error)
	// SourceShardDelete deletes the SourceShard record with the provided index.
	// This should be used only as an emergency cleanup function.
	//
	// It does not call RefreshState for the shard primary.
	SourceShardDelete(context.Context, *vtctldata.SourceShardDeleteRequest) (*vtctldata.SourceShardDeleteResponse, error)
	// StartReplication starts replication on the specified tablet.
	StartReplication(context.Context, *vtctldata.StartReplicationRequest) (*vtctldata.StartReplicationResponse, error)
	// StopReplication stops replication on the specified tablet.
	StopReplication(context.Context, *vtctldata.StopReplicationRequest) (*vtctldata.StopReplicationResponse, error)
	// TabletExternallyReparented changes metadata in the topology server to
	// acknowledge a shard primary change performed by an external tool (e.g.
	// orchestrator).
	//
	// See the Reparenting guide for more information:
	// https://vitess.io/docs/user-guides/configuration-advanced/reparenting/#external-reparenting.
	TabletExternallyReparented(context.Context, *vtctldata.TabletExternallyReparentedRequest) (*vtctldata.TabletExternallyReparentedResponse, error)
	// UpdateCellInfo updates the content of a CellInfo with the provided
	// parameters. Empty values are ignored. If the cell does not exist, the
	// CellInfo will be created.
	UpdateCellInfo(context.Context, *vtctldata.UpdateCellInfoRequest) (*vtctldata.UpdateCellInfoResponse, error)
	// UpdateCellsAlias updates the content of a CellsAlias with the provided
	// parameters. Empty values are ignored. If the alias does not exist, the
	// CellsAlias will be created.
	UpdateCellsAlias(context.Context, *vtctldata.UpdateCellsAliasRequest) (*vtctldata.UpdateCellsAliasResponse, error)
	// Validate validates that all nodes from the global replication graph are
	// reachable, and that all tablets in discoverable cells are consistent.
	Validate(context.Context, *vtctldata.ValidateRequest) (*vtctldata.ValidateResponse, error)
	// ValidateKeyspace validates that all nodes reachable from the specified
	// keyspace are consistent.
	ValidateKeyspace(context.Context, *vtctldata.ValidateKeyspaceRequest) (*vtctldata.ValidateKeyspaceResponse, error)
	// ValidateSchemaKeyspace validates that the schema on the primary tablet for shard 0 matches the schema on all of the other tablets in the keyspace.
	ValidateSchemaKeyspace(context.Context, *vtctldata.ValidateSchemaKeyspaceRequest) (*vtctldata.ValidateSchemaKeyspaceResponse, error)
	// ValidateShard validates that all nodes reachable from the specified shard
	// are consistent.
	ValidateShard(context.Context, *vtctldata.ValidateShardRequest) (*vtctldata.ValidateShardResponse, error)
	// ValidateVersionKeyspace validates that the version on the primary of shard 0 matches all of the other tablets in the keyspace.
	ValidateVersionKeyspace(context.Context, *vtctldata.ValidateVersionKeyspaceRequest) (*vtctldata.ValidateVersionKeyspaceResponse, error)
	// ValidateVersionShard validates that the version on the primary matches all of the replicas.
	ValidateVersionShard(context.Context, *vtctldata.ValidateVersionShardRequest) (*vtctldata.ValidateVersionShardResponse, error)
	// ValidateVSchema compares the schema of each primary tablet in "keyspace/shards..." to the vschema and errs if there are differences.
	ValidateVSchema(context.Context, *vtctldata.ValidateVSchemaRequest) (*vtctldata.ValidateVSchemaResponse, error)
	// WorkflowUpdate updates the configuration of a vreplication workflow
	// using the provided updated parameters.
	WorkflowUpdate(context.Context, *vtctldata.WorkflowUpdateRequest) (*vtctldata.WorkflowUpdateResponse, error)
	mustEmbedUnimplementedVtctldServer()
}

// UnimplementedVtctldServer must be embedded to have forward compatible implementations.
type UnimplementedVtctldServer struct {
}

func (UnimplementedVtctldServer) AddCellInfo(context.Context, *vtctldata.AddCellInfoRequest) (*vtctldata.AddCellInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddCellInfo not implemented")
}
func (UnimplementedVtctldServer) AddCellsAlias(context.Context, *vtctldata.AddCellsAliasRequest) (*vtctldata.AddCellsAliasResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddCellsAlias not implemented")
}
func (UnimplementedVtctldServer) ApplyRoutingRules(context.Context, *vtctldata.ApplyRoutingRulesRequest) (*vtctldata.ApplyRoutingRulesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyRoutingRules not implemented")
}
func (UnimplementedVtctldServer) ApplySchema(context.Context, *vtctldata.ApplySchemaRequest) (*vtctldata.ApplySchemaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplySchema not implemented")
}
func (UnimplementedVtctldServer) ApplyShardRoutingRules(context.Context, *vtctldata.ApplyShardRoutingRulesRequest) (*vtctldata.ApplyShardRoutingRulesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyShardRoutingRules not implemented")
}
func (UnimplementedVtctldServer) ApplyVSchema(context.Context, *vtctldata.ApplyVSchemaRequest) (*vtctldata.ApplyVSchemaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyVSchema not implemented")
}
func (UnimplementedVtctldServer) Backup(*vtctldata.BackupRequest, Vtctld_BackupServer) error {
	return status.Errorf(codes.Unimplemented, "method Backup not implemented")
}
func (UnimplementedVtctldServer) BackupShard(*vtctldata.BackupShardRequest, Vtctld_BackupShardServer) error {
	return status.Errorf(codes.Unimplemented, "method BackupShard not implemented")
}
func (UnimplementedVtctldServer) ChangeTabletType(context.Context, *vtctldata.ChangeTabletTypeRequest) (*vtctldata.ChangeTabletTypeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangeTabletType not implemented")
}
func (UnimplementedVtctldServer) CreateKeyspace(context.Context, *vtctldata.CreateKeyspaceRequest) (*vtctldata.CreateKeyspaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateKeyspace not implemented")
}
func (UnimplementedVtctldServer) CreateShard(context.Context, *vtctldata.CreateShardRequest) (*vtctldata.CreateShardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateShard not implemented")
}
func (UnimplementedVtctldServer) DeleteCellInfo(context.Context, *vtctldata.DeleteCellInfoRequest) (*vtctldata.DeleteCellInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCellInfo not implemented")
}
func (UnimplementedVtctldServer) DeleteCellsAlias(context.Context, *vtctldata.DeleteCellsAliasRequest) (*vtctldata.DeleteCellsAliasResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCellsAlias not implemented")
}
func (UnimplementedVtctldServer) DeleteKeyspace(context.Context, *vtctldata.DeleteKeyspaceRequest) (*vtctldata.DeleteKeyspaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteKeyspace not implemented")
}
func (UnimplementedVtctldServer) DeleteShards(context.Context, *vtctldata.DeleteShardsRequest) (*vtctldata.DeleteShardsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteShards not implemented")
}
func (UnimplementedVtctldServer) DeleteSrvVSchema(context.Context, *vtctldata.DeleteSrvVSchemaRequest) (*vtctldata.DeleteSrvVSchemaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSrvVSchema not implemented")
}
func (UnimplementedVtctldServer) DeleteTablets(context.Context, *vtctldata.DeleteTabletsRequest) (*vtctldata.DeleteTabletsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTablets not implemented")
}
func (UnimplementedVtctldServer) EmergencyReparentShard(context.Context, *vtctldata.EmergencyReparentShardRequest) (*vtctldata.EmergencyReparentShardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EmergencyReparentShard not implemented")
}
func (UnimplementedVtctldServer) ExecuteFetchAsApp(context.Context, *vtctldata.ExecuteFetchAsAppRequest) (*vtctldata.ExecuteFetchAsAppResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteFetchAsApp not implemented")
}
func (UnimplementedVtctldServer) ExecuteFetchAsDBA(context.Context, *vtctldata.ExecuteFetchAsDBARequest) (*vtctldata.ExecuteFetchAsDBAResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteFetchAsDBA not implemented")
}
func (UnimplementedVtctldServer) ExecuteHook(context.Context, *vtctldata.ExecuteHookRequest) (*vtctldata.ExecuteHookResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteHook not implemented")
}
func (UnimplementedVtctldServer) FindAllShardsInKeyspace(context.Context, *vtctldata.FindAllShardsInKeyspaceRequest) (*vtctldata.FindAllShardsInKeyspaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindAllShardsInKeyspace not implemented")
}
func (UnimplementedVtctldServer) GetBackups(context.Context, *vtctldata.GetBackupsRequest) (*vtctldata.GetBackupsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBackups not implemented")
}
func (UnimplementedVtctldServer) GetCellInfo(context.Context, *vtctldata.GetCellInfoRequest) (*vtctldata.GetCellInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCellInfo not implemented")
}
func (UnimplementedVtctldServer) GetCellInfoNames(context.Context, *vtctldata.GetCellInfoNamesRequest) (*vtctldata.GetCellInfoNamesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCellInfoNames not implemented")
}
func (UnimplementedVtctldServer) GetCellsAliases(context.Context, *vtctldata.GetCellsAliasesRequest) (*vtctldata.GetCellsAliasesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCellsAliases not implemented")
}
func (UnimplementedVtctldServer) GetFullStatus(context.Context, *vtctldata.GetFullStatusRequest) (*vtctldata.GetFullStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFullStatus not implemented")
}
func (UnimplementedVtctldServer) GetKeyspace(context.Context, *vtctldata.GetKeyspaceRequest) (*vtctldata.GetKeyspaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetKeyspace not implemented")
}
func (UnimplementedVtctldServer) GetKeyspaces(context.Context, *vtctldata.GetKeyspacesRequest) (*vtctldata.GetKeyspacesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetKeyspaces not implemented")
}
func (UnimplementedVtctldServer) GetPermissions(context.Context, *vtctldata.GetPermissionsRequest) (*vtctldata.GetPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPermissions not implemented")
}
func (UnimplementedVtctldServer) GetRoutingRules(context.Context, *vtctldata.GetRoutingRulesRequest) (*vtctldata.GetRoutingRulesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRoutingRules not implemented")
}
func (UnimplementedVtctldServer) GetSchema(context.Context, *vtctldata.GetSchemaRequest) (*vtctldata.GetSchemaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSchema not implemented")
}
func (UnimplementedVtctldServer) GetShard(context.Context, *vtctldata.GetShardRequest) (*vtctldata.GetShardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetShard not implemented")
}
func (UnimplementedVtctldServer) GetShardRoutingRules(context.Context, *vtctldata.GetShardRoutingRulesRequest) (*vtctldata.GetShardRoutingRulesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetShardRoutingRules not implemented")
}
func (UnimplementedVtctldServer) GetSrvKeyspaceNames(context.Context, *vtctldata.GetSrvKeyspaceNamesRequest) (*vtctldata.GetSrvKeyspaceNamesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSrvKeyspaceNames not implemented")
}
func (UnimplementedVtctldServer) GetSrvKeyspaces(context.Context, *vtctldata.GetSrvKeyspacesRequest) (*vtctldata.GetSrvKeyspacesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSrvKeyspaces not implemented")
}
func (UnimplementedVtctldServer) UpdateThrottlerConfig(context.Context, *vtctldata.UpdateThrottlerConfigRequest) (*vtctldata.UpdateThrottlerConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateThrottlerConfig not implemented")
}
func (UnimplementedVtctldServer) GetSrvVSchema(context.Context, *vtctldata.GetSrvVSchemaRequest) (*vtctldata.GetSrvVSchemaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSrvVSchema not implemented")
}
func (UnimplementedVtctldServer) GetSrvVSchemas(context.Context, *vtctldata.GetSrvVSchemasRequest) (*vtctldata.GetSrvVSchemasResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSrvVSchemas not implemented")
}
func (UnimplementedVtctldServer) GetTablet(context.Context, *vtctldata.GetTabletRequest) (*vtctldata.GetTabletResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTablet not implemented")
}
func (UnimplementedVtctldServer) GetTablets(context.Context, *vtctldata.GetTabletsRequest) (*vtctldata.GetTabletsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTablets not implemented")
}
func (UnimplementedVtctldServer) GetTopologyPath(context.Context, *vtctldata.GetTopologyPathRequest) (*vtctldata.GetTopologyPathResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTopologyPath not implemented")
}
func (UnimplementedVtctldServer) GetVersion(context.Context, *vtctldata.GetVersionRequest) (*vtctldata.GetVersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVersion not implemented")
}
func (UnimplementedVtctldServer) GetVSchema(context.Context, *vtctldata.GetVSchemaRequest) (*vtctldata.GetVSchemaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVSchema not implemented")
}
func (UnimplementedVtctldServer) GetWorkflows(context.Context, *vtctldata.GetWorkflowsRequest) (*vtctldata.GetWorkflowsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWorkflows not implemented")
}
func (UnimplementedVtctldServer) InitShardPrimary(context.Context, *vtctldata.InitShardPrimaryRequest) (*vtctldata.InitShardPrimaryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitShardPrimary not implemented")
}
func (UnimplementedVtctldServer) PingTablet(context.Context, *vtctldata.PingTabletRequest) (*vtctldata.PingTabletResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PingTablet not implemented")
}
func (UnimplementedVtctldServer) PlannedReparentShard(context.Context, *vtctldata.PlannedReparentShardRequest) (*vtctldata.PlannedReparentShardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PlannedReparentShard not implemented")
}
func (UnimplementedVtctldServer) RebuildKeyspaceGraph(context.Context, *vtctldata.RebuildKeyspaceGraphRequest) (*vtctldata.RebuildKeyspaceGraphResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RebuildKeyspaceGraph not implemented")
}
func (UnimplementedVtctldServer) RebuildVSchemaGraph(context.Context, *vtctldata.RebuildVSchemaGraphRequest) (*vtctldata.RebuildVSchemaGraphResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RebuildVSchemaGraph not implemented")
}
func (UnimplementedVtctldServer) RefreshState(context.Context, *vtctldata.RefreshStateRequest) (*vtctldata.RefreshStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RefreshState not implemented")
}
func (UnimplementedVtctldServer) RefreshStateByShard(context.Context, *vtctldata.RefreshStateByShardRequest) (*vtctldata.RefreshStateByShardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RefreshStateByShard not implemented")
}
func (UnimplementedVtctldServer) ReloadSchema(context.Context, *vtctldata.ReloadSchemaRequest) (*vtctldata.ReloadSchemaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReloadSchema not implemented")
}
func (UnimplementedVtctldServer) ReloadSchemaKeyspace(context.Context, *vtctldata.ReloadSchemaKeyspaceRequest) (*vtctldata.ReloadSchemaKeyspaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReloadSchemaKeyspace not implemented")
}
func (UnimplementedVtctldServer) ReloadSchemaShard(context.Context, *vtctldata.ReloadSchemaShardRequest) (*vtctldata.ReloadSchemaShardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReloadSchemaShard not implemented")
}
func (UnimplementedVtctldServer) RemoveBackup(context.Context, *vtctldata.RemoveBackupRequest) (*vtctldata.RemoveBackupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveBackup not implemented")
}
func (UnimplementedVtctldServer) RemoveKeyspaceCell(context.Context, *vtctldata.RemoveKeyspaceCellRequest) (*vtctldata.RemoveKeyspaceCellResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveKeyspaceCell not implemented")
}
func (UnimplementedVtctldServer) RemoveShardCell(context.Context, *vtctldata.RemoveShardCellRequest) (*vtctldata.RemoveShardCellResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveShardCell not implemented")
}
func (UnimplementedVtctldServer) ReparentTablet(context.Context, *vtctldata.ReparentTabletRequest) (*vtctldata.ReparentTabletResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReparentTablet not implemented")
}
func (UnimplementedVtctldServer) RestoreFromBackup(*vtctldata.RestoreFromBackupRequest, Vtctld_RestoreFromBackupServer) error {
	return status.Errorf(codes.Unimplemented, "method RestoreFromBackup not implemented")
}
func (UnimplementedVtctldServer) RunHealthCheck(context.Context, *vtctldata.RunHealthCheckRequest) (*vtctldata.RunHealthCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunHealthCheck not implemented")
}
func (UnimplementedVtctldServer) SetKeyspaceDurabilityPolicy(context.Context, *vtctldata.SetKeyspaceDurabilityPolicyRequest) (*vtctldata.SetKeyspaceDurabilityPolicyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetKeyspaceDurabilityPolicy not implemented")
}
func (UnimplementedVtctldServer) SetShardIsPrimaryServing(context.Context, *vtctldata.SetShardIsPrimaryServingRequest) (*vtctldata.SetShardIsPrimaryServingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetShardIsPrimaryServing not implemented")
}
func (UnimplementedVtctldServer) SetShardTabletControl(context.Context, *vtctldata.SetShardTabletControlRequest) (*vtctldata.SetShardTabletControlResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetShardTabletControl not implemented")
}
func (UnimplementedVtctldServer) SetWritable(context.Context, *vtctldata.SetWritableRequest) (*vtctldata.SetWritableResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetWritable not implemented")
}
func (UnimplementedVtctldServer) ShardReplicationAdd(context.Context, *vtctldata.ShardReplicationAddRequest) (*vtctldata.ShardReplicationAddResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShardReplicationAdd not implemented")
}
func (UnimplementedVtctldServer) ShardReplicationFix(context.Context, *vtctldata.ShardReplicationFixRequest) (*vtctldata.ShardReplicationFixResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShardReplicationFix not implemented")
}
func (UnimplementedVtctldServer) ShardReplicationPositions(context.Context, *vtctldata.ShardReplicationPositionsRequest) (*vtctldata.ShardReplicationPositionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShardReplicationPositions not implemented")
}
func (UnimplementedVtctldServer) ShardReplicationRemove(context.Context, *vtctldata.ShardReplicationRemoveRequest) (*vtctldata.ShardReplicationRemoveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShardReplicationRemove not implemented")
}
func (UnimplementedVtctldServer) SleepTablet(context.Context, *vtctldata.SleepTabletRequest) (*vtctldata.SleepTabletResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SleepTablet not implemented")
}
func (UnimplementedVtctldServer) SourceShardAdd(context.Context, *vtctldata.SourceShardAddRequest) (*vtctldata.SourceShardAddResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SourceShardAdd not implemented")
}
func (UnimplementedVtctldServer) SourceShardDelete(context.Context, *vtctldata.SourceShardDeleteRequest) (*vtctldata.SourceShardDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SourceShardDelete not implemented")
}
func (UnimplementedVtctldServer) StartReplication(context.Context, *vtctldata.StartReplicationRequest) (*vtctldata.StartReplicationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartReplication not implemented")
}
func (UnimplementedVtctldServer) StopReplication(context.Context, *vtctldata.StopReplicationRequest) (*vtctldata.StopReplicationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopReplication not implemented")
}
func (UnimplementedVtctldServer) TabletExternallyReparented(context.Context, *vtctldata.TabletExternallyReparentedRequest) (*vtctldata.TabletExternallyReparentedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TabletExternallyReparented not implemented")
}
func (UnimplementedVtctldServer) UpdateCellInfo(context.Context, *vtctldata.UpdateCellInfoRequest) (*vtctldata.UpdateCellInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCellInfo not implemented")
}
func (UnimplementedVtctldServer) UpdateCellsAlias(context.Context, *vtctldata.UpdateCellsAliasRequest) (*vtctldata.UpdateCellsAliasResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCellsAlias not implemented")
}
func (UnimplementedVtctldServer) Validate(context.Context, *vtctldata.ValidateRequest) (*vtctldata.ValidateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Validate not implemented")
}
func (UnimplementedVtctldServer) ValidateKeyspace(context.Context, *vtctldata.ValidateKeyspaceRequest) (*vtctldata.ValidateKeyspaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateKeyspace not implemented")
}
func (UnimplementedVtctldServer) ValidateSchemaKeyspace(context.Context, *vtctldata.ValidateSchemaKeyspaceRequest) (*vtctldata.ValidateSchemaKeyspaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateSchemaKeyspace not implemented")
}
func (UnimplementedVtctldServer) ValidateShard(context.Context, *vtctldata.ValidateShardRequest) (*vtctldata.ValidateShardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateShard not implemented")
}
func (UnimplementedVtctldServer) ValidateVersionKeyspace(context.Context, *vtctldata.ValidateVersionKeyspaceRequest) (*vtctldata.ValidateVersionKeyspaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateVersionKeyspace not implemented")
}
func (UnimplementedVtctldServer) ValidateVersionShard(context.Context, *vtctldata.ValidateVersionShardRequest) (*vtctldata.ValidateVersionShardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateVersionShard not implemented")
}
func (UnimplementedVtctldServer) ValidateVSchema(context.Context, *vtctldata.ValidateVSchemaRequest) (*vtctldata.ValidateVSchemaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateVSchema not implemented")
}
func (UnimplementedVtctldServer) WorkflowUpdate(context.Context, *vtctldata.WorkflowUpdateRequest) (*vtctldata.WorkflowUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WorkflowUpdate not implemented")
}
func (UnimplementedVtctldServer) mustEmbedUnimplementedVtctldServer() {}

// UnsafeVtctldServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VtctldServer will
// result in compilation errors.
type UnsafeVtctldServer interface {
	mustEmbedUnimplementedVtctldServer()
}

func RegisterVtctldServer(s grpc.ServiceRegistrar, srv VtctldServer) {
	s.RegisterService(&Vtctld_ServiceDesc, srv)
}

func _Vtctld_AddCellInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.AddCellInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).AddCellInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/AddCellInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).AddCellInfo(ctx, req.(*vtctldata.AddCellInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_AddCellsAlias_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.AddCellsAliasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).AddCellsAlias(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/AddCellsAlias",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).AddCellsAlias(ctx, req.(*vtctldata.AddCellsAliasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_ApplyRoutingRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.ApplyRoutingRulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).ApplyRoutingRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/ApplyRoutingRules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).ApplyRoutingRules(ctx, req.(*vtctldata.ApplyRoutingRulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_ApplySchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.ApplySchemaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).ApplySchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/ApplySchema",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).ApplySchema(ctx, req.(*vtctldata.ApplySchemaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_ApplyShardRoutingRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.ApplyShardRoutingRulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).ApplyShardRoutingRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/ApplyShardRoutingRules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).ApplyShardRoutingRules(ctx, req.(*vtctldata.ApplyShardRoutingRulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_ApplyVSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.ApplyVSchemaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).ApplyVSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/ApplyVSchema",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).ApplyVSchema(ctx, req.(*vtctldata.ApplyVSchemaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_Backup_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(vtctldata.BackupRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VtctldServer).Backup(m, &vtctldBackupServer{stream})
}

type Vtctld_BackupServer interface {
	Send(*vtctldata.BackupResponse) error
	grpc.ServerStream
}

type vtctldBackupServer struct {
	grpc.ServerStream
}

func (x *vtctldBackupServer) Send(m *vtctldata.BackupResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Vtctld_BackupShard_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(vtctldata.BackupShardRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VtctldServer).BackupShard(m, &vtctldBackupShardServer{stream})
}

type Vtctld_BackupShardServer interface {
	Send(*vtctldata.BackupResponse) error
	grpc.ServerStream
}

type vtctldBackupShardServer struct {
	grpc.ServerStream
}

func (x *vtctldBackupShardServer) Send(m *vtctldata.BackupResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Vtctld_ChangeTabletType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.ChangeTabletTypeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).ChangeTabletType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/ChangeTabletType",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).ChangeTabletType(ctx, req.(*vtctldata.ChangeTabletTypeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_CreateKeyspace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.CreateKeyspaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).CreateKeyspace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/CreateKeyspace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).CreateKeyspace(ctx, req.(*vtctldata.CreateKeyspaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_CreateShard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.CreateShardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).CreateShard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/CreateShard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).CreateShard(ctx, req.(*vtctldata.CreateShardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_DeleteCellInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.DeleteCellInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).DeleteCellInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/DeleteCellInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).DeleteCellInfo(ctx, req.(*vtctldata.DeleteCellInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_DeleteCellsAlias_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.DeleteCellsAliasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).DeleteCellsAlias(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/DeleteCellsAlias",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).DeleteCellsAlias(ctx, req.(*vtctldata.DeleteCellsAliasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_DeleteKeyspace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.DeleteKeyspaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).DeleteKeyspace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/DeleteKeyspace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).DeleteKeyspace(ctx, req.(*vtctldata.DeleteKeyspaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_DeleteShards_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.DeleteShardsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).DeleteShards(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/DeleteShards",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).DeleteShards(ctx, req.(*vtctldata.DeleteShardsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_DeleteSrvVSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.DeleteSrvVSchemaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).DeleteSrvVSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/DeleteSrvVSchema",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).DeleteSrvVSchema(ctx, req.(*vtctldata.DeleteSrvVSchemaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_DeleteTablets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.DeleteTabletsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).DeleteTablets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/DeleteTablets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).DeleteTablets(ctx, req.(*vtctldata.DeleteTabletsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_EmergencyReparentShard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.EmergencyReparentShardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).EmergencyReparentShard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/EmergencyReparentShard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).EmergencyReparentShard(ctx, req.(*vtctldata.EmergencyReparentShardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_ExecuteFetchAsApp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.ExecuteFetchAsAppRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).ExecuteFetchAsApp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/ExecuteFetchAsApp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).ExecuteFetchAsApp(ctx, req.(*vtctldata.ExecuteFetchAsAppRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_ExecuteFetchAsDBA_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.ExecuteFetchAsDBARequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).ExecuteFetchAsDBA(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/ExecuteFetchAsDBA",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).ExecuteFetchAsDBA(ctx, req.(*vtctldata.ExecuteFetchAsDBARequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_ExecuteHook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.ExecuteHookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).ExecuteHook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/ExecuteHook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).ExecuteHook(ctx, req.(*vtctldata.ExecuteHookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_FindAllShardsInKeyspace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.FindAllShardsInKeyspaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).FindAllShardsInKeyspace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/FindAllShardsInKeyspace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).FindAllShardsInKeyspace(ctx, req.(*vtctldata.FindAllShardsInKeyspaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetBackups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetBackupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetBackups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetBackups",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetBackups(ctx, req.(*vtctldata.GetBackupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetCellInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetCellInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetCellInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetCellInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetCellInfo(ctx, req.(*vtctldata.GetCellInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetCellInfoNames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetCellInfoNamesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetCellInfoNames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetCellInfoNames",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetCellInfoNames(ctx, req.(*vtctldata.GetCellInfoNamesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetCellsAliases_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetCellsAliasesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetCellsAliases(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetCellsAliases",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetCellsAliases(ctx, req.(*vtctldata.GetCellsAliasesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetFullStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetFullStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetFullStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetFullStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetFullStatus(ctx, req.(*vtctldata.GetFullStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetKeyspace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetKeyspaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetKeyspace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetKeyspace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetKeyspace(ctx, req.(*vtctldata.GetKeyspaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetKeyspaces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetKeyspacesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetKeyspaces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetKeyspaces",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetKeyspaces(ctx, req.(*vtctldata.GetKeyspacesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetPermissionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetPermissions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetPermissions(ctx, req.(*vtctldata.GetPermissionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetRoutingRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetRoutingRulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetRoutingRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetRoutingRules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetRoutingRules(ctx, req.(*vtctldata.GetRoutingRulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetSchemaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetSchema",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetSchema(ctx, req.(*vtctldata.GetSchemaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetShard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetShardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetShard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetShard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetShard(ctx, req.(*vtctldata.GetShardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetShardRoutingRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetShardRoutingRulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetShardRoutingRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetShardRoutingRules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetShardRoutingRules(ctx, req.(*vtctldata.GetShardRoutingRulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetSrvKeyspaceNames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetSrvKeyspaceNamesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetSrvKeyspaceNames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetSrvKeyspaceNames",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetSrvKeyspaceNames(ctx, req.(*vtctldata.GetSrvKeyspaceNamesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetSrvKeyspaces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetSrvKeyspacesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetSrvKeyspaces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetSrvKeyspaces",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetSrvKeyspaces(ctx, req.(*vtctldata.GetSrvKeyspacesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_UpdateThrottlerConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.UpdateThrottlerConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).UpdateThrottlerConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/UpdateThrottlerConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).UpdateThrottlerConfig(ctx, req.(*vtctldata.UpdateThrottlerConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetSrvVSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetSrvVSchemaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetSrvVSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetSrvVSchema",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetSrvVSchema(ctx, req.(*vtctldata.GetSrvVSchemaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetSrvVSchemas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetSrvVSchemasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetSrvVSchemas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetSrvVSchemas",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetSrvVSchemas(ctx, req.(*vtctldata.GetSrvVSchemasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetTablet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetTabletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetTablet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetTablet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetTablet(ctx, req.(*vtctldata.GetTabletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetTablets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetTabletsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetTablets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetTablets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetTablets(ctx, req.(*vtctldata.GetTabletsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetTopologyPath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetTopologyPathRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetTopologyPath(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetTopologyPath",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetTopologyPath(ctx, req.(*vtctldata.GetTopologyPathRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetVersion(ctx, req.(*vtctldata.GetVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetVSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetVSchemaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetVSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetVSchema",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetVSchema(ctx, req.(*vtctldata.GetVSchemaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetWorkflows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetWorkflowsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetWorkflows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetWorkflows",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetWorkflows(ctx, req.(*vtctldata.GetWorkflowsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_InitShardPrimary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.InitShardPrimaryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).InitShardPrimary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/InitShardPrimary",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).InitShardPrimary(ctx, req.(*vtctldata.InitShardPrimaryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_PingTablet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.PingTabletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).PingTablet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/PingTablet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).PingTablet(ctx, req.(*vtctldata.PingTabletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_PlannedReparentShard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.PlannedReparentShardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).PlannedReparentShard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/PlannedReparentShard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).PlannedReparentShard(ctx, req.(*vtctldata.PlannedReparentShardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_RebuildKeyspaceGraph_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.RebuildKeyspaceGraphRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).RebuildKeyspaceGraph(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/RebuildKeyspaceGraph",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).RebuildKeyspaceGraph(ctx, req.(*vtctldata.RebuildKeyspaceGraphRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_RebuildVSchemaGraph_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.RebuildVSchemaGraphRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).RebuildVSchemaGraph(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/RebuildVSchemaGraph",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).RebuildVSchemaGraph(ctx, req.(*vtctldata.RebuildVSchemaGraphRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_RefreshState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.RefreshStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).RefreshState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/RefreshState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).RefreshState(ctx, req.(*vtctldata.RefreshStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_RefreshStateByShard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.RefreshStateByShardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).RefreshStateByShard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/RefreshStateByShard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).RefreshStateByShard(ctx, req.(*vtctldata.RefreshStateByShardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_ReloadSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.ReloadSchemaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).ReloadSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/ReloadSchema",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).ReloadSchema(ctx, req.(*vtctldata.ReloadSchemaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_ReloadSchemaKeyspace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.ReloadSchemaKeyspaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).ReloadSchemaKeyspace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/ReloadSchemaKeyspace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).ReloadSchemaKeyspace(ctx, req.(*vtctldata.ReloadSchemaKeyspaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_ReloadSchemaShard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.ReloadSchemaShardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).ReloadSchemaShard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/ReloadSchemaShard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).ReloadSchemaShard(ctx, req.(*vtctldata.ReloadSchemaShardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_RemoveBackup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.RemoveBackupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).RemoveBackup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/RemoveBackup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).RemoveBackup(ctx, req.(*vtctldata.RemoveBackupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_RemoveKeyspaceCell_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.RemoveKeyspaceCellRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).RemoveKeyspaceCell(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/RemoveKeyspaceCell",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).RemoveKeyspaceCell(ctx, req.(*vtctldata.RemoveKeyspaceCellRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_RemoveShardCell_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.RemoveShardCellRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).RemoveShardCell(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/RemoveShardCell",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).RemoveShardCell(ctx, req.(*vtctldata.RemoveShardCellRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_ReparentTablet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.ReparentTabletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).ReparentTablet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/ReparentTablet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).ReparentTablet(ctx, req.(*vtctldata.ReparentTabletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_RestoreFromBackup_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(vtctldata.RestoreFromBackupRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VtctldServer).RestoreFromBackup(m, &vtctldRestoreFromBackupServer{stream})
}

type Vtctld_RestoreFromBackupServer interface {
	Send(*vtctldata.RestoreFromBackupResponse) error
	grpc.ServerStream
}

type vtctldRestoreFromBackupServer struct {
	grpc.ServerStream
}

func (x *vtctldRestoreFromBackupServer) Send(m *vtctldata.RestoreFromBackupResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Vtctld_RunHealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.RunHealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).RunHealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/RunHealthCheck",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).RunHealthCheck(ctx, req.(*vtctldata.RunHealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_SetKeyspaceDurabilityPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.SetKeyspaceDurabilityPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).SetKeyspaceDurabilityPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/SetKeyspaceDurabilityPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).SetKeyspaceDurabilityPolicy(ctx, req.(*vtctldata.SetKeyspaceDurabilityPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_SetShardIsPrimaryServing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.SetShardIsPrimaryServingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).SetShardIsPrimaryServing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/SetShardIsPrimaryServing",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).SetShardIsPrimaryServing(ctx, req.(*vtctldata.SetShardIsPrimaryServingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_SetShardTabletControl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.SetShardTabletControlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).SetShardTabletControl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/SetShardTabletControl",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).SetShardTabletControl(ctx, req.(*vtctldata.SetShardTabletControlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_SetWritable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.SetWritableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).SetWritable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/SetWritable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).SetWritable(ctx, req.(*vtctldata.SetWritableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_ShardReplicationAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.ShardReplicationAddRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).ShardReplicationAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/ShardReplicationAdd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).ShardReplicationAdd(ctx, req.(*vtctldata.ShardReplicationAddRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_ShardReplicationFix_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.ShardReplicationFixRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).ShardReplicationFix(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/ShardReplicationFix",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).ShardReplicationFix(ctx, req.(*vtctldata.ShardReplicationFixRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_ShardReplicationPositions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.ShardReplicationPositionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).ShardReplicationPositions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/ShardReplicationPositions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).ShardReplicationPositions(ctx, req.(*vtctldata.ShardReplicationPositionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_ShardReplicationRemove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.ShardReplicationRemoveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).ShardReplicationRemove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/ShardReplicationRemove",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).ShardReplicationRemove(ctx, req.(*vtctldata.ShardReplicationRemoveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_SleepTablet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.SleepTabletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).SleepTablet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/SleepTablet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).SleepTablet(ctx, req.(*vtctldata.SleepTabletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_SourceShardAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.SourceShardAddRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).SourceShardAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/SourceShardAdd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).SourceShardAdd(ctx, req.(*vtctldata.SourceShardAddRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_SourceShardDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.SourceShardDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).SourceShardDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/SourceShardDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).SourceShardDelete(ctx, req.(*vtctldata.SourceShardDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_StartReplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.StartReplicationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).StartReplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/StartReplication",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).StartReplication(ctx, req.(*vtctldata.StartReplicationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_StopReplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.StopReplicationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).StopReplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/StopReplication",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).StopReplication(ctx, req.(*vtctldata.StopReplicationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_TabletExternallyReparented_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.TabletExternallyReparentedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).TabletExternallyReparented(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/TabletExternallyReparented",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).TabletExternallyReparented(ctx, req.(*vtctldata.TabletExternallyReparentedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_UpdateCellInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.UpdateCellInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).UpdateCellInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/UpdateCellInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).UpdateCellInfo(ctx, req.(*vtctldata.UpdateCellInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_UpdateCellsAlias_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.UpdateCellsAliasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).UpdateCellsAlias(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/UpdateCellsAlias",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).UpdateCellsAlias(ctx, req.(*vtctldata.UpdateCellsAliasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_Validate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.ValidateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).Validate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/Validate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).Validate(ctx, req.(*vtctldata.ValidateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_ValidateKeyspace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.ValidateKeyspaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).ValidateKeyspace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/ValidateKeyspace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).ValidateKeyspace(ctx, req.(*vtctldata.ValidateKeyspaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_ValidateSchemaKeyspace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.ValidateSchemaKeyspaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).ValidateSchemaKeyspace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/ValidateSchemaKeyspace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).ValidateSchemaKeyspace(ctx, req.(*vtctldata.ValidateSchemaKeyspaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_ValidateShard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.ValidateShardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).ValidateShard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/ValidateShard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).ValidateShard(ctx, req.(*vtctldata.ValidateShardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_ValidateVersionKeyspace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.ValidateVersionKeyspaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).ValidateVersionKeyspace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/ValidateVersionKeyspace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).ValidateVersionKeyspace(ctx, req.(*vtctldata.ValidateVersionKeyspaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_ValidateVersionShard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.ValidateVersionShardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).ValidateVersionShard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/ValidateVersionShard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).ValidateVersionShard(ctx, req.(*vtctldata.ValidateVersionShardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_ValidateVSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.ValidateVSchemaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).ValidateVSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/ValidateVSchema",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).ValidateVSchema(ctx, req.(*vtctldata.ValidateVSchemaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_WorkflowUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.WorkflowUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).WorkflowUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/WorkflowUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).WorkflowUpdate(ctx, req.(*vtctldata.WorkflowUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Vtctld_ServiceDesc is the grpc.ServiceDesc for Vtctld service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Vtctld_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "vtctlservice.Vtctld",
	HandlerType: (*VtctldServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddCellInfo",
			Handler:    _Vtctld_AddCellInfo_Handler,
		},
		{
			MethodName: "AddCellsAlias",
			Handler:    _Vtctld_AddCellsAlias_Handler,
		},
		{
			MethodName: "ApplyRoutingRules",
			Handler:    _Vtctld_ApplyRoutingRules_Handler,
		},
		{
			MethodName: "ApplySchema",
			Handler:    _Vtctld_ApplySchema_Handler,
		},
		{
			MethodName: "ApplyShardRoutingRules",
			Handler:    _Vtctld_ApplyShardRoutingRules_Handler,
		},
		{
			MethodName: "ApplyVSchema",
			Handler:    _Vtctld_ApplyVSchema_Handler,
		},
		{
			MethodName: "ChangeTabletType",
			Handler:    _Vtctld_ChangeTabletType_Handler,
		},
		{
			MethodName: "CreateKeyspace",
			Handler:    _Vtctld_CreateKeyspace_Handler,
		},
		{
			MethodName: "CreateShard",
			Handler:    _Vtctld_CreateShard_Handler,
		},
		{
			MethodName: "DeleteCellInfo",
			Handler:    _Vtctld_DeleteCellInfo_Handler,
		},
		{
			MethodName: "DeleteCellsAlias",
			Handler:    _Vtctld_DeleteCellsAlias_Handler,
		},
		{
			MethodName: "DeleteKeyspace",
			Handler:    _Vtctld_DeleteKeyspace_Handler,
		},
		{
			MethodName: "DeleteShards",
			Handler:    _Vtctld_DeleteShards_Handler,
		},
		{
			MethodName: "DeleteSrvVSchema",
			Handler:    _Vtctld_DeleteSrvVSchema_Handler,
		},
		{
			MethodName: "DeleteTablets",
			Handler:    _Vtctld_DeleteTablets_Handler,
		},
		{
			MethodName: "EmergencyReparentShard",
			Handler:    _Vtctld_EmergencyReparentShard_Handler,
		},
		{
			MethodName: "ExecuteFetchAsApp",
			Handler:    _Vtctld_ExecuteFetchAsApp_Handler,
		},
		{
			MethodName: "ExecuteFetchAsDBA",
			Handler:    _Vtctld_ExecuteFetchAsDBA_Handler,
		},
		{
			MethodName: "ExecuteHook",
			Handler:    _Vtctld_ExecuteHook_Handler,
		},
		{
			MethodName: "FindAllShardsInKeyspace",
			Handler:    _Vtctld_FindAllShardsInKeyspace_Handler,
		},
		{
			MethodName: "GetBackups",
			Handler:    _Vtctld_GetBackups_Handler,
		},
		{
			MethodName: "GetCellInfo",
			Handler:    _Vtctld_GetCellInfo_Handler,
		},
		{
			MethodName: "GetCellInfoNames",
			Handler:    _Vtctld_GetCellInfoNames_Handler,
		},
		{
			MethodName: "GetCellsAliases",
			Handler:    _Vtctld_GetCellsAliases_Handler,
		},
		{
			MethodName: "GetFullStatus",
			Handler:    _Vtctld_GetFullStatus_Handler,
		},
		{
			MethodName: "GetKeyspace",
			Handler:    _Vtctld_GetKeyspace_Handler,
		},
		{
			MethodName: "GetKeyspaces",
			Handler:    _Vtctld_GetKeyspaces_Handler,
		},
		{
			MethodName: "GetPermissions",
			Handler:    _Vtctld_GetPermissions_Handler,
		},
		{
			MethodName: "GetRoutingRules",
			Handler:    _Vtctld_GetRoutingRules_Handler,
		},
		{
			MethodName: "GetSchema",
			Handler:    _Vtctld_GetSchema_Handler,
		},
		{
			MethodName: "GetShard",
			Handler:    _Vtctld_GetShard_Handler,
		},
		{
			MethodName: "GetShardRoutingRules",
			Handler:    _Vtctld_GetShardRoutingRules_Handler,
		},
		{
			MethodName: "GetSrvKeyspaceNames",
			Handler:    _Vtctld_GetSrvKeyspaceNames_Handler,
		},
		{
			MethodName: "GetSrvKeyspaces",
			Handler:    _Vtctld_GetSrvKeyspaces_Handler,
		},
		{
			MethodName: "UpdateThrottlerConfig",
			Handler:    _Vtctld_UpdateThrottlerConfig_Handler,
		},
		{
			MethodName: "GetSrvVSchema",
			Handler:    _Vtctld_GetSrvVSchema_Handler,
		},
		{
			MethodName: "GetSrvVSchemas",
			Handler:    _Vtctld_GetSrvVSchemas_Handler,
		},
		{
			MethodName: "GetTablet",
			Handler:    _Vtctld_GetTablet_Handler,
		},
		{
			MethodName: "GetTablets",
			Handler:    _Vtctld_GetTablets_Handler,
		},
		{
			MethodName: "GetTopologyPath",
			Handler:    _Vtctld_GetTopologyPath_Handler,
		},
		{
			MethodName: "GetVersion",
			Handler:    _Vtctld_GetVersion_Handler,
		},
		{
			MethodName: "GetVSchema",
			Handler:    _Vtctld_GetVSchema_Handler,
		},
		{
			MethodName: "GetWorkflows",
			Handler:    _Vtctld_GetWorkflows_Handler,
		},
		{
			MethodName: "InitShardPrimary",
			Handler:    _Vtctld_InitShardPrimary_Handler,
		},
		{
			MethodName: "PingTablet",
			Handler:    _Vtctld_PingTablet_Handler,
		},
		{
			MethodName: "PlannedReparentShard",
			Handler:    _Vtctld_PlannedReparentShard_Handler,
		},
		{
			MethodName: "RebuildKeyspaceGraph",
			Handler:    _Vtctld_RebuildKeyspaceGraph_Handler,
		},
		{
			MethodName: "RebuildVSchemaGraph",
			Handler:    _Vtctld_RebuildVSchemaGraph_Handler,
		},
		{
			MethodName: "RefreshState",
			Handler:    _Vtctld_RefreshState_Handler,
		},
		{
			MethodName: "RefreshStateByShard",
			Handler:    _Vtctld_RefreshStateByShard_Handler,
		},
		{
			MethodName: "ReloadSchema",
			Handler:    _Vtctld_ReloadSchema_Handler,
		},
		{
			MethodName: "ReloadSchemaKeyspace",
			Handler:    _Vtctld_ReloadSchemaKeyspace_Handler,
		},
		{
			MethodName: "ReloadSchemaShard",
			Handler:    _Vtctld_ReloadSchemaShard_Handler,
		},
		{
			MethodName: "RemoveBackup",
			Handler:    _Vtctld_RemoveBackup_Handler,
		},
		{
			MethodName: "RemoveKeyspaceCell",
			Handler:    _Vtctld_RemoveKeyspaceCell_Handler,
		},
		{
			MethodName: "RemoveShardCell",
			Handler:    _Vtctld_RemoveShardCell_Handler,
		},
		{
			MethodName: "ReparentTablet",
			Handler:    _Vtctld_ReparentTablet_Handler,
		},
		{
			MethodName: "RunHealthCheck",
			Handler:    _Vtctld_RunHealthCheck_Handler,
		},
		{
			MethodName: "SetKeyspaceDurabilityPolicy",
			Handler:    _Vtctld_SetKeyspaceDurabilityPolicy_Handler,
		},
		{
			MethodName: "SetShardIsPrimaryServing",
			Handler:    _Vtctld_SetShardIsPrimaryServing_Handler,
		},
		{
			MethodName: "SetShardTabletControl",
			Handler:    _Vtctld_SetShardTabletControl_Handler,
		},
		{
			MethodName: "SetWritable",
			Handler:    _Vtctld_SetWritable_Handler,
		},
		{
			MethodName: "ShardReplicationAdd",
			Handler:    _Vtctld_ShardReplicationAdd_Handler,
		},
		{
			MethodName: "ShardReplicationFix",
			Handler:    _Vtctld_ShardReplicationFix_Handler,
		},
		{
			MethodName: "ShardReplicationPositions",
			Handler:    _Vtctld_ShardReplicationPositions_Handler,
		},
		{
			MethodName: "ShardReplicationRemove",
			Handler:    _Vtctld_ShardReplicationRemove_Handler,
		},
		{
			MethodName: "SleepTablet",
			Handler:    _Vtctld_SleepTablet_Handler,
		},
		{
			MethodName: "SourceShardAdd",
			Handler:    _Vtctld_SourceShardAdd_Handler,
		},
		{
			MethodName: "SourceShardDelete",
			Handler:    _Vtctld_SourceShardDelete_Handler,
		},
		{
			MethodName: "StartReplication",
			Handler:    _Vtctld_StartReplication_Handler,
		},
		{
			MethodName: "StopReplication",
			Handler:    _Vtctld_StopReplication_Handler,
		},
		{
			MethodName: "TabletExternallyReparented",
			Handler:    _Vtctld_TabletExternallyReparented_Handler,
		},
		{
			MethodName: "UpdateCellInfo",
			Handler:    _Vtctld_UpdateCellInfo_Handler,
		},
		{
			MethodName: "UpdateCellsAlias",
			Handler:    _Vtctld_UpdateCellsAlias_Handler,
		},
		{
			MethodName: "Validate",
			Handler:    _Vtctld_Validate_Handler,
		},
		{
			MethodName: "ValidateKeyspace",
			Handler:    _Vtctld_ValidateKeyspace_Handler,
		},
		{
			MethodName: "ValidateSchemaKeyspace",
			Handler:    _Vtctld_ValidateSchemaKeyspace_Handler,
		},
		{
			MethodName: "ValidateShard",
			Handler:    _Vtctld_ValidateShard_Handler,
		},
		{
			MethodName: "ValidateVersionKeyspace",
			Handler:    _Vtctld_ValidateVersionKeyspace_Handler,
		},
		{
			MethodName: "ValidateVersionShard",
			Handler:    _Vtctld_ValidateVersionShard_Handler,
		},
		{
			MethodName: "ValidateVSchema",
			Handler:    _Vtctld_ValidateVSchema_Handler,
		},
		{
			MethodName: "WorkflowUpdate",
			Handler:    _Vtctld_WorkflowUpdate_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Backup",
			Handler:       _Vtctld_Backup_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "BackupShard",
			Handler:       _Vtctld_BackupShard_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RestoreFromBackup",
			Handler:       _Vtctld_RestoreFromBackup_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "vtctlservice.proto",
}
