// Code generated by protoc-gen-go. DO NOT EDIT.
// source: throttlerdata.proto

package throttlerdata

import (
	fmt "fmt"
	math "math"

	proto "github.com/golang/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// MaxRatesRequest is the payload for the MaxRates RPC.
type MaxRatesRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MaxRatesRequest) Reset()         { *m = MaxRatesRequest{} }
func (m *MaxRatesRequest) String() string { return proto.CompactTextString(m) }
func (*MaxRatesRequest) ProtoMessage()    {}
func (*MaxRatesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b67db2b008a2453d, []int{0}
}

func (m *MaxRatesRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MaxRatesRequest.Unmarshal(m, b)
}
func (m *MaxRatesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MaxRatesRequest.Marshal(b, m, deterministic)
}
func (m *MaxRatesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MaxRatesRequest.Merge(m, src)
}
func (m *MaxRatesRequest) XXX_Size() int {
	return xxx_messageInfo_MaxRatesRequest.Size(m)
}
func (m *MaxRatesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MaxRatesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MaxRatesRequest proto.InternalMessageInfo

// MaxRatesResponse is returned by the MaxRates RPC.
type MaxRatesResponse struct {
	// max_rates returns the max rate for each throttler. It's keyed by the
	// throttler name.
	Rates                map[string]int64 `protobuf:"bytes,1,rep,name=rates,proto3" json:"rates,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *MaxRatesResponse) Reset()         { *m = MaxRatesResponse{} }
func (m *MaxRatesResponse) String() string { return proto.CompactTextString(m) }
func (*MaxRatesResponse) ProtoMessage()    {}
func (*MaxRatesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b67db2b008a2453d, []int{1}
}

func (m *MaxRatesResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MaxRatesResponse.Unmarshal(m, b)
}
func (m *MaxRatesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MaxRatesResponse.Marshal(b, m, deterministic)
}
func (m *MaxRatesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MaxRatesResponse.Merge(m, src)
}
func (m *MaxRatesResponse) XXX_Size() int {
	return xxx_messageInfo_MaxRatesResponse.Size(m)
}
func (m *MaxRatesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MaxRatesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MaxRatesResponse proto.InternalMessageInfo

func (m *MaxRatesResponse) GetRates() map[string]int64 {
	if m != nil {
		return m.Rates
	}
	return nil
}

// SetMaxRateRequest is the payload for the SetMaxRate RPC.
type SetMaxRateRequest struct {
	Rate                 int64    `protobuf:"varint,1,opt,name=rate,proto3" json:"rate,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetMaxRateRequest) Reset()         { *m = SetMaxRateRequest{} }
func (m *SetMaxRateRequest) String() string { return proto.CompactTextString(m) }
func (*SetMaxRateRequest) ProtoMessage()    {}
func (*SetMaxRateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b67db2b008a2453d, []int{2}
}

func (m *SetMaxRateRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SetMaxRateRequest.Unmarshal(m, b)
}
func (m *SetMaxRateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SetMaxRateRequest.Marshal(b, m, deterministic)
}
func (m *SetMaxRateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetMaxRateRequest.Merge(m, src)
}
func (m *SetMaxRateRequest) XXX_Size() int {
	return xxx_messageInfo_SetMaxRateRequest.Size(m)
}
func (m *SetMaxRateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetMaxRateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetMaxRateRequest proto.InternalMessageInfo

func (m *SetMaxRateRequest) GetRate() int64 {
	if m != nil {
		return m.Rate
	}
	return 0
}

// SetMaxRateResponse is returned by the SetMaxRate RPC.
type SetMaxRateResponse struct {
	// names is the list of throttler names which were updated.
	Names                []string `protobuf:"bytes,1,rep,name=names,proto3" json:"names,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetMaxRateResponse) Reset()         { *m = SetMaxRateResponse{} }
func (m *SetMaxRateResponse) String() string { return proto.CompactTextString(m) }
func (*SetMaxRateResponse) ProtoMessage()    {}
func (*SetMaxRateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b67db2b008a2453d, []int{3}
}

func (m *SetMaxRateResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SetMaxRateResponse.Unmarshal(m, b)
}
func (m *SetMaxRateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SetMaxRateResponse.Marshal(b, m, deterministic)
}
func (m *SetMaxRateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetMaxRateResponse.Merge(m, src)
}
func (m *SetMaxRateResponse) XXX_Size() int {
	return xxx_messageInfo_SetMaxRateResponse.Size(m)
}
func (m *SetMaxRateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SetMaxRateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SetMaxRateResponse proto.InternalMessageInfo

func (m *SetMaxRateResponse) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

// Configuration holds the configuration parameters for the
// MaxReplicationLagModule which adaptively adjusts the throttling rate based on
// the observed replication lag across all replicas.
type Configuration struct {
	// target_replication_lag_sec is the replication lag (in seconds) the
	// MaxReplicationLagModule tries to aim for.
	// If it is within the target, it tries to increase the throttler
	// rate, otherwise it will lower it based on an educated guess of the
	// replica's throughput.
	TargetReplicationLagSec int64 `protobuf:"varint,1,opt,name=target_replication_lag_sec,json=targetReplicationLagSec,proto3" json:"target_replication_lag_sec,omitempty"`
	// max_replication_lag_sec is meant as a last resort.
	// By default, the module tries to find out the system maximum capacity while
	// trying to keep the replication lag around "target_replication_lag_sec".
	// Usually, we'll wait min_duration_between_(increases|decreases)_sec to see
	// the effect of a throttler rate change on the replication lag.
	// But if the lag goes above this field's value we will go into an "emergency"
	// state and throttle more aggressively (see "emergency_decrease" below).
	// This is the only way to ensure that the system will recover.
	MaxReplicationLagSec int64 `protobuf:"varint,2,opt,name=max_replication_lag_sec,json=maxReplicationLagSec,proto3" json:"max_replication_lag_sec,omitempty"`
	// initial_rate is the rate at which the module will start.
	InitialRate int64 `protobuf:"varint,3,opt,name=initial_rate,json=initialRate,proto3" json:"initial_rate,omitempty"`
	// max_increase defines by how much we will increase the rate
	// e.g. 0.05 increases the rate by 5% while 1.0 by 100%.
	// Note that any increase will let the system wait for at least
	// (1 / MaxIncrease) seconds. If we wait for shorter periods of time, we
	// won't notice if the rate increase also increases the replication lag.
	// (If the system was already at its maximum capacity (e.g. 1k QPS) and we
	// increase the rate by e.g. 5% to 1050 QPS, it will take 20 seconds until
	// 1000 extra queries are buffered and the lag increases by 1 second.)
	MaxIncrease float64 `protobuf:"fixed64,4,opt,name=max_increase,json=maxIncrease,proto3" json:"max_increase,omitempty"`
	// emergency_decrease defines by how much we will decrease the current rate
	// if the observed replication lag is above "max_replication_lag_sec".
	// E.g. 0.50 decreases the current rate by 50%.
	EmergencyDecrease float64 `protobuf:"fixed64,5,opt,name=emergency_decrease,json=emergencyDecrease,proto3" json:"emergency_decrease,omitempty"`
	// min_duration_between_increases_sec specifies how long we'll wait at least
	// for the last rate increase to have an effect on the system.
	MinDurationBetweenIncreasesSec int64 `protobuf:"varint,6,opt,name=min_duration_between_increases_sec,json=minDurationBetweenIncreasesSec,proto3" json:"min_duration_between_increases_sec,omitempty"`
	// max_duration_between_increases_sec specifies how long we'll wait at most
	// for the last rate increase to have an effect on the system.
	MaxDurationBetweenIncreasesSec int64 `protobuf:"varint,7,opt,name=max_duration_between_increases_sec,json=maxDurationBetweenIncreasesSec,proto3" json:"max_duration_between_increases_sec,omitempty"`
	// min_duration_between_decreases_sec specifies how long we'll wait at least
	// for the last rate decrease to have an effect on the system.
	MinDurationBetweenDecreasesSec int64 `protobuf:"varint,8,opt,name=min_duration_between_decreases_sec,json=minDurationBetweenDecreasesSec,proto3" json:"min_duration_between_decreases_sec,omitempty"`
	// spread_backlog_across_sec is used when we set the throttler rate after
	// we guessed the rate of a replica and determined its backlog.
	// For example, at a guessed rate of 100 QPS and a lag of 10s, the replica has
	// a backlog of 1000 queries.
	// When we set the new, decreased throttler rate, we factor in how long it
	// will take the replica to go through the backlog (in addition to new
	// requests). This field specifies over which timespan we plan to spread this.
	// For example, for a backlog of 1000 queries spread over 5s means that we
	// have to further reduce the rate by 200 QPS or the backlog will not be
	// processed within the 5 seconds.
	SpreadBacklogAcrossSec int64 `protobuf:"varint,9,opt,name=spread_backlog_across_sec,json=spreadBacklogAcrossSec,proto3" json:"spread_backlog_across_sec,omitempty"`
	// ignore_n_slowest_replicas will ignore replication lag updates from the
	// N slowest REPLICA tablets. Under certain circumstances, replicas are still
	// considered e.g. a) if the lag is at most max_replication_lag_sec, b) there
	// are less than N+1 replicas or c) the lag increased on each replica such
	// that all replicas were ignored in a row.
	IgnoreNSlowestReplicas int32 `protobuf:"varint,10,opt,name=ignore_n_slowest_replicas,json=ignoreNSlowestReplicas,proto3" json:"ignore_n_slowest_replicas,omitempty"`
	// ignore_n_slowest_rdonlys does the same thing as ignore_n_slowest_replicas
	// but for RDONLY tablets. Note that these two settings are independent.
	IgnoreNSlowestRdonlys int32 `protobuf:"varint,11,opt,name=ignore_n_slowest_rdonlys,json=ignoreNSlowestRdonlys,proto3" json:"ignore_n_slowest_rdonlys,omitempty"`
	// age_bad_rate_after_sec is the duration after which an unchanged bad rate
	// will "age out" and increase by "bad_rate_increase".
	// Bad rates are tracked by the code in memory.go and serve as an upper bound
	// for future rate changes. This ensures that the adaptive throttler does not
	// try known too high (bad) rates over and over again.
	// To avoid that temporary degradations permanently reduce the maximum rate,
	// a stable bad rate "ages out" after "age_bad_rate_after_sec".
	AgeBadRateAfterSec int64 `protobuf:"varint,12,opt,name=age_bad_rate_after_sec,json=ageBadRateAfterSec,proto3" json:"age_bad_rate_after_sec,omitempty"`
	// bad_rate_increase defines the percentage by which a bad rate will be
	// increased when it's aging out.
	BadRateIncrease float64 `protobuf:"fixed64,13,opt,name=bad_rate_increase,json=badRateIncrease,proto3" json:"bad_rate_increase,omitempty"`
	// max_rate_approach_threshold is the fraction of the current rate limit that the actual
	// rate must exceed for the throttler to increase the limit when the replication lag
	// is below target_replication_lag_sec. For example, assuming the actual replication lag
	// is below target_replication_lag_sec, if the current rate limit is 100, then the actual
	// rate must exceed 100*max_rate_approach_threshold for the throttler to increase the current
	// limit.
	MaxRateApproachThreshold float64  `protobuf:"fixed64,14,opt,name=max_rate_approach_threshold,json=maxRateApproachThreshold,proto3" json:"max_rate_approach_threshold,omitempty"`
	XXX_NoUnkeyedLiteral     struct{} `json:"-"`
	XXX_unrecognized         []byte   `json:"-"`
	XXX_sizecache            int32    `json:"-"`
}

func (m *Configuration) Reset()         { *m = Configuration{} }
func (m *Configuration) String() string { return proto.CompactTextString(m) }
func (*Configuration) ProtoMessage()    {}
func (*Configuration) Descriptor() ([]byte, []int) {
	return fileDescriptor_b67db2b008a2453d, []int{4}
}

func (m *Configuration) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Configuration.Unmarshal(m, b)
}
func (m *Configuration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Configuration.Marshal(b, m, deterministic)
}
func (m *Configuration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Configuration.Merge(m, src)
}
func (m *Configuration) XXX_Size() int {
	return xxx_messageInfo_Configuration.Size(m)
}
func (m *Configuration) XXX_DiscardUnknown() {
	xxx_messageInfo_Configuration.DiscardUnknown(m)
}

var xxx_messageInfo_Configuration proto.InternalMessageInfo

func (m *Configuration) GetTargetReplicationLagSec() int64 {
	if m != nil {
		return m.TargetReplicationLagSec
	}
	return 0
}

func (m *Configuration) GetMaxReplicationLagSec() int64 {
	if m != nil {
		return m.MaxReplicationLagSec
	}
	return 0
}

func (m *Configuration) GetInitialRate() int64 {
	if m != nil {
		return m.InitialRate
	}
	return 0
}

func (m *Configuration) GetMaxIncrease() float64 {
	if m != nil {
		return m.MaxIncrease
	}
	return 0
}

func (m *Configuration) GetEmergencyDecrease() float64 {
	if m != nil {
		return m.EmergencyDecrease
	}
	return 0
}

func (m *Configuration) GetMinDurationBetweenIncreasesSec() int64 {
	if m != nil {
		return m.MinDurationBetweenIncreasesSec
	}
	return 0
}

func (m *Configuration) GetMaxDurationBetweenIncreasesSec() int64 {
	if m != nil {
		return m.MaxDurationBetweenIncreasesSec
	}
	return 0
}

func (m *Configuration) GetMinDurationBetweenDecreasesSec() int64 {
	if m != nil {
		return m.MinDurationBetweenDecreasesSec
	}
	return 0
}

func (m *Configuration) GetSpreadBacklogAcrossSec() int64 {
	if m != nil {
		return m.SpreadBacklogAcrossSec
	}
	return 0
}

func (m *Configuration) GetIgnoreNSlowestReplicas() int32 {
	if m != nil {
		return m.IgnoreNSlowestReplicas
	}
	return 0
}

func (m *Configuration) GetIgnoreNSlowestRdonlys() int32 {
	if m != nil {
		return m.IgnoreNSlowestRdonlys
	}
	return 0
}

func (m *Configuration) GetAgeBadRateAfterSec() int64 {
	if m != nil {
		return m.AgeBadRateAfterSec
	}
	return 0
}

func (m *Configuration) GetBadRateIncrease() float64 {
	if m != nil {
		return m.BadRateIncrease
	}
	return 0
}

func (m *Configuration) GetMaxRateApproachThreshold() float64 {
	if m != nil {
		return m.MaxRateApproachThreshold
	}
	return 0
}

// GetConfigurationRequest is the payload for the GetConfiguration RPC.
type GetConfigurationRequest struct {
	// throttler_name specifies which throttler to select. If empty, all active
	// throttlers will be selected.
	ThrottlerName        string   `protobuf:"bytes,1,opt,name=throttler_name,json=throttlerName,proto3" json:"throttler_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetConfigurationRequest) Reset()         { *m = GetConfigurationRequest{} }
func (m *GetConfigurationRequest) String() string { return proto.CompactTextString(m) }
func (*GetConfigurationRequest) ProtoMessage()    {}
func (*GetConfigurationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b67db2b008a2453d, []int{5}
}

func (m *GetConfigurationRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetConfigurationRequest.Unmarshal(m, b)
}
func (m *GetConfigurationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetConfigurationRequest.Marshal(b, m, deterministic)
}
func (m *GetConfigurationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetConfigurationRequest.Merge(m, src)
}
func (m *GetConfigurationRequest) XXX_Size() int {
	return xxx_messageInfo_GetConfigurationRequest.Size(m)
}
func (m *GetConfigurationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetConfigurationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetConfigurationRequest proto.InternalMessageInfo

func (m *GetConfigurationRequest) GetThrottlerName() string {
	if m != nil {
		return m.ThrottlerName
	}
	return ""
}

// GetConfigurationResponse is returned by the GetConfiguration RPC.
type GetConfigurationResponse struct {
	// max_rates returns the configurations for each throttler.
	// It's keyed by the throttler name.
	Configurations       map[string]*Configuration `protobuf:"bytes,1,rep,name=configurations,proto3" json:"configurations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *GetConfigurationResponse) Reset()         { *m = GetConfigurationResponse{} }
func (m *GetConfigurationResponse) String() string { return proto.CompactTextString(m) }
func (*GetConfigurationResponse) ProtoMessage()    {}
func (*GetConfigurationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b67db2b008a2453d, []int{6}
}

func (m *GetConfigurationResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetConfigurationResponse.Unmarshal(m, b)
}
func (m *GetConfigurationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetConfigurationResponse.Marshal(b, m, deterministic)
}
func (m *GetConfigurationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetConfigurationResponse.Merge(m, src)
}
func (m *GetConfigurationResponse) XXX_Size() int {
	return xxx_messageInfo_GetConfigurationResponse.Size(m)
}
func (m *GetConfigurationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetConfigurationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetConfigurationResponse proto.InternalMessageInfo

func (m *GetConfigurationResponse) GetConfigurations() map[string]*Configuration {
	if m != nil {
		return m.Configurations
	}
	return nil
}

// UpdateConfigurationRequest is the payload for the UpdateConfiguration RPC.
type UpdateConfigurationRequest struct {
	// throttler_name specifies which throttler to update. If empty, all active
	// throttlers will be updated.
	ThrottlerName string `protobuf:"bytes,1,opt,name=throttler_name,json=throttlerName,proto3" json:"throttler_name,omitempty"`
	// configuration is the new (partial) configuration.
	Configuration *Configuration `protobuf:"bytes,2,opt,name=configuration,proto3" json:"configuration,omitempty"`
	// copy_zero_values specifies whether fields with zero values should be copied
	// as well.
	CopyZeroValues       bool     `protobuf:"varint,3,opt,name=copy_zero_values,json=copyZeroValues,proto3" json:"copy_zero_values,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateConfigurationRequest) Reset()         { *m = UpdateConfigurationRequest{} }
func (m *UpdateConfigurationRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateConfigurationRequest) ProtoMessage()    {}
func (*UpdateConfigurationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b67db2b008a2453d, []int{7}
}

func (m *UpdateConfigurationRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UpdateConfigurationRequest.Unmarshal(m, b)
}
func (m *UpdateConfigurationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UpdateConfigurationRequest.Marshal(b, m, deterministic)
}
func (m *UpdateConfigurationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateConfigurationRequest.Merge(m, src)
}
func (m *UpdateConfigurationRequest) XXX_Size() int {
	return xxx_messageInfo_UpdateConfigurationRequest.Size(m)
}
func (m *UpdateConfigurationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateConfigurationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateConfigurationRequest proto.InternalMessageInfo

func (m *UpdateConfigurationRequest) GetThrottlerName() string {
	if m != nil {
		return m.ThrottlerName
	}
	return ""
}

func (m *UpdateConfigurationRequest) GetConfiguration() *Configuration {
	if m != nil {
		return m.Configuration
	}
	return nil
}

func (m *UpdateConfigurationRequest) GetCopyZeroValues() bool {
	if m != nil {
		return m.CopyZeroValues
	}
	return false
}

// UpdateConfigurationResponse is returned by the UpdateConfiguration RPC.
type UpdateConfigurationResponse struct {
	// names is the list of throttler names which were updated.
	Names                []string `protobuf:"bytes,1,rep,name=names,proto3" json:"names,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateConfigurationResponse) Reset()         { *m = UpdateConfigurationResponse{} }
func (m *UpdateConfigurationResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateConfigurationResponse) ProtoMessage()    {}
func (*UpdateConfigurationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b67db2b008a2453d, []int{8}
}

func (m *UpdateConfigurationResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UpdateConfigurationResponse.Unmarshal(m, b)
}
func (m *UpdateConfigurationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UpdateConfigurationResponse.Marshal(b, m, deterministic)
}
func (m *UpdateConfigurationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateConfigurationResponse.Merge(m, src)
}
func (m *UpdateConfigurationResponse) XXX_Size() int {
	return xxx_messageInfo_UpdateConfigurationResponse.Size(m)
}
func (m *UpdateConfigurationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateConfigurationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateConfigurationResponse proto.InternalMessageInfo

func (m *UpdateConfigurationResponse) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

// ResetConfigurationRequest is the payload for the ResetConfiguration RPC.
type ResetConfigurationRequest struct {
	// throttler_name specifies which throttler to reset. If empty, all active
	// throttlers will be reset.
	ThrottlerName        string   `protobuf:"bytes,1,opt,name=throttler_name,json=throttlerName,proto3" json:"throttler_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResetConfigurationRequest) Reset()         { *m = ResetConfigurationRequest{} }
func (m *ResetConfigurationRequest) String() string { return proto.CompactTextString(m) }
func (*ResetConfigurationRequest) ProtoMessage()    {}
func (*ResetConfigurationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b67db2b008a2453d, []int{9}
}

func (m *ResetConfigurationRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ResetConfigurationRequest.Unmarshal(m, b)
}
func (m *ResetConfigurationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ResetConfigurationRequest.Marshal(b, m, deterministic)
}
func (m *ResetConfigurationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResetConfigurationRequest.Merge(m, src)
}
func (m *ResetConfigurationRequest) XXX_Size() int {
	return xxx_messageInfo_ResetConfigurationRequest.Size(m)
}
func (m *ResetConfigurationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ResetConfigurationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ResetConfigurationRequest proto.InternalMessageInfo

func (m *ResetConfigurationRequest) GetThrottlerName() string {
	if m != nil {
		return m.ThrottlerName
	}
	return ""
}

// ResetConfigurationResponse is returned by the ResetConfiguration RPC.
type ResetConfigurationResponse struct {
	// names is the list of throttler names which were updated.
	Names                []string `protobuf:"bytes,1,rep,name=names,proto3" json:"names,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResetConfigurationResponse) Reset()         { *m = ResetConfigurationResponse{} }
func (m *ResetConfigurationResponse) String() string { return proto.CompactTextString(m) }
func (*ResetConfigurationResponse) ProtoMessage()    {}
func (*ResetConfigurationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b67db2b008a2453d, []int{10}
}

func (m *ResetConfigurationResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ResetConfigurationResponse.Unmarshal(m, b)
}
func (m *ResetConfigurationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ResetConfigurationResponse.Marshal(b, m, deterministic)
}
func (m *ResetConfigurationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResetConfigurationResponse.Merge(m, src)
}
func (m *ResetConfigurationResponse) XXX_Size() int {
	return xxx_messageInfo_ResetConfigurationResponse.Size(m)
}
func (m *ResetConfigurationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ResetConfigurationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ResetConfigurationResponse proto.InternalMessageInfo

func (m *ResetConfigurationResponse) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

func init() {
	proto.RegisterType((*MaxRatesRequest)(nil), "throttlerdata.MaxRatesRequest")
	proto.RegisterType((*MaxRatesResponse)(nil), "throttlerdata.MaxRatesResponse")
	proto.RegisterMapType((map[string]int64)(nil), "throttlerdata.MaxRatesResponse.RatesEntry")
	proto.RegisterType((*SetMaxRateRequest)(nil), "throttlerdata.SetMaxRateRequest")
	proto.RegisterType((*SetMaxRateResponse)(nil), "throttlerdata.SetMaxRateResponse")
	proto.RegisterType((*Configuration)(nil), "throttlerdata.Configuration")
	proto.RegisterType((*GetConfigurationRequest)(nil), "throttlerdata.GetConfigurationRequest")
	proto.RegisterType((*GetConfigurationResponse)(nil), "throttlerdata.GetConfigurationResponse")
	proto.RegisterMapType((map[string]*Configuration)(nil), "throttlerdata.GetConfigurationResponse.ConfigurationsEntry")
	proto.RegisterType((*UpdateConfigurationRequest)(nil), "throttlerdata.UpdateConfigurationRequest")
	proto.RegisterType((*UpdateConfigurationResponse)(nil), "throttlerdata.UpdateConfigurationResponse")
	proto.RegisterType((*ResetConfigurationRequest)(nil), "throttlerdata.ResetConfigurationRequest")
	proto.RegisterType((*ResetConfigurationResponse)(nil), "throttlerdata.ResetConfigurationResponse")
}

func init() { proto.RegisterFile("throttlerdata.proto", fileDescriptor_b67db2b008a2453d) }

var fileDescriptor_b67db2b008a2453d = []byte{
	// 734 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x55, 0x5f, 0x4f, 0x03, 0x45,
	0x10, 0xcf, 0x51, 0x8a, 0x30, 0xa5, 0x40, 0x17, 0x84, 0xa3, 0x18, 0x53, 0x2f, 0x31, 0x36, 0x8d,
	0xb6, 0x49, 0x89, 0x11, 0x25, 0x26, 0x50, 0x31, 0x46, 0xa3, 0x3c, 0x1c, 0xea, 0x03, 0x2f, 0x9b,
	0xed, 0xdd, 0x70, 0xbd, 0x70, 0x77, 0x7b, 0xee, 0x2e, 0xd0, 0xfa, 0x21, 0xfc, 0x20, 0xbe, 0xf9,
	0x8d, 0xfc, 0x28, 0xe6, 0x76, 0xb7, 0x7f, 0xae, 0x14, 0x30, 0xe1, 0x6d, 0x77, 0xe6, 0x37, 0xbf,
	0xf9, 0xcd, 0xde, 0xcc, 0x1c, 0xec, 0xab, 0x91, 0xe0, 0x4a, 0x25, 0x28, 0x42, 0xa6, 0x58, 0x37,
	0x17, 0x5c, 0x71, 0x52, 0x2f, 0x19, 0xbd, 0x06, 0xec, 0xfe, 0xc2, 0xc6, 0x3e, 0x53, 0x28, 0x7d,
	0xfc, 0xe3, 0x01, 0xa5, 0xf2, 0xfe, 0x72, 0x60, 0x6f, 0x6e, 0x93, 0x39, 0xcf, 0x24, 0x92, 0x0b,
	0xa8, 0x8a, 0xc2, 0xe0, 0x3a, 0xad, 0x4a, 0xbb, 0xd6, 0xef, 0x74, 0xcb, 0xdc, 0xcb, 0xf8, 0xae,
	0xbe, 0x7d, 0x9f, 0x29, 0x31, 0xf1, 0x4d, 0x60, 0xf3, 0x0c, 0x60, 0x6e, 0x24, 0x7b, 0x50, 0xb9,
	0xc7, 0x89, 0xeb, 0xb4, 0x9c, 0xf6, 0x96, 0x5f, 0x1c, 0xc9, 0x01, 0x54, 0x1f, 0x59, 0xf2, 0x80,
	0xee, 0x5a, 0xcb, 0x69, 0x57, 0x7c, 0x73, 0xf9, 0x66, 0xed, 0xcc, 0xf1, 0x3e, 0x83, 0xc6, 0x0d,
	0x2a, 0x9b, 0xc2, 0xaa, 0x24, 0x04, 0xd6, 0x0b, 0x5e, 0xcd, 0x50, 0xf1, 0xf5, 0xd9, 0xeb, 0x00,
	0x59, 0x04, 0x5a, 0xe9, 0x07, 0x50, 0xcd, 0x58, 0x6a, 0xa5, 0x6f, 0xf9, 0xe6, 0xe2, 0xfd, 0xbd,
	0x01, 0xf5, 0xef, 0x78, 0x76, 0x17, 0x47, 0x0f, 0x82, 0xa9, 0x98, 0x67, 0xe4, 0x1c, 0x9a, 0x8a,
	0x89, 0x08, 0x15, 0x15, 0x98, 0x27, 0x71, 0xa0, 0xad, 0x34, 0x61, 0x11, 0x95, 0x18, 0xd8, 0x3c,
	0x47, 0x06, 0xe1, 0xcf, 0x01, 0x3f, 0xb3, 0xe8, 0x06, 0x03, 0xf2, 0x25, 0x1c, 0xa5, 0x6c, 0xbc,
	0x32, 0xd2, 0xd4, 0x73, 0x90, 0xb2, 0xf1, 0xf3, 0xb0, 0x4f, 0x60, 0x3b, 0xce, 0x62, 0x15, 0xb3,
	0x84, 0xea, 0x6a, 0x2a, 0x1a, 0x5b, 0xb3, 0xb6, 0xa2, 0x8c, 0x02, 0x52, 0x30, 0xc7, 0x59, 0x20,
	0x90, 0x49, 0x74, 0xd7, 0x5b, 0x4e, 0xdb, 0xf1, 0x6b, 0x29, 0x1b, 0xff, 0x68, 0x4d, 0xe4, 0x0b,
	0x20, 0x98, 0xa2, 0x88, 0x30, 0x0b, 0x26, 0x34, 0x44, 0x0b, 0xac, 0x6a, 0x60, 0x63, 0xe6, 0xb9,
	0xb2, 0x0e, 0xf2, 0x13, 0x78, 0x69, 0x9c, 0xd1, 0xd0, 0x16, 0x4e, 0x87, 0xa8, 0x9e, 0x10, 0xb3,
	0x59, 0x0a, 0xa9, 0x65, 0x6f, 0x68, 0x29, 0x1f, 0xa7, 0x71, 0x76, 0x65, 0x81, 0x03, 0x83, 0x9b,
	0xa6, 0x95, 0x45, 0x01, 0x05, 0x17, 0x1b, 0xbf, 0xc5, 0xf5, 0x81, 0xe5, 0x62, 0xe3, 0xb7, 0xb8,
	0x56, 0xe9, 0x9a, 0x56, 0x64, 0xb8, 0x36, 0x5f, 0xd2, 0x35, 0xad, 0x4f, 0x73, 0x7d, 0x0d, 0xc7,
	0x32, 0x17, 0xc8, 0x42, 0x3a, 0x64, 0xc1, 0x7d, 0xc2, 0x23, 0xca, 0x02, 0xc1, 0xa5, 0xa1, 0xd8,
	0xd2, 0x14, 0x87, 0x06, 0x30, 0x30, 0xfe, 0x4b, 0xed, 0xb6, 0xa1, 0x71, 0x94, 0x71, 0x81, 0x34,
	0xa3, 0x32, 0xe1, 0x4f, 0x28, 0x67, 0x1d, 0x21, 0x5d, 0x68, 0x39, 0xed, 0xaa, 0x7f, 0x68, 0x00,
	0xd7, 0x37, 0xc6, 0x6d, 0xbf, 0xab, 0x24, 0x5f, 0x81, 0xfb, 0x3c, 0x34, 0xe4, 0x59, 0x32, 0x91,
	0x6e, 0x4d, 0x47, 0x7e, 0xb8, 0x14, 0x69, 0x9c, 0xa4, 0x0f, 0x87, 0x2c, 0x42, 0x3a, 0x64, 0xa1,
	0xee, 0x03, 0xca, 0xee, 0x14, 0x0a, 0xad, 0x75, 0x5b, 0x6b, 0x25, 0x2c, 0xc2, 0x01, 0x0b, 0x8b,
	0x86, 0xb8, 0x2c, 0x5c, 0x85, 0xce, 0x0e, 0x34, 0x66, 0xf8, 0x59, 0x77, 0xd4, 0xf5, 0x47, 0xdf,
	0x1d, 0x1a, 0xec, 0xac, 0x43, 0xbe, 0x85, 0x13, 0xdd, 0x9e, 0x9a, 0x3b, 0xcf, 0x05, 0x67, 0xc1,
	0x88, 0xaa, 0x91, 0x40, 0x39, 0xe2, 0x49, 0xe8, 0xee, 0xe8, 0x28, 0x37, 0x35, 0x93, 0x73, 0x69,
	0x01, 0xbf, 0x4e, 0xfd, 0xde, 0x05, 0x1c, 0xfd, 0x80, 0xaa, 0x34, 0x2e, 0xd3, 0x39, 0xfc, 0x14,
	0x76, 0x66, 0xab, 0x80, 0x16, 0xa3, 0x65, 0x67, 0x7a, 0xbe, 0x67, 0xae, 0x59, 0x8a, 0xde, 0xbf,
	0x0e, 0xb8, 0xcf, 0x29, 0xec, 0x84, 0x06, 0xb0, 0x13, 0x2c, 0x3a, 0xa6, 0x5b, 0xe6, 0x7c, 0x69,
	0xcb, 0xbc, 0x44, 0xd0, 0x2d, 0x59, 0xed, 0xda, 0x59, 0xa2, 0x6c, 0x52, 0xd8, 0x5f, 0x01, 0x5b,
	0xb1, 0x88, 0xfa, 0x8b, 0x8b, 0xa8, 0xd6, 0xff, 0x68, 0x49, 0x44, 0x59, 0xc1, 0xc2, 0x9a, 0xfa,
	0xc7, 0x81, 0xe6, 0x6f, 0x79, 0xc8, 0x14, 0xbe, 0xe3, 0xa1, 0xc8, 0x00, 0xea, 0x25, 0xe1, 0xff,
	0x4b, 0x45, 0x39, 0x84, 0xb4, 0x61, 0x2f, 0xe0, 0xf9, 0x84, 0xfe, 0x89, 0x82, 0x53, 0x2d, 0x50,
	0xea, 0xcd, 0xb2, 0x59, 0x3c, 0x4a, 0x3e, 0xb9, 0x45, 0xc1, 0x7f, 0xd7, 0x56, 0xef, 0x14, 0x4e,
	0x56, 0x4a, 0x7e, 0x75, 0x75, 0x0e, 0xe0, 0xd8, 0x47, 0xf9, 0xbe, 0x7e, 0xe8, 0x43, 0x73, 0x15,
	0xc7, 0x6b, 0x79, 0x07, 0x9f, 0xdf, 0x76, 0x1e, 0x63, 0x85, 0x52, 0x76, 0x63, 0xde, 0x33, 0xa7,
	0x5e, 0xc4, 0x7b, 0x8f, 0xaa, 0xa7, 0x7f, 0x6d, 0xbd, 0xd2, 0x0b, 0x0d, 0x37, 0xb4, 0xf1, 0xf4,
	0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x6c, 0xe5, 0x12, 0x96, 0x06, 0x07, 0x00, 0x00,
}
