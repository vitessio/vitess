// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: binlogdata.proto

package binlogdata

import (
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	proto "github.com/golang/protobuf/proto"
	query "vitess.io/vitess/go/vt/proto/query"
	topodata "vitess.io/vitess/go/vt/proto/topodata"
	vtrpc "vitess.io/vitess/go/vt/proto/vtrpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// OnDDLAction lists the possible actions for DDLs.
type OnDDLAction int32

const (
	OnDDLAction_IGNORE      OnDDLAction = 0
	OnDDLAction_STOP        OnDDLAction = 1
	OnDDLAction_EXEC        OnDDLAction = 2
	OnDDLAction_EXEC_IGNORE OnDDLAction = 3
)

var OnDDLAction_name = map[int32]string{
	0: "IGNORE",
	1: "STOP",
	2: "EXEC",
	3: "EXEC_IGNORE",
}

var OnDDLAction_value = map[string]int32{
	"IGNORE":      0,
	"STOP":        1,
	"EXEC":        2,
	"EXEC_IGNORE": 3,
}

func (x OnDDLAction) String() string {
	return proto.EnumName(OnDDLAction_name, int32(x))
}

func (OnDDLAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{0}
}

// VEventType enumerates the event types. Many of these types
// will not be encountered in RBR mode.
type VEventType int32

const (
	VEventType_UNKNOWN  VEventType = 0
	VEventType_GTID     VEventType = 1
	VEventType_BEGIN    VEventType = 2
	VEventType_COMMIT   VEventType = 3
	VEventType_ROLLBACK VEventType = 4
	VEventType_DDL      VEventType = 5
	// INSERT, REPLACE, UPDATE, DELETE and SET will not be seen in RBR mode.
	VEventType_INSERT  VEventType = 6
	VEventType_REPLACE VEventType = 7
	VEventType_UPDATE  VEventType = 8
	VEventType_DELETE  VEventType = 9
	VEventType_SET     VEventType = 10
	// OTHER is a dummy event. If encountered, the current GTID must be
	// recorded by the client to be able to resume.
	VEventType_OTHER VEventType = 11
	VEventType_ROW   VEventType = 12
	VEventType_FIELD VEventType = 13
	// HEARTBEAT is sent if there is inactivity. If a client does not
	// receive events beyond the hearbeat interval, it can assume that it's
	// lost connection to the vstreamer.
	VEventType_HEARTBEAT VEventType = 14
	// VGTID is generated by VTGate's VStream that combines multiple
	// GTIDs.
	VEventType_VGTID     VEventType = 15
	VEventType_JOURNAL   VEventType = 16
	VEventType_VERSION   VEventType = 17
	VEventType_LASTPK    VEventType = 18
	VEventType_SAVEPOINT VEventType = 19
)

var VEventType_name = map[int32]string{
	0:  "UNKNOWN",
	1:  "GTID",
	2:  "BEGIN",
	3:  "COMMIT",
	4:  "ROLLBACK",
	5:  "DDL",
	6:  "INSERT",
	7:  "REPLACE",
	8:  "UPDATE",
	9:  "DELETE",
	10: "SET",
	11: "OTHER",
	12: "ROW",
	13: "FIELD",
	14: "HEARTBEAT",
	15: "VGTID",
	16: "JOURNAL",
	17: "VERSION",
	18: "LASTPK",
	19: "SAVEPOINT",
}

var VEventType_value = map[string]int32{
	"UNKNOWN":   0,
	"GTID":      1,
	"BEGIN":     2,
	"COMMIT":    3,
	"ROLLBACK":  4,
	"DDL":       5,
	"INSERT":    6,
	"REPLACE":   7,
	"UPDATE":    8,
	"DELETE":    9,
	"SET":       10,
	"OTHER":     11,
	"ROW":       12,
	"FIELD":     13,
	"HEARTBEAT": 14,
	"VGTID":     15,
	"JOURNAL":   16,
	"VERSION":   17,
	"LASTPK":    18,
	"SAVEPOINT": 19,
}

func (x VEventType) String() string {
	return proto.EnumName(VEventType_name, int32(x))
}

func (VEventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{1}
}

// MigrationType specifies the type of migration for the Journal.
type MigrationType int32

const (
	MigrationType_TABLES MigrationType = 0
	MigrationType_SHARDS MigrationType = 1
)

var MigrationType_name = map[int32]string{
	0: "TABLES",
	1: "SHARDS",
}

var MigrationType_value = map[string]int32{
	"TABLES": 0,
	"SHARDS": 1,
}

func (x MigrationType) String() string {
	return proto.EnumName(MigrationType_name, int32(x))
}

func (MigrationType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{2}
}

type BinlogTransaction_Statement_Category int32

const (
	BinlogTransaction_Statement_BL_UNRECOGNIZED BinlogTransaction_Statement_Category = 0
	BinlogTransaction_Statement_BL_BEGIN        BinlogTransaction_Statement_Category = 1
	BinlogTransaction_Statement_BL_COMMIT       BinlogTransaction_Statement_Category = 2
	BinlogTransaction_Statement_BL_ROLLBACK     BinlogTransaction_Statement_Category = 3
	// BL_DML is deprecated.
	BinlogTransaction_Statement_BL_DML_DEPRECATED BinlogTransaction_Statement_Category = 4
	BinlogTransaction_Statement_BL_DDL            BinlogTransaction_Statement_Category = 5
	BinlogTransaction_Statement_BL_SET            BinlogTransaction_Statement_Category = 6
	BinlogTransaction_Statement_BL_INSERT         BinlogTransaction_Statement_Category = 7
	BinlogTransaction_Statement_BL_UPDATE         BinlogTransaction_Statement_Category = 8
	BinlogTransaction_Statement_BL_DELETE         BinlogTransaction_Statement_Category = 9
)

var BinlogTransaction_Statement_Category_name = map[int32]string{
	0: "BL_UNRECOGNIZED",
	1: "BL_BEGIN",
	2: "BL_COMMIT",
	3: "BL_ROLLBACK",
	4: "BL_DML_DEPRECATED",
	5: "BL_DDL",
	6: "BL_SET",
	7: "BL_INSERT",
	8: "BL_UPDATE",
	9: "BL_DELETE",
}

var BinlogTransaction_Statement_Category_value = map[string]int32{
	"BL_UNRECOGNIZED":   0,
	"BL_BEGIN":          1,
	"BL_COMMIT":         2,
	"BL_ROLLBACK":       3,
	"BL_DML_DEPRECATED": 4,
	"BL_DDL":            5,
	"BL_SET":            6,
	"BL_INSERT":         7,
	"BL_UPDATE":         8,
	"BL_DELETE":         9,
}

func (x BinlogTransaction_Statement_Category) String() string {
	return proto.EnumName(BinlogTransaction_Statement_Category_name, int32(x))
}

func (BinlogTransaction_Statement_Category) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{1, 0, 0}
}

type Filter_FieldEventMode int32

const (
	Filter_ERR_ON_MISMATCH Filter_FieldEventMode = 0
	Filter_BEST_EFFORT     Filter_FieldEventMode = 1
)

var Filter_FieldEventMode_name = map[int32]string{
	0: "ERR_ON_MISMATCH",
	1: "BEST_EFFORT",
}

var Filter_FieldEventMode_value = map[string]int32{
	"ERR_ON_MISMATCH": 0,
	"BEST_EFFORT":     1,
}

func (x Filter_FieldEventMode) String() string {
	return proto.EnumName(Filter_FieldEventMode_name, int32(x))
}

func (Filter_FieldEventMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{7, 0}
}

// Charset is the per-statement charset info from a QUERY_EVENT binlog entry.
type Charset struct {
	// @@session.character_set_client
	Client int32 `protobuf:"varint,1,opt,name=client,proto3" json:"client,omitempty"`
	// @@session.collation_connection
	Conn int32 `protobuf:"varint,2,opt,name=conn,proto3" json:"conn,omitempty"`
	// @@session.collation_server
	Server               int32    `protobuf:"varint,3,opt,name=server,proto3" json:"server,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Charset) Reset()         { *m = Charset{} }
func (m *Charset) String() string { return proto.CompactTextString(m) }
func (*Charset) ProtoMessage()    {}
func (*Charset) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{0}
}
func (m *Charset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Charset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Charset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Charset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Charset.Merge(m, src)
}
func (m *Charset) XXX_Size() int {
	return m.Size()
}
func (m *Charset) XXX_DiscardUnknown() {
	xxx_messageInfo_Charset.DiscardUnknown(m)
}

var xxx_messageInfo_Charset proto.InternalMessageInfo

func (m *Charset) GetClient() int32 {
	if m != nil {
		return m.Client
	}
	return 0
}

func (m *Charset) GetConn() int32 {
	if m != nil {
		return m.Conn
	}
	return 0
}

func (m *Charset) GetServer() int32 {
	if m != nil {
		return m.Server
	}
	return 0
}

// BinlogTransaction describes a transaction inside the binlogs.
// It is streamed by vttablet for filtered replication, used during resharding.
type BinlogTransaction struct {
	// the statements in this transaction
	Statements []*BinlogTransaction_Statement `protobuf:"bytes,1,rep,name=statements,proto3" json:"statements,omitempty"`
	// The Event Token for this event.
	EventToken           *query.EventToken `protobuf:"bytes,4,opt,name=event_token,json=eventToken,proto3" json:"event_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *BinlogTransaction) Reset()         { *m = BinlogTransaction{} }
func (m *BinlogTransaction) String() string { return proto.CompactTextString(m) }
func (*BinlogTransaction) ProtoMessage()    {}
func (*BinlogTransaction) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{1}
}
func (m *BinlogTransaction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BinlogTransaction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BinlogTransaction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BinlogTransaction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BinlogTransaction.Merge(m, src)
}
func (m *BinlogTransaction) XXX_Size() int {
	return m.Size()
}
func (m *BinlogTransaction) XXX_DiscardUnknown() {
	xxx_messageInfo_BinlogTransaction.DiscardUnknown(m)
}

var xxx_messageInfo_BinlogTransaction proto.InternalMessageInfo

func (m *BinlogTransaction) GetStatements() []*BinlogTransaction_Statement {
	if m != nil {
		return m.Statements
	}
	return nil
}

func (m *BinlogTransaction) GetEventToken() *query.EventToken {
	if m != nil {
		return m.EventToken
	}
	return nil
}

type BinlogTransaction_Statement struct {
	// what type of statement is this?
	Category BinlogTransaction_Statement_Category `protobuf:"varint,1,opt,name=category,proto3,enum=binlogdata.BinlogTransaction_Statement_Category" json:"category,omitempty"`
	// charset of this statement, if different from pre-negotiated default.
	Charset *Charset `protobuf:"bytes,2,opt,name=charset,proto3" json:"charset,omitempty"`
	// the sql
	Sql                  []byte   `protobuf:"bytes,3,opt,name=sql,proto3" json:"sql,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BinlogTransaction_Statement) Reset()         { *m = BinlogTransaction_Statement{} }
func (m *BinlogTransaction_Statement) String() string { return proto.CompactTextString(m) }
func (*BinlogTransaction_Statement) ProtoMessage()    {}
func (*BinlogTransaction_Statement) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{1, 0}
}
func (m *BinlogTransaction_Statement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BinlogTransaction_Statement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BinlogTransaction_Statement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BinlogTransaction_Statement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BinlogTransaction_Statement.Merge(m, src)
}
func (m *BinlogTransaction_Statement) XXX_Size() int {
	return m.Size()
}
func (m *BinlogTransaction_Statement) XXX_DiscardUnknown() {
	xxx_messageInfo_BinlogTransaction_Statement.DiscardUnknown(m)
}

var xxx_messageInfo_BinlogTransaction_Statement proto.InternalMessageInfo

func (m *BinlogTransaction_Statement) GetCategory() BinlogTransaction_Statement_Category {
	if m != nil {
		return m.Category
	}
	return BinlogTransaction_Statement_BL_UNRECOGNIZED
}

func (m *BinlogTransaction_Statement) GetCharset() *Charset {
	if m != nil {
		return m.Charset
	}
	return nil
}

func (m *BinlogTransaction_Statement) GetSql() []byte {
	if m != nil {
		return m.Sql
	}
	return nil
}

// StreamKeyRangeRequest is the payload to StreamKeyRange
type StreamKeyRangeRequest struct {
	// where to start
	Position string `protobuf:"bytes,1,opt,name=position,proto3" json:"position,omitempty"`
	// what to get
	KeyRange *topodata.KeyRange `protobuf:"bytes,2,opt,name=key_range,json=keyRange,proto3" json:"key_range,omitempty"`
	// default charset on the player side
	Charset              *Charset `protobuf:"bytes,3,opt,name=charset,proto3" json:"charset,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StreamKeyRangeRequest) Reset()         { *m = StreamKeyRangeRequest{} }
func (m *StreamKeyRangeRequest) String() string { return proto.CompactTextString(m) }
func (*StreamKeyRangeRequest) ProtoMessage()    {}
func (*StreamKeyRangeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{2}
}
func (m *StreamKeyRangeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamKeyRangeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamKeyRangeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamKeyRangeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamKeyRangeRequest.Merge(m, src)
}
func (m *StreamKeyRangeRequest) XXX_Size() int {
	return m.Size()
}
func (m *StreamKeyRangeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamKeyRangeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StreamKeyRangeRequest proto.InternalMessageInfo

func (m *StreamKeyRangeRequest) GetPosition() string {
	if m != nil {
		return m.Position
	}
	return ""
}

func (m *StreamKeyRangeRequest) GetKeyRange() *topodata.KeyRange {
	if m != nil {
		return m.KeyRange
	}
	return nil
}

func (m *StreamKeyRangeRequest) GetCharset() *Charset {
	if m != nil {
		return m.Charset
	}
	return nil
}

// StreamKeyRangeResponse is the response from StreamKeyRange
type StreamKeyRangeResponse struct {
	BinlogTransaction    *BinlogTransaction `protobuf:"bytes,1,opt,name=binlog_transaction,json=binlogTransaction,proto3" json:"binlog_transaction,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *StreamKeyRangeResponse) Reset()         { *m = StreamKeyRangeResponse{} }
func (m *StreamKeyRangeResponse) String() string { return proto.CompactTextString(m) }
func (*StreamKeyRangeResponse) ProtoMessage()    {}
func (*StreamKeyRangeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{3}
}
func (m *StreamKeyRangeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamKeyRangeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamKeyRangeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamKeyRangeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamKeyRangeResponse.Merge(m, src)
}
func (m *StreamKeyRangeResponse) XXX_Size() int {
	return m.Size()
}
func (m *StreamKeyRangeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamKeyRangeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StreamKeyRangeResponse proto.InternalMessageInfo

func (m *StreamKeyRangeResponse) GetBinlogTransaction() *BinlogTransaction {
	if m != nil {
		return m.BinlogTransaction
	}
	return nil
}

// StreamTablesRequest is the payload to StreamTables
type StreamTablesRequest struct {
	// where to start
	Position string `protobuf:"bytes,1,opt,name=position,proto3" json:"position,omitempty"`
	// what to get
	Tables []string `protobuf:"bytes,2,rep,name=tables,proto3" json:"tables,omitempty"`
	// default charset on the player side
	Charset              *Charset `protobuf:"bytes,3,opt,name=charset,proto3" json:"charset,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StreamTablesRequest) Reset()         { *m = StreamTablesRequest{} }
func (m *StreamTablesRequest) String() string { return proto.CompactTextString(m) }
func (*StreamTablesRequest) ProtoMessage()    {}
func (*StreamTablesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{4}
}
func (m *StreamTablesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamTablesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamTablesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamTablesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamTablesRequest.Merge(m, src)
}
func (m *StreamTablesRequest) XXX_Size() int {
	return m.Size()
}
func (m *StreamTablesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamTablesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StreamTablesRequest proto.InternalMessageInfo

func (m *StreamTablesRequest) GetPosition() string {
	if m != nil {
		return m.Position
	}
	return ""
}

func (m *StreamTablesRequest) GetTables() []string {
	if m != nil {
		return m.Tables
	}
	return nil
}

func (m *StreamTablesRequest) GetCharset() *Charset {
	if m != nil {
		return m.Charset
	}
	return nil
}

// StreamTablesResponse is the response from StreamTables
type StreamTablesResponse struct {
	BinlogTransaction    *BinlogTransaction `protobuf:"bytes,1,opt,name=binlog_transaction,json=binlogTransaction,proto3" json:"binlog_transaction,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *StreamTablesResponse) Reset()         { *m = StreamTablesResponse{} }
func (m *StreamTablesResponse) String() string { return proto.CompactTextString(m) }
func (*StreamTablesResponse) ProtoMessage()    {}
func (*StreamTablesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{5}
}
func (m *StreamTablesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamTablesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamTablesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamTablesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamTablesResponse.Merge(m, src)
}
func (m *StreamTablesResponse) XXX_Size() int {
	return m.Size()
}
func (m *StreamTablesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamTablesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StreamTablesResponse proto.InternalMessageInfo

func (m *StreamTablesResponse) GetBinlogTransaction() *BinlogTransaction {
	if m != nil {
		return m.BinlogTransaction
	}
	return nil
}

// Rule represents one rule in a Filter.
type Rule struct {
	// Match can be a table name or a regular expression.
	// If it starts with a '/', it's a regular expression.
	// For example, "t" matches a table named "t", whereas
	// "/t.*" matches all tables that begin with 't'.
	Match string `protobuf:"bytes,1,opt,name=match,proto3" json:"match,omitempty"`
	// Filter: If empty, all columns and rows of the matching tables
	// are sent. If it's a keyrange like "-80", only rows that
	// match the keyrange are sent.
	// If Match is a table name instead of a regular expression,
	// the Filter can also be a select expression like this:
	// "select * from t", same as an empty Filter, or
	// "select * from t where in_keyrange('-80')", same as "-80", or
	// "select col1, col2 from t where in_keyrange(col1, 'hash', '-80'), or
	// What is allowed in a select expression depends on whether
	// it's a vstreamer or vreplication request. For more details,
	// please refer to the specific package documentation.
	// On the vreplication side, Filter can also accept a special
	// "exclude" value, which will cause the matched tables
	// to be excluded.
	// TODO(sougou): support this on vstreamer side also.
	Filter               string   `protobuf:"bytes,2,opt,name=filter,proto3" json:"filter,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Rule) Reset()         { *m = Rule{} }
func (m *Rule) String() string { return proto.CompactTextString(m) }
func (*Rule) ProtoMessage()    {}
func (*Rule) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{6}
}
func (m *Rule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Rule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Rule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Rule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Rule.Merge(m, src)
}
func (m *Rule) XXX_Size() int {
	return m.Size()
}
func (m *Rule) XXX_DiscardUnknown() {
	xxx_messageInfo_Rule.DiscardUnknown(m)
}

var xxx_messageInfo_Rule proto.InternalMessageInfo

func (m *Rule) GetMatch() string {
	if m != nil {
		return m.Match
	}
	return ""
}

func (m *Rule) GetFilter() string {
	if m != nil {
		return m.Filter
	}
	return ""
}

// Filter represents a list of ordered rules. The first
// match wins.
type Filter struct {
	Rules []*Rule `protobuf:"bytes,1,rep,name=rules,proto3" json:"rules,omitempty"`
	// FieldEventMode specifies the behavior if there is a mismatch
	// between the current schema and the fields in the binlog. This
	// can happen if the binlog position is before a DDL that would
	// cause the fields to change. If vstreamer detects such
	// an inconsistency, the behavior depends on the FieldEventMode.
	// If the value is ERR_ON_MISMATCH (default), then it errors out.
	// If it's BEST_EFFORT, it sends a field event with fake column
	// names as "@1", "@2", etc.
	FieldEventMode       Filter_FieldEventMode `protobuf:"varint,2,opt,name=fieldEventMode,proto3,enum=binlogdata.Filter_FieldEventMode" json:"fieldEventMode,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *Filter) Reset()         { *m = Filter{} }
func (m *Filter) String() string { return proto.CompactTextString(m) }
func (*Filter) ProtoMessage()    {}
func (*Filter) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{7}
}
func (m *Filter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Filter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Filter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Filter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Filter.Merge(m, src)
}
func (m *Filter) XXX_Size() int {
	return m.Size()
}
func (m *Filter) XXX_DiscardUnknown() {
	xxx_messageInfo_Filter.DiscardUnknown(m)
}

var xxx_messageInfo_Filter proto.InternalMessageInfo

func (m *Filter) GetRules() []*Rule {
	if m != nil {
		return m.Rules
	}
	return nil
}

func (m *Filter) GetFieldEventMode() Filter_FieldEventMode {
	if m != nil {
		return m.FieldEventMode
	}
	return Filter_ERR_ON_MISMATCH
}

// BinlogSource specifies the source  and filter parameters for
// Filtered Replication. KeyRange and Tables are legacy. Filter
// is the new way to specify the filtering rules.
type BinlogSource struct {
	// the source keyspace
	Keyspace string `protobuf:"bytes,1,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	// the source shard
	Shard string `protobuf:"bytes,2,opt,name=shard,proto3" json:"shard,omitempty"`
	// the source tablet type
	TabletType topodata.TabletType `protobuf:"varint,3,opt,name=tablet_type,json=tabletType,proto3,enum=topodata.TabletType" json:"tablet_type,omitempty"`
	// KeyRange is set if the request is for a keyrange
	KeyRange *topodata.KeyRange `protobuf:"bytes,4,opt,name=key_range,json=keyRange,proto3" json:"key_range,omitempty"`
	// Tables is set if the request is for a list of tables
	Tables []string `protobuf:"bytes,5,rep,name=tables,proto3" json:"tables,omitempty"`
	// Filter is set if we're using the generalized representation
	// for the filter.
	Filter *Filter `protobuf:"bytes,6,opt,name=filter,proto3" json:"filter,omitempty"`
	// OnDdl specifies the action to be taken when a DDL is encountered.
	OnDdl OnDDLAction `protobuf:"varint,7,opt,name=on_ddl,json=onDdl,proto3,enum=binlogdata.OnDDLAction" json:"on_ddl,omitempty"`
	// Source is an external mysql. This attribute should be set to the username
	// to use in the connection
	ExternalMysql string `protobuf:"bytes,8,opt,name=external_mysql,json=externalMysql,proto3" json:"external_mysql,omitempty"`
	// StopAfterCopy specifies if vreplication should be stopped
	// after copying is done.
	StopAfterCopy bool `protobuf:"varint,9,opt,name=stop_after_copy,json=stopAfterCopy,proto3" json:"stop_after_copy,omitempty"`
	// ExternalCluster is the name of the mounted cluster which has the source keyspace/db for this workflow
	// it is of the type <cluster_type.cluster_name>
	ExternalCluster      string   `protobuf:"bytes,10,opt,name=external_cluster,json=externalCluster,proto3" json:"external_cluster,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BinlogSource) Reset()         { *m = BinlogSource{} }
func (m *BinlogSource) String() string { return proto.CompactTextString(m) }
func (*BinlogSource) ProtoMessage()    {}
func (*BinlogSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{8}
}
func (m *BinlogSource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BinlogSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BinlogSource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BinlogSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BinlogSource.Merge(m, src)
}
func (m *BinlogSource) XXX_Size() int {
	return m.Size()
}
func (m *BinlogSource) XXX_DiscardUnknown() {
	xxx_messageInfo_BinlogSource.DiscardUnknown(m)
}

var xxx_messageInfo_BinlogSource proto.InternalMessageInfo

func (m *BinlogSource) GetKeyspace() string {
	if m != nil {
		return m.Keyspace
	}
	return ""
}

func (m *BinlogSource) GetShard() string {
	if m != nil {
		return m.Shard
	}
	return ""
}

func (m *BinlogSource) GetTabletType() topodata.TabletType {
	if m != nil {
		return m.TabletType
	}
	return topodata.TabletType_UNKNOWN
}

func (m *BinlogSource) GetKeyRange() *topodata.KeyRange {
	if m != nil {
		return m.KeyRange
	}
	return nil
}

func (m *BinlogSource) GetTables() []string {
	if m != nil {
		return m.Tables
	}
	return nil
}

func (m *BinlogSource) GetFilter() *Filter {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *BinlogSource) GetOnDdl() OnDDLAction {
	if m != nil {
		return m.OnDdl
	}
	return OnDDLAction_IGNORE
}

func (m *BinlogSource) GetExternalMysql() string {
	if m != nil {
		return m.ExternalMysql
	}
	return ""
}

func (m *BinlogSource) GetStopAfterCopy() bool {
	if m != nil {
		return m.StopAfterCopy
	}
	return false
}

func (m *BinlogSource) GetExternalCluster() string {
	if m != nil {
		return m.ExternalCluster
	}
	return ""
}

// RowChange represents one row change.
// If Before is set and not After, it's a delete.
// If After is set and not Before, it's an insert.
// If both are set, it's an update.
type RowChange struct {
	Before               *query.Row `protobuf:"bytes,1,opt,name=before,proto3" json:"before,omitempty"`
	After                *query.Row `protobuf:"bytes,2,opt,name=after,proto3" json:"after,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *RowChange) Reset()         { *m = RowChange{} }
func (m *RowChange) String() string { return proto.CompactTextString(m) }
func (*RowChange) ProtoMessage()    {}
func (*RowChange) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{9}
}
func (m *RowChange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RowChange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RowChange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RowChange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RowChange.Merge(m, src)
}
func (m *RowChange) XXX_Size() int {
	return m.Size()
}
func (m *RowChange) XXX_DiscardUnknown() {
	xxx_messageInfo_RowChange.DiscardUnknown(m)
}

var xxx_messageInfo_RowChange proto.InternalMessageInfo

func (m *RowChange) GetBefore() *query.Row {
	if m != nil {
		return m.Before
	}
	return nil
}

func (m *RowChange) GetAfter() *query.Row {
	if m != nil {
		return m.After
	}
	return nil
}

// RowEvent represent row events for one table.
type RowEvent struct {
	TableName            string       `protobuf:"bytes,1,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	RowChanges           []*RowChange `protobuf:"bytes,2,rep,name=row_changes,json=rowChanges,proto3" json:"row_changes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *RowEvent) Reset()         { *m = RowEvent{} }
func (m *RowEvent) String() string { return proto.CompactTextString(m) }
func (*RowEvent) ProtoMessage()    {}
func (*RowEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{10}
}
func (m *RowEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RowEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RowEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RowEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RowEvent.Merge(m, src)
}
func (m *RowEvent) XXX_Size() int {
	return m.Size()
}
func (m *RowEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_RowEvent.DiscardUnknown(m)
}

var xxx_messageInfo_RowEvent proto.InternalMessageInfo

func (m *RowEvent) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *RowEvent) GetRowChanges() []*RowChange {
	if m != nil {
		return m.RowChanges
	}
	return nil
}

// FieldEvent represents the field info for a table.
type FieldEvent struct {
	TableName            string         `protobuf:"bytes,1,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	Fields               []*query.Field `protobuf:"bytes,2,rep,name=fields,proto3" json:"fields,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *FieldEvent) Reset()         { *m = FieldEvent{} }
func (m *FieldEvent) String() string { return proto.CompactTextString(m) }
func (*FieldEvent) ProtoMessage()    {}
func (*FieldEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{11}
}
func (m *FieldEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FieldEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FieldEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FieldEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FieldEvent.Merge(m, src)
}
func (m *FieldEvent) XXX_Size() int {
	return m.Size()
}
func (m *FieldEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_FieldEvent.DiscardUnknown(m)
}

var xxx_messageInfo_FieldEvent proto.InternalMessageInfo

func (m *FieldEvent) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *FieldEvent) GetFields() []*query.Field {
	if m != nil {
		return m.Fields
	}
	return nil
}

// ShardGtid contains the GTID position for one shard.
// It's used in a request for requesting a starting position.
// It's used in a response to transmit the current position
// of a shard. It's also used in a Journal to indicate the
// list of targets and shard positions to migrate to.
type ShardGtid struct {
	Keyspace             string         `protobuf:"bytes,1,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	Shard                string         `protobuf:"bytes,2,opt,name=shard,proto3" json:"shard,omitempty"`
	Gtid                 string         `protobuf:"bytes,3,opt,name=gtid,proto3" json:"gtid,omitempty"`
	TablePKs             []*TableLastPK `protobuf:"bytes,4,rep,name=table_p_ks,json=tablePKs,proto3" json:"table_p_ks,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ShardGtid) Reset()         { *m = ShardGtid{} }
func (m *ShardGtid) String() string { return proto.CompactTextString(m) }
func (*ShardGtid) ProtoMessage()    {}
func (*ShardGtid) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{12}
}
func (m *ShardGtid) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardGtid) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardGtid.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardGtid) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardGtid.Merge(m, src)
}
func (m *ShardGtid) XXX_Size() int {
	return m.Size()
}
func (m *ShardGtid) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardGtid.DiscardUnknown(m)
}

var xxx_messageInfo_ShardGtid proto.InternalMessageInfo

func (m *ShardGtid) GetKeyspace() string {
	if m != nil {
		return m.Keyspace
	}
	return ""
}

func (m *ShardGtid) GetShard() string {
	if m != nil {
		return m.Shard
	}
	return ""
}

func (m *ShardGtid) GetGtid() string {
	if m != nil {
		return m.Gtid
	}
	return ""
}

func (m *ShardGtid) GetTablePKs() []*TableLastPK {
	if m != nil {
		return m.TablePKs
	}
	return nil
}

// A VGtid is a list of ShardGtids.
type VGtid struct {
	ShardGtids           []*ShardGtid `protobuf:"bytes,1,rep,name=shard_gtids,json=shardGtids,proto3" json:"shard_gtids,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *VGtid) Reset()         { *m = VGtid{} }
func (m *VGtid) String() string { return proto.CompactTextString(m) }
func (*VGtid) ProtoMessage()    {}
func (*VGtid) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{13}
}
func (m *VGtid) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VGtid) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VGtid.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VGtid) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VGtid.Merge(m, src)
}
func (m *VGtid) XXX_Size() int {
	return m.Size()
}
func (m *VGtid) XXX_DiscardUnknown() {
	xxx_messageInfo_VGtid.DiscardUnknown(m)
}

var xxx_messageInfo_VGtid proto.InternalMessageInfo

func (m *VGtid) GetShardGtids() []*ShardGtid {
	if m != nil {
		return m.ShardGtids
	}
	return nil
}

// KeyspaceShard represents a keyspace and shard.
type KeyspaceShard struct {
	Keyspace             string   `protobuf:"bytes,1,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	Shard                string   `protobuf:"bytes,2,opt,name=shard,proto3" json:"shard,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KeyspaceShard) Reset()         { *m = KeyspaceShard{} }
func (m *KeyspaceShard) String() string { return proto.CompactTextString(m) }
func (*KeyspaceShard) ProtoMessage()    {}
func (*KeyspaceShard) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{14}
}
func (m *KeyspaceShard) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyspaceShard) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyspaceShard.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyspaceShard) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyspaceShard.Merge(m, src)
}
func (m *KeyspaceShard) XXX_Size() int {
	return m.Size()
}
func (m *KeyspaceShard) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyspaceShard.DiscardUnknown(m)
}

var xxx_messageInfo_KeyspaceShard proto.InternalMessageInfo

func (m *KeyspaceShard) GetKeyspace() string {
	if m != nil {
		return m.Keyspace
	}
	return ""
}

func (m *KeyspaceShard) GetShard() string {
	if m != nil {
		return m.Shard
	}
	return ""
}

// Journal contains the metadata for a journal event.
// The commit of a journal event indicates the point of no return
// for a migration.
type Journal struct {
	// Id represents a unique journal id.
	Id            int64         `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	MigrationType MigrationType `protobuf:"varint,2,opt,name=migration_type,json=migrationType,proto3,enum=binlogdata.MigrationType" json:"migration_type,omitempty"`
	// Tables is set if the journal represents a TABLES migration.
	Tables []string `protobuf:"bytes,3,rep,name=tables,proto3" json:"tables,omitempty"`
	// LocalPosition is the source position at which the migration happened.
	LocalPosition string `protobuf:"bytes,4,opt,name=local_position,json=localPosition,proto3" json:"local_position,omitempty"`
	// ShardGtids is the list of targets to which the migration took place.
	ShardGtids []*ShardGtid `protobuf:"bytes,5,rep,name=shard_gtids,json=shardGtids,proto3" json:"shard_gtids,omitempty"`
	// Participants is the list of source participants for a migration.
	// Every participant is expected to have an identical journal entry.
	// While streaming, the client must wait for the journal entry to
	// be received from all pariticipants, and then replace them with new
	// streams specified by ShardGtid.
	// If a stream does not have all participants, a consistent migration
	// is not possible.
	Participants []*KeyspaceShard `protobuf:"bytes,6,rep,name=participants,proto3" json:"participants,omitempty"`
	// SourceWorkflows is the list of workflows in the source shard that
	// were migrated to the target. If a migration fails after a Journal
	// is committed, this information is used to start the target streams
	// that were created prior to the creation of the journal.
	SourceWorkflows      []string `protobuf:"bytes,7,rep,name=source_workflows,json=sourceWorkflows,proto3" json:"source_workflows,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Journal) Reset()         { *m = Journal{} }
func (m *Journal) String() string { return proto.CompactTextString(m) }
func (*Journal) ProtoMessage()    {}
func (*Journal) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{15}
}
func (m *Journal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Journal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Journal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Journal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Journal.Merge(m, src)
}
func (m *Journal) XXX_Size() int {
	return m.Size()
}
func (m *Journal) XXX_DiscardUnknown() {
	xxx_messageInfo_Journal.DiscardUnknown(m)
}

var xxx_messageInfo_Journal proto.InternalMessageInfo

func (m *Journal) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Journal) GetMigrationType() MigrationType {
	if m != nil {
		return m.MigrationType
	}
	return MigrationType_TABLES
}

func (m *Journal) GetTables() []string {
	if m != nil {
		return m.Tables
	}
	return nil
}

func (m *Journal) GetLocalPosition() string {
	if m != nil {
		return m.LocalPosition
	}
	return ""
}

func (m *Journal) GetShardGtids() []*ShardGtid {
	if m != nil {
		return m.ShardGtids
	}
	return nil
}

func (m *Journal) GetParticipants() []*KeyspaceShard {
	if m != nil {
		return m.Participants
	}
	return nil
}

func (m *Journal) GetSourceWorkflows() []string {
	if m != nil {
		return m.SourceWorkflows
	}
	return nil
}

// VEvent represents a vstream event.
// A FieldEvent is sent once for every table, just before
// the first event for that table. The client is expected
// to cache this information and match it against the RowEvent
// which contains the table name.
// A GTID event always precedes a commitable event, which can be
// COMMIT, DDL or OTHER.
// OTHER events are non-material events that have no additional metadata.
type VEvent struct {
	Type VEventType `protobuf:"varint,1,opt,name=type,proto3,enum=binlogdata.VEventType" json:"type,omitempty"`
	// Timestamp is the binlog timestamp in seconds.
	// The value should be ignored if 0.
	Timestamp int64 `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Gtid is set if the event type is GTID.
	Gtid string `protobuf:"bytes,3,opt,name=gtid,proto3" json:"gtid,omitempty"`
	// Statement is set if the event type is DDL, DML or SAVEPOINT.
	Statement string `protobuf:"bytes,4,opt,name=statement,proto3" json:"statement,omitempty"`
	// RowEvent is set if the event type is ROW.
	RowEvent *RowEvent `protobuf:"bytes,5,opt,name=row_event,json=rowEvent,proto3" json:"row_event,omitempty"`
	// FieldEvent is set if the event type is FIELD.
	FieldEvent *FieldEvent `protobuf:"bytes,6,opt,name=field_event,json=fieldEvent,proto3" json:"field_event,omitempty"`
	// Vgtid is set if the event type is VGTID.
	// This event is only generated by VTGate's VStream function.
	Vgtid *VGtid `protobuf:"bytes,7,opt,name=vgtid,proto3" json:"vgtid,omitempty"`
	// Journal is set if the event type is JOURNAL.
	Journal *Journal `protobuf:"bytes,8,opt,name=journal,proto3" json:"journal,omitempty"`
	// Dml is set if the event type is INSERT, REPLACE, UPDATE or DELETE.
	Dml string `protobuf:"bytes,9,opt,name=dml,proto3" json:"dml,omitempty"`
	// CurrentTime specifies the current time when the message was sent.
	// This can be used to compenssate for clock skew.
	CurrentTime int64 `protobuf:"varint,20,opt,name=current_time,json=currentTime,proto3" json:"current_time,omitempty"`
	// LastPK is the last PK for a table
	LastPKEvent          *LastPKEvent `protobuf:"bytes,21,opt,name=last_p_k_event,json=lastPKEvent,proto3" json:"last_p_k_event,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *VEvent) Reset()         { *m = VEvent{} }
func (m *VEvent) String() string { return proto.CompactTextString(m) }
func (*VEvent) ProtoMessage()    {}
func (*VEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{16}
}
func (m *VEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VEvent.Merge(m, src)
}
func (m *VEvent) XXX_Size() int {
	return m.Size()
}
func (m *VEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_VEvent.DiscardUnknown(m)
}

var xxx_messageInfo_VEvent proto.InternalMessageInfo

func (m *VEvent) GetType() VEventType {
	if m != nil {
		return m.Type
	}
	return VEventType_UNKNOWN
}

func (m *VEvent) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *VEvent) GetGtid() string {
	if m != nil {
		return m.Gtid
	}
	return ""
}

func (m *VEvent) GetStatement() string {
	if m != nil {
		return m.Statement
	}
	return ""
}

func (m *VEvent) GetRowEvent() *RowEvent {
	if m != nil {
		return m.RowEvent
	}
	return nil
}

func (m *VEvent) GetFieldEvent() *FieldEvent {
	if m != nil {
		return m.FieldEvent
	}
	return nil
}

func (m *VEvent) GetVgtid() *VGtid {
	if m != nil {
		return m.Vgtid
	}
	return nil
}

func (m *VEvent) GetJournal() *Journal {
	if m != nil {
		return m.Journal
	}
	return nil
}

func (m *VEvent) GetDml() string {
	if m != nil {
		return m.Dml
	}
	return ""
}

func (m *VEvent) GetCurrentTime() int64 {
	if m != nil {
		return m.CurrentTime
	}
	return 0
}

func (m *VEvent) GetLastPKEvent() *LastPKEvent {
	if m != nil {
		return m.LastPKEvent
	}
	return nil
}

type MinimalTable struct {
	Name                 string         `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Fields               []*query.Field `protobuf:"bytes,2,rep,name=fields,proto3" json:"fields,omitempty"`
	PKColumns            []int64        `protobuf:"varint,3,rep,packed,name=p_k_columns,json=pKColumns,proto3" json:"p_k_columns,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *MinimalTable) Reset()         { *m = MinimalTable{} }
func (m *MinimalTable) String() string { return proto.CompactTextString(m) }
func (*MinimalTable) ProtoMessage()    {}
func (*MinimalTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{17}
}
func (m *MinimalTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MinimalTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MinimalTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MinimalTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MinimalTable.Merge(m, src)
}
func (m *MinimalTable) XXX_Size() int {
	return m.Size()
}
func (m *MinimalTable) XXX_DiscardUnknown() {
	xxx_messageInfo_MinimalTable.DiscardUnknown(m)
}

var xxx_messageInfo_MinimalTable proto.InternalMessageInfo

func (m *MinimalTable) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MinimalTable) GetFields() []*query.Field {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *MinimalTable) GetPKColumns() []int64 {
	if m != nil {
		return m.PKColumns
	}
	return nil
}

type MinimalSchema struct {
	Tables               []*MinimalTable `protobuf:"bytes,1,rep,name=tables,proto3" json:"tables,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *MinimalSchema) Reset()         { *m = MinimalSchema{} }
func (m *MinimalSchema) String() string { return proto.CompactTextString(m) }
func (*MinimalSchema) ProtoMessage()    {}
func (*MinimalSchema) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{18}
}
func (m *MinimalSchema) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MinimalSchema) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MinimalSchema.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MinimalSchema) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MinimalSchema.Merge(m, src)
}
func (m *MinimalSchema) XXX_Size() int {
	return m.Size()
}
func (m *MinimalSchema) XXX_DiscardUnknown() {
	xxx_messageInfo_MinimalSchema.DiscardUnknown(m)
}

var xxx_messageInfo_MinimalSchema proto.InternalMessageInfo

func (m *MinimalSchema) GetTables() []*MinimalTable {
	if m != nil {
		return m.Tables
	}
	return nil
}

// VStreamRequest is the payload for VStreamer
type VStreamRequest struct {
	EffectiveCallerId    *vtrpc.CallerID       `protobuf:"bytes,1,opt,name=effective_caller_id,json=effectiveCallerId,proto3" json:"effective_caller_id,omitempty"`
	ImmediateCallerId    *query.VTGateCallerID `protobuf:"bytes,2,opt,name=immediate_caller_id,json=immediateCallerId,proto3" json:"immediate_caller_id,omitempty"`
	Target               *query.Target         `protobuf:"bytes,3,opt,name=target,proto3" json:"target,omitempty"`
	Position             string                `protobuf:"bytes,4,opt,name=position,proto3" json:"position,omitempty"`
	Filter               *Filter               `protobuf:"bytes,5,opt,name=filter,proto3" json:"filter,omitempty"`
	TableLastPKs         []*TableLastPK        `protobuf:"bytes,6,rep,name=table_last_p_ks,json=tableLastPKs,proto3" json:"table_last_p_ks,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *VStreamRequest) Reset()         { *m = VStreamRequest{} }
func (m *VStreamRequest) String() string { return proto.CompactTextString(m) }
func (*VStreamRequest) ProtoMessage()    {}
func (*VStreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{19}
}
func (m *VStreamRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VStreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VStreamRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VStreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VStreamRequest.Merge(m, src)
}
func (m *VStreamRequest) XXX_Size() int {
	return m.Size()
}
func (m *VStreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VStreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VStreamRequest proto.InternalMessageInfo

func (m *VStreamRequest) GetEffectiveCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.EffectiveCallerId
	}
	return nil
}

func (m *VStreamRequest) GetImmediateCallerId() *query.VTGateCallerID {
	if m != nil {
		return m.ImmediateCallerId
	}
	return nil
}

func (m *VStreamRequest) GetTarget() *query.Target {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *VStreamRequest) GetPosition() string {
	if m != nil {
		return m.Position
	}
	return ""
}

func (m *VStreamRequest) GetFilter() *Filter {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *VStreamRequest) GetTableLastPKs() []*TableLastPK {
	if m != nil {
		return m.TableLastPKs
	}
	return nil
}

// VStreamResponse is the response from VStreamer
type VStreamResponse struct {
	Events               []*VEvent `protobuf:"bytes,1,rep,name=events,proto3" json:"events,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *VStreamResponse) Reset()         { *m = VStreamResponse{} }
func (m *VStreamResponse) String() string { return proto.CompactTextString(m) }
func (*VStreamResponse) ProtoMessage()    {}
func (*VStreamResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{20}
}
func (m *VStreamResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VStreamResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VStreamResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VStreamResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VStreamResponse.Merge(m, src)
}
func (m *VStreamResponse) XXX_Size() int {
	return m.Size()
}
func (m *VStreamResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VStreamResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VStreamResponse proto.InternalMessageInfo

func (m *VStreamResponse) GetEvents() []*VEvent {
	if m != nil {
		return m.Events
	}
	return nil
}

// VStreamRowsRequest is the payload for VStreamRows
type VStreamRowsRequest struct {
	EffectiveCallerId    *vtrpc.CallerID       `protobuf:"bytes,1,opt,name=effective_caller_id,json=effectiveCallerId,proto3" json:"effective_caller_id,omitempty"`
	ImmediateCallerId    *query.VTGateCallerID `protobuf:"bytes,2,opt,name=immediate_caller_id,json=immediateCallerId,proto3" json:"immediate_caller_id,omitempty"`
	Target               *query.Target         `protobuf:"bytes,3,opt,name=target,proto3" json:"target,omitempty"`
	Query                string                `protobuf:"bytes,4,opt,name=query,proto3" json:"query,omitempty"`
	Lastpk               *query.QueryResult    `protobuf:"bytes,5,opt,name=lastpk,proto3" json:"lastpk,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *VStreamRowsRequest) Reset()         { *m = VStreamRowsRequest{} }
func (m *VStreamRowsRequest) String() string { return proto.CompactTextString(m) }
func (*VStreamRowsRequest) ProtoMessage()    {}
func (*VStreamRowsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{21}
}
func (m *VStreamRowsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VStreamRowsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VStreamRowsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VStreamRowsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VStreamRowsRequest.Merge(m, src)
}
func (m *VStreamRowsRequest) XXX_Size() int {
	return m.Size()
}
func (m *VStreamRowsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VStreamRowsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VStreamRowsRequest proto.InternalMessageInfo

func (m *VStreamRowsRequest) GetEffectiveCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.EffectiveCallerId
	}
	return nil
}

func (m *VStreamRowsRequest) GetImmediateCallerId() *query.VTGateCallerID {
	if m != nil {
		return m.ImmediateCallerId
	}
	return nil
}

func (m *VStreamRowsRequest) GetTarget() *query.Target {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *VStreamRowsRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *VStreamRowsRequest) GetLastpk() *query.QueryResult {
	if m != nil {
		return m.Lastpk
	}
	return nil
}

// VStreamRowsResponse is the response from VStreamRows
type VStreamRowsResponse struct {
	Fields               []*query.Field `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"`
	Pkfields             []*query.Field `protobuf:"bytes,2,rep,name=pkfields,proto3" json:"pkfields,omitempty"`
	Gtid                 string         `protobuf:"bytes,3,opt,name=gtid,proto3" json:"gtid,omitempty"`
	Rows                 []*query.Row   `protobuf:"bytes,4,rep,name=rows,proto3" json:"rows,omitempty"`
	Lastpk               *query.Row     `protobuf:"bytes,5,opt,name=lastpk,proto3" json:"lastpk,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *VStreamRowsResponse) Reset()         { *m = VStreamRowsResponse{} }
func (m *VStreamRowsResponse) String() string { return proto.CompactTextString(m) }
func (*VStreamRowsResponse) ProtoMessage()    {}
func (*VStreamRowsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{22}
}
func (m *VStreamRowsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VStreamRowsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VStreamRowsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VStreamRowsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VStreamRowsResponse.Merge(m, src)
}
func (m *VStreamRowsResponse) XXX_Size() int {
	return m.Size()
}
func (m *VStreamRowsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VStreamRowsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VStreamRowsResponse proto.InternalMessageInfo

func (m *VStreamRowsResponse) GetFields() []*query.Field {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *VStreamRowsResponse) GetPkfields() []*query.Field {
	if m != nil {
		return m.Pkfields
	}
	return nil
}

func (m *VStreamRowsResponse) GetGtid() string {
	if m != nil {
		return m.Gtid
	}
	return ""
}

func (m *VStreamRowsResponse) GetRows() []*query.Row {
	if m != nil {
		return m.Rows
	}
	return nil
}

func (m *VStreamRowsResponse) GetLastpk() *query.Row {
	if m != nil {
		return m.Lastpk
	}
	return nil
}

type LastPKEvent struct {
	TableLastPK          *TableLastPK `protobuf:"bytes,1,opt,name=table_last_p_k,json=tableLastPK,proto3" json:"table_last_p_k,omitempty"`
	Completed            bool         `protobuf:"varint,2,opt,name=completed,proto3" json:"completed,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *LastPKEvent) Reset()         { *m = LastPKEvent{} }
func (m *LastPKEvent) String() string { return proto.CompactTextString(m) }
func (*LastPKEvent) ProtoMessage()    {}
func (*LastPKEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{23}
}
func (m *LastPKEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LastPKEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LastPKEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LastPKEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LastPKEvent.Merge(m, src)
}
func (m *LastPKEvent) XXX_Size() int {
	return m.Size()
}
func (m *LastPKEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_LastPKEvent.DiscardUnknown(m)
}

var xxx_messageInfo_LastPKEvent proto.InternalMessageInfo

func (m *LastPKEvent) GetTableLastPK() *TableLastPK {
	if m != nil {
		return m.TableLastPK
	}
	return nil
}

func (m *LastPKEvent) GetCompleted() bool {
	if m != nil {
		return m.Completed
	}
	return false
}

type TableLastPK struct {
	TableName            string             `protobuf:"bytes,1,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	Lastpk               *query.QueryResult `protobuf:"bytes,3,opt,name=lastpk,proto3" json:"lastpk,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *TableLastPK) Reset()         { *m = TableLastPK{} }
func (m *TableLastPK) String() string { return proto.CompactTextString(m) }
func (*TableLastPK) ProtoMessage()    {}
func (*TableLastPK) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{24}
}
func (m *TableLastPK) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableLastPK) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableLastPK.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableLastPK) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableLastPK.Merge(m, src)
}
func (m *TableLastPK) XXX_Size() int {
	return m.Size()
}
func (m *TableLastPK) XXX_DiscardUnknown() {
	xxx_messageInfo_TableLastPK.DiscardUnknown(m)
}

var xxx_messageInfo_TableLastPK proto.InternalMessageInfo

func (m *TableLastPK) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *TableLastPK) GetLastpk() *query.QueryResult {
	if m != nil {
		return m.Lastpk
	}
	return nil
}

// VStreamResultsRequest is the payload for VStreamResults
// The ids match VStreamRows, in case we decide to merge the two.
// The ids match VStreamRows, in case we decide to merge the two.
type VStreamResultsRequest struct {
	EffectiveCallerId    *vtrpc.CallerID       `protobuf:"bytes,1,opt,name=effective_caller_id,json=effectiveCallerId,proto3" json:"effective_caller_id,omitempty"`
	ImmediateCallerId    *query.VTGateCallerID `protobuf:"bytes,2,opt,name=immediate_caller_id,json=immediateCallerId,proto3" json:"immediate_caller_id,omitempty"`
	Target               *query.Target         `protobuf:"bytes,3,opt,name=target,proto3" json:"target,omitempty"`
	Query                string                `protobuf:"bytes,4,opt,name=query,proto3" json:"query,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *VStreamResultsRequest) Reset()         { *m = VStreamResultsRequest{} }
func (m *VStreamResultsRequest) String() string { return proto.CompactTextString(m) }
func (*VStreamResultsRequest) ProtoMessage()    {}
func (*VStreamResultsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{25}
}
func (m *VStreamResultsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VStreamResultsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VStreamResultsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VStreamResultsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VStreamResultsRequest.Merge(m, src)
}
func (m *VStreamResultsRequest) XXX_Size() int {
	return m.Size()
}
func (m *VStreamResultsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VStreamResultsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VStreamResultsRequest proto.InternalMessageInfo

func (m *VStreamResultsRequest) GetEffectiveCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.EffectiveCallerId
	}
	return nil
}

func (m *VStreamResultsRequest) GetImmediateCallerId() *query.VTGateCallerID {
	if m != nil {
		return m.ImmediateCallerId
	}
	return nil
}

func (m *VStreamResultsRequest) GetTarget() *query.Target {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *VStreamResultsRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

// VStreamResultsResponse is the response from VStreamResults
// The ids match VStreamRows, in case we decide to merge the two.
type VStreamResultsResponse struct {
	Fields               []*query.Field `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"`
	Gtid                 string         `protobuf:"bytes,3,opt,name=gtid,proto3" json:"gtid,omitempty"`
	Rows                 []*query.Row   `protobuf:"bytes,4,rep,name=rows,proto3" json:"rows,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *VStreamResultsResponse) Reset()         { *m = VStreamResultsResponse{} }
func (m *VStreamResultsResponse) String() string { return proto.CompactTextString(m) }
func (*VStreamResultsResponse) ProtoMessage()    {}
func (*VStreamResultsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{26}
}
func (m *VStreamResultsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VStreamResultsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VStreamResultsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VStreamResultsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VStreamResultsResponse.Merge(m, src)
}
func (m *VStreamResultsResponse) XXX_Size() int {
	return m.Size()
}
func (m *VStreamResultsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VStreamResultsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VStreamResultsResponse proto.InternalMessageInfo

func (m *VStreamResultsResponse) GetFields() []*query.Field {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *VStreamResultsResponse) GetGtid() string {
	if m != nil {
		return m.Gtid
	}
	return ""
}

func (m *VStreamResultsResponse) GetRows() []*query.Row {
	if m != nil {
		return m.Rows
	}
	return nil
}

func init() {
	proto.RegisterEnum("binlogdata.OnDDLAction", OnDDLAction_name, OnDDLAction_value)
	proto.RegisterEnum("binlogdata.VEventType", VEventType_name, VEventType_value)
	proto.RegisterEnum("binlogdata.MigrationType", MigrationType_name, MigrationType_value)
	proto.RegisterEnum("binlogdata.BinlogTransaction_Statement_Category", BinlogTransaction_Statement_Category_name, BinlogTransaction_Statement_Category_value)
	proto.RegisterEnum("binlogdata.Filter_FieldEventMode", Filter_FieldEventMode_name, Filter_FieldEventMode_value)
	proto.RegisterType((*Charset)(nil), "binlogdata.Charset")
	proto.RegisterType((*BinlogTransaction)(nil), "binlogdata.BinlogTransaction")
	proto.RegisterType((*BinlogTransaction_Statement)(nil), "binlogdata.BinlogTransaction.Statement")
	proto.RegisterType((*StreamKeyRangeRequest)(nil), "binlogdata.StreamKeyRangeRequest")
	proto.RegisterType((*StreamKeyRangeResponse)(nil), "binlogdata.StreamKeyRangeResponse")
	proto.RegisterType((*StreamTablesRequest)(nil), "binlogdata.StreamTablesRequest")
	proto.RegisterType((*StreamTablesResponse)(nil), "binlogdata.StreamTablesResponse")
	proto.RegisterType((*Rule)(nil), "binlogdata.Rule")
	proto.RegisterType((*Filter)(nil), "binlogdata.Filter")
	proto.RegisterType((*BinlogSource)(nil), "binlogdata.BinlogSource")
	proto.RegisterType((*RowChange)(nil), "binlogdata.RowChange")
	proto.RegisterType((*RowEvent)(nil), "binlogdata.RowEvent")
	proto.RegisterType((*FieldEvent)(nil), "binlogdata.FieldEvent")
	proto.RegisterType((*ShardGtid)(nil), "binlogdata.ShardGtid")
	proto.RegisterType((*VGtid)(nil), "binlogdata.VGtid")
	proto.RegisterType((*KeyspaceShard)(nil), "binlogdata.KeyspaceShard")
	proto.RegisterType((*Journal)(nil), "binlogdata.Journal")
	proto.RegisterType((*VEvent)(nil), "binlogdata.VEvent")
	proto.RegisterType((*MinimalTable)(nil), "binlogdata.MinimalTable")
	proto.RegisterType((*MinimalSchema)(nil), "binlogdata.MinimalSchema")
	proto.RegisterType((*VStreamRequest)(nil), "binlogdata.VStreamRequest")
	proto.RegisterType((*VStreamResponse)(nil), "binlogdata.VStreamResponse")
	proto.RegisterType((*VStreamRowsRequest)(nil), "binlogdata.VStreamRowsRequest")
	proto.RegisterType((*VStreamRowsResponse)(nil), "binlogdata.VStreamRowsResponse")
	proto.RegisterType((*LastPKEvent)(nil), "binlogdata.LastPKEvent")
	proto.RegisterType((*TableLastPK)(nil), "binlogdata.TableLastPK")
	proto.RegisterType((*VStreamResultsRequest)(nil), "binlogdata.VStreamResultsRequest")
	proto.RegisterType((*VStreamResultsResponse)(nil), "binlogdata.VStreamResultsResponse")
}

func init() { proto.RegisterFile("binlogdata.proto", fileDescriptor_5fd02bcb2e350dad) }

var fileDescriptor_5fd02bcb2e350dad = []byte{
	// 1955 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x58, 0x4b, 0x6f, 0x23, 0x59,
	0x15, 0xee, 0xf2, 0xdb, 0xa7, 0x1c, 0xa7, 0x72, 0xf3, 0xc0, 0xb4, 0x66, 0xa2, 0x4c, 0x89, 0x99,
	0x0e, 0x91, 0x70, 0x06, 0xc3, 0x34, 0x42, 0x62, 0x66, 0xf0, 0xa3, 0x3a, 0xed, 0x8e, 0x1f, 0xe9,
	0xeb, 0xea, 0xf4, 0x68, 0x36, 0xa5, 0x4a, 0xf9, 0x26, 0x29, 0x52, 0x76, 0xb9, 0xab, 0xae, 0x93,
	0xf1, 0x0f, 0x40, 0x62, 0x8f, 0x84, 0xf8, 0x0b, 0xac, 0x59, 0x02, 0x5b, 0x60, 0xc9, 0x0f, 0x60,
	0x81, 0x1a, 0xf1, 0x23, 0xd8, 0xa1, 0xfb, 0xa8, 0x57, 0x7a, 0xa6, 0x93, 0x1e, 0x89, 0x05, 0x6c,
	0xac, 0x7b, 0xcf, 0x3d, 0xe7, 0xdc, 0xf3, 0xfa, 0x4e, 0x1d, 0x5f, 0xd0, 0xce, 0xdc, 0xb9, 0xe7,
	0x5f, 0x4c, 0x6d, 0x6a, 0x37, 0x17, 0x81, 0x4f, 0x7d, 0x04, 0x09, 0xe5, 0xa1, 0x7a, 0x4d, 0x83,
	0x85, 0x23, 0x0e, 0x1e, 0xaa, 0xaf, 0x96, 0x24, 0x58, 0xc9, 0x4d, 0x9d, 0xfa, 0x0b, 0x3f, 0x91,
	0xd2, 0x87, 0x50, 0xee, 0x5e, 0xda, 0x41, 0x48, 0x28, 0xda, 0x81, 0x92, 0xe3, 0xb9, 0x64, 0x4e,
	0x1b, 0xca, 0x9e, 0xb2, 0x5f, 0xc4, 0x72, 0x87, 0x10, 0x14, 0x1c, 0x7f, 0x3e, 0x6f, 0xe4, 0x38,
	0x95, 0xaf, 0x19, 0x6f, 0x48, 0x82, 0x6b, 0x12, 0x34, 0xf2, 0x82, 0x57, 0xec, 0xf4, 0x7f, 0xe5,
	0x61, 0xa3, 0xc3, 0xed, 0x30, 0x03, 0x7b, 0x1e, 0xda, 0x0e, 0x75, 0xfd, 0x39, 0x3a, 0x02, 0x08,
	0xa9, 0x4d, 0xc9, 0x8c, 0xcc, 0x69, 0xd8, 0x50, 0xf6, 0xf2, 0xfb, 0x6a, 0xeb, 0x51, 0x33, 0xe5,
	0xc1, 0x1b, 0x22, 0xcd, 0x49, 0xc4, 0x8f, 0x53, 0xa2, 0xa8, 0x05, 0x2a, 0xb9, 0x26, 0x73, 0x6a,
	0x51, 0xff, 0x8a, 0xcc, 0x1b, 0x85, 0x3d, 0x65, 0x5f, 0x6d, 0x6d, 0x34, 0x85, 0x83, 0x06, 0x3b,
	0x31, 0xd9, 0x01, 0x06, 0x12, 0xaf, 0x1f, 0xfe, 0x39, 0x07, 0xd5, 0x58, 0x1b, 0x1a, 0x40, 0xc5,
	0xb1, 0x29, 0xb9, 0xf0, 0x83, 0x15, 0x77, 0xb3, 0xde, 0xfa, 0xf8, 0x9e, 0x86, 0x34, 0xbb, 0x52,
	0x0e, 0xc7, 0x1a, 0xd0, 0x0f, 0xa0, 0xec, 0x88, 0xe8, 0xf1, 0xe8, 0xa8, 0xad, 0xcd, 0xb4, 0x32,
	0x19, 0x58, 0x1c, 0xf1, 0x20, 0x0d, 0xf2, 0xe1, 0x2b, 0x8f, 0x87, 0xac, 0x86, 0xd9, 0x52, 0xff,
	0x9d, 0x02, 0x95, 0x48, 0x2f, 0xda, 0x84, 0xf5, 0xce, 0xc0, 0x7a, 0x31, 0xc2, 0x46, 0x77, 0x7c,
	0x34, 0xea, 0x7f, 0x69, 0xf4, 0xb4, 0x07, 0xa8, 0x06, 0x95, 0xce, 0xc0, 0xea, 0x18, 0x47, 0xfd,
	0x91, 0xa6, 0xa0, 0x35, 0xa8, 0x76, 0x06, 0x56, 0x77, 0x3c, 0x1c, 0xf6, 0x4d, 0x2d, 0x87, 0xd6,
	0x41, 0xed, 0x0c, 0x2c, 0x3c, 0x1e, 0x0c, 0x3a, 0xed, 0xee, 0xb1, 0x96, 0x47, 0xdb, 0xb0, 0xd1,
	0x19, 0x58, 0xbd, 0xe1, 0xc0, 0xea, 0x19, 0x27, 0xd8, 0xe8, 0xb6, 0x4d, 0xa3, 0xa7, 0x15, 0x10,
	0x40, 0x89, 0x91, 0x7b, 0x03, 0xad, 0x28, 0xd7, 0x13, 0xc3, 0xd4, 0x4a, 0x52, 0x5d, 0x7f, 0x34,
	0x31, 0xb0, 0xa9, 0x95, 0xe5, 0xf6, 0xc5, 0x49, 0xaf, 0x6d, 0x1a, 0x5a, 0x45, 0x6e, 0x7b, 0xc6,
	0xc0, 0x30, 0x0d, 0xad, 0xfa, 0xac, 0x50, 0xc9, 0x69, 0xf9, 0x67, 0x85, 0x4a, 0x5e, 0x2b, 0xe8,
	0xbf, 0x56, 0x60, 0x7b, 0x42, 0x03, 0x62, 0xcf, 0x8e, 0xc9, 0x0a, 0xdb, 0xf3, 0x0b, 0x82, 0xc9,
	0xab, 0x25, 0x09, 0x29, 0x7a, 0x08, 0x95, 0x85, 0x1f, 0xba, 0x2c, 0x76, 0x3c, 0xc0, 0x55, 0x1c,
	0xef, 0xd1, 0x21, 0x54, 0xaf, 0xc8, 0xca, 0x0a, 0x18, 0xbf, 0x0c, 0x18, 0x6a, 0xc6, 0x05, 0x19,
	0x6b, 0xaa, 0x5c, 0xc9, 0x55, 0x3a, 0xbe, 0xf9, 0xbb, 0xe3, 0xab, 0x9f, 0xc3, 0xce, 0x6d, 0xa3,
	0xc2, 0x85, 0x3f, 0x0f, 0x09, 0x1a, 0x00, 0x12, 0x82, 0x16, 0x4d, 0x72, 0xcb, 0xed, 0x53, 0x5b,
	0xef, 0xbf, 0xb5, 0x00, 0xf0, 0xc6, 0xd9, 0x6d, 0x92, 0xfe, 0x15, 0x6c, 0x8a, 0x7b, 0x4c, 0xfb,
	0xcc, 0x23, 0xe1, 0x7d, 0x5c, 0xdf, 0x81, 0x12, 0xe5, 0xcc, 0x8d, 0xdc, 0x5e, 0x7e, 0xbf, 0x8a,
	0xe5, 0xee, 0x5d, 0x3d, 0x9c, 0xc2, 0x56, 0xf6, 0xe6, 0xff, 0x8a, 0x7f, 0x3f, 0x86, 0x02, 0x5e,
	0x7a, 0x04, 0x6d, 0x41, 0x71, 0x66, 0x53, 0xe7, 0x52, 0x7a, 0x23, 0x36, 0xcc, 0x95, 0x73, 0xd7,
	0xa3, 0x24, 0xe0, 0x29, 0xac, 0x62, 0xb9, 0xd3, 0x7f, 0xaf, 0x40, 0xe9, 0x09, 0x5f, 0xa2, 0x8f,
	0xa0, 0x18, 0x2c, 0x99, 0xb3, 0x02, 0xeb, 0x5a, 0xda, 0x02, 0xa6, 0x19, 0x8b, 0x63, 0xd4, 0x87,
	0xfa, 0xb9, 0x4b, 0xbc, 0x29, 0x87, 0xee, 0xd0, 0x9f, 0x8a, 0xaa, 0xa8, 0xb7, 0x3e, 0x48, 0x0b,
	0x08, 0x9d, 0xcd, 0x27, 0x19, 0x46, 0x7c, 0x4b, 0x50, 0x7f, 0x0c, 0xf5, 0x2c, 0x07, 0x83, 0x93,
	0x81, 0xb1, 0x35, 0x1e, 0x59, 0xc3, 0xfe, 0x64, 0xd8, 0x36, 0xbb, 0x4f, 0xb5, 0x07, 0x1c, 0x31,
	0xc6, 0xc4, 0xb4, 0x8c, 0x27, 0x4f, 0xc6, 0xd8, 0xd4, 0x14, 0xfd, 0x37, 0x79, 0xa8, 0x89, 0xa0,
	0x4c, 0xfc, 0x65, 0xe0, 0x10, 0x96, 0xc5, 0x2b, 0xb2, 0x0a, 0x17, 0xb6, 0x43, 0xa2, 0x2c, 0x46,
	0x7b, 0x16, 0x90, 0xf0, 0xd2, 0x0e, 0xa6, 0xd2, 0x73, 0xb1, 0x41, 0x9f, 0x80, 0xca, 0xb3, 0x49,
	0x2d, 0xba, 0x5a, 0x10, 0x9e, 0xc7, 0x7a, 0x6b, 0x2b, 0x29, 0x6c, 0x9e, 0x2b, 0x6a, 0xae, 0x16,
	0x04, 0x03, 0x8d, 0xd7, 0x59, 0x34, 0x14, 0xee, 0x81, 0x86, 0xa4, 0x86, 0x8a, 0x99, 0x1a, 0x3a,
	0x88, 0x13, 0x52, 0x92, 0x5a, 0xde, 0x88, 0x5e, 0x94, 0x24, 0xd4, 0x84, 0x92, 0x3f, 0xb7, 0xa6,
	0x53, 0xaf, 0x51, 0xe6, 0x66, 0x7e, 0x27, 0xcd, 0x3b, 0x9e, 0xf7, 0x7a, 0x83, 0xb6, 0x28, 0x8b,
	0xa2, 0x3f, 0xef, 0x4d, 0x3d, 0xf4, 0x21, 0xd4, 0xc9, 0x57, 0x94, 0x04, 0x73, 0xdb, 0xb3, 0x66,
	0x2b, 0xd6, 0xbd, 0x2a, 0xdc, 0xf5, 0xb5, 0x88, 0x3a, 0x64, 0x44, 0xf4, 0x11, 0xac, 0x87, 0xd4,
	0x5f, 0x58, 0xf6, 0x39, 0x25, 0x81, 0xe5, 0xf8, 0x8b, 0x55, 0xa3, 0xba, 0xa7, 0xec, 0x57, 0xf0,
	0x1a, 0x23, 0xb7, 0x19, 0xb5, 0xeb, 0x2f, 0x56, 0xe8, 0xfb, 0xa0, 0xc5, 0xea, 0x1c, 0x6f, 0x19,
	0x32, 0xa3, 0x81, 0x2b, 0x5c, 0x8f, 0xe8, 0x5d, 0x41, 0xd6, 0x9f, 0x43, 0x15, 0xfb, 0x37, 0xdd,
	0x4b, 0xee, 0xba, 0x0e, 0xa5, 0x33, 0x72, 0xee, 0x07, 0x44, 0xd6, 0x34, 0xc8, 0x9e, 0x8f, 0xfd,
	0x1b, 0x2c, 0x4f, 0xd0, 0x1e, 0x14, 0xf9, 0xf5, 0xb2, 0xb3, 0xa4, 0x59, 0xc4, 0x81, 0x6e, 0x43,
	0x05, 0xfb, 0x37, 0xbc, 0x42, 0xd0, 0xfb, 0x20, 0x72, 0x61, 0xcd, 0xed, 0x59, 0x94, 0xe8, 0x2a,
	0xa7, 0x8c, 0xec, 0x19, 0x41, 0x8f, 0x41, 0x0d, 0xfc, 0x1b, 0xcb, 0xe1, 0xd7, 0x0b, 0xd0, 0xaa,
	0xad, 0xed, 0x4c, 0x1d, 0x47, 0xc6, 0x61, 0x08, 0xa2, 0x65, 0xa8, 0x3f, 0x07, 0x48, 0xca, 0xf0,
	0xae, 0x4b, 0xbe, 0xc7, 0x12, 0x47, 0xbc, 0x69, 0xa4, 0xbf, 0x26, 0x4d, 0xe6, 0x1a, 0xb0, 0x3c,
	0xd3, 0x7f, 0xa5, 0x40, 0x75, 0xc2, 0x0a, 0xed, 0x88, 0xba, 0xd3, 0x6f, 0x51, 0x9e, 0x08, 0x0a,
	0x17, 0xd4, 0x9d, 0xf2, 0xba, 0xac, 0x62, 0xbe, 0x46, 0x9f, 0x44, 0x86, 0x2d, 0xac, 0xab, 0xb0,
	0x51, 0xe0, 0xb7, 0x67, 0x4a, 0x81, 0xd7, 0xec, 0xc0, 0x0e, 0xe9, 0xc9, 0x31, 0xae, 0x70, 0xd6,
	0x93, 0xe3, 0x50, 0xff, 0x1c, 0x8a, 0xa7, 0xdc, 0x8a, 0xc7, 0xa0, 0x72, 0xe5, 0x16, 0xd3, 0x16,
	0xc1, 0x3c, 0x13, 0x9e, 0xd8, 0x62, 0x0c, 0x61, 0xb4, 0x0c, 0xf5, 0x36, 0xac, 0x1d, 0x4b, 0x6b,
	0x39, 0xc3, 0xbb, 0xbb, 0xa3, 0xff, 0x31, 0x07, 0xe5, 0x67, 0xfe, 0x92, 0x95, 0x0a, 0xaa, 0x43,
	0xce, 0x9d, 0x72, 0xb9, 0x3c, 0xce, 0xb9, 0x53, 0xf4, 0x73, 0xa8, 0xcf, 0xdc, 0x8b, 0xc0, 0x66,
	0x15, 0x2c, 0xc0, 0x28, 0xfa, 0xc9, 0x77, 0xd3, 0x96, 0x0d, 0x23, 0x0e, 0x8e, 0xc8, 0xb5, 0x59,
	0x7a, 0x9b, 0xc2, 0x58, 0x3e, 0x83, 0xb1, 0x0f, 0xa1, 0xee, 0xf9, 0x8e, 0xed, 0x59, 0x71, 0x87,
	0x2f, 0x08, 0x1c, 0x70, 0xea, 0x49, 0xd4, 0xe6, 0x6f, 0xc5, 0xa5, 0x78, 0xcf, 0xb8, 0xa0, 0x4f,
	0xa1, 0xb6, 0xb0, 0x03, 0xea, 0x3a, 0xee, 0xc2, 0x66, 0x33, 0x52, 0x89, 0x0b, 0x66, 0xcc, 0xce,
	0xc4, 0x0d, 0x67, 0xd8, 0x19, 0xac, 0x42, 0xde, 0xbd, 0xac, 0x1b, 0x3f, 0xb8, 0x3a, 0xf7, 0xfc,
	0x9b, 0xb0, 0x51, 0xe6, 0xf6, 0xaf, 0x0b, 0xfa, 0xcb, 0x88, 0xac, 0xff, 0x21, 0x0f, 0xa5, 0x53,
	0x51, 0x9d, 0x07, 0x50, 0xe0, 0x31, 0x12, 0x73, 0xd0, 0x4e, 0xfa, 0x32, 0xc1, 0xc1, 0x03, 0xc4,
	0x79, 0xd0, 0x7b, 0x50, 0xa5, 0xee, 0x8c, 0x84, 0xd4, 0x9e, 0x2d, 0x78, 0x50, 0xf3, 0x38, 0x21,
	0x7c, 0x6d, 0x89, 0xbd, 0x07, 0xd5, 0x78, 0x72, 0x93, 0xc1, 0x4a, 0x08, 0xe8, 0x87, 0x50, 0x65,
	0xf8, 0xe2, 0x73, 0x5a, 0xa3, 0xc8, 0x01, 0xbb, 0x75, 0x0b, 0x5d, 0xdc, 0x04, 0x5c, 0x09, 0x22,
	0xc4, 0xfe, 0x04, 0x54, 0x8e, 0x08, 0x29, 0x24, 0x7a, 0xdd, 0x4e, 0xb6, 0xd7, 0x45, 0xc8, 0xc3,
	0x90, 0x7c, 0x1e, 0xd0, 0x23, 0x28, 0x5e, 0x73, 0xf3, 0xca, 0x72, 0x5e, 0x4c, 0x3b, 0xca, 0x53,
	0x21, 0xce, 0xd9, 0xc7, 0xf8, 0x17, 0xa2, 0xb2, 0x78, 0x97, 0xbb, 0xf5, 0x31, 0x96, 0x45, 0x87,
	0x23, 0x1e, 0x36, 0xce, 0x4d, 0x67, 0x1e, 0x6f, 0x74, 0x55, 0xcc, 0x96, 0xe8, 0x03, 0xa8, 0x39,
	0xcb, 0x20, 0xe0, 0x13, 0xaa, 0x3b, 0x23, 0x8d, 0x2d, 0x1e, 0x28, 0x55, 0xd2, 0x4c, 0x77, 0x46,
	0xd0, 0xcf, 0xa0, 0xee, 0xd9, 0x21, 0x65, 0xc0, 0x93, 0x8e, 0x6c, 0xf3, 0xab, 0x32, 0xe8, 0x13,
	0xc0, 0x13, 0x9e, 0xa8, 0x5e, 0xb2, 0xd1, 0x2f, 0xa1, 0x36, 0x74, 0xe7, 0xee, 0xcc, 0xf6, 0x38,
	0x40, 0x59, 0xe0, 0x53, 0xad, 0x85, 0xaf, 0xef, 0xd7, 0x55, 0xd0, 0x2e, 0xa8, 0xcc, 0x04, 0xc7,
	0xf7, 0x96, 0xb3, 0xb9, 0xa8, 0xf6, 0x3c, 0xae, 0x2e, 0x8e, 0xbb, 0x82, 0xc0, 0x90, 0x2a, 0x6f,
	0x9a, 0x38, 0x97, 0x64, 0x66, 0xa3, 0x8f, 0x63, 0x64, 0x08, 0xb4, 0x37, 0xb2, 0x98, 0x4a, 0x8c,
	0x8a, 0x30, 0xa3, 0xff, 0x25, 0x07, 0xf5, 0x53, 0x31, 0xae, 0x44, 0x23, 0xd2, 0xe7, 0xb0, 0x49,
	0xce, 0xcf, 0x89, 0x43, 0xdd, 0x6b, 0x62, 0x39, 0xb6, 0xe7, 0x91, 0xc0, 0x92, 0x08, 0x56, 0x5b,
	0xeb, 0x4d, 0xf1, 0xb7, 0xa5, 0xcb, 0xe9, 0xfd, 0x1e, 0xde, 0x88, 0x79, 0x25, 0x69, 0x8a, 0x0c,
	0xd8, 0x74, 0x67, 0x33, 0x32, 0x75, 0x6d, 0x9a, 0x56, 0x20, 0x5a, 0xfe, 0xb6, 0xf4, 0xf4, 0xd4,
	0x3c, 0xb2, 0x29, 0x49, 0xd4, 0xc4, 0x12, 0xb1, 0x9a, 0x0f, 0x99, 0x33, 0xc1, 0x45, 0x3c, 0x75,
	0xad, 0x49, 0x49, 0x93, 0x13, 0xb1, 0x3c, 0xcc, 0x4c, 0x74, 0x85, 0x5b, 0x13, 0x5d, 0xf2, 0xd5,
	0x2d, 0xde, 0xf9, 0xd5, 0xfd, 0x0c, 0xd6, 0x45, 0xbb, 0x8d, 0x52, 0x1f, 0x21, 0xfc, 0x1b, 0x7b,
	0x6e, 0x8d, 0x26, 0x9b, 0x50, 0xff, 0x14, 0xd6, 0xe3, 0x40, 0xca, 0x89, 0xef, 0x00, 0x4a, 0xbc,
	0x7c, 0xa2, 0x74, 0xa0, 0x37, 0xe1, 0x8b, 0x25, 0x87, 0xfe, 0xcb, 0x1c, 0xa0, 0x48, 0xde, 0xbf,
	0x09, 0xff, 0x47, 0x93, 0xb1, 0x05, 0x45, 0x4e, 0x97, 0x99, 0x10, 0x1b, 0x16, 0x07, 0x16, 0xd4,
	0xc5, 0x55, 0x9c, 0x06, 0x21, 0xfc, 0x9c, 0xfd, 0x62, 0x12, 0x2e, 0x3d, 0x8a, 0x25, 0x87, 0xfe,
	0x27, 0x05, 0x36, 0x33, 0x71, 0x90, 0xb1, 0x4c, 0x10, 0xa3, 0xbc, 0x05, 0x31, 0xfb, 0x50, 0x59,
	0x5c, 0xbd, 0x05, 0x59, 0xf1, 0xe9, 0xd7, 0xb6, 0xc3, 0x5d, 0x28, 0x04, 0xac, 0x2d, 0x8b, 0x6f,
	0x6d, 0x7a, 0x38, 0xe1, 0x74, 0x36, 0xe1, 0x64, 0xfc, 0xc8, 0x4c, 0x38, 0xd2, 0x7e, 0x17, 0xd4,
	0x54, 0x67, 0x60, 0xad, 0x24, 0x5b, 0x55, 0x32, 0x75, 0xdf, 0x58, 0x54, 0x6a, 0xaa, 0xa8, 0x58,
	0x7f, 0x76, 0xfc, 0xd9, 0xc2, 0x23, 0x94, 0x88, 0x94, 0x55, 0x70, 0x42, 0xd0, 0xbf, 0x00, 0x35,
	0x25, 0x79, 0xd7, 0x20, 0x93, 0x24, 0x21, 0x7f, 0x67, 0x12, 0xfe, 0xae, 0xc0, 0x76, 0x52, 0xcc,
	0x4b, 0x8f, 0xfe, 0x5f, 0xd5, 0xa3, 0x1e, 0xc0, 0xce, 0x6d, 0xef, 0xde, 0xa9, 0xca, 0xbe, 0x45,
	0xed, 0x1c, 0x7c, 0x06, 0x6a, 0x6a, 0x74, 0x67, 0xff, 0xf0, 0xfb, 0x47, 0xa3, 0x31, 0x36, 0xb4,
	0x07, 0xa8, 0x02, 0x85, 0x89, 0x39, 0x3e, 0xd1, 0x14, 0xb6, 0x32, 0xbe, 0x30, 0xba, 0xe2, 0xd5,
	0x80, 0xad, 0x2c, 0xc9, 0x94, 0x3f, 0xf8, 0xb7, 0x02, 0x90, 0x7c, 0xf1, 0x91, 0x0a, 0xe5, 0x17,
	0xa3, 0xe3, 0xd1, 0xf8, 0xe5, 0x48, 0x28, 0x38, 0x32, 0xfb, 0x3d, 0x4d, 0x41, 0x55, 0x28, 0x8a,
	0x67, 0x88, 0x1c, 0xbb, 0x41, 0xbe, 0x41, 0xe4, 0x51, 0x0d, 0x2a, 0xf1, 0x03, 0x44, 0x01, 0x95,
	0x21, 0x1f, 0x3f, 0x33, 0xc8, 0x77, 0x85, 0x12, 0x53, 0x88, 0x8d, 0x93, 0x41, 0xbb, 0x6b, 0x68,
	0x65, 0x76, 0x10, 0xbf, 0x30, 0x00, 0x94, 0xa2, 0xe7, 0x05, 0x26, 0x39, 0x31, 0x4c, 0x0d, 0xd8,
	0x3d, 0x63, 0xf3, 0xa9, 0x81, 0x35, 0x95, 0xd1, 0xf0, 0xf8, 0xa5, 0x56, 0x63, 0xb4, 0x27, 0x7d,
	0x63, 0xd0, 0xd3, 0xd6, 0xd0, 0x1a, 0x54, 0x9f, 0x1a, 0x6d, 0x6c, 0x76, 0x8c, 0xb6, 0xa9, 0xd5,
	0xd9, 0xc9, 0x29, 0x37, 0x70, 0x9d, 0x5d, 0xf3, 0x6c, 0xfc, 0x02, 0x8f, 0xda, 0x03, 0x4d, 0x63,
	0x9b, 0x53, 0x03, 0x4f, 0xfa, 0xe3, 0x91, 0xb6, 0xc1, 0xee, 0x19, 0xb4, 0x27, 0xe6, 0xc9, 0xb1,
	0x86, 0x98, 0xfc, 0xa4, 0x7d, 0x6a, 0x9c, 0x8c, 0xfb, 0x23, 0x53, 0xdb, 0x3c, 0x78, 0xc4, 0xbe,
	0x73, 0xe9, 0x09, 0x10, 0xa0, 0x64, 0xb6, 0x3b, 0x03, 0x63, 0xa2, 0x3d, 0x60, 0xeb, 0xc9, 0xd3,
	0x36, 0xee, 0x4d, 0x34, 0xa5, 0xf3, 0xd3, 0xbf, 0xbe, 0xde, 0x55, 0xfe, 0xf6, 0x7a, 0x57, 0xf9,
	0xc7, 0xeb, 0x5d, 0xe5, 0xb7, 0xff, 0xdc, 0x7d, 0xf0, 0xe5, 0xa3, 0x6b, 0x97, 0x92, 0x30, 0x6c,
	0xba, 0xfe, 0xa1, 0x58, 0x1d, 0x5e, 0xf8, 0x87, 0xd7, 0xf4, 0x90, 0xbf, 0xac, 0x1d, 0x26, 0x18,
	0x3c, 0x2b, 0x71, 0xca, 0x8f, 0xfe, 0x13, 0x00, 0x00, 0xff, 0xff, 0x22, 0xbd, 0x3f, 0x86, 0xb5,
	0x13, 0x00, 0x00,
}

func (m *Charset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Charset) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Charset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Server != 0 {
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.Server))
		i--
		dAtA[i] = 0x18
	}
	if m.Conn != 0 {
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.Conn))
		i--
		dAtA[i] = 0x10
	}
	if m.Client != 0 {
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.Client))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BinlogTransaction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BinlogTransaction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BinlogTransaction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EventToken != nil {
		{
			size, err := m.EventToken.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBinlogdata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Statements) > 0 {
		for iNdEx := len(m.Statements) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Statements[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBinlogdata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BinlogTransaction_Statement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BinlogTransaction_Statement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BinlogTransaction_Statement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Sql) > 0 {
		i -= len(m.Sql)
		copy(dAtA[i:], m.Sql)
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.Sql)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Charset != nil {
		{
			size, err := m.Charset.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBinlogdata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Category != 0 {
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.Category))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StreamKeyRangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamKeyRangeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamKeyRangeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Charset != nil {
		{
			size, err := m.Charset.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBinlogdata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.KeyRange != nil {
		{
			size, err := m.KeyRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBinlogdata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Position) > 0 {
		i -= len(m.Position)
		copy(dAtA[i:], m.Position)
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.Position)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StreamKeyRangeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamKeyRangeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamKeyRangeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BinlogTransaction != nil {
		{
			size, err := m.BinlogTransaction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBinlogdata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StreamTablesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamTablesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamTablesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Charset != nil {
		{
			size, err := m.Charset.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBinlogdata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Tables) > 0 {
		for iNdEx := len(m.Tables) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Tables[iNdEx])
			copy(dAtA[i:], m.Tables[iNdEx])
			i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.Tables[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Position) > 0 {
		i -= len(m.Position)
		copy(dAtA[i:], m.Position)
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.Position)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StreamTablesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamTablesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamTablesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BinlogTransaction != nil {
		{
			size, err := m.BinlogTransaction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBinlogdata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Rule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Rule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Rule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Filter) > 0 {
		i -= len(m.Filter)
		copy(dAtA[i:], m.Filter)
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.Filter)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Match) > 0 {
		i -= len(m.Match)
		copy(dAtA[i:], m.Match)
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.Match)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Filter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Filter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Filter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.FieldEventMode != 0 {
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.FieldEventMode))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Rules) > 0 {
		for iNdEx := len(m.Rules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBinlogdata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BinlogSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BinlogSource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BinlogSource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ExternalCluster) > 0 {
		i -= len(m.ExternalCluster)
		copy(dAtA[i:], m.ExternalCluster)
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.ExternalCluster)))
		i--
		dAtA[i] = 0x52
	}
	if m.StopAfterCopy {
		i--
		if m.StopAfterCopy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.ExternalMysql) > 0 {
		i -= len(m.ExternalMysql)
		copy(dAtA[i:], m.ExternalMysql)
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.ExternalMysql)))
		i--
		dAtA[i] = 0x42
	}
	if m.OnDdl != 0 {
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.OnDdl))
		i--
		dAtA[i] = 0x38
	}
	if m.Filter != nil {
		{
			size, err := m.Filter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBinlogdata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Tables) > 0 {
		for iNdEx := len(m.Tables) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Tables[iNdEx])
			copy(dAtA[i:], m.Tables[iNdEx])
			i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.Tables[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.KeyRange != nil {
		{
			size, err := m.KeyRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBinlogdata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.TabletType != 0 {
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.TabletType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Shard) > 0 {
		i -= len(m.Shard)
		copy(dAtA[i:], m.Shard)
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.Shard)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Keyspace) > 0 {
		i -= len(m.Keyspace)
		copy(dAtA[i:], m.Keyspace)
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.Keyspace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RowChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RowChange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RowChange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.After != nil {
		{
			size, err := m.After.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBinlogdata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Before != nil {
		{
			size, err := m.Before.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBinlogdata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RowEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RowEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RowEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RowChanges) > 0 {
		for iNdEx := len(m.RowChanges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RowChanges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBinlogdata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.TableName) > 0 {
		i -= len(m.TableName)
		copy(dAtA[i:], m.TableName)
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.TableName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FieldEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FieldEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FieldEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fields[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBinlogdata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.TableName) > 0 {
		i -= len(m.TableName)
		copy(dAtA[i:], m.TableName)
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.TableName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ShardGtid) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardGtid) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardGtid) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TablePKs) > 0 {
		for iNdEx := len(m.TablePKs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TablePKs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBinlogdata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Gtid) > 0 {
		i -= len(m.Gtid)
		copy(dAtA[i:], m.Gtid)
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.Gtid)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Shard) > 0 {
		i -= len(m.Shard)
		copy(dAtA[i:], m.Shard)
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.Shard)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Keyspace) > 0 {
		i -= len(m.Keyspace)
		copy(dAtA[i:], m.Keyspace)
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.Keyspace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VGtid) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VGtid) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VGtid) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ShardGtids) > 0 {
		for iNdEx := len(m.ShardGtids) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ShardGtids[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBinlogdata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *KeyspaceShard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyspaceShard) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyspaceShard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Shard) > 0 {
		i -= len(m.Shard)
		copy(dAtA[i:], m.Shard)
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.Shard)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Keyspace) > 0 {
		i -= len(m.Keyspace)
		copy(dAtA[i:], m.Keyspace)
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.Keyspace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Journal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Journal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Journal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SourceWorkflows) > 0 {
		for iNdEx := len(m.SourceWorkflows) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SourceWorkflows[iNdEx])
			copy(dAtA[i:], m.SourceWorkflows[iNdEx])
			i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.SourceWorkflows[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Participants) > 0 {
		for iNdEx := len(m.Participants) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Participants[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBinlogdata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.ShardGtids) > 0 {
		for iNdEx := len(m.ShardGtids) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ShardGtids[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBinlogdata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.LocalPosition) > 0 {
		i -= len(m.LocalPosition)
		copy(dAtA[i:], m.LocalPosition)
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.LocalPosition)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Tables) > 0 {
		for iNdEx := len(m.Tables) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Tables[iNdEx])
			copy(dAtA[i:], m.Tables[iNdEx])
			i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.Tables[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.MigrationType != 0 {
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.MigrationType))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LastPKEvent != nil {
		{
			size, err := m.LastPKEvent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBinlogdata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.CurrentTime != 0 {
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.CurrentTime))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if len(m.Dml) > 0 {
		i -= len(m.Dml)
		copy(dAtA[i:], m.Dml)
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.Dml)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Journal != nil {
		{
			size, err := m.Journal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBinlogdata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Vgtid != nil {
		{
			size, err := m.Vgtid.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBinlogdata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.FieldEvent != nil {
		{
			size, err := m.FieldEvent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBinlogdata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.RowEvent != nil {
		{
			size, err := m.RowEvent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBinlogdata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Statement) > 0 {
		i -= len(m.Statement)
		copy(dAtA[i:], m.Statement)
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.Statement)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Gtid) > 0 {
		i -= len(m.Gtid)
		copy(dAtA[i:], m.Gtid)
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.Gtid)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Timestamp != 0 {
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MinimalTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MinimalTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MinimalTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PKColumns) > 0 {
		dAtA18 := make([]byte, len(m.PKColumns)*10)
		var j17 int
		for _, num1 := range m.PKColumns {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		i -= j17
		copy(dAtA[i:], dAtA18[:j17])
		i = encodeVarintBinlogdata(dAtA, i, uint64(j17))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fields[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBinlogdata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MinimalSchema) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MinimalSchema) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MinimalSchema) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tables) > 0 {
		for iNdEx := len(m.Tables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBinlogdata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *VStreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VStreamRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VStreamRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TableLastPKs) > 0 {
		for iNdEx := len(m.TableLastPKs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TableLastPKs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBinlogdata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Filter != nil {
		{
			size, err := m.Filter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBinlogdata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Position) > 0 {
		i -= len(m.Position)
		copy(dAtA[i:], m.Position)
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.Position)))
		i--
		dAtA[i] = 0x22
	}
	if m.Target != nil {
		{
			size, err := m.Target.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBinlogdata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ImmediateCallerId != nil {
		{
			size, err := m.ImmediateCallerId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBinlogdata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.EffectiveCallerId != nil {
		{
			size, err := m.EffectiveCallerId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBinlogdata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VStreamResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VStreamResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VStreamResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Events) > 0 {
		for iNdEx := len(m.Events) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Events[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBinlogdata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *VStreamRowsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VStreamRowsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VStreamRowsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Lastpk != nil {
		{
			size, err := m.Lastpk.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBinlogdata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x22
	}
	if m.Target != nil {
		{
			size, err := m.Target.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBinlogdata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ImmediateCallerId != nil {
		{
			size, err := m.ImmediateCallerId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBinlogdata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.EffectiveCallerId != nil {
		{
			size, err := m.EffectiveCallerId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBinlogdata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VStreamRowsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VStreamRowsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VStreamRowsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Lastpk != nil {
		{
			size, err := m.Lastpk.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBinlogdata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Rows) > 0 {
		for iNdEx := len(m.Rows) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rows[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBinlogdata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Gtid) > 0 {
		i -= len(m.Gtid)
		copy(dAtA[i:], m.Gtid)
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.Gtid)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Pkfields) > 0 {
		for iNdEx := len(m.Pkfields) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pkfields[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBinlogdata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fields[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBinlogdata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LastPKEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LastPKEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LastPKEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Completed {
		i--
		if m.Completed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.TableLastPK != nil {
		{
			size, err := m.TableLastPK.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBinlogdata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TableLastPK) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableLastPK) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableLastPK) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Lastpk != nil {
		{
			size, err := m.Lastpk.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBinlogdata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TableName) > 0 {
		i -= len(m.TableName)
		copy(dAtA[i:], m.TableName)
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.TableName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VStreamResultsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VStreamResultsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VStreamResultsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x22
	}
	if m.Target != nil {
		{
			size, err := m.Target.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBinlogdata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ImmediateCallerId != nil {
		{
			size, err := m.ImmediateCallerId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBinlogdata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.EffectiveCallerId != nil {
		{
			size, err := m.EffectiveCallerId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBinlogdata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VStreamResultsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VStreamResultsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VStreamResultsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Rows) > 0 {
		for iNdEx := len(m.Rows) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rows[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBinlogdata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Gtid) > 0 {
		i -= len(m.Gtid)
		copy(dAtA[i:], m.Gtid)
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.Gtid)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fields[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBinlogdata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintBinlogdata(dAtA []byte, offset int, v uint64) int {
	offset -= sovBinlogdata(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Charset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Client != 0 {
		n += 1 + sovBinlogdata(uint64(m.Client))
	}
	if m.Conn != 0 {
		n += 1 + sovBinlogdata(uint64(m.Conn))
	}
	if m.Server != 0 {
		n += 1 + sovBinlogdata(uint64(m.Server))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BinlogTransaction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Statements) > 0 {
		for _, e := range m.Statements {
			l = e.Size()
			n += 1 + l + sovBinlogdata(uint64(l))
		}
	}
	if m.EventToken != nil {
		l = m.EventToken.Size()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BinlogTransaction_Statement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Category != 0 {
		n += 1 + sovBinlogdata(uint64(m.Category))
	}
	if m.Charset != nil {
		l = m.Charset.Size()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	l = len(m.Sql)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StreamKeyRangeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Position)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.KeyRange != nil {
		l = m.KeyRange.Size()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.Charset != nil {
		l = m.Charset.Size()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StreamKeyRangeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BinlogTransaction != nil {
		l = m.BinlogTransaction.Size()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StreamTablesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Position)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if len(m.Tables) > 0 {
		for _, s := range m.Tables {
			l = len(s)
			n += 1 + l + sovBinlogdata(uint64(l))
		}
	}
	if m.Charset != nil {
		l = m.Charset.Size()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StreamTablesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BinlogTransaction != nil {
		l = m.BinlogTransaction.Size()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Rule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Match)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	l = len(m.Filter)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Filter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovBinlogdata(uint64(l))
		}
	}
	if m.FieldEventMode != 0 {
		n += 1 + sovBinlogdata(uint64(m.FieldEventMode))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BinlogSource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	l = len(m.Shard)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.TabletType != 0 {
		n += 1 + sovBinlogdata(uint64(m.TabletType))
	}
	if m.KeyRange != nil {
		l = m.KeyRange.Size()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if len(m.Tables) > 0 {
		for _, s := range m.Tables {
			l = len(s)
			n += 1 + l + sovBinlogdata(uint64(l))
		}
	}
	if m.Filter != nil {
		l = m.Filter.Size()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.OnDdl != 0 {
		n += 1 + sovBinlogdata(uint64(m.OnDdl))
	}
	l = len(m.ExternalMysql)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.StopAfterCopy {
		n += 2
	}
	l = len(m.ExternalCluster)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RowChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Before != nil {
		l = m.Before.Size()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.After != nil {
		l = m.After.Size()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RowEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if len(m.RowChanges) > 0 {
		for _, e := range m.RowChanges {
			l = e.Size()
			n += 1 + l + sovBinlogdata(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FieldEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if len(m.Fields) > 0 {
		for _, e := range m.Fields {
			l = e.Size()
			n += 1 + l + sovBinlogdata(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShardGtid) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	l = len(m.Shard)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	l = len(m.Gtid)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if len(m.TablePKs) > 0 {
		for _, e := range m.TablePKs {
			l = e.Size()
			n += 1 + l + sovBinlogdata(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VGtid) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ShardGtids) > 0 {
		for _, e := range m.ShardGtids {
			l = e.Size()
			n += 1 + l + sovBinlogdata(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KeyspaceShard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	l = len(m.Shard)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Journal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovBinlogdata(uint64(m.Id))
	}
	if m.MigrationType != 0 {
		n += 1 + sovBinlogdata(uint64(m.MigrationType))
	}
	if len(m.Tables) > 0 {
		for _, s := range m.Tables {
			l = len(s)
			n += 1 + l + sovBinlogdata(uint64(l))
		}
	}
	l = len(m.LocalPosition)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if len(m.ShardGtids) > 0 {
		for _, e := range m.ShardGtids {
			l = e.Size()
			n += 1 + l + sovBinlogdata(uint64(l))
		}
	}
	if len(m.Participants) > 0 {
		for _, e := range m.Participants {
			l = e.Size()
			n += 1 + l + sovBinlogdata(uint64(l))
		}
	}
	if len(m.SourceWorkflows) > 0 {
		for _, s := range m.SourceWorkflows {
			l = len(s)
			n += 1 + l + sovBinlogdata(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovBinlogdata(uint64(m.Type))
	}
	if m.Timestamp != 0 {
		n += 1 + sovBinlogdata(uint64(m.Timestamp))
	}
	l = len(m.Gtid)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	l = len(m.Statement)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.RowEvent != nil {
		l = m.RowEvent.Size()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.FieldEvent != nil {
		l = m.FieldEvent.Size()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.Vgtid != nil {
		l = m.Vgtid.Size()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.Journal != nil {
		l = m.Journal.Size()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	l = len(m.Dml)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.CurrentTime != 0 {
		n += 2 + sovBinlogdata(uint64(m.CurrentTime))
	}
	if m.LastPKEvent != nil {
		l = m.LastPKEvent.Size()
		n += 2 + l + sovBinlogdata(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MinimalTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if len(m.Fields) > 0 {
		for _, e := range m.Fields {
			l = e.Size()
			n += 1 + l + sovBinlogdata(uint64(l))
		}
	}
	if len(m.PKColumns) > 0 {
		l = 0
		for _, e := range m.PKColumns {
			l += sovBinlogdata(uint64(e))
		}
		n += 1 + sovBinlogdata(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MinimalSchema) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Tables) > 0 {
		for _, e := range m.Tables {
			l = e.Size()
			n += 1 + l + sovBinlogdata(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VStreamRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EffectiveCallerId != nil {
		l = m.EffectiveCallerId.Size()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.ImmediateCallerId != nil {
		l = m.ImmediateCallerId.Size()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.Target != nil {
		l = m.Target.Size()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	l = len(m.Position)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.Filter != nil {
		l = m.Filter.Size()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if len(m.TableLastPKs) > 0 {
		for _, e := range m.TableLastPKs {
			l = e.Size()
			n += 1 + l + sovBinlogdata(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VStreamResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovBinlogdata(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VStreamRowsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EffectiveCallerId != nil {
		l = m.EffectiveCallerId.Size()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.ImmediateCallerId != nil {
		l = m.ImmediateCallerId.Size()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.Target != nil {
		l = m.Target.Size()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.Lastpk != nil {
		l = m.Lastpk.Size()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VStreamRowsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, e := range m.Fields {
			l = e.Size()
			n += 1 + l + sovBinlogdata(uint64(l))
		}
	}
	if len(m.Pkfields) > 0 {
		for _, e := range m.Pkfields {
			l = e.Size()
			n += 1 + l + sovBinlogdata(uint64(l))
		}
	}
	l = len(m.Gtid)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if len(m.Rows) > 0 {
		for _, e := range m.Rows {
			l = e.Size()
			n += 1 + l + sovBinlogdata(uint64(l))
		}
	}
	if m.Lastpk != nil {
		l = m.Lastpk.Size()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LastPKEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableLastPK != nil {
		l = m.TableLastPK.Size()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.Completed {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableLastPK) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.Lastpk != nil {
		l = m.Lastpk.Size()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VStreamResultsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EffectiveCallerId != nil {
		l = m.EffectiveCallerId.Size()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.ImmediateCallerId != nil {
		l = m.ImmediateCallerId.Size()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.Target != nil {
		l = m.Target.Size()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VStreamResultsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, e := range m.Fields {
			l = e.Size()
			n += 1 + l + sovBinlogdata(uint64(l))
		}
	}
	l = len(m.Gtid)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if len(m.Rows) > 0 {
		for _, e := range m.Rows {
			l = e.Size()
			n += 1 + l + sovBinlogdata(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovBinlogdata(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBinlogdata(x uint64) (n int) {
	return sovBinlogdata(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Charset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Charset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Charset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Client", wireType)
			}
			m.Client = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Client |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conn", wireType)
			}
			m.Conn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Conn |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Server", wireType)
			}
			m.Server = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Server |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BinlogTransaction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BinlogTransaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BinlogTransaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Statements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Statements = append(m.Statements, &BinlogTransaction_Statement{})
			if err := m.Statements[len(m.Statements)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EventToken == nil {
				m.EventToken = &query.EventToken{}
			}
			if err := m.EventToken.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BinlogTransaction_Statement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Statement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Statement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Category", wireType)
			}
			m.Category = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Category |= BinlogTransaction_Statement_Category(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Charset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Charset == nil {
				m.Charset = &Charset{}
			}
			if err := m.Charset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sql", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sql = append(m.Sql[:0], dAtA[iNdEx:postIndex]...)
			if m.Sql == nil {
				m.Sql = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamKeyRangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamKeyRangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamKeyRangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Position = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyRange == nil {
				m.KeyRange = &topodata.KeyRange{}
			}
			if err := m.KeyRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Charset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Charset == nil {
				m.Charset = &Charset{}
			}
			if err := m.Charset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamKeyRangeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamKeyRangeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamKeyRangeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinlogTransaction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BinlogTransaction == nil {
				m.BinlogTransaction = &BinlogTransaction{}
			}
			if err := m.BinlogTransaction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamTablesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamTablesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamTablesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Position = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tables", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tables = append(m.Tables, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Charset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Charset == nil {
				m.Charset = &Charset{}
			}
			if err := m.Charset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamTablesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamTablesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamTablesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinlogTransaction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BinlogTransaction == nil {
				m.BinlogTransaction = &BinlogTransaction{}
			}
			if err := m.BinlogTransaction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Match = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Filter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Filter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Filter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &Rule{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldEventMode", wireType)
			}
			m.FieldEventMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FieldEventMode |= Filter_FieldEventMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BinlogSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BinlogSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BinlogSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shard = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabletType", wireType)
			}
			m.TabletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabletType |= topodata.TabletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyRange == nil {
				m.KeyRange = &topodata.KeyRange{}
			}
			if err := m.KeyRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tables", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tables = append(m.Tables, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = &Filter{}
			}
			if err := m.Filter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDdl", wireType)
			}
			m.OnDdl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnDdl |= OnDDLAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalMysql", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalMysql = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StopAfterCopy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StopAfterCopy = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalCluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalCluster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RowChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RowChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RowChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Before", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Before == nil {
				m.Before = &query.Row{}
			}
			if err := m.Before.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field After", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.After == nil {
				m.After = &query.Row{}
			}
			if err := m.After.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RowEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RowEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RowEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowChanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RowChanges = append(m.RowChanges, &RowChange{})
			if err := m.RowChanges[len(m.RowChanges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FieldEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FieldEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FieldEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, &query.Field{})
			if err := m.Fields[len(m.Fields)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardGtid) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardGtid: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardGtid: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shard = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gtid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gtid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TablePKs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TablePKs = append(m.TablePKs, &TableLastPK{})
			if err := m.TablePKs[len(m.TablePKs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VGtid) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VGtid: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VGtid: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardGtids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardGtids = append(m.ShardGtids, &ShardGtid{})
			if err := m.ShardGtids[len(m.ShardGtids)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyspaceShard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyspaceShard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyspaceShard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shard = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Journal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Journal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Journal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MigrationType", wireType)
			}
			m.MigrationType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MigrationType |= MigrationType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tables", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tables = append(m.Tables, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalPosition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalPosition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardGtids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardGtids = append(m.ShardGtids, &ShardGtid{})
			if err := m.ShardGtids[len(m.ShardGtids)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Participants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Participants = append(m.Participants, &KeyspaceShard{})
			if err := m.Participants[len(m.Participants)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceWorkflows", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceWorkflows = append(m.SourceWorkflows, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= VEventType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gtid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gtid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Statement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Statement = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RowEvent == nil {
				m.RowEvent = &RowEvent{}
			}
			if err := m.RowEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FieldEvent == nil {
				m.FieldEvent = &FieldEvent{}
			}
			if err := m.FieldEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vgtid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vgtid == nil {
				m.Vgtid = &VGtid{}
			}
			if err := m.Vgtid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Journal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Journal == nil {
				m.Journal = &Journal{}
			}
			if err := m.Journal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dml", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dml = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentTime", wireType)
			}
			m.CurrentTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastPKEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastPKEvent == nil {
				m.LastPKEvent = &LastPKEvent{}
			}
			if err := m.LastPKEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MinimalTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MinimalTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MinimalTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, &query.Field{})
			if err := m.Fields[len(m.Fields)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBinlogdata
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PKColumns = append(m.PKColumns, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBinlogdata
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBinlogdata
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBinlogdata
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PKColumns) == 0 {
					m.PKColumns = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBinlogdata
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PKColumns = append(m.PKColumns, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PKColumns", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MinimalSchema) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MinimalSchema: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MinimalSchema: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tables = append(m.Tables, &MinimalTable{})
			if err := m.Tables[len(m.Tables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VStreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VStreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VStreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectiveCallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EffectiveCallerId == nil {
				m.EffectiveCallerId = &vtrpc.CallerID{}
			}
			if err := m.EffectiveCallerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImmediateCallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ImmediateCallerId == nil {
				m.ImmediateCallerId = &query.VTGateCallerID{}
			}
			if err := m.ImmediateCallerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &query.Target{}
			}
			if err := m.Target.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Position = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = &Filter{}
			}
			if err := m.Filter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableLastPKs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableLastPKs = append(m.TableLastPKs, &TableLastPK{})
			if err := m.TableLastPKs[len(m.TableLastPKs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VStreamResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VStreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VStreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &VEvent{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VStreamRowsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VStreamRowsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VStreamRowsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectiveCallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EffectiveCallerId == nil {
				m.EffectiveCallerId = &vtrpc.CallerID{}
			}
			if err := m.EffectiveCallerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImmediateCallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ImmediateCallerId == nil {
				m.ImmediateCallerId = &query.VTGateCallerID{}
			}
			if err := m.ImmediateCallerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &query.Target{}
			}
			if err := m.Target.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lastpk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lastpk == nil {
				m.Lastpk = &query.QueryResult{}
			}
			if err := m.Lastpk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VStreamRowsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VStreamRowsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VStreamRowsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, &query.Field{})
			if err := m.Fields[len(m.Fields)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pkfields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pkfields = append(m.Pkfields, &query.Field{})
			if err := m.Pkfields[len(m.Pkfields)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gtid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gtid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rows = append(m.Rows, &query.Row{})
			if err := m.Rows[len(m.Rows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lastpk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lastpk == nil {
				m.Lastpk = &query.Row{}
			}
			if err := m.Lastpk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LastPKEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LastPKEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LastPKEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableLastPK", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableLastPK == nil {
				m.TableLastPK = &TableLastPK{}
			}
			if err := m.TableLastPK.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Completed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Completed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableLastPK) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableLastPK: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableLastPK: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lastpk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lastpk == nil {
				m.Lastpk = &query.QueryResult{}
			}
			if err := m.Lastpk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VStreamResultsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VStreamResultsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VStreamResultsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectiveCallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EffectiveCallerId == nil {
				m.EffectiveCallerId = &vtrpc.CallerID{}
			}
			if err := m.EffectiveCallerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImmediateCallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ImmediateCallerId == nil {
				m.ImmediateCallerId = &query.VTGateCallerID{}
			}
			if err := m.ImmediateCallerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &query.Target{}
			}
			if err := m.Target.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VStreamResultsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VStreamResultsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VStreamResultsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, &query.Field{})
			if err := m.Fields[len(m.Fields)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gtid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gtid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rows = append(m.Rows, &query.Row{})
			if err := m.Rows[len(m.Rows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBinlogdata(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBinlogdata
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBinlogdata
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBinlogdata
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBinlogdata        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBinlogdata          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBinlogdata = fmt.Errorf("proto: unexpected end of group")
)
