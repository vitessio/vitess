// Code generated by protoc-gen-go-vtproto. DO NOT EDIT.
// protoc-gen-go-vtproto version: v0.6.1-0.20241121165744-79df5c4772f2
// source: vtorcdata.proto

package vtorcdata

import (
	binary "encoding/binary"
	fmt "fmt"
	protohelpers "github.com/planetscale/vtprotobuf/protohelpers"
	proto "google.golang.org/protobuf/proto"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	io "io"
	math "math"
	topodata "vitess.io/vitess/go/vt/proto/topodata"
	vttime "vitess.io/vitess/go/vt/proto/vttime"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

func (m *BinlogCoordinates) CloneVT() *BinlogCoordinates {
	if m == nil {
		return (*BinlogCoordinates)(nil)
	}
	r := new(BinlogCoordinates)
	r.LogFile = m.LogFile
	r.LogPos = m.LogPos
	r.Type = m.Type
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *BinlogCoordinates) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (m *ReplicationAnalysis) CloneVT() *ReplicationAnalysis {
	if m == nil {
		return (*ReplicationAnalysis)(nil)
	}
	r := new(ReplicationAnalysis)
	r.RecoveryId = m.RecoveryId
	r.AnalyzedInstanceAlias = m.AnalyzedInstanceAlias
	r.AnalyzedInstancePrimaryAlias = m.AnalyzedInstancePrimaryAlias
	r.AnalyzedKeyspace = m.AnalyzedKeyspace
	r.AnalyzedShard = m.AnalyzedShard
	r.TabletType = m.TabletType
	r.CurrentTabletType = m.CurrentTabletType
	r.PrimaryTimestamp = m.PrimaryTimestamp.CloneVT()
	r.ShardPrimaryTermTimestamp = m.ShardPrimaryTermTimestamp.CloneVT()
	r.AnalyzedInstanceBinlogCoordinates = m.AnalyzedInstanceBinlogCoordinates.CloneVT()
	r.IsPrimary = m.IsPrimary
	r.IsClusterPrimary = m.IsClusterPrimary
	r.IsReadOnly = m.IsReadOnly
	r.IsDiskStalled = m.IsDiskStalled
	r.IsActionableRecovery = m.IsActionableRecovery
	r.LastCheckValid = m.LastCheckValid
	r.LastCheckPartialSuccess = m.LastCheckPartialSuccess
	r.ReplicationStopped = m.ReplicationStopped
	r.GtidMode = m.GtidMode
	r.MinReplicaGtidMode = m.MinReplicaGtidMode
	r.MaxReplicaGtidMode = m.MaxReplicaGtidMode
	r.ErrantGtid = m.ErrantGtid
	r.MaxReplicaErrantGtid = m.MaxReplicaErrantGtid
	r.ReplicaNetTimeout = m.ReplicaNetTimeout
	r.HeartbeatInterval = m.HeartbeatInterval
	r.Analysis = m.Analysis
	r.Description = m.Description
	r.OracleGtidImmediateTopology = m.OracleGtidImmediateTopology
	r.BinlogServerImmediateTopology = m.BinlogServerImmediateTopology
	r.SemiSyncPrimaryEnabled = m.SemiSyncPrimaryEnabled
	r.SemiSyncPrimaryStatus = m.SemiSyncPrimaryStatus
	r.SemiSyncReplicaEnabled = m.SemiSyncReplicaEnabled
	r.SemiSyncBlocked = m.SemiSyncBlocked
	r.CountReplicas = m.CountReplicas
	r.CountValidReplicas = m.CountValidReplicas
	r.CountValidReplicatingReplicas = m.CountValidReplicatingReplicas
	r.CountSemiSyncPrimaryWaitForReplica = m.CountSemiSyncPrimaryWaitForReplica
	r.CountSemiSyncPrimaryClients = m.CountSemiSyncPrimaryClients
	r.CountSemiSyncReplicasEnabled = m.CountSemiSyncReplicasEnabled
	r.CountLoggingReplicas = m.CountLoggingReplicas
	r.CountStatementBasedLoggingReplicas = m.CountStatementBasedLoggingReplicas
	r.CountMixedBasedLoggingReplicas = m.CountMixedBasedLoggingReplicas
	r.CountRowBasedLoggingReplicas = m.CountRowBasedLoggingReplicas
	r.CountDistinctMajorVersionsLoggingReplicas = m.CountDistinctMajorVersionsLoggingReplicas
	r.CountDelayedReplicas = m.CountDelayedReplicas
	r.CountLaggingReplicas = m.CountLaggingReplicas
	if rhs := m.StructureAnalysis; rhs != nil {
		tmpContainer := make([]StructureAnalysisType, len(rhs))
		copy(tmpContainer, rhs)
		r.StructureAnalysis = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *ReplicationAnalysis) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (m *BinlogCoordinates) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BinlogCoordinates) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *BinlogCoordinates) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Type != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if m.LogPos != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.LogPos))
		i--
		dAtA[i] = 0x10
	}
	if len(m.LogFile) > 0 {
		i -= len(m.LogFile)
		copy(dAtA[i:], m.LogFile)
		i = protohelpers.EncodeVarint(dAtA, i, uint64(len(m.LogFile)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReplicationAnalysis) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplicationAnalysis) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *ReplicationAnalysis) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.CountLaggingReplicas != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.CountLaggingReplicas))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf8
	}
	if m.CountDelayedReplicas != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.CountDelayedReplicas))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf0
	}
	if m.CountDistinctMajorVersionsLoggingReplicas != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.CountDistinctMajorVersionsLoggingReplicas))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe8
	}
	if m.CountRowBasedLoggingReplicas != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.CountRowBasedLoggingReplicas))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe0
	}
	if m.CountMixedBasedLoggingReplicas != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.CountMixedBasedLoggingReplicas))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd8
	}
	if m.CountStatementBasedLoggingReplicas != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.CountStatementBasedLoggingReplicas))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd0
	}
	if m.CountLoggingReplicas != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.CountLoggingReplicas))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc8
	}
	if m.CountSemiSyncReplicasEnabled != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.CountSemiSyncReplicasEnabled))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if m.CountSemiSyncPrimaryClients != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.CountSemiSyncPrimaryClients))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb8
	}
	if m.CountSemiSyncPrimaryWaitForReplica != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.CountSemiSyncPrimaryWaitForReplica))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb0
	}
	if m.CountValidReplicatingReplicas != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.CountValidReplicatingReplicas))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if m.CountValidReplicas != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.CountValidReplicas))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa0
	}
	if m.CountReplicas != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.CountReplicas))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x98
	}
	if m.SemiSyncBlocked {
		i--
		if m.SemiSyncBlocked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.SemiSyncReplicaEnabled {
		i--
		if m.SemiSyncReplicaEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.SemiSyncPrimaryStatus {
		i--
		if m.SemiSyncPrimaryStatus {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.SemiSyncPrimaryEnabled {
		i--
		if m.SemiSyncPrimaryEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.BinlogServerImmediateTopology {
		i--
		if m.BinlogServerImmediateTopology {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.OracleGtidImmediateTopology {
		i--
		if m.OracleGtidImmediateTopology {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if len(m.StructureAnalysis) > 0 {
		var pksize2 int
		for _, num := range m.StructureAnalysis {
			pksize2 += protohelpers.SizeOfVarint(uint64(num))
		}
		i -= pksize2
		j1 := i
		for _, num1 := range m.StructureAnalysis {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA[j1] = uint8(num)
			j1++
		}
		i = protohelpers.EncodeVarint(dAtA, i, uint64(pksize2))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = protohelpers.EncodeVarint(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if m.Analysis != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.Analysis))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.HeartbeatInterval != 0 {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.HeartbeatInterval))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xcd
	}
	if m.ReplicaNetTimeout != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.ReplicaNetTimeout))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if len(m.MaxReplicaErrantGtid) > 0 {
		i -= len(m.MaxReplicaErrantGtid)
		copy(dAtA[i:], m.MaxReplicaErrantGtid)
		i = protohelpers.EncodeVarint(dAtA, i, uint64(len(m.MaxReplicaErrantGtid)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if len(m.ErrantGtid) > 0 {
		i -= len(m.ErrantGtid)
		copy(dAtA[i:], m.ErrantGtid)
		i = protohelpers.EncodeVarint(dAtA, i, uint64(len(m.ErrantGtid)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.MaxReplicaGtidMode != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.MaxReplicaGtidMode))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.MinReplicaGtidMode != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.MinReplicaGtidMode))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.GtidMode != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.GtidMode))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.ReplicationStopped {
		i--
		if m.ReplicationStopped {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.LastCheckPartialSuccess {
		i--
		if m.LastCheckPartialSuccess {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.LastCheckValid {
		i--
		if m.LastCheckValid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.IsActionableRecovery {
		i--
		if m.IsActionableRecovery {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if m.IsDiskStalled {
		i--
		if m.IsDiskStalled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.IsReadOnly {
		i--
		if m.IsReadOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.IsClusterPrimary {
		i--
		if m.IsClusterPrimary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.IsPrimary {
		i--
		if m.IsPrimary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.AnalyzedInstanceBinlogCoordinates != nil {
		size, err := m.AnalyzedInstanceBinlogCoordinates.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x52
	}
	if m.ShardPrimaryTermTimestamp != nil {
		size, err := m.ShardPrimaryTermTimestamp.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x4a
	}
	if m.PrimaryTimestamp != nil {
		size, err := m.PrimaryTimestamp.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x42
	}
	if m.CurrentTabletType != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.CurrentTabletType))
		i--
		dAtA[i] = 0x38
	}
	if m.TabletType != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.TabletType))
		i--
		dAtA[i] = 0x30
	}
	if len(m.AnalyzedShard) > 0 {
		i -= len(m.AnalyzedShard)
		copy(dAtA[i:], m.AnalyzedShard)
		i = protohelpers.EncodeVarint(dAtA, i, uint64(len(m.AnalyzedShard)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AnalyzedKeyspace) > 0 {
		i -= len(m.AnalyzedKeyspace)
		copy(dAtA[i:], m.AnalyzedKeyspace)
		i = protohelpers.EncodeVarint(dAtA, i, uint64(len(m.AnalyzedKeyspace)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AnalyzedInstancePrimaryAlias) > 0 {
		i -= len(m.AnalyzedInstancePrimaryAlias)
		copy(dAtA[i:], m.AnalyzedInstancePrimaryAlias)
		i = protohelpers.EncodeVarint(dAtA, i, uint64(len(m.AnalyzedInstancePrimaryAlias)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AnalyzedInstanceAlias) > 0 {
		i -= len(m.AnalyzedInstanceAlias)
		copy(dAtA[i:], m.AnalyzedInstanceAlias)
		i = protohelpers.EncodeVarint(dAtA, i, uint64(len(m.AnalyzedInstanceAlias)))
		i--
		dAtA[i] = 0x12
	}
	if m.RecoveryId != 0 {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(m.RecoveryId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BinlogCoordinates) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LogFile)
	if l > 0 {
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	if m.LogPos != 0 {
		n += 1 + protohelpers.SizeOfVarint(uint64(m.LogPos))
	}
	if m.Type != 0 {
		n += 1 + protohelpers.SizeOfVarint(uint64(m.Type))
	}
	n += len(m.unknownFields)
	return n
}

func (m *ReplicationAnalysis) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RecoveryId != 0 {
		n += 1 + protohelpers.SizeOfVarint(uint64(m.RecoveryId))
	}
	l = len(m.AnalyzedInstanceAlias)
	if l > 0 {
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	l = len(m.AnalyzedInstancePrimaryAlias)
	if l > 0 {
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	l = len(m.AnalyzedKeyspace)
	if l > 0 {
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	l = len(m.AnalyzedShard)
	if l > 0 {
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	if m.TabletType != 0 {
		n += 1 + protohelpers.SizeOfVarint(uint64(m.TabletType))
	}
	if m.CurrentTabletType != 0 {
		n += 1 + protohelpers.SizeOfVarint(uint64(m.CurrentTabletType))
	}
	if m.PrimaryTimestamp != nil {
		l = m.PrimaryTimestamp.SizeVT()
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	if m.ShardPrimaryTermTimestamp != nil {
		l = m.ShardPrimaryTermTimestamp.SizeVT()
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	if m.AnalyzedInstanceBinlogCoordinates != nil {
		l = m.AnalyzedInstanceBinlogCoordinates.SizeVT()
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	if m.IsPrimary {
		n += 2
	}
	if m.IsClusterPrimary {
		n += 2
	}
	if m.IsReadOnly {
		n += 2
	}
	if m.IsDiskStalled {
		n += 2
	}
	if m.IsActionableRecovery {
		n += 2
	}
	if m.LastCheckValid {
		n += 3
	}
	if m.LastCheckPartialSuccess {
		n += 3
	}
	if m.ReplicationStopped {
		n += 3
	}
	if m.GtidMode != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.GtidMode))
	}
	if m.MinReplicaGtidMode != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.MinReplicaGtidMode))
	}
	if m.MaxReplicaGtidMode != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.MaxReplicaGtidMode))
	}
	l = len(m.ErrantGtid)
	if l > 0 {
		n += 2 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	l = len(m.MaxReplicaErrantGtid)
	if l > 0 {
		n += 2 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	if m.ReplicaNetTimeout != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.ReplicaNetTimeout))
	}
	if m.HeartbeatInterval != 0 {
		n += 6
	}
	if m.Analysis != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.Analysis))
	}
	l = len(m.Description)
	if l > 0 {
		n += 2 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	if len(m.StructureAnalysis) > 0 {
		l = 0
		for _, e := range m.StructureAnalysis {
			l += protohelpers.SizeOfVarint(uint64(e))
		}
		n += 2 + protohelpers.SizeOfVarint(uint64(l)) + l
	}
	if m.OracleGtidImmediateTopology {
		n += 3
	}
	if m.BinlogServerImmediateTopology {
		n += 3
	}
	if m.SemiSyncPrimaryEnabled {
		n += 3
	}
	if m.SemiSyncPrimaryStatus {
		n += 3
	}
	if m.SemiSyncReplicaEnabled {
		n += 3
	}
	if m.SemiSyncBlocked {
		n += 3
	}
	if m.CountReplicas != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.CountReplicas))
	}
	if m.CountValidReplicas != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.CountValidReplicas))
	}
	if m.CountValidReplicatingReplicas != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.CountValidReplicatingReplicas))
	}
	if m.CountSemiSyncPrimaryWaitForReplica != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.CountSemiSyncPrimaryWaitForReplica))
	}
	if m.CountSemiSyncPrimaryClients != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.CountSemiSyncPrimaryClients))
	}
	if m.CountSemiSyncReplicasEnabled != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.CountSemiSyncReplicasEnabled))
	}
	if m.CountLoggingReplicas != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.CountLoggingReplicas))
	}
	if m.CountStatementBasedLoggingReplicas != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.CountStatementBasedLoggingReplicas))
	}
	if m.CountMixedBasedLoggingReplicas != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.CountMixedBasedLoggingReplicas))
	}
	if m.CountRowBasedLoggingReplicas != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.CountRowBasedLoggingReplicas))
	}
	if m.CountDistinctMajorVersionsLoggingReplicas != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.CountDistinctMajorVersionsLoggingReplicas))
	}
	if m.CountDelayedReplicas != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.CountDelayedReplicas))
	}
	if m.CountLaggingReplicas != 0 {
		n += 2 + protohelpers.SizeOfVarint(uint64(m.CountLaggingReplicas))
	}
	n += len(m.unknownFields)
	return n
}

func (m *BinlogCoordinates) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protohelpers.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BinlogCoordinates: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BinlogCoordinates: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogFile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogPos", wireType)
			}
			m.LogPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogPos |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= BinlogType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := protohelpers.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protohelpers.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicationAnalysis) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protohelpers.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicationAnalysis: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicationAnalysis: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoveryId", wireType)
			}
			m.RecoveryId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecoveryId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnalyzedInstanceAlias", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AnalyzedInstanceAlias = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnalyzedInstancePrimaryAlias", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AnalyzedInstancePrimaryAlias = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnalyzedKeyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AnalyzedKeyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnalyzedShard", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AnalyzedShard = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabletType", wireType)
			}
			m.TabletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabletType |= topodata.TabletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentTabletType", wireType)
			}
			m.CurrentTabletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentTabletType |= topodata.TabletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrimaryTimestamp == nil {
				m.PrimaryTimestamp = &vttime.Time{}
			}
			if err := m.PrimaryTimestamp.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardPrimaryTermTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardPrimaryTermTimestamp == nil {
				m.ShardPrimaryTermTimestamp = &vttime.Time{}
			}
			if err := m.ShardPrimaryTermTimestamp.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnalyzedInstanceBinlogCoordinates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AnalyzedInstanceBinlogCoordinates == nil {
				m.AnalyzedInstanceBinlogCoordinates = &BinlogCoordinates{}
			}
			if err := m.AnalyzedInstanceBinlogCoordinates.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPrimary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPrimary = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsClusterPrimary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsClusterPrimary = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsReadOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsReadOnly = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDiskStalled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDiskStalled = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsActionableRecovery", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsActionableRecovery = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastCheckValid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LastCheckValid = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastCheckPartialSuccess", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LastCheckPartialSuccess = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicationStopped", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReplicationStopped = bool(v != 0)
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GtidMode", wireType)
			}
			m.GtidMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GtidMode |= GTIDMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinReplicaGtidMode", wireType)
			}
			m.MinReplicaGtidMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinReplicaGtidMode |= GTIDMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxReplicaGtidMode", wireType)
			}
			m.MaxReplicaGtidMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxReplicaGtidMode |= GTIDMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrantGtid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrantGtid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxReplicaErrantGtid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxReplicaErrantGtid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaNetTimeout", wireType)
			}
			m.ReplicaNetTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaNetTimeout |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeartbeatInterval", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.HeartbeatInterval = float32(math.Float32frombits(v))
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Analysis", wireType)
			}
			m.Analysis = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Analysis |= AnalysisType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 28:
			if wireType == 0 {
				var v StructureAnalysisType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= StructureAnalysisType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.StructureAnalysis = append(m.StructureAnalysis, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protohelpers.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protohelpers.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.StructureAnalysis) == 0 {
					m.StructureAnalysis = make([]StructureAnalysisType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v StructureAnalysisType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protohelpers.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= StructureAnalysisType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.StructureAnalysis = append(m.StructureAnalysis, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field StructureAnalysis", wireType)
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleGtidImmediateTopology", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OracleGtidImmediateTopology = bool(v != 0)
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinlogServerImmediateTopology", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BinlogServerImmediateTopology = bool(v != 0)
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SemiSyncPrimaryEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SemiSyncPrimaryEnabled = bool(v != 0)
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SemiSyncPrimaryStatus", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SemiSyncPrimaryStatus = bool(v != 0)
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SemiSyncReplicaEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SemiSyncReplicaEnabled = bool(v != 0)
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SemiSyncBlocked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SemiSyncBlocked = bool(v != 0)
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountReplicas", wireType)
			}
			m.CountReplicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CountReplicas |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountValidReplicas", wireType)
			}
			m.CountValidReplicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CountValidReplicas |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountValidReplicatingReplicas", wireType)
			}
			m.CountValidReplicatingReplicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CountValidReplicatingReplicas |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountSemiSyncPrimaryWaitForReplica", wireType)
			}
			m.CountSemiSyncPrimaryWaitForReplica = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CountSemiSyncPrimaryWaitForReplica |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountSemiSyncPrimaryClients", wireType)
			}
			m.CountSemiSyncPrimaryClients = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CountSemiSyncPrimaryClients |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountSemiSyncReplicasEnabled", wireType)
			}
			m.CountSemiSyncReplicasEnabled = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CountSemiSyncReplicasEnabled |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountLoggingReplicas", wireType)
			}
			m.CountLoggingReplicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CountLoggingReplicas |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountStatementBasedLoggingReplicas", wireType)
			}
			m.CountStatementBasedLoggingReplicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CountStatementBasedLoggingReplicas |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountMixedBasedLoggingReplicas", wireType)
			}
			m.CountMixedBasedLoggingReplicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CountMixedBasedLoggingReplicas |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountRowBasedLoggingReplicas", wireType)
			}
			m.CountRowBasedLoggingReplicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CountRowBasedLoggingReplicas |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 45:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountDistinctMajorVersionsLoggingReplicas", wireType)
			}
			m.CountDistinctMajorVersionsLoggingReplicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CountDistinctMajorVersionsLoggingReplicas |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 46:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountDelayedReplicas", wireType)
			}
			m.CountDelayedReplicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CountDelayedReplicas |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 47:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountLaggingReplicas", wireType)
			}
			m.CountLaggingReplicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CountLaggingReplicas |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := protohelpers.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protohelpers.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
