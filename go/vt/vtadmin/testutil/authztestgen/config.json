{
    "package": "vtadmin_test",
    "clusters": [
        {
            "id": "test",
            "name": "test",
            "vtctldclient_mock_data": [
                {
                    "field": "DeleteShardsResults",
                    "type": "map[string]error",
                    "value": "\"test/-\": nil,"
                },
                {
                    "field": "DeleteTabletsResults",
                    "type": "map[string]error",
                    "value": "\"zone1-0000000100\": nil,"
                },
                {
                    "field": "FindAllShardsInKeyspaceResults",
                    "type": "map[string]struct{\nResponse *vtctldatapb.FindAllShardsInKeyspaceResponse\nError error}",
                    "value": "\"test\": {\nResponse: &vtctldatapb.FindAllShardsInKeyspaceResponse{\nShards: map[string]*vtctldatapb.Shard{\n\"-\": {\nKeyspace: \"test\",\nName: \"-\",\nShard: &topodatapb.Shard{},\n},\n},\n},\n},"
                },
                {
                    "field": "GetBackupsResults",
                    "type": "map[string]struct{\nResponse *vtctldatapb.GetBackupsResponse\nError error}",
                    "value": "\"test/-\": {\nResponse: &vtctldatapb.GetBackupsResponse{\nBackups: []*mysqlctlpb.BackupInfo{\n{},\n},\n},\n},"
                },
                {
                    "field": "GetCellInfoNamesResults",
                    "type": "&struct{\nResponse *vtctldatapb.GetCellInfoNamesResponse\nError error}",
                    "value": "Response: &vtctldatapb.GetCellInfoNamesResponse{\nNames: []string{\"zone1\"},\n},"
                },
                {
                    "field": "GetCellsAliasesResults",
                    "type": "&struct{\nResponse *vtctldatapb.GetCellsAliasesResponse\nError error}",
                    "value": "Response: &vtctldatapb.GetCellsAliasesResponse{\nAliases: map[string]*topodatapb.CellsAlias{\n\"zone\": {\nCells: []string{\"zone1\"}},\n},\n},"
                },
                {
                    "field": "GetKeyspaceResults",
                    "type": "map[string]struct{\nResponse *vtctldatapb.GetKeyspaceResponse\nError error}",
                    "value": "\"test\": {\nResponse: &vtctldatapb.GetKeyspaceResponse{\nKeyspace: &vtctldatapb.Keyspace{\nName: \"test\",\nKeyspace: &topodatapb.Keyspace{},\n},\n},\n},"
                },
                {
                    "field": "GetKeyspacesResults",
                    "type": "&struct{\nKeyspaces []*vtctldatapb.Keyspace\nError error}",
                    "value": "Keyspaces: []*vtctldatapb.Keyspace{\n{\nName: \"test\",\nKeyspace: &topodatapb.Keyspace{},\n},\n},"
                }
            ],
            "db_tablet_list": [
                {
                    "tablet": {
                        "alias": {"cell": "zone1", "uid": 100}
                    }
                }
            ]
        },
        {
            "id": "other",
            "name": "other",
            "vtctldclient_mock_data": [
                {
                    "field": "FindAllShardsInKeyspaceResults",
                    "type": "map[string]struct{\nResponse *vtctldatapb.FindAllShardsInKeyspaceResponse\nError error}",
                    "value": "\"otherks\": {\nResponse: &vtctldatapb.FindAllShardsInKeyspaceResponse{\nShards: map[string]*vtctldatapb.Shard{\n\"-\": {\nKeyspace: \"otherks\",\nName: \"-\",\nShard: &topodatapb.Shard{},\n},\n},\n},\n},"
                },
                {
                    "field": "GetBackupsResults",
                    "type": "map[string]struct{\nResponse *vtctldatapb.GetBackupsResponse\nError error}",
                    "value": "\"otherks/-\": {\nResponse: &vtctldatapb.GetBackupsResponse{\nBackups: []*mysqlctlpb.BackupInfo{\n{}, {}, {},\n},\n},\n},"
                },
                {
                    "field": "GetCellInfoNamesResults",
                    "type": "&struct{\nResponse *vtctldatapb.GetCellInfoNamesResponse\nError error}",
                    "value": "Response: &vtctldatapb.GetCellInfoNamesResponse{\nNames: []string{\"other1\"},\n},"
                },
                {
                    "field": "GetCellsAliasesResults",
                    "type": "&struct{\nResponse *vtctldatapb.GetCellsAliasesResponse\nError error}",
                    "value": "Response: &vtctldatapb.GetCellsAliasesResponse{\nAliases: map[string]*topodatapb.CellsAlias{\n\"other\": {\nCells: []string{\"other1\"}},\n},\n},"
                },
                {
                    "field": "GetKeyspacesResults",
                    "type": "&struct{\nKeyspaces []*vtctldatapb.Keyspace\nError error}",
                    "value": "Keyspaces: []*vtctldatapb.Keyspace{\n{\nName: \"otherks\",\nKeyspace: &topodatapb.Keyspace{},\n},\n},"
                }
            ]
        }
    ],
    "tests": [
        {
            "method": "CreateKeyspace",
            "rules": [
                {
                    "resource": "Keyspace",
                    "actions": ["create"],
                    "subjects": ["user:allowed"],
                    "clusters": ["*"]
                }
            ],
            "request": "&vtadminpb.CreateKeyspaceRequest{\nClusterId: \"test\",\nOptions: &vtctldatapb.CreateKeyspaceRequest{\nName: \"test\",\n},\n}",
            "cases": [
                {
                    "name": "unauthorized actor",
                    "actor": {"name": "other"},
                    "include_error_var": true,
                    "assertions": [
                        "assert.Error(t, err, $$)",
                        "assert.Nil(t, resp, $$)"
                    ]
                },
                {
                    "name": "authorized actor",
                    "actor": {"name": "allowed"},
                    "include_error_var": true,
                    "is_permitted": true,
                    "assertions": [
                        "require.NoError(t, err)",
                        "assert.NotNil(t, resp, $$)"
                    ]
                }
            ]
        },
        {
            "method": "CreateShard",
            "rules": [
                {
                    "resource": "Shard",
                    "actions": ["create"],
                    "subjects": ["user:allowed"],
                    "clusters": ["*"]
                }
            ],
            "request": "&vtadminpb.CreateShardRequest{\nClusterId: \"test\",\nOptions: &vtctldatapb.CreateShardRequest{\nKeyspace: \"test\",\nShardName: \"-\",\n},\n}",
            "cases": [
                {
                    "name": "unauthorized actor",
                    "actor": {"name": "other"},
                    "include_error_var": true,
                    "assertions": [
                        "assert.Error(t, err, $$)",
                        "assert.Nil(t, resp, $$)"
                    ]
                },
                {
                    "name": "authorized actor",
                    "actor": {"name": "allowed"},
                    "include_error_var": true,
                    "is_permitted": true,
                    "assertions": [
                        "require.NoError(t, err)",
                        "assert.NotNil(t, resp, $$)"
                    ]
                }
            ]
        },
        {
            "method": "DeleteKeyspace",
            "rules": [
                {
                    "resource": "Keyspace",
                    "actions": ["delete"],
                    "subjects": ["user:allowed"],
                    "clusters": ["*"]
                }
            ],
            "request": "&vtadminpb.DeleteKeyspaceRequest{\nClusterId: \"test\",\nOptions: &vtctldatapb.DeleteKeyspaceRequest{\nKeyspace: \"test\",\n},\n}",
            "cases": [
                {
                    "name": "unauthorized actor",
                    "actor": {"name": "other"},
                    "include_error_var": true,
                    "assertions": [
                        "assert.Error(t, err, $$)",
                        "assert.Nil(t, resp, $$)"
                    ]
                },
                {
                    "name": "authorized actor",
                    "actor": {"name": "allowed"},
                    "include_error_var": true,
                    "is_permitted": true,
                    "assertions": [
                        "require.NoError(t, err)",
                        "assert.NotNil(t, resp, $$)"
                    ]
                }
            ]
        },
        {
            "method": "DeleteShards",
            "rules": [
                {
                    "resource": "Shard",
                    "actions": ["delete"],
                    "subjects": ["user:allowed"],
                    "clusters": ["*"]
                }
            ],
            "request": "&vtadminpb.DeleteShardsRequest{\nClusterId: \"test\",\nOptions: &vtctldatapb.DeleteShardsRequest{\nShards: []*vtctldatapb.Shard{\n{\nKeyspace: \"test\",\nName: \"-\",\n},\n},\n},\n}",
            "cases": [
                {
                    "name": "unauthorized actor",
                    "actor": {"name": "other"},
                    "include_error_var": true,
                    "assertions": [
                        "assert.Error(t, err, $$)",
                        "assert.Nil(t, resp, $$)"
                    ]
                },
                {
                    "name": "authorized actor",
                    "actor": {"name": "allowed"},
                    "include_error_var": true,
                    "is_permitted": true,
                    "assertions": [
                        "require.NoError(t, err)",
                        "assert.NotNil(t, resp, $$)"
                    ]
                }
            ]
        },
        {
            "method": "DeleteTablet",
            "rules": [
                {
                    "resource": "Tablet",
                    "actions": ["delete"],
                    "subjects": ["user:allowed"],
                    "clusters": ["*"]
                }
            ],
            "request": "&vtadminpb.DeleteTabletRequest{\nClusterIds: []string{\"test\"},\nAlias: &topodatapb.TabletAlias{\nCell: \"zone1\",\nUid: 100,\n},\n}",
            "cases": [
                {
                    "name": "unauthorized actor",
                    "actor": {"name": "other"},
                    "include_error_var": true,
                    "assertions": [
                        "assert.Error(t, err, $$)",
                        "assert.Nil(t, resp, $$)"
                    ]
                },
                {
                    "name": "authorized actor",
                    "actor": {"name": "allowed"},
                    "include_error_var": true,
                    "is_permitted": true,
                    "assertions": [
                        "require.NoError(t, err)",
                        "assert.NotNil(t, resp, $$)"
                    ]
                }
            ]
        },
        {
            "method": "GetBackups",
            "rules": [
                {
                    "resource": "Backup",
                    "actions": ["get"],
                    "subjects": ["user:allowed-all"],
                    "clusters": ["*"]
                },
                {
                    "resource": "Backup",
                    "actions": ["get"],
                    "subjects": ["user:allowed-other"],
                    "clusters": ["other"]
                }
            ],
            "request": "&vtadminpb.GetBackupsRequest{}",
            "cases": [
                {
                    "name": "unauthorized actor",
                    "actor": {"name": "unauthorized"},
                    "is_permitted": false,
                    "include_error_var": true,
                    "assertions": [
                        "assert.NoError(t, err)",
                        "assert.Empty(t, resp.Backups, $$)"
                    ]
                },
                {
                    "name": "partial access",
                    "actor": {"name": "allowed-other"},
                    "is_permitted": true,
                    "assertions": [
                        "assert.NotEmpty(t, resp.Backups, $$)",
                        "assert.Len(t, resp.Backups, 3, \"'other' actor should be able to see the 3 backups in cluster 'other'\")"
                    ]
                },
                {
                    "name": "full access",
                    "actor": {"name": "allowed-all"},
                    "is_permitted": true,
                    "assertions": [
                        "assert.NotEmpty(t, resp.Backups, $$)",
                        "assert.Len(t, resp.Backups, 4, \"'all' actor should be able to see backups in all clusters\")"
                    ]
                }
            ]
        },
        {
            "method": "GetCellInfos",
            "rules": [
                {
                    "resource": "CellInfo",
                    "actions": ["get"],
                    "subjects": ["user:allowed-all"],
                    "clusters": ["*"]
                },
                {
                    "resource": "CellInfo",
                    "actions": ["get"],
                    "subjects": ["user:allowed-other"],
                    "clusters": ["other"]
                }
            ],
            "request": "&vtadminpb.GetCellInfosRequest{\nNamesOnly: true,\n}",
            "cases": [
                {
                    "name": "unauthorized actor",
                    "actor": {"name": "unauthorized"},
                    "is_permitted": false,
                    "include_error_var": true,
                    "assertions": [
                        "assert.NoError(t, err)",
                        "assert.Empty(t, resp.CellInfos, $$)"
                    ]
                },
                {
                    "name": "partial access",
                    "actor": {"name": "allowed-other"},
                    "is_permitted": true,
                    "assertions": [
                        "assert.NotEmpty(t, resp.CellInfos, $$)",
                        "assert.ElementsMatch(t, resp.CellInfos, []*vtadminpb.ClusterCellInfo{{Cluster: &vtadminpb.Cluster{Id: \"other\", Name: \"other\"}, Name: \"other1\"}})"
                    ]
                },
                {
                    "name": "full access",
                    "actor": {"name": "allowed-all"},
                    "is_permitted": true,
                    "assertions": [
                        "assert.NotEmpty(t, resp.CellInfos, $$)",
                        "assert.ElementsMatch(t, resp.CellInfos, []*vtadminpb.ClusterCellInfo{{Cluster: &vtadminpb.Cluster{Id: \"test\", Name: \"test\"}, Name: \"zone1\"}, {Cluster: &vtadminpb.Cluster{Id: \"other\", Name: \"other\"}, Name: \"other1\"}})"
                    ]
                }
            ]
        },
        {
            "method": "GetCellsAliases",
            "rules": [
                {
                    "resource": "CellsAlias",
                    "actions": ["get"],
                    "subjects": ["user:allowed-all"],
                    "clusters": ["*"]
                },
                {
                    "resource": "CellsAlias",
                    "actions": ["get"],
                    "subjects": ["user:allowed-other"],
                    "clusters": ["other"]
                }
            ],
            "request": "&vtadminpb.GetCellsAliasesRequest{}",
            "cases": [
                {
                    "name": "unauthorized actor",
                    "actor": {"name": "unauthorized"},
                    "is_permitted": false,
                    "include_error_var": true,
                    "assertions": [
                        "assert.NoError(t, err)",
                        "assert.Empty(t, resp.Aliases, $$)"
                    ]
                },
                {
                    "name": "partial access",
                    "actor": {"name": "allowed-other"},
                    "is_permitted": true,
                    "assertions": [
                        "assert.NotEmpty(t, resp.Aliases, $$)",
                        "assert.ElementsMatch(t, resp.Aliases, []*vtadminpb.ClusterCellsAliases{{Cluster: &vtadminpb.Cluster{Id: \"other\", Name: \"other\"}, Aliases: map[string]*topodatapb.CellsAlias{\"other\": {Cells: []string{\"other1\"}}}}})"
                    ]
                },
                {
                    "name": "full access",
                    "actor": {"name": "allowed-all"},
                    "is_permitted": true,
                    "assertions": [
                        "assert.NotEmpty(t, resp.Aliases, $$)",
                        "assert.ElementsMatch(t, resp.Aliases, []*vtadminpb.ClusterCellsAliases{{Cluster: &vtadminpb.Cluster{Id: \"test\", Name: \"test\"}, Aliases: map[string]*topodatapb.CellsAlias{\"zone\": {Cells: []string{\"zone1\"}}}}, {Cluster: &vtadminpb.Cluster{Id: \"other\", Name: \"other\"}, Aliases: map[string]*topodatapb.CellsAlias{\"other\": {Cells: []string{\"other1\"}}}}})"
                    ]
                }
            ]
        },
        {
            "method": "GetClusters",
            "rules": [
                {
                    "resource": "Cluster",
                    "actions": ["get"],
                    "subjects": ["user:allowed"],
                    "clusters": ["*"]
                }
            ],
            "request": "&vtadminpb.GetClustersRequest{}",
            "cases": [
                {
                    "name": "unauthenticated",
                    "actor": null,
                    "assertions": [
                        "assert.Empty(t, resp.Clusters, $$)"
                    ]
                },
                {
                    "name": "unauthorized actor",
                    "actor": {"name": "other"},
                    "assertions": [
                        "assert.Empty(t, resp.Clusters, $$)"
                    ]
                },
                {
                    "name": "authorized actor",
                    "actor": {"name": "allowed"},
                    "is_permitted": true,
                    "include_error_var": true,
                    "assertions": [
                        "require.NoError(t, err)",
                        "assert.NotEmpty(t, resp.Clusters, $$)"
                    ]
                }
            ]
        },
        {
            "method": "GetGates",
            "rules": [
                {
                    "resource": "VTGate",
                    "actions": ["get"],
                    "subjects": ["user:allowed-all"],
                    "clusters": ["*"]
                },
                {
                    "resource": "VTGate",
                    "actions": ["get"],
                    "subjects": ["user:allowed-other"],
                    "clusters": ["other"]
                }
            ],
            "request": "&vtadminpb.GetGatesRequest{}",
            "serialize_cases": true,
            "cases": [
                {
                    "name": "unauthorized actor",
                    "actor": {"name": "unauthorized"},
                    "is_permitted": false,
                    "include_error_var": true,
                    "assertions": [
                        "assert.NoError(t, err)",
                        "assert.Empty(t, resp.Gates, $$)"
                    ]
                },
                {
                    "name": "partial access",
                    "actor": {"name": "allowed-other"},
                    "is_permitted": true,
                    "assertions": [
                        "assert.NotEmpty(t, resp.Gates, $$)",
                        "// testutil.BuildCluster creates exactly one gate per cluster",
                        "assert.Len(t, resp.Gates, 1, \"actor %+v should only be able to see VTGate from cluster 'other'\", actor)"
                    ]
                },
                {
                    "name": "full access",
                    "actor": {"name": "allowed-all"},
                    "is_permitted": true,
                    "assertions": [
                        "assert.NotEmpty(t, resp.Gates, $$)",
                        "// testutil.BuildCluster creates exactly one gate per cluster",
                        "assert.Len(t, resp.Gates, 2, \"actor %+v should be able to see VTGate from all clusters\", actor)"
                    ]
                }
            ]
        },
        {
            "method": "GetKeyspace",
            "rules": [
                {
                    "resource": "Keyspace",
                    "actions": ["get"],
                    "subjects": ["user:allowed"],
                    "clusters": ["*"]
                }
            ],
            "request": "&vtadminpb.GetKeyspaceRequest{\nClusterId: \"test\",\nKeyspace: \"test\",\n}",
            "cases": [
                {
                    "name": "unauthorized actor",
                    "actor": {"name": "other"},
                    "include_error_var": true,
                    "assertions": [
                        "require.NoError(t, err)",
                        "assert.Nil(t, resp, $$)"
                    ]
                },
                {
                    "name": "authorized actor",
                    "actor": {"name": "allowed"},
                    "include_error_var": true,
                    "is_permitted": true,
                    "assertions": [
                        "require.NoError(t, err)",
                        "assert.NotNil(t, resp, $$)"
                    ]
                }
            ]
        },
        {
            "method": "GetKeyspaces",
            "rules": [
                {
                    "resource": "Keyspace",
                    "actions": ["get"],
                    "subjects": ["user:allowed-all"],
                    "clusters": ["*"]
                },
                {
                    "resource": "Keyspace",
                    "actions": ["get"],
                    "subjects": ["user:allowed-other"],
                    "clusters": ["other"]
                }
            ],
            "request": "&vtadminpb.GetKeyspacesRequest{}",
            "cases": [
                {
                    "name": "unauthorized actor",
                    "actor": {"name": "unauthorized"},
                    "is_permitted": false,
                    "include_error_var": true,
                    "assertions": [
                        "assert.NoError(t, err)",
                        "assert.Empty(t, resp.Keyspaces, $$)"
                    ]
                },
                {
                    "name": "partial access",
                    "actor": {"name": "allowed-other"},
                    "is_permitted": true,
                    "assertions": [
                        "assert.NotEmpty(t, resp.Keyspaces, $$)",
                        "ksMap := map[string][]string{}",
                        "for _, ks := range resp.Keyspaces {",
                        "if _, ok := ksMap[ks.Cluster.Id]; !ok {\n ksMap[ks.Cluster.Id] = []string{}\n}",
                        "ksMap[ks.Cluster.Id] = append(ksMap[ks.Cluster.Id], ks.Keyspace.Name)",
                        "}",
                        "assert.Equal(t, ksMap, map[string][]string{\"other\": {\"otherks\"}}, $$)"
                    ]
                },
                {
                    "name": "full access",
                    "actor": {"name": "allowed-all"},
                    "is_permitted": true,
                    "assertions": [
                        "assert.NotEmpty(t, resp.Keyspaces, $$)",
                        "ksMap := map[string][]string{}",
                        "for _, ks := range resp.Keyspaces {",
                        "if _, ok := ksMap[ks.Cluster.Id]; !ok {\n ksMap[ks.Cluster.Id] = []string{}\n}",
                        "ksMap[ks.Cluster.Id] = append(ksMap[ks.Cluster.Id], ks.Keyspace.Name)",
                        "}",
                        "assert.Equal(t, ksMap, map[string][]string{\"test\": {\"test\"}, \"other\": {\"otherks\"}}, $$)"
                    ]
                }
            ]
        }
    ]
}