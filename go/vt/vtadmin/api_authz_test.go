// Code generated by testutil/authztestgen. DO NOT EDIT.

/*
Copyright 2022 The Vitess Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package vtadmin_test

import (
	"context"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"vitess.io/vitess/go/vt/vtadmin"
	"vitess.io/vitess/go/vt/vtadmin/cluster"
	"vitess.io/vitess/go/vt/vtadmin/rbac"
	"vitess.io/vitess/go/vt/vtadmin/testutil"
	"vitess.io/vitess/go/vt/vtadmin/vtctldclient/fakevtctldclient"

	mysqlctlpb "vitess.io/vitess/go/vt/proto/mysqlctl"
	topodatapb "vitess.io/vitess/go/vt/proto/topodata"
	vtadminpb "vitess.io/vitess/go/vt/proto/vtadmin"
	vtctldatapb "vitess.io/vitess/go/vt/proto/vtctldata"
)

func TestCreateKeyspace(t *testing.T) {
	opts := vtadmin.Options{
		RBAC: &rbac.Config{
			Rules: []*struct {
				Resource string
				Actions  []string
				Subjects []string
				Clusters []string
			}{
				{
					Resource: "Keyspace",
					Actions:  []string{"create"},
					Subjects: []string{"user:allowed"},
					Clusters: []string{"*"},
				},
			},
		},
	}
	err := opts.RBAC.Reify()
	require.NoError(t, err, "failed to reify authorization rules: %+v", opts.RBAC.Rules)

	api := vtadmin.NewAPI(testClusters(t), opts)
	t.Cleanup(func() {
		if err := api.Close(); err != nil {
			t.Logf("api did not close cleanly: %s", err.Error())
		}
	})

	t.Run("unauthorized actor", func(t *testing.T) {
		t.Parallel()
		actor := &rbac.Actor{Name: "other"}

		ctx := context.Background()
		if actor != nil {
			ctx = rbac.NewContext(ctx, actor)
		}

		resp, err := api.CreateKeyspace(ctx, &vtadminpb.CreateKeyspaceRequest{
			ClusterId: "test",
			Options: &vtctldatapb.CreateKeyspaceRequest{
				Name: "test",
			},
		})
		assert.Error(t, err, "actor %+v should not be permitted to CreateKeyspace", actor)
		assert.Nil(t, resp, "actor %+v should not be permitted to CreateKeyspace", actor)
	})

	t.Run("authorized actor", func(t *testing.T) {
		t.Parallel()
		actor := &rbac.Actor{Name: "allowed"}

		ctx := context.Background()
		if actor != nil {
			ctx = rbac.NewContext(ctx, actor)
		}

		resp, err := api.CreateKeyspace(ctx, &vtadminpb.CreateKeyspaceRequest{
			ClusterId: "test",
			Options: &vtctldatapb.CreateKeyspaceRequest{
				Name: "test",
			},
		})
		require.NoError(t, err)
		assert.NotNil(t, resp, "actor %+v should be permitted to CreateKeyspace", actor)
	})
}

func TestCreateShard(t *testing.T) {
	opts := vtadmin.Options{
		RBAC: &rbac.Config{
			Rules: []*struct {
				Resource string
				Actions  []string
				Subjects []string
				Clusters []string
			}{
				{
					Resource: "Shard",
					Actions:  []string{"create"},
					Subjects: []string{"user:allowed"},
					Clusters: []string{"*"},
				},
			},
		},
	}
	err := opts.RBAC.Reify()
	require.NoError(t, err, "failed to reify authorization rules: %+v", opts.RBAC.Rules)

	api := vtadmin.NewAPI(testClusters(t), opts)
	t.Cleanup(func() {
		if err := api.Close(); err != nil {
			t.Logf("api did not close cleanly: %s", err.Error())
		}
	})

	t.Run("unauthorized actor", func(t *testing.T) {
		t.Parallel()
		actor := &rbac.Actor{Name: "other"}

		ctx := context.Background()
		if actor != nil {
			ctx = rbac.NewContext(ctx, actor)
		}

		resp, err := api.CreateShard(ctx, &vtadminpb.CreateShardRequest{
			ClusterId: "test",
			Options: &vtctldatapb.CreateShardRequest{
				Keyspace:  "test",
				ShardName: "-",
			},
		})
		assert.Error(t, err, "actor %+v should not be permitted to CreateShard", actor)
		assert.Nil(t, resp, "actor %+v should not be permitted to CreateShard", actor)
	})

	t.Run("authorized actor", func(t *testing.T) {
		t.Parallel()
		actor := &rbac.Actor{Name: "allowed"}

		ctx := context.Background()
		if actor != nil {
			ctx = rbac.NewContext(ctx, actor)
		}

		resp, err := api.CreateShard(ctx, &vtadminpb.CreateShardRequest{
			ClusterId: "test",
			Options: &vtctldatapb.CreateShardRequest{
				Keyspace:  "test",
				ShardName: "-",
			},
		})
		require.NoError(t, err)
		assert.NotNil(t, resp, "actor %+v should be permitted to CreateShard", actor)
	})
}

func TestDeleteKeyspace(t *testing.T) {
	opts := vtadmin.Options{
		RBAC: &rbac.Config{
			Rules: []*struct {
				Resource string
				Actions  []string
				Subjects []string
				Clusters []string
			}{
				{
					Resource: "Keyspace",
					Actions:  []string{"delete"},
					Subjects: []string{"user:allowed"},
					Clusters: []string{"*"},
				},
			},
		},
	}
	err := opts.RBAC.Reify()
	require.NoError(t, err, "failed to reify authorization rules: %+v", opts.RBAC.Rules)

	api := vtadmin.NewAPI(testClusters(t), opts)
	t.Cleanup(func() {
		if err := api.Close(); err != nil {
			t.Logf("api did not close cleanly: %s", err.Error())
		}
	})

	t.Run("unauthorized actor", func(t *testing.T) {
		t.Parallel()
		actor := &rbac.Actor{Name: "other"}

		ctx := context.Background()
		if actor != nil {
			ctx = rbac.NewContext(ctx, actor)
		}

		resp, err := api.DeleteKeyspace(ctx, &vtadminpb.DeleteKeyspaceRequest{
			ClusterId: "test",
			Options: &vtctldatapb.DeleteKeyspaceRequest{
				Keyspace: "test",
			},
		})
		assert.Error(t, err, "actor %+v should not be permitted to DeleteKeyspace", actor)
		assert.Nil(t, resp, "actor %+v should not be permitted to DeleteKeyspace", actor)
	})

	t.Run("authorized actor", func(t *testing.T) {
		t.Parallel()
		actor := &rbac.Actor{Name: "allowed"}

		ctx := context.Background()
		if actor != nil {
			ctx = rbac.NewContext(ctx, actor)
		}

		resp, err := api.DeleteKeyspace(ctx, &vtadminpb.DeleteKeyspaceRequest{
			ClusterId: "test",
			Options: &vtctldatapb.DeleteKeyspaceRequest{
				Keyspace: "test",
			},
		})
		require.NoError(t, err)
		assert.NotNil(t, resp, "actor %+v should be permitted to DeleteKeyspace", actor)
	})
}

func TestDeleteShards(t *testing.T) {
	opts := vtadmin.Options{
		RBAC: &rbac.Config{
			Rules: []*struct {
				Resource string
				Actions  []string
				Subjects []string
				Clusters []string
			}{
				{
					Resource: "Shard",
					Actions:  []string{"delete"},
					Subjects: []string{"user:allowed"},
					Clusters: []string{"*"},
				},
			},
		},
	}
	err := opts.RBAC.Reify()
	require.NoError(t, err, "failed to reify authorization rules: %+v", opts.RBAC.Rules)

	api := vtadmin.NewAPI(testClusters(t), opts)
	t.Cleanup(func() {
		if err := api.Close(); err != nil {
			t.Logf("api did not close cleanly: %s", err.Error())
		}
	})

	t.Run("unauthorized actor", func(t *testing.T) {
		t.Parallel()
		actor := &rbac.Actor{Name: "other"}

		ctx := context.Background()
		if actor != nil {
			ctx = rbac.NewContext(ctx, actor)
		}

		resp, err := api.DeleteShards(ctx, &vtadminpb.DeleteShardsRequest{
			ClusterId: "test",
			Options: &vtctldatapb.DeleteShardsRequest{
				Shards: []*vtctldatapb.Shard{
					{
						Keyspace: "test",
						Name:     "-",
					},
				},
			},
		})
		assert.Error(t, err, "actor %+v should not be permitted to DeleteShards", actor)
		assert.Nil(t, resp, "actor %+v should not be permitted to DeleteShards", actor)
	})

	t.Run("authorized actor", func(t *testing.T) {
		t.Parallel()
		actor := &rbac.Actor{Name: "allowed"}

		ctx := context.Background()
		if actor != nil {
			ctx = rbac.NewContext(ctx, actor)
		}

		resp, err := api.DeleteShards(ctx, &vtadminpb.DeleteShardsRequest{
			ClusterId: "test",
			Options: &vtctldatapb.DeleteShardsRequest{
				Shards: []*vtctldatapb.Shard{
					{
						Keyspace: "test",
						Name:     "-",
					},
				},
			},
		})
		require.NoError(t, err)
		assert.NotNil(t, resp, "actor %+v should be permitted to DeleteShards", actor)
	})
}

func TestDeleteTablet(t *testing.T) {
	opts := vtadmin.Options{
		RBAC: &rbac.Config{
			Rules: []*struct {
				Resource string
				Actions  []string
				Subjects []string
				Clusters []string
			}{
				{
					Resource: "Tablet",
					Actions:  []string{"delete"},
					Subjects: []string{"user:allowed"},
					Clusters: []string{"*"},
				},
			},
		},
	}
	err := opts.RBAC.Reify()
	require.NoError(t, err, "failed to reify authorization rules: %+v", opts.RBAC.Rules)

	api := vtadmin.NewAPI(testClusters(t), opts)
	t.Cleanup(func() {
		if err := api.Close(); err != nil {
			t.Logf("api did not close cleanly: %s", err.Error())
		}
	})

	t.Run("unauthorized actor", func(t *testing.T) {
		t.Parallel()
		actor := &rbac.Actor{Name: "other"}

		ctx := context.Background()
		if actor != nil {
			ctx = rbac.NewContext(ctx, actor)
		}

		resp, err := api.DeleteTablet(ctx, &vtadminpb.DeleteTabletRequest{
			ClusterIds: []string{"test"},
			Alias: &topodatapb.TabletAlias{
				Cell: "zone1",
				Uid:  100,
			},
		})
		assert.Error(t, err, "actor %+v should not be permitted to DeleteTablet", actor)
		assert.Nil(t, resp, "actor %+v should not be permitted to DeleteTablet", actor)
	})

	t.Run("authorized actor", func(t *testing.T) {
		t.Parallel()
		actor := &rbac.Actor{Name: "allowed"}

		ctx := context.Background()
		if actor != nil {
			ctx = rbac.NewContext(ctx, actor)
		}

		resp, err := api.DeleteTablet(ctx, &vtadminpb.DeleteTabletRequest{
			ClusterIds: []string{"test"},
			Alias: &topodatapb.TabletAlias{
				Cell: "zone1",
				Uid:  100,
			},
		})
		require.NoError(t, err)
		assert.NotNil(t, resp, "actor %+v should be permitted to DeleteTablet", actor)
	})
}

func TestGetBackups(t *testing.T) {
	opts := vtadmin.Options{
		RBAC: &rbac.Config{
			Rules: []*struct {
				Resource string
				Actions  []string
				Subjects []string
				Clusters []string
			}{
				{
					Resource: "Backup",
					Actions:  []string{"get"},
					Subjects: []string{"user:allowed-all"},
					Clusters: []string{"*"},
				},
				{
					Resource: "Backup",
					Actions:  []string{"get"},
					Subjects: []string{"user:allowed-other"},
					Clusters: []string{"other"},
				},
			},
		},
	}
	err := opts.RBAC.Reify()
	require.NoError(t, err, "failed to reify authorization rules: %+v", opts.RBAC.Rules)

	api := vtadmin.NewAPI(testClusters(t), opts)
	t.Cleanup(func() {
		if err := api.Close(); err != nil {
			t.Logf("api did not close cleanly: %s", err.Error())
		}
	})

	t.Run("unauthorized actor", func(t *testing.T) {
		t.Parallel()
		actor := &rbac.Actor{Name: "unauthorized"}

		ctx := context.Background()
		if actor != nil {
			ctx = rbac.NewContext(ctx, actor)
		}

		resp, _ := api.GetBackups(ctx, &vtadminpb.GetBackupsRequest{})
		assert.Empty(t, resp.Backups, "actor %+v should not be permitted to GetBackups", actor)
	})

	t.Run("partial access", func(t *testing.T) {
		t.Parallel()
		actor := &rbac.Actor{Name: "allowed-other"}

		ctx := context.Background()
		if actor != nil {
			ctx = rbac.NewContext(ctx, actor)
		}

		resp, _ := api.GetBackups(ctx, &vtadminpb.GetBackupsRequest{})
		assert.NotEmpty(t, resp.Backups, "actor %+v should be permitted to GetBackups", actor)
		assert.Len(t, resp.Backups, 3, "'other' actor should be able to see the 3 backups in cluster 'other'")
	})

	t.Run("full access", func(t *testing.T) {
		t.Parallel()
		actor := &rbac.Actor{Name: "allowed-all"}

		ctx := context.Background()
		if actor != nil {
			ctx = rbac.NewContext(ctx, actor)
		}

		resp, _ := api.GetBackups(ctx, &vtadminpb.GetBackupsRequest{})
		assert.NotEmpty(t, resp.Backups, "actor %+v should be permitted to GetBackups", actor)
		assert.Len(t, resp.Backups, 4, "'all' actor should be able to see backups in all clusters")
	})
}

func TestGetClusters(t *testing.T) {
	opts := vtadmin.Options{
		RBAC: &rbac.Config{
			Rules: []*struct {
				Resource string
				Actions  []string
				Subjects []string
				Clusters []string
			}{
				{
					Resource: "Cluster",
					Actions:  []string{"get"},
					Subjects: []string{"user:allowed"},
					Clusters: []string{"*"},
				},
			},
		},
	}
	err := opts.RBAC.Reify()
	require.NoError(t, err, "failed to reify authorization rules: %+v", opts.RBAC.Rules)

	api := vtadmin.NewAPI(testClusters(t), opts)
	t.Cleanup(func() {
		if err := api.Close(); err != nil {
			t.Logf("api did not close cleanly: %s", err.Error())
		}
	})

	t.Run("unauthenticated", func(t *testing.T) {
		t.Parallel()
		var actor *rbac.Actor

		ctx := context.Background()
		if actor != nil {
			ctx = rbac.NewContext(ctx, actor)
		}

		resp, _ := api.GetClusters(ctx, &vtadminpb.GetClustersRequest{})
		assert.Empty(t, resp.Clusters, "actor %+v should not be permitted to GetClusters", actor)
	})

	t.Run("unauthorized actor", func(t *testing.T) {
		t.Parallel()
		actor := &rbac.Actor{Name: "other"}

		ctx := context.Background()
		if actor != nil {
			ctx = rbac.NewContext(ctx, actor)
		}

		resp, _ := api.GetClusters(ctx, &vtadminpb.GetClustersRequest{})
		assert.Empty(t, resp.Clusters, "actor %+v should not be permitted to GetClusters", actor)
	})

	t.Run("authorized actor", func(t *testing.T) {
		t.Parallel()
		actor := &rbac.Actor{Name: "allowed"}

		ctx := context.Background()
		if actor != nil {
			ctx = rbac.NewContext(ctx, actor)
		}

		resp, err := api.GetClusters(ctx, &vtadminpb.GetClustersRequest{})
		require.NoError(t, err)
		assert.NotEmpty(t, resp.Clusters, "actor %+v should be permitted to GetClusters", actor)
	})
}

func testClusters(t testing.TB) []*cluster.Cluster {
	configs := []testutil.TestClusterConfig{
		{
			Cluster: &vtadminpb.Cluster{
				Id:   "test",
				Name: "test",
			},
			VtctldClient: &fakevtctldclient.VtctldClient{
				DeleteShardsResults: map[string]error{
					"test/-": nil,
				},
				DeleteTabletsResults: map[string]error{
					"zone1-0000000100": nil,
				},
				FindAllShardsInKeyspaceResults: map[string]struct {
					Response *vtctldatapb.FindAllShardsInKeyspaceResponse
					Error    error
				}{
					"test": {
						Response: &vtctldatapb.FindAllShardsInKeyspaceResponse{
							Shards: map[string]*vtctldatapb.Shard{
								"-": {
									Keyspace: "test",
									Name:     "-",
									Shard:    &topodatapb.Shard{},
								},
							},
						},
					},
				},
				GetBackupsResults: map[string]struct {
					Response *vtctldatapb.GetBackupsResponse
					Error    error
				}{
					"test/-": {
						Response: &vtctldatapb.GetBackupsResponse{
							Backups: []*mysqlctlpb.BackupInfo{
								{},
							},
						},
					},
				},
				GetCellInfoNamesResults: &struct {
					Response *vtctldatapb.GetCellInfoNamesResponse
					Error    error
				}{
					Response: &vtctldatapb.GetCellInfoNamesResponse{
						Names: []string{"zone1"},
					},
				},
				GetKeyspacesResults: &struct {
					Keyspaces []*vtctldatapb.Keyspace
					Error     error
				}{
					Keyspaces: []*vtctldatapb.Keyspace{
						{
							Name:     "test",
							Keyspace: &topodatapb.Keyspace{},
						},
					},
				},
			},
			Tablets: []*vtadminpb.Tablet{
				{
					Cluster: &vtadminpb.Cluster{Id: "test", Name: "test"},
					Tablet: &topodatapb.Tablet{
						Alias: &topodatapb.TabletAlias{
							Cell: "zone1",
							Uid:  100,
						},
					},
				},
			},
		}, {
			Cluster: &vtadminpb.Cluster{
				Id:   "other",
				Name: "other",
			},
			VtctldClient: &fakevtctldclient.VtctldClient{
				FindAllShardsInKeyspaceResults: map[string]struct {
					Response *vtctldatapb.FindAllShardsInKeyspaceResponse
					Error    error
				}{
					"otherks": {
						Response: &vtctldatapb.FindAllShardsInKeyspaceResponse{
							Shards: map[string]*vtctldatapb.Shard{
								"-": {
									Keyspace: "otherks",
									Name:     "-",
									Shard:    &topodatapb.Shard{},
								},
							},
						},
					},
				},
				GetBackupsResults: map[string]struct {
					Response *vtctldatapb.GetBackupsResponse
					Error    error
				}{
					"otherks/-": {
						Response: &vtctldatapb.GetBackupsResponse{
							Backups: []*mysqlctlpb.BackupInfo{
								{}, {}, {},
							},
						},
					},
				},
				GetKeyspacesResults: &struct {
					Keyspaces []*vtctldatapb.Keyspace
					Error     error
				}{
					Keyspaces: []*vtctldatapb.Keyspace{
						{
							Name:     "otherks",
							Keyspace: &topodatapb.Keyspace{},
						},
					},
				},
			},
			Tablets: []*vtadminpb.Tablet{},
		},
	}

	return testutil.BuildClusters(t, configs...)
}
