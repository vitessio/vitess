/*
Copyright 2021 The Vitess Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
// Code generated by ASTHelperGen. DO NOT EDIT.

package sqlparser

// CloneSQLNode creates a deep clone of the input.
func CloneSQLNode(in SQLNode) SQLNode {
	if in == nil {
		return nil
	}
	switch in := in.(type) {
	case AccessMode:
		return in
	case *AddColumns:
		return CloneRefOfAddColumns(in)
	case *AddConstraintDefinition:
		return CloneRefOfAddConstraintDefinition(in)
	case *AddIndexDefinition:
		return CloneRefOfAddIndexDefinition(in)
	case AlgorithmValue:
		return in
	case *AliasedExpr:
		return CloneRefOfAliasedExpr(in)
	case *AliasedTableExpr:
		return CloneRefOfAliasedTableExpr(in)
	case *AlterCharset:
		return CloneRefOfAlterCharset(in)
	case *AlterCheck:
		return CloneRefOfAlterCheck(in)
	case *AlterColumn:
		return CloneRefOfAlterColumn(in)
	case *AlterDatabase:
		return CloneRefOfAlterDatabase(in)
	case *AlterIndex:
		return CloneRefOfAlterIndex(in)
	case *AlterMigration:
		return CloneRefOfAlterMigration(in)
	case *AlterTable:
		return CloneRefOfAlterTable(in)
	case *AlterView:
		return CloneRefOfAlterView(in)
	case *AlterVschema:
		return CloneRefOfAlterVschema(in)
	case *AndExpr:
		return CloneRefOfAndExpr(in)
	case Argument:
		return in
	case *ArgumentLessWindowExpr:
		return CloneRefOfArgumentLessWindowExpr(in)
	case *AutoIncSpec:
		return CloneRefOfAutoIncSpec(in)
	case *Begin:
		return CloneRefOfBegin(in)
	case *BetweenExpr:
		return CloneRefOfBetweenExpr(in)
	case *BinaryExpr:
		return CloneRefOfBinaryExpr(in)
	case BoolVal:
		return in
	case *CallProc:
		return CloneRefOfCallProc(in)
	case *CaseExpr:
		return CloneRefOfCaseExpr(in)
	case *ChangeColumn:
		return CloneRefOfChangeColumn(in)
	case *CheckConstraintDefinition:
		return CloneRefOfCheckConstraintDefinition(in)
	case ColIdent:
		return CloneColIdent(in)
	case *ColName:
		return CloneRefOfColName(in)
	case *CollateExpr:
		return CloneRefOfCollateExpr(in)
	case *ColumnDefinition:
		return CloneRefOfColumnDefinition(in)
	case *ColumnType:
		return CloneRefOfColumnType(in)
	case Columns:
		return CloneColumns(in)
	case *Commit:
		return CloneRefOfCommit(in)
	case *CommonTableExpr:
		return CloneRefOfCommonTableExpr(in)
	case *ComparisonExpr:
		return CloneRefOfComparisonExpr(in)
	case *ConstraintDefinition:
		return CloneRefOfConstraintDefinition(in)
	case *ConvertExpr:
		return CloneRefOfConvertExpr(in)
	case *ConvertType:
		return CloneRefOfConvertType(in)
	case *ConvertUsingExpr:
		return CloneRefOfConvertUsingExpr(in)
	case *CreateDatabase:
		return CloneRefOfCreateDatabase(in)
	case *CreateTable:
		return CloneRefOfCreateTable(in)
	case *CreateView:
		return CloneRefOfCreateView(in)
	case *CurTimeFuncExpr:
		return CloneRefOfCurTimeFuncExpr(in)
	case *DeallocateStmt:
		return CloneRefOfDeallocateStmt(in)
	case *Default:
		return CloneRefOfDefault(in)
	case *Definer:
		return CloneRefOfDefiner(in)
	case *Delete:
		return CloneRefOfDelete(in)
	case *DerivedTable:
		return CloneRefOfDerivedTable(in)
	case *DropColumn:
		return CloneRefOfDropColumn(in)
	case *DropDatabase:
		return CloneRefOfDropDatabase(in)
	case *DropKey:
		return CloneRefOfDropKey(in)
	case *DropTable:
		return CloneRefOfDropTable(in)
	case *DropView:
		return CloneRefOfDropView(in)
	case *ExecuteStmt:
		return CloneRefOfExecuteStmt(in)
	case *ExistsExpr:
		return CloneRefOfExistsExpr(in)
	case *ExplainStmt:
		return CloneRefOfExplainStmt(in)
	case *ExplainTab:
		return CloneRefOfExplainTab(in)
	case Exprs:
		return CloneExprs(in)
	case *ExtractFuncExpr:
		return CloneRefOfExtractFuncExpr(in)
	case *ExtractValueExpr:
		return CloneRefOfExtractValueExpr(in)
	case *ExtractedSubquery:
		return CloneRefOfExtractedSubquery(in)
	case *FirstOrLastValueExpr:
		return CloneRefOfFirstOrLastValueExpr(in)
	case *Flush:
		return CloneRefOfFlush(in)
	case *Force:
		return CloneRefOfForce(in)
	case *ForeignKeyDefinition:
		return CloneRefOfForeignKeyDefinition(in)
	case *FrameClause:
		return CloneRefOfFrameClause(in)
	case *FramePoint:
		return CloneRefOfFramePoint(in)
	case *FromFirstLastClause:
		return CloneRefOfFromFirstLastClause(in)
	case *FuncExpr:
		return CloneRefOfFuncExpr(in)
	case GroupBy:
		return CloneGroupBy(in)
	case *GroupConcatExpr:
		return CloneRefOfGroupConcatExpr(in)
	case *IndexDefinition:
		return CloneRefOfIndexDefinition(in)
	case *IndexHint:
		return CloneRefOfIndexHint(in)
	case IndexHints:
		return CloneIndexHints(in)
	case *IndexInfo:
		return CloneRefOfIndexInfo(in)
	case *Insert:
		return CloneRefOfInsert(in)
	case *IntervalExpr:
		return CloneRefOfIntervalExpr(in)
	case *IntroducerExpr:
		return CloneRefOfIntroducerExpr(in)
	case *IsExpr:
		return CloneRefOfIsExpr(in)
	case IsolationLevel:
		return in
	case *JSONArrayExpr:
		return CloneRefOfJSONArrayExpr(in)
	case *JSONAttributesExpr:
		return CloneRefOfJSONAttributesExpr(in)
	case *JSONContainsExpr:
		return CloneRefOfJSONContainsExpr(in)
	case *JSONContainsPathExpr:
		return CloneRefOfJSONContainsPathExpr(in)
	case *JSONExtractExpr:
		return CloneRefOfJSONExtractExpr(in)
	case *JSONKeysExpr:
		return CloneRefOfJSONKeysExpr(in)
	case *JSONObjectExpr:
		return CloneRefOfJSONObjectExpr(in)
	case JSONObjectParam:
		return CloneJSONObjectParam(in)
	case *JSONOverlapsExpr:
		return CloneRefOfJSONOverlapsExpr(in)
	case *JSONPrettyExpr:
		return CloneRefOfJSONPrettyExpr(in)
	case *JSONQuoteExpr:
		return CloneRefOfJSONQuoteExpr(in)
	case *JSONRemoveExpr:
		return CloneRefOfJSONRemoveExpr(in)
	case *JSONSchemaValidFuncExpr:
		return CloneRefOfJSONSchemaValidFuncExpr(in)
	case *JSONSchemaValidationReportFuncExpr:
		return CloneRefOfJSONSchemaValidationReportFuncExpr(in)
	case *JSONSearchExpr:
		return CloneRefOfJSONSearchExpr(in)
	case *JSONStorageFreeExpr:
		return CloneRefOfJSONStorageFreeExpr(in)
	case *JSONStorageSizeExpr:
		return CloneRefOfJSONStorageSizeExpr(in)
	case *JSONTableExpr:
		return CloneRefOfJSONTableExpr(in)
	case *JSONUnquoteExpr:
		return CloneRefOfJSONUnquoteExpr(in)
	case *JSONValueExpr:
		return CloneRefOfJSONValueExpr(in)
	case *JSONValueMergeExpr:
		return CloneRefOfJSONValueMergeExpr(in)
	case *JSONValueModifierExpr:
		return CloneRefOfJSONValueModifierExpr(in)
	case *JoinCondition:
		return CloneRefOfJoinCondition(in)
	case *JoinTableExpr:
		return CloneRefOfJoinTableExpr(in)
	case *JtColumnDefinition:
		return CloneRefOfJtColumnDefinition(in)
	case *JtOnResponse:
		return CloneRefOfJtOnResponse(in)
	case *KeyState:
		return CloneRefOfKeyState(in)
	case *LagLeadExpr:
		return CloneRefOfLagLeadExpr(in)
	case *Limit:
		return CloneRefOfLimit(in)
	case ListArg:
		return in
	case *Literal:
		return CloneRefOfLiteral(in)
	case *Load:
		return CloneRefOfLoad(in)
	case *LockOption:
		return CloneRefOfLockOption(in)
	case *LockTables:
		return CloneRefOfLockTables(in)
	case *LockingFunc:
		return CloneRefOfLockingFunc(in)
	case MatchAction:
		return in
	case *MatchExpr:
		return CloneRefOfMatchExpr(in)
	case *MemberOfExpr:
		return CloneRefOfMemberOfExpr(in)
	case *ModifyColumn:
		return CloneRefOfModifyColumn(in)
	case *NTHValueExpr:
		return CloneRefOfNTHValueExpr(in)
	case *NamedWindow:
		return CloneRefOfNamedWindow(in)
	case NamedWindows:
		return CloneNamedWindows(in)
	case *Nextval:
		return CloneRefOfNextval(in)
	case *NotExpr:
		return CloneRefOfNotExpr(in)
	case *NtileExpr:
		return CloneRefOfNtileExpr(in)
	case *NullTreatmentClause:
		return CloneRefOfNullTreatmentClause(in)
	case *NullVal:
		return CloneRefOfNullVal(in)
	case *Offset:
		return CloneRefOfOffset(in)
	case OnDup:
		return CloneOnDup(in)
	case *OptLike:
		return CloneRefOfOptLike(in)
	case *OrExpr:
		return CloneRefOfOrExpr(in)
	case *Order:
		return CloneRefOfOrder(in)
	case OrderBy:
		return CloneOrderBy(in)
	case *OrderByOption:
		return CloneRefOfOrderByOption(in)
	case *OtherAdmin:
		return CloneRefOfOtherAdmin(in)
	case *OtherRead:
		return CloneRefOfOtherRead(in)
	case *OverClause:
		return CloneRefOfOverClause(in)
	case *ParenTableExpr:
		return CloneRefOfParenTableExpr(in)
	case *ParsedComments:
		return CloneRefOfParsedComments(in)
	case *PartitionDefinition:
		return CloneRefOfPartitionDefinition(in)
	case *PartitionDefinitionOptions:
		return CloneRefOfPartitionDefinitionOptions(in)
	case *PartitionEngine:
		return CloneRefOfPartitionEngine(in)
	case *PartitionOption:
		return CloneRefOfPartitionOption(in)
	case *PartitionSpec:
		return CloneRefOfPartitionSpec(in)
	case *PartitionValueRange:
		return CloneRefOfPartitionValueRange(in)
	case Partitions:
		return ClonePartitions(in)
	case *PrepareStmt:
		return CloneRefOfPrepareStmt(in)
	case ReferenceAction:
		return in
	case *ReferenceDefinition:
		return CloneRefOfReferenceDefinition(in)
	case *RegexpInstrExpr:
		return CloneRefOfRegexpInstrExpr(in)
	case *RegexpLikeExpr:
		return CloneRefOfRegexpLikeExpr(in)
	case *RegexpReplaceExpr:
		return CloneRefOfRegexpReplaceExpr(in)
	case *RegexpSubstrExpr:
		return CloneRefOfRegexpSubstrExpr(in)
	case *Release:
		return CloneRefOfRelease(in)
	case *RenameIndex:
		return CloneRefOfRenameIndex(in)
	case *RenameTable:
		return CloneRefOfRenameTable(in)
	case *RenameTableName:
		return CloneRefOfRenameTableName(in)
	case *RevertMigration:
		return CloneRefOfRevertMigration(in)
	case *Rollback:
		return CloneRefOfRollback(in)
	case RootNode:
		return CloneRootNode(in)
	case *SRollback:
		return CloneRefOfSRollback(in)
	case *Savepoint:
		return CloneRefOfSavepoint(in)
	case *Select:
		return CloneRefOfSelect(in)
	case SelectExprs:
		return CloneSelectExprs(in)
	case *SelectInto:
		return CloneRefOfSelectInto(in)
	case *Set:
		return CloneRefOfSet(in)
	case *SetExpr:
		return CloneRefOfSetExpr(in)
	case SetExprs:
		return CloneSetExprs(in)
	case *SetTransaction:
		return CloneRefOfSetTransaction(in)
	case *Show:
		return CloneRefOfShow(in)
	case *ShowBasic:
		return CloneRefOfShowBasic(in)
	case *ShowCreate:
		return CloneRefOfShowCreate(in)
	case *ShowFilter:
		return CloneRefOfShowFilter(in)
	case *ShowMigrationLogs:
		return CloneRefOfShowMigrationLogs(in)
	case *ShowOther:
		return CloneRefOfShowOther(in)
	case *ShowThrottledApps:
		return CloneRefOfShowThrottledApps(in)
	case *StarExpr:
		return CloneRefOfStarExpr(in)
	case *Stream:
		return CloneRefOfStream(in)
	case *SubPartition:
		return CloneRefOfSubPartition(in)
	case *SubPartitionDefinition:
		return CloneRefOfSubPartitionDefinition(in)
	case *SubPartitionDefinitionOptions:
		return CloneRefOfSubPartitionDefinitionOptions(in)
	case SubPartitionDefinitions:
		return CloneSubPartitionDefinitions(in)
	case *Subquery:
		return CloneRefOfSubquery(in)
	case *SubstrExpr:
		return CloneRefOfSubstrExpr(in)
	case TableExprs:
		return CloneTableExprs(in)
	case TableIdent:
		return CloneTableIdent(in)
	case TableName:
		return CloneTableName(in)
	case TableNames:
		return CloneTableNames(in)
	case TableOptions:
		return CloneTableOptions(in)
	case *TableSpec:
		return CloneRefOfTableSpec(in)
	case *TablespaceOperation:
		return CloneRefOfTablespaceOperation(in)
	case *TimestampFuncExpr:
		return CloneRefOfTimestampFuncExpr(in)
	case *TrimFuncExpr:
		return CloneRefOfTrimFuncExpr(in)
	case *TruncateTable:
		return CloneRefOfTruncateTable(in)
	case *UnaryExpr:
		return CloneRefOfUnaryExpr(in)
	case *Union:
		return CloneRefOfUnion(in)
	case *UnlockTables:
		return CloneRefOfUnlockTables(in)
	case *Update:
		return CloneRefOfUpdate(in)
	case *UpdateExpr:
		return CloneRefOfUpdateExpr(in)
	case UpdateExprs:
		return CloneUpdateExprs(in)
	case *UpdateXMLExpr:
		return CloneRefOfUpdateXMLExpr(in)
	case *Use:
		return CloneRefOfUse(in)
	case *VStream:
		return CloneRefOfVStream(in)
	case ValTuple:
		return CloneValTuple(in)
	case *Validation:
		return CloneRefOfValidation(in)
	case Values:
		return CloneValues(in)
	case *ValuesFuncExpr:
		return CloneRefOfValuesFuncExpr(in)
	case VindexParam:
		return CloneVindexParam(in)
	case *VindexSpec:
		return CloneRefOfVindexSpec(in)
	case *WeightStringFuncExpr:
		return CloneRefOfWeightStringFuncExpr(in)
	case *When:
		return CloneRefOfWhen(in)
	case *Where:
		return CloneRefOfWhere(in)
	case *WindowDefinition:
		return CloneRefOfWindowDefinition(in)
	case WindowDefinitions:
		return CloneWindowDefinitions(in)
	case *WindowSpecification:
		return CloneRefOfWindowSpecification(in)
	case *With:
		return CloneRefOfWith(in)
	case *XorExpr:
		return CloneRefOfXorExpr(in)
	default:
		// this should never happen
		return nil
	}
}

// CloneRefOfAddColumns creates a deep clone of the input.
func CloneRefOfAddColumns(n *AddColumns) *AddColumns {
	if n == nil {
		return nil
	}
	out := *n
	out.Columns = CloneSliceOfRefOfColumnDefinition(n.Columns)
	out.After = CloneRefOfColName(n.After)
	return &out
}

// CloneRefOfAddConstraintDefinition creates a deep clone of the input.
func CloneRefOfAddConstraintDefinition(n *AddConstraintDefinition) *AddConstraintDefinition {
	if n == nil {
		return nil
	}
	out := *n
	out.ConstraintDefinition = CloneRefOfConstraintDefinition(n.ConstraintDefinition)
	return &out
}

// CloneRefOfAddIndexDefinition creates a deep clone of the input.
func CloneRefOfAddIndexDefinition(n *AddIndexDefinition) *AddIndexDefinition {
	if n == nil {
		return nil
	}
	out := *n
	out.IndexDefinition = CloneRefOfIndexDefinition(n.IndexDefinition)
	return &out
}

// CloneRefOfAliasedExpr creates a deep clone of the input.
func CloneRefOfAliasedExpr(n *AliasedExpr) *AliasedExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = CloneExpr(n.Expr)
	out.As = CloneColIdent(n.As)
	return &out
}

// CloneRefOfAliasedTableExpr creates a deep clone of the input.
func CloneRefOfAliasedTableExpr(n *AliasedTableExpr) *AliasedTableExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = CloneSimpleTableExpr(n.Expr)
	out.Partitions = ClonePartitions(n.Partitions)
	out.As = CloneTableIdent(n.As)
	out.Hints = CloneIndexHints(n.Hints)
	out.Columns = CloneColumns(n.Columns)
	return &out
}

// CloneRefOfAlterCharset creates a deep clone of the input.
func CloneRefOfAlterCharset(n *AlterCharset) *AlterCharset {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// CloneRefOfAlterCheck creates a deep clone of the input.
func CloneRefOfAlterCheck(n *AlterCheck) *AlterCheck {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = CloneColIdent(n.Name)
	return &out
}

// CloneRefOfAlterColumn creates a deep clone of the input.
func CloneRefOfAlterColumn(n *AlterColumn) *AlterColumn {
	if n == nil {
		return nil
	}
	out := *n
	out.Column = CloneRefOfColName(n.Column)
	out.DefaultVal = CloneExpr(n.DefaultVal)
	out.Invisible = CloneRefOfBool(n.Invisible)
	return &out
}

// CloneRefOfAlterDatabase creates a deep clone of the input.
func CloneRefOfAlterDatabase(n *AlterDatabase) *AlterDatabase {
	if n == nil {
		return nil
	}
	out := *n
	out.DBName = CloneTableIdent(n.DBName)
	out.AlterOptions = CloneSliceOfDatabaseOption(n.AlterOptions)
	return &out
}

// CloneRefOfAlterIndex creates a deep clone of the input.
func CloneRefOfAlterIndex(n *AlterIndex) *AlterIndex {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = CloneColIdent(n.Name)
	return &out
}

// CloneRefOfAlterMigration creates a deep clone of the input.
func CloneRefOfAlterMigration(n *AlterMigration) *AlterMigration {
	if n == nil {
		return nil
	}
	out := *n
	out.Ratio = CloneRefOfLiteral(n.Ratio)
	return &out
}

// CloneRefOfAlterTable creates a deep clone of the input.
func CloneRefOfAlterTable(n *AlterTable) *AlterTable {
	if n == nil {
		return nil
	}
	out := *n
	out.Table = CloneTableName(n.Table)
	out.AlterOptions = CloneSliceOfAlterOption(n.AlterOptions)
	out.PartitionSpec = CloneRefOfPartitionSpec(n.PartitionSpec)
	out.PartitionOption = CloneRefOfPartitionOption(n.PartitionOption)
	out.Comments = CloneRefOfParsedComments(n.Comments)
	return &out
}

// CloneRefOfAlterView creates a deep clone of the input.
func CloneRefOfAlterView(n *AlterView) *AlterView {
	if n == nil {
		return nil
	}
	out := *n
	out.ViewName = CloneTableName(n.ViewName)
	out.Definer = CloneRefOfDefiner(n.Definer)
	out.Columns = CloneColumns(n.Columns)
	out.Select = CloneSelectStatement(n.Select)
	out.Comments = CloneRefOfParsedComments(n.Comments)
	return &out
}

// CloneRefOfAlterVschema creates a deep clone of the input.
func CloneRefOfAlterVschema(n *AlterVschema) *AlterVschema {
	if n == nil {
		return nil
	}
	out := *n
	out.Table = CloneTableName(n.Table)
	out.VindexSpec = CloneRefOfVindexSpec(n.VindexSpec)
	out.VindexCols = CloneSliceOfColIdent(n.VindexCols)
	out.AutoIncSpec = CloneRefOfAutoIncSpec(n.AutoIncSpec)
	return &out
}

// CloneRefOfAndExpr creates a deep clone of the input.
func CloneRefOfAndExpr(n *AndExpr) *AndExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Left = CloneExpr(n.Left)
	out.Right = CloneExpr(n.Right)
	return &out
}

// CloneRefOfArgumentLessWindowExpr creates a deep clone of the input.
func CloneRefOfArgumentLessWindowExpr(n *ArgumentLessWindowExpr) *ArgumentLessWindowExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.OverClause = CloneRefOfOverClause(n.OverClause)
	return &out
}

// CloneRefOfAutoIncSpec creates a deep clone of the input.
func CloneRefOfAutoIncSpec(n *AutoIncSpec) *AutoIncSpec {
	if n == nil {
		return nil
	}
	out := *n
	out.Column = CloneColIdent(n.Column)
	out.Sequence = CloneTableName(n.Sequence)
	return &out
}

// CloneRefOfBegin creates a deep clone of the input.
func CloneRefOfBegin(n *Begin) *Begin {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// CloneRefOfBetweenExpr creates a deep clone of the input.
func CloneRefOfBetweenExpr(n *BetweenExpr) *BetweenExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Left = CloneExpr(n.Left)
	out.From = CloneExpr(n.From)
	out.To = CloneExpr(n.To)
	return &out
}

// CloneRefOfBinaryExpr creates a deep clone of the input.
func CloneRefOfBinaryExpr(n *BinaryExpr) *BinaryExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Left = CloneExpr(n.Left)
	out.Right = CloneExpr(n.Right)
	return &out
}

// CloneRefOfCallProc creates a deep clone of the input.
func CloneRefOfCallProc(n *CallProc) *CallProc {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = CloneTableName(n.Name)
	out.Params = CloneExprs(n.Params)
	return &out
}

// CloneRefOfCaseExpr creates a deep clone of the input.
func CloneRefOfCaseExpr(n *CaseExpr) *CaseExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = CloneExpr(n.Expr)
	out.Whens = CloneSliceOfRefOfWhen(n.Whens)
	out.Else = CloneExpr(n.Else)
	return &out
}

// CloneRefOfChangeColumn creates a deep clone of the input.
func CloneRefOfChangeColumn(n *ChangeColumn) *ChangeColumn {
	if n == nil {
		return nil
	}
	out := *n
	out.OldColumn = CloneRefOfColName(n.OldColumn)
	out.NewColDefinition = CloneRefOfColumnDefinition(n.NewColDefinition)
	out.After = CloneRefOfColName(n.After)
	return &out
}

// CloneRefOfCheckConstraintDefinition creates a deep clone of the input.
func CloneRefOfCheckConstraintDefinition(n *CheckConstraintDefinition) *CheckConstraintDefinition {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = CloneExpr(n.Expr)
	return &out
}

// CloneColIdent creates a deep clone of the input.
func CloneColIdent(n ColIdent) ColIdent {
	return *CloneRefOfColIdent(&n)
}

// CloneRefOfColName creates a deep clone of the input.
func CloneRefOfColName(n *ColName) *ColName {
	return n
}

// CloneRefOfCollateExpr creates a deep clone of the input.
func CloneRefOfCollateExpr(n *CollateExpr) *CollateExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = CloneExpr(n.Expr)
	return &out
}

// CloneRefOfColumnDefinition creates a deep clone of the input.
func CloneRefOfColumnDefinition(n *ColumnDefinition) *ColumnDefinition {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = CloneColIdent(n.Name)
	out.Type = CloneColumnType(n.Type)
	return &out
}

// CloneRefOfColumnType creates a deep clone of the input.
func CloneRefOfColumnType(n *ColumnType) *ColumnType {
	if n == nil {
		return nil
	}
	out := *n
	out.Options = CloneRefOfColumnTypeOptions(n.Options)
	out.Length = CloneRefOfLiteral(n.Length)
	out.Scale = CloneRefOfLiteral(n.Scale)
	out.Charset = CloneColumnCharset(n.Charset)
	out.EnumValues = CloneSliceOfString(n.EnumValues)
	return &out
}

// CloneColumns creates a deep clone of the input.
func CloneColumns(n Columns) Columns {
	if n == nil {
		return nil
	}
	res := make(Columns, 0, len(n))
	for _, x := range n {
		res = append(res, CloneColIdent(x))
	}
	return res
}

// CloneRefOfCommit creates a deep clone of the input.
func CloneRefOfCommit(n *Commit) *Commit {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// CloneRefOfCommonTableExpr creates a deep clone of the input.
func CloneRefOfCommonTableExpr(n *CommonTableExpr) *CommonTableExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.TableID = CloneTableIdent(n.TableID)
	out.Columns = CloneColumns(n.Columns)
	out.Subquery = CloneRefOfSubquery(n.Subquery)
	return &out
}

// CloneRefOfComparisonExpr creates a deep clone of the input.
func CloneRefOfComparisonExpr(n *ComparisonExpr) *ComparisonExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Left = CloneExpr(n.Left)
	out.Right = CloneExpr(n.Right)
	out.Escape = CloneExpr(n.Escape)
	return &out
}

// CloneRefOfConstraintDefinition creates a deep clone of the input.
func CloneRefOfConstraintDefinition(n *ConstraintDefinition) *ConstraintDefinition {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = CloneColIdent(n.Name)
	out.Details = CloneConstraintInfo(n.Details)
	return &out
}

// CloneRefOfConvertExpr creates a deep clone of the input.
func CloneRefOfConvertExpr(n *ConvertExpr) *ConvertExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = CloneExpr(n.Expr)
	out.Type = CloneRefOfConvertType(n.Type)
	return &out
}

// CloneRefOfConvertType creates a deep clone of the input.
func CloneRefOfConvertType(n *ConvertType) *ConvertType {
	if n == nil {
		return nil
	}
	out := *n
	out.Length = CloneRefOfLiteral(n.Length)
	out.Scale = CloneRefOfLiteral(n.Scale)
	out.Charset = CloneColumnCharset(n.Charset)
	return &out
}

// CloneRefOfConvertUsingExpr creates a deep clone of the input.
func CloneRefOfConvertUsingExpr(n *ConvertUsingExpr) *ConvertUsingExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = CloneExpr(n.Expr)
	return &out
}

// CloneRefOfCreateDatabase creates a deep clone of the input.
func CloneRefOfCreateDatabase(n *CreateDatabase) *CreateDatabase {
	if n == nil {
		return nil
	}
	out := *n
	out.Comments = CloneRefOfParsedComments(n.Comments)
	out.DBName = CloneTableIdent(n.DBName)
	out.CreateOptions = CloneSliceOfDatabaseOption(n.CreateOptions)
	return &out
}

// CloneRefOfCreateTable creates a deep clone of the input.
func CloneRefOfCreateTable(n *CreateTable) *CreateTable {
	if n == nil {
		return nil
	}
	out := *n
	out.Table = CloneTableName(n.Table)
	out.TableSpec = CloneRefOfTableSpec(n.TableSpec)
	out.OptLike = CloneRefOfOptLike(n.OptLike)
	out.Comments = CloneRefOfParsedComments(n.Comments)
	return &out
}

// CloneRefOfCreateView creates a deep clone of the input.
func CloneRefOfCreateView(n *CreateView) *CreateView {
	if n == nil {
		return nil
	}
	out := *n
	out.ViewName = CloneTableName(n.ViewName)
	out.Definer = CloneRefOfDefiner(n.Definer)
	out.Columns = CloneColumns(n.Columns)
	out.Select = CloneSelectStatement(n.Select)
	out.Comments = CloneRefOfParsedComments(n.Comments)
	return &out
}

// CloneRefOfCurTimeFuncExpr creates a deep clone of the input.
func CloneRefOfCurTimeFuncExpr(n *CurTimeFuncExpr) *CurTimeFuncExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = CloneColIdent(n.Name)
	out.Fsp = CloneExpr(n.Fsp)
	return &out
}

// CloneRefOfDeallocateStmt creates a deep clone of the input.
func CloneRefOfDeallocateStmt(n *DeallocateStmt) *DeallocateStmt {
	if n == nil {
		return nil
	}
	out := *n
	out.Comments = CloneRefOfParsedComments(n.Comments)
	out.Name = CloneColIdent(n.Name)
	return &out
}

// CloneRefOfDefault creates a deep clone of the input.
func CloneRefOfDefault(n *Default) *Default {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// CloneRefOfDefiner creates a deep clone of the input.
func CloneRefOfDefiner(n *Definer) *Definer {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// CloneRefOfDelete creates a deep clone of the input.
func CloneRefOfDelete(n *Delete) *Delete {
	if n == nil {
		return nil
	}
	out := *n
	out.With = CloneRefOfWith(n.With)
	out.Comments = CloneRefOfParsedComments(n.Comments)
	out.Targets = CloneTableNames(n.Targets)
	out.TableExprs = CloneTableExprs(n.TableExprs)
	out.Partitions = ClonePartitions(n.Partitions)
	out.Where = CloneRefOfWhere(n.Where)
	out.OrderBy = CloneOrderBy(n.OrderBy)
	out.Limit = CloneRefOfLimit(n.Limit)
	return &out
}

// CloneRefOfDerivedTable creates a deep clone of the input.
func CloneRefOfDerivedTable(n *DerivedTable) *DerivedTable {
	if n == nil {
		return nil
	}
	out := *n
	out.Select = CloneSelectStatement(n.Select)
	return &out
}

// CloneRefOfDropColumn creates a deep clone of the input.
func CloneRefOfDropColumn(n *DropColumn) *DropColumn {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = CloneRefOfColName(n.Name)
	return &out
}

// CloneRefOfDropDatabase creates a deep clone of the input.
func CloneRefOfDropDatabase(n *DropDatabase) *DropDatabase {
	if n == nil {
		return nil
	}
	out := *n
	out.Comments = CloneRefOfParsedComments(n.Comments)
	out.DBName = CloneTableIdent(n.DBName)
	return &out
}

// CloneRefOfDropKey creates a deep clone of the input.
func CloneRefOfDropKey(n *DropKey) *DropKey {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = CloneColIdent(n.Name)
	return &out
}

// CloneRefOfDropTable creates a deep clone of the input.
func CloneRefOfDropTable(n *DropTable) *DropTable {
	if n == nil {
		return nil
	}
	out := *n
	out.FromTables = CloneTableNames(n.FromTables)
	out.Comments = CloneRefOfParsedComments(n.Comments)
	return &out
}

// CloneRefOfDropView creates a deep clone of the input.
func CloneRefOfDropView(n *DropView) *DropView {
	if n == nil {
		return nil
	}
	out := *n
	out.FromTables = CloneTableNames(n.FromTables)
	out.Comments = CloneRefOfParsedComments(n.Comments)
	return &out
}

// CloneRefOfExecuteStmt creates a deep clone of the input.
func CloneRefOfExecuteStmt(n *ExecuteStmt) *ExecuteStmt {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = CloneColIdent(n.Name)
	out.Comments = CloneRefOfParsedComments(n.Comments)
	out.Arguments = CloneColumns(n.Arguments)
	return &out
}

// CloneRefOfExistsExpr creates a deep clone of the input.
func CloneRefOfExistsExpr(n *ExistsExpr) *ExistsExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Subquery = CloneRefOfSubquery(n.Subquery)
	return &out
}

// CloneRefOfExplainStmt creates a deep clone of the input.
func CloneRefOfExplainStmt(n *ExplainStmt) *ExplainStmt {
	if n == nil {
		return nil
	}
	out := *n
	out.Statement = CloneStatement(n.Statement)
	return &out
}

// CloneRefOfExplainTab creates a deep clone of the input.
func CloneRefOfExplainTab(n *ExplainTab) *ExplainTab {
	if n == nil {
		return nil
	}
	out := *n
	out.Table = CloneTableName(n.Table)
	return &out
}

// CloneExprs creates a deep clone of the input.
func CloneExprs(n Exprs) Exprs {
	if n == nil {
		return nil
	}
	res := make(Exprs, 0, len(n))
	for _, x := range n {
		res = append(res, CloneExpr(x))
	}
	return res
}

// CloneRefOfExtractFuncExpr creates a deep clone of the input.
func CloneRefOfExtractFuncExpr(n *ExtractFuncExpr) *ExtractFuncExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = CloneExpr(n.Expr)
	return &out
}

// CloneRefOfExtractValueExpr creates a deep clone of the input.
func CloneRefOfExtractValueExpr(n *ExtractValueExpr) *ExtractValueExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Fragment = CloneExpr(n.Fragment)
	out.XPathExpr = CloneExpr(n.XPathExpr)
	return &out
}

// CloneRefOfExtractedSubquery creates a deep clone of the input.
func CloneRefOfExtractedSubquery(n *ExtractedSubquery) *ExtractedSubquery {
	if n == nil {
		return nil
	}
	out := *n
	out.Original = CloneExpr(n.Original)
	out.Subquery = CloneRefOfSubquery(n.Subquery)
	out.OtherSide = CloneExpr(n.OtherSide)
	out.alternative = CloneExpr(n.alternative)
	return &out
}

// CloneRefOfFirstOrLastValueExpr creates a deep clone of the input.
func CloneRefOfFirstOrLastValueExpr(n *FirstOrLastValueExpr) *FirstOrLastValueExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = CloneExpr(n.Expr)
	out.NullTreatmentClause = CloneRefOfNullTreatmentClause(n.NullTreatmentClause)
	out.OverClause = CloneRefOfOverClause(n.OverClause)
	return &out
}

// CloneRefOfFlush creates a deep clone of the input.
func CloneRefOfFlush(n *Flush) *Flush {
	if n == nil {
		return nil
	}
	out := *n
	out.FlushOptions = CloneSliceOfString(n.FlushOptions)
	out.TableNames = CloneTableNames(n.TableNames)
	return &out
}

// CloneRefOfForce creates a deep clone of the input.
func CloneRefOfForce(n *Force) *Force {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// CloneRefOfForeignKeyDefinition creates a deep clone of the input.
func CloneRefOfForeignKeyDefinition(n *ForeignKeyDefinition) *ForeignKeyDefinition {
	if n == nil {
		return nil
	}
	out := *n
	out.Source = CloneColumns(n.Source)
	out.IndexName = CloneColIdent(n.IndexName)
	out.ReferenceDefinition = CloneRefOfReferenceDefinition(n.ReferenceDefinition)
	return &out
}

// CloneRefOfFrameClause creates a deep clone of the input.
func CloneRefOfFrameClause(n *FrameClause) *FrameClause {
	if n == nil {
		return nil
	}
	out := *n
	out.Start = CloneRefOfFramePoint(n.Start)
	out.End = CloneRefOfFramePoint(n.End)
	return &out
}

// CloneRefOfFramePoint creates a deep clone of the input.
func CloneRefOfFramePoint(n *FramePoint) *FramePoint {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = CloneExpr(n.Expr)
	return &out
}

// CloneRefOfFromFirstLastClause creates a deep clone of the input.
func CloneRefOfFromFirstLastClause(n *FromFirstLastClause) *FromFirstLastClause {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// CloneRefOfFuncExpr creates a deep clone of the input.
func CloneRefOfFuncExpr(n *FuncExpr) *FuncExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Qualifier = CloneTableIdent(n.Qualifier)
	out.Name = CloneColIdent(n.Name)
	out.Exprs = CloneSelectExprs(n.Exprs)
	return &out
}

// CloneGroupBy creates a deep clone of the input.
func CloneGroupBy(n GroupBy) GroupBy {
	if n == nil {
		return nil
	}
	res := make(GroupBy, 0, len(n))
	for _, x := range n {
		res = append(res, CloneExpr(x))
	}
	return res
}

// CloneRefOfGroupConcatExpr creates a deep clone of the input.
func CloneRefOfGroupConcatExpr(n *GroupConcatExpr) *GroupConcatExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Exprs = CloneSelectExprs(n.Exprs)
	out.OrderBy = CloneOrderBy(n.OrderBy)
	out.Limit = CloneRefOfLimit(n.Limit)
	return &out
}

// CloneRefOfIndexDefinition creates a deep clone of the input.
func CloneRefOfIndexDefinition(n *IndexDefinition) *IndexDefinition {
	if n == nil {
		return nil
	}
	out := *n
	out.Info = CloneRefOfIndexInfo(n.Info)
	out.Columns = CloneSliceOfRefOfIndexColumn(n.Columns)
	out.Options = CloneSliceOfRefOfIndexOption(n.Options)
	return &out
}

// CloneRefOfIndexHint creates a deep clone of the input.
func CloneRefOfIndexHint(n *IndexHint) *IndexHint {
	if n == nil {
		return nil
	}
	out := *n
	out.Indexes = CloneSliceOfColIdent(n.Indexes)
	return &out
}

// CloneIndexHints creates a deep clone of the input.
func CloneIndexHints(n IndexHints) IndexHints {
	if n == nil {
		return nil
	}
	res := make(IndexHints, 0, len(n))
	for _, x := range n {
		res = append(res, CloneRefOfIndexHint(x))
	}
	return res
}

// CloneRefOfIndexInfo creates a deep clone of the input.
func CloneRefOfIndexInfo(n *IndexInfo) *IndexInfo {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = CloneColIdent(n.Name)
	out.ConstraintName = CloneColIdent(n.ConstraintName)
	return &out
}

// CloneRefOfInsert creates a deep clone of the input.
func CloneRefOfInsert(n *Insert) *Insert {
	if n == nil {
		return nil
	}
	out := *n
	out.Comments = CloneRefOfParsedComments(n.Comments)
	out.Table = CloneTableName(n.Table)
	out.Partitions = ClonePartitions(n.Partitions)
	out.Columns = CloneColumns(n.Columns)
	out.Rows = CloneInsertRows(n.Rows)
	out.OnDup = CloneOnDup(n.OnDup)
	return &out
}

// CloneRefOfIntervalExpr creates a deep clone of the input.
func CloneRefOfIntervalExpr(n *IntervalExpr) *IntervalExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = CloneExpr(n.Expr)
	return &out
}

// CloneRefOfIntroducerExpr creates a deep clone of the input.
func CloneRefOfIntroducerExpr(n *IntroducerExpr) *IntroducerExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = CloneExpr(n.Expr)
	return &out
}

// CloneRefOfIsExpr creates a deep clone of the input.
func CloneRefOfIsExpr(n *IsExpr) *IsExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Left = CloneExpr(n.Left)
	return &out
}

// CloneRefOfJSONArrayExpr creates a deep clone of the input.
func CloneRefOfJSONArrayExpr(n *JSONArrayExpr) *JSONArrayExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Params = CloneExprs(n.Params)
	return &out
}

// CloneRefOfJSONAttributesExpr creates a deep clone of the input.
func CloneRefOfJSONAttributesExpr(n *JSONAttributesExpr) *JSONAttributesExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.JSONDoc = CloneExpr(n.JSONDoc)
	out.Path = CloneJSONPathParam(n.Path)
	return &out
}

// CloneRefOfJSONContainsExpr creates a deep clone of the input.
func CloneRefOfJSONContainsExpr(n *JSONContainsExpr) *JSONContainsExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Target = CloneExpr(n.Target)
	out.Candidate = CloneExpr(n.Candidate)
	out.PathList = CloneSliceOfJSONPathParam(n.PathList)
	return &out
}

// CloneRefOfJSONContainsPathExpr creates a deep clone of the input.
func CloneRefOfJSONContainsPathExpr(n *JSONContainsPathExpr) *JSONContainsPathExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.JSONDoc = CloneExpr(n.JSONDoc)
	out.OneOrAll = CloneExpr(n.OneOrAll)
	out.PathList = CloneSliceOfJSONPathParam(n.PathList)
	return &out
}

// CloneRefOfJSONExtractExpr creates a deep clone of the input.
func CloneRefOfJSONExtractExpr(n *JSONExtractExpr) *JSONExtractExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.JSONDoc = CloneExpr(n.JSONDoc)
	out.PathList = CloneSliceOfJSONPathParam(n.PathList)
	return &out
}

// CloneRefOfJSONKeysExpr creates a deep clone of the input.
func CloneRefOfJSONKeysExpr(n *JSONKeysExpr) *JSONKeysExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.JSONDoc = CloneExpr(n.JSONDoc)
	out.PathList = CloneSliceOfJSONPathParam(n.PathList)
	return &out
}

// CloneRefOfJSONObjectExpr creates a deep clone of the input.
func CloneRefOfJSONObjectExpr(n *JSONObjectExpr) *JSONObjectExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Params = CloneSliceOfRefOfJSONObjectParam(n.Params)
	return &out
}

// CloneJSONObjectParam creates a deep clone of the input.
func CloneJSONObjectParam(n JSONObjectParam) JSONObjectParam {
	return *CloneRefOfJSONObjectParam(&n)
}

// CloneRefOfJSONOverlapsExpr creates a deep clone of the input.
func CloneRefOfJSONOverlapsExpr(n *JSONOverlapsExpr) *JSONOverlapsExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.JSONDoc1 = CloneExpr(n.JSONDoc1)
	out.JSONDoc2 = CloneExpr(n.JSONDoc2)
	return &out
}

// CloneRefOfJSONPrettyExpr creates a deep clone of the input.
func CloneRefOfJSONPrettyExpr(n *JSONPrettyExpr) *JSONPrettyExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.JSONVal = CloneExpr(n.JSONVal)
	return &out
}

// CloneRefOfJSONQuoteExpr creates a deep clone of the input.
func CloneRefOfJSONQuoteExpr(n *JSONQuoteExpr) *JSONQuoteExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.StringArg = CloneExpr(n.StringArg)
	return &out
}

// CloneRefOfJSONRemoveExpr creates a deep clone of the input.
func CloneRefOfJSONRemoveExpr(n *JSONRemoveExpr) *JSONRemoveExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.JSONDoc = CloneExpr(n.JSONDoc)
	out.PathList = CloneExprs(n.PathList)
	return &out
}

// CloneRefOfJSONSchemaValidFuncExpr creates a deep clone of the input.
func CloneRefOfJSONSchemaValidFuncExpr(n *JSONSchemaValidFuncExpr) *JSONSchemaValidFuncExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Schema = CloneExpr(n.Schema)
	out.Document = CloneExpr(n.Document)
	return &out
}

// CloneRefOfJSONSchemaValidationReportFuncExpr creates a deep clone of the input.
func CloneRefOfJSONSchemaValidationReportFuncExpr(n *JSONSchemaValidationReportFuncExpr) *JSONSchemaValidationReportFuncExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Schema = CloneExpr(n.Schema)
	out.Document = CloneExpr(n.Document)
	return &out
}

// CloneRefOfJSONSearchExpr creates a deep clone of the input.
func CloneRefOfJSONSearchExpr(n *JSONSearchExpr) *JSONSearchExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.JSONDoc = CloneExpr(n.JSONDoc)
	out.OneOrAll = CloneExpr(n.OneOrAll)
	out.SearchStr = CloneExpr(n.SearchStr)
	out.EscapeChar = CloneExpr(n.EscapeChar)
	out.PathList = CloneSliceOfJSONPathParam(n.PathList)
	return &out
}

// CloneRefOfJSONStorageFreeExpr creates a deep clone of the input.
func CloneRefOfJSONStorageFreeExpr(n *JSONStorageFreeExpr) *JSONStorageFreeExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.JSONVal = CloneExpr(n.JSONVal)
	return &out
}

// CloneRefOfJSONStorageSizeExpr creates a deep clone of the input.
func CloneRefOfJSONStorageSizeExpr(n *JSONStorageSizeExpr) *JSONStorageSizeExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.JSONVal = CloneExpr(n.JSONVal)
	return &out
}

// CloneRefOfJSONTableExpr creates a deep clone of the input.
func CloneRefOfJSONTableExpr(n *JSONTableExpr) *JSONTableExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = CloneExpr(n.Expr)
	out.Alias = CloneTableIdent(n.Alias)
	out.Filter = CloneExpr(n.Filter)
	out.Columns = CloneSliceOfRefOfJtColumnDefinition(n.Columns)
	return &out
}

// CloneRefOfJSONUnquoteExpr creates a deep clone of the input.
func CloneRefOfJSONUnquoteExpr(n *JSONUnquoteExpr) *JSONUnquoteExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.JSONValue = CloneExpr(n.JSONValue)
	return &out
}

// CloneRefOfJSONValueExpr creates a deep clone of the input.
func CloneRefOfJSONValueExpr(n *JSONValueExpr) *JSONValueExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.JSONDoc = CloneExpr(n.JSONDoc)
	out.Path = CloneJSONPathParam(n.Path)
	out.ReturningType = CloneRefOfConvertType(n.ReturningType)
	out.EmptyOnResponse = CloneRefOfJtOnResponse(n.EmptyOnResponse)
	out.ErrorOnResponse = CloneRefOfJtOnResponse(n.ErrorOnResponse)
	return &out
}

// CloneRefOfJSONValueMergeExpr creates a deep clone of the input.
func CloneRefOfJSONValueMergeExpr(n *JSONValueMergeExpr) *JSONValueMergeExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.JSONDoc = CloneExpr(n.JSONDoc)
	out.JSONDocList = CloneExprs(n.JSONDocList)
	return &out
}

// CloneRefOfJSONValueModifierExpr creates a deep clone of the input.
func CloneRefOfJSONValueModifierExpr(n *JSONValueModifierExpr) *JSONValueModifierExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.JSONDoc = CloneExpr(n.JSONDoc)
	out.Params = CloneSliceOfRefOfJSONObjectParam(n.Params)
	return &out
}

// CloneRefOfJoinCondition creates a deep clone of the input.
func CloneRefOfJoinCondition(n *JoinCondition) *JoinCondition {
	if n == nil {
		return nil
	}
	out := *n
	out.On = CloneExpr(n.On)
	out.Using = CloneColumns(n.Using)
	return &out
}

// CloneRefOfJoinTableExpr creates a deep clone of the input.
func CloneRefOfJoinTableExpr(n *JoinTableExpr) *JoinTableExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.LeftExpr = CloneTableExpr(n.LeftExpr)
	out.RightExpr = CloneTableExpr(n.RightExpr)
	out.Condition = CloneRefOfJoinCondition(n.Condition)
	return &out
}

// CloneRefOfJtColumnDefinition creates a deep clone of the input.
func CloneRefOfJtColumnDefinition(n *JtColumnDefinition) *JtColumnDefinition {
	if n == nil {
		return nil
	}
	out := *n
	out.JtOrdinal = CloneRefOfJtOrdinalColDef(n.JtOrdinal)
	out.JtPath = CloneRefOfJtPathColDef(n.JtPath)
	out.JtNestedPath = CloneRefOfJtNestedPathColDef(n.JtNestedPath)
	return &out
}

// CloneRefOfJtOnResponse creates a deep clone of the input.
func CloneRefOfJtOnResponse(n *JtOnResponse) *JtOnResponse {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = CloneExpr(n.Expr)
	return &out
}

// CloneRefOfKeyState creates a deep clone of the input.
func CloneRefOfKeyState(n *KeyState) *KeyState {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// CloneRefOfLagLeadExpr creates a deep clone of the input.
func CloneRefOfLagLeadExpr(n *LagLeadExpr) *LagLeadExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = CloneExpr(n.Expr)
	out.N = CloneExpr(n.N)
	out.Default = CloneExpr(n.Default)
	out.OverClause = CloneRefOfOverClause(n.OverClause)
	out.NullTreatmentClause = CloneRefOfNullTreatmentClause(n.NullTreatmentClause)
	return &out
}

// CloneRefOfLimit creates a deep clone of the input.
func CloneRefOfLimit(n *Limit) *Limit {
	if n == nil {
		return nil
	}
	out := *n
	out.Offset = CloneExpr(n.Offset)
	out.Rowcount = CloneExpr(n.Rowcount)
	return &out
}

// CloneRefOfLiteral creates a deep clone of the input.
func CloneRefOfLiteral(n *Literal) *Literal {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// CloneRefOfLoad creates a deep clone of the input.
func CloneRefOfLoad(n *Load) *Load {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// CloneRefOfLockOption creates a deep clone of the input.
func CloneRefOfLockOption(n *LockOption) *LockOption {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// CloneRefOfLockTables creates a deep clone of the input.
func CloneRefOfLockTables(n *LockTables) *LockTables {
	if n == nil {
		return nil
	}
	out := *n
	out.Tables = CloneTableAndLockTypes(n.Tables)
	return &out
}

// CloneRefOfLockingFunc creates a deep clone of the input.
func CloneRefOfLockingFunc(n *LockingFunc) *LockingFunc {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = CloneExpr(n.Name)
	out.Timeout = CloneExpr(n.Timeout)
	return &out
}

// CloneRefOfMatchExpr creates a deep clone of the input.
func CloneRefOfMatchExpr(n *MatchExpr) *MatchExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Columns = CloneSelectExprs(n.Columns)
	out.Expr = CloneExpr(n.Expr)
	return &out
}

// CloneRefOfMemberOfExpr creates a deep clone of the input.
func CloneRefOfMemberOfExpr(n *MemberOfExpr) *MemberOfExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Value = CloneExpr(n.Value)
	out.JSONArr = CloneExpr(n.JSONArr)
	return &out
}

// CloneRefOfModifyColumn creates a deep clone of the input.
func CloneRefOfModifyColumn(n *ModifyColumn) *ModifyColumn {
	if n == nil {
		return nil
	}
	out := *n
	out.NewColDefinition = CloneRefOfColumnDefinition(n.NewColDefinition)
	out.After = CloneRefOfColName(n.After)
	return &out
}

// CloneRefOfNTHValueExpr creates a deep clone of the input.
func CloneRefOfNTHValueExpr(n *NTHValueExpr) *NTHValueExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = CloneExpr(n.Expr)
	out.N = CloneExpr(n.N)
	out.OverClause = CloneRefOfOverClause(n.OverClause)
	out.FromFirstLastClause = CloneRefOfFromFirstLastClause(n.FromFirstLastClause)
	out.NullTreatmentClause = CloneRefOfNullTreatmentClause(n.NullTreatmentClause)
	return &out
}

// CloneRefOfNamedWindow creates a deep clone of the input.
func CloneRefOfNamedWindow(n *NamedWindow) *NamedWindow {
	if n == nil {
		return nil
	}
	out := *n
	out.Windows = CloneWindowDefinitions(n.Windows)
	return &out
}

// CloneNamedWindows creates a deep clone of the input.
func CloneNamedWindows(n NamedWindows) NamedWindows {
	if n == nil {
		return nil
	}
	res := make(NamedWindows, 0, len(n))
	for _, x := range n {
		res = append(res, CloneRefOfNamedWindow(x))
	}
	return res
}

// CloneRefOfNextval creates a deep clone of the input.
func CloneRefOfNextval(n *Nextval) *Nextval {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = CloneExpr(n.Expr)
	return &out
}

// CloneRefOfNotExpr creates a deep clone of the input.
func CloneRefOfNotExpr(n *NotExpr) *NotExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = CloneExpr(n.Expr)
	return &out
}

// CloneRefOfNtileExpr creates a deep clone of the input.
func CloneRefOfNtileExpr(n *NtileExpr) *NtileExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.N = CloneExpr(n.N)
	out.OverClause = CloneRefOfOverClause(n.OverClause)
	return &out
}

// CloneRefOfNullTreatmentClause creates a deep clone of the input.
func CloneRefOfNullTreatmentClause(n *NullTreatmentClause) *NullTreatmentClause {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// CloneRefOfNullVal creates a deep clone of the input.
func CloneRefOfNullVal(n *NullVal) *NullVal {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// CloneRefOfOffset creates a deep clone of the input.
func CloneRefOfOffset(n *Offset) *Offset {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// CloneOnDup creates a deep clone of the input.
func CloneOnDup(n OnDup) OnDup {
	if n == nil {
		return nil
	}
	res := make(OnDup, 0, len(n))
	for _, x := range n {
		res = append(res, CloneRefOfUpdateExpr(x))
	}
	return res
}

// CloneRefOfOptLike creates a deep clone of the input.
func CloneRefOfOptLike(n *OptLike) *OptLike {
	if n == nil {
		return nil
	}
	out := *n
	out.LikeTable = CloneTableName(n.LikeTable)
	return &out
}

// CloneRefOfOrExpr creates a deep clone of the input.
func CloneRefOfOrExpr(n *OrExpr) *OrExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Left = CloneExpr(n.Left)
	out.Right = CloneExpr(n.Right)
	return &out
}

// CloneRefOfOrder creates a deep clone of the input.
func CloneRefOfOrder(n *Order) *Order {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = CloneExpr(n.Expr)
	return &out
}

// CloneOrderBy creates a deep clone of the input.
func CloneOrderBy(n OrderBy) OrderBy {
	if n == nil {
		return nil
	}
	res := make(OrderBy, 0, len(n))
	for _, x := range n {
		res = append(res, CloneRefOfOrder(x))
	}
	return res
}

// CloneRefOfOrderByOption creates a deep clone of the input.
func CloneRefOfOrderByOption(n *OrderByOption) *OrderByOption {
	if n == nil {
		return nil
	}
	out := *n
	out.Cols = CloneColumns(n.Cols)
	return &out
}

// CloneRefOfOtherAdmin creates a deep clone of the input.
func CloneRefOfOtherAdmin(n *OtherAdmin) *OtherAdmin {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// CloneRefOfOtherRead creates a deep clone of the input.
func CloneRefOfOtherRead(n *OtherRead) *OtherRead {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// CloneRefOfOverClause creates a deep clone of the input.
func CloneRefOfOverClause(n *OverClause) *OverClause {
	if n == nil {
		return nil
	}
	out := *n
	out.WindowName = CloneColIdent(n.WindowName)
	out.WindowSpec = CloneRefOfWindowSpecification(n.WindowSpec)
	return &out
}

// CloneRefOfParenTableExpr creates a deep clone of the input.
func CloneRefOfParenTableExpr(n *ParenTableExpr) *ParenTableExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Exprs = CloneTableExprs(n.Exprs)
	return &out
}

// CloneRefOfParsedComments creates a deep clone of the input.
func CloneRefOfParsedComments(n *ParsedComments) *ParsedComments {
	if n == nil {
		return nil
	}
	out := *n
	out.comments = CloneComments(n.comments)
	return &out
}

// CloneRefOfPartitionDefinition creates a deep clone of the input.
func CloneRefOfPartitionDefinition(n *PartitionDefinition) *PartitionDefinition {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = CloneColIdent(n.Name)
	out.Options = CloneRefOfPartitionDefinitionOptions(n.Options)
	return &out
}

// CloneRefOfPartitionDefinitionOptions creates a deep clone of the input.
func CloneRefOfPartitionDefinitionOptions(n *PartitionDefinitionOptions) *PartitionDefinitionOptions {
	if n == nil {
		return nil
	}
	out := *n
	out.ValueRange = CloneRefOfPartitionValueRange(n.ValueRange)
	out.Comment = CloneRefOfLiteral(n.Comment)
	out.Engine = CloneRefOfPartitionEngine(n.Engine)
	out.DataDirectory = CloneRefOfLiteral(n.DataDirectory)
	out.IndexDirectory = CloneRefOfLiteral(n.IndexDirectory)
	out.MaxRows = CloneRefOfInt(n.MaxRows)
	out.MinRows = CloneRefOfInt(n.MinRows)
	out.SubPartitionDefinitions = CloneSubPartitionDefinitions(n.SubPartitionDefinitions)
	return &out
}

// CloneRefOfPartitionEngine creates a deep clone of the input.
func CloneRefOfPartitionEngine(n *PartitionEngine) *PartitionEngine {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// CloneRefOfPartitionOption creates a deep clone of the input.
func CloneRefOfPartitionOption(n *PartitionOption) *PartitionOption {
	if n == nil {
		return nil
	}
	out := *n
	out.ColList = CloneColumns(n.ColList)
	out.Expr = CloneExpr(n.Expr)
	out.SubPartition = CloneRefOfSubPartition(n.SubPartition)
	out.Definitions = CloneSliceOfRefOfPartitionDefinition(n.Definitions)
	return &out
}

// CloneRefOfPartitionSpec creates a deep clone of the input.
func CloneRefOfPartitionSpec(n *PartitionSpec) *PartitionSpec {
	if n == nil {
		return nil
	}
	out := *n
	out.Names = ClonePartitions(n.Names)
	out.Number = CloneRefOfLiteral(n.Number)
	out.TableName = CloneTableName(n.TableName)
	out.Definitions = CloneSliceOfRefOfPartitionDefinition(n.Definitions)
	return &out
}

// CloneRefOfPartitionValueRange creates a deep clone of the input.
func CloneRefOfPartitionValueRange(n *PartitionValueRange) *PartitionValueRange {
	if n == nil {
		return nil
	}
	out := *n
	out.Range = CloneValTuple(n.Range)
	return &out
}

// ClonePartitions creates a deep clone of the input.
func ClonePartitions(n Partitions) Partitions {
	if n == nil {
		return nil
	}
	res := make(Partitions, 0, len(n))
	for _, x := range n {
		res = append(res, CloneColIdent(x))
	}
	return res
}

// CloneRefOfPrepareStmt creates a deep clone of the input.
func CloneRefOfPrepareStmt(n *PrepareStmt) *PrepareStmt {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = CloneColIdent(n.Name)
	out.Statement = CloneExpr(n.Statement)
	out.Comments = CloneRefOfParsedComments(n.Comments)
	return &out
}

// CloneRefOfReferenceDefinition creates a deep clone of the input.
func CloneRefOfReferenceDefinition(n *ReferenceDefinition) *ReferenceDefinition {
	if n == nil {
		return nil
	}
	out := *n
	out.ReferencedTable = CloneTableName(n.ReferencedTable)
	out.ReferencedColumns = CloneColumns(n.ReferencedColumns)
	return &out
}

// CloneRefOfRegexpInstrExpr creates a deep clone of the input.
func CloneRefOfRegexpInstrExpr(n *RegexpInstrExpr) *RegexpInstrExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = CloneExpr(n.Expr)
	out.Pattern = CloneExpr(n.Pattern)
	out.Position = CloneExpr(n.Position)
	out.Occurrence = CloneExpr(n.Occurrence)
	out.ReturnOption = CloneExpr(n.ReturnOption)
	out.MatchType = CloneExpr(n.MatchType)
	return &out
}

// CloneRefOfRegexpLikeExpr creates a deep clone of the input.
func CloneRefOfRegexpLikeExpr(n *RegexpLikeExpr) *RegexpLikeExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = CloneExpr(n.Expr)
	out.Pattern = CloneExpr(n.Pattern)
	out.MatchType = CloneExpr(n.MatchType)
	return &out
}

// CloneRefOfRegexpReplaceExpr creates a deep clone of the input.
func CloneRefOfRegexpReplaceExpr(n *RegexpReplaceExpr) *RegexpReplaceExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = CloneExpr(n.Expr)
	out.Pattern = CloneExpr(n.Pattern)
	out.Repl = CloneExpr(n.Repl)
	out.Occurrence = CloneExpr(n.Occurrence)
	out.Position = CloneExpr(n.Position)
	out.MatchType = CloneExpr(n.MatchType)
	return &out
}

// CloneRefOfRegexpSubstrExpr creates a deep clone of the input.
func CloneRefOfRegexpSubstrExpr(n *RegexpSubstrExpr) *RegexpSubstrExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = CloneExpr(n.Expr)
	out.Pattern = CloneExpr(n.Pattern)
	out.Occurrence = CloneExpr(n.Occurrence)
	out.Position = CloneExpr(n.Position)
	out.MatchType = CloneExpr(n.MatchType)
	return &out
}

// CloneRefOfRelease creates a deep clone of the input.
func CloneRefOfRelease(n *Release) *Release {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = CloneColIdent(n.Name)
	return &out
}

// CloneRefOfRenameIndex creates a deep clone of the input.
func CloneRefOfRenameIndex(n *RenameIndex) *RenameIndex {
	if n == nil {
		return nil
	}
	out := *n
	out.OldName = CloneColIdent(n.OldName)
	out.NewName = CloneColIdent(n.NewName)
	return &out
}

// CloneRefOfRenameTable creates a deep clone of the input.
func CloneRefOfRenameTable(n *RenameTable) *RenameTable {
	if n == nil {
		return nil
	}
	out := *n
	out.TablePairs = CloneSliceOfRefOfRenameTablePair(n.TablePairs)
	return &out
}

// CloneRefOfRenameTableName creates a deep clone of the input.
func CloneRefOfRenameTableName(n *RenameTableName) *RenameTableName {
	if n == nil {
		return nil
	}
	out := *n
	out.Table = CloneTableName(n.Table)
	return &out
}

// CloneRefOfRevertMigration creates a deep clone of the input.
func CloneRefOfRevertMigration(n *RevertMigration) *RevertMigration {
	if n == nil {
		return nil
	}
	out := *n
	out.Comments = CloneRefOfParsedComments(n.Comments)
	return &out
}

// CloneRefOfRollback creates a deep clone of the input.
func CloneRefOfRollback(n *Rollback) *Rollback {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// CloneRootNode creates a deep clone of the input.
func CloneRootNode(n RootNode) RootNode {
	return *CloneRefOfRootNode(&n)
}

// CloneRefOfSRollback creates a deep clone of the input.
func CloneRefOfSRollback(n *SRollback) *SRollback {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = CloneColIdent(n.Name)
	return &out
}

// CloneRefOfSavepoint creates a deep clone of the input.
func CloneRefOfSavepoint(n *Savepoint) *Savepoint {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = CloneColIdent(n.Name)
	return &out
}

// CloneRefOfSelect creates a deep clone of the input.
func CloneRefOfSelect(n *Select) *Select {
	if n == nil {
		return nil
	}
	out := *n
	out.Cache = CloneRefOfBool(n.Cache)
	out.From = CloneSliceOfTableExpr(n.From)
	out.Comments = CloneRefOfParsedComments(n.Comments)
	out.SelectExprs = CloneSelectExprs(n.SelectExprs)
	out.Where = CloneRefOfWhere(n.Where)
	out.With = CloneRefOfWith(n.With)
	out.GroupBy = CloneGroupBy(n.GroupBy)
	out.Having = CloneRefOfWhere(n.Having)
	out.Windows = CloneNamedWindows(n.Windows)
	out.OrderBy = CloneOrderBy(n.OrderBy)
	out.Limit = CloneRefOfLimit(n.Limit)
	out.Into = CloneRefOfSelectInto(n.Into)
	return &out
}

// CloneSelectExprs creates a deep clone of the input.
func CloneSelectExprs(n SelectExprs) SelectExprs {
	if n == nil {
		return nil
	}
	res := make(SelectExprs, 0, len(n))
	for _, x := range n {
		res = append(res, CloneSelectExpr(x))
	}
	return res
}

// CloneRefOfSelectInto creates a deep clone of the input.
func CloneRefOfSelectInto(n *SelectInto) *SelectInto {
	if n == nil {
		return nil
	}
	out := *n
	out.Charset = CloneColumnCharset(n.Charset)
	return &out
}

// CloneRefOfSet creates a deep clone of the input.
func CloneRefOfSet(n *Set) *Set {
	if n == nil {
		return nil
	}
	out := *n
	out.Comments = CloneRefOfParsedComments(n.Comments)
	out.Exprs = CloneSetExprs(n.Exprs)
	return &out
}

// CloneRefOfSetExpr creates a deep clone of the input.
func CloneRefOfSetExpr(n *SetExpr) *SetExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = CloneColIdent(n.Name)
	out.Expr = CloneExpr(n.Expr)
	return &out
}

// CloneSetExprs creates a deep clone of the input.
func CloneSetExprs(n SetExprs) SetExprs {
	if n == nil {
		return nil
	}
	res := make(SetExprs, 0, len(n))
	for _, x := range n {
		res = append(res, CloneRefOfSetExpr(x))
	}
	return res
}

// CloneRefOfSetTransaction creates a deep clone of the input.
func CloneRefOfSetTransaction(n *SetTransaction) *SetTransaction {
	if n == nil {
		return nil
	}
	out := *n
	out.SQLNode = CloneSQLNode(n.SQLNode)
	out.Comments = CloneRefOfParsedComments(n.Comments)
	out.Characteristics = CloneSliceOfCharacteristic(n.Characteristics)
	return &out
}

// CloneRefOfShow creates a deep clone of the input.
func CloneRefOfShow(n *Show) *Show {
	if n == nil {
		return nil
	}
	out := *n
	out.Internal = CloneShowInternal(n.Internal)
	return &out
}

// CloneRefOfShowBasic creates a deep clone of the input.
func CloneRefOfShowBasic(n *ShowBasic) *ShowBasic {
	if n == nil {
		return nil
	}
	out := *n
	out.Tbl = CloneTableName(n.Tbl)
	out.DbName = CloneTableIdent(n.DbName)
	out.Filter = CloneRefOfShowFilter(n.Filter)
	return &out
}

// CloneRefOfShowCreate creates a deep clone of the input.
func CloneRefOfShowCreate(n *ShowCreate) *ShowCreate {
	if n == nil {
		return nil
	}
	out := *n
	out.Op = CloneTableName(n.Op)
	return &out
}

// CloneRefOfShowFilter creates a deep clone of the input.
func CloneRefOfShowFilter(n *ShowFilter) *ShowFilter {
	if n == nil {
		return nil
	}
	out := *n
	out.Filter = CloneExpr(n.Filter)
	return &out
}

// CloneRefOfShowMigrationLogs creates a deep clone of the input.
func CloneRefOfShowMigrationLogs(n *ShowMigrationLogs) *ShowMigrationLogs {
	if n == nil {
		return nil
	}
	out := *n
	out.Comments = CloneRefOfParsedComments(n.Comments)
	return &out
}

// CloneRefOfShowOther creates a deep clone of the input.
func CloneRefOfShowOther(n *ShowOther) *ShowOther {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// CloneRefOfShowThrottledApps creates a deep clone of the input.
func CloneRefOfShowThrottledApps(n *ShowThrottledApps) *ShowThrottledApps {
	if n == nil {
		return nil
	}
	out := *n
	out.Comments = CloneComments(n.Comments)
	return &out
}

// CloneRefOfStarExpr creates a deep clone of the input.
func CloneRefOfStarExpr(n *StarExpr) *StarExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.TableName = CloneTableName(n.TableName)
	return &out
}

// CloneRefOfStream creates a deep clone of the input.
func CloneRefOfStream(n *Stream) *Stream {
	if n == nil {
		return nil
	}
	out := *n
	out.Comments = CloneRefOfParsedComments(n.Comments)
	out.SelectExpr = CloneSelectExpr(n.SelectExpr)
	out.Table = CloneTableName(n.Table)
	return &out
}

// CloneRefOfSubPartition creates a deep clone of the input.
func CloneRefOfSubPartition(n *SubPartition) *SubPartition {
	if n == nil {
		return nil
	}
	out := *n
	out.ColList = CloneColumns(n.ColList)
	out.Expr = CloneExpr(n.Expr)
	return &out
}

// CloneRefOfSubPartitionDefinition creates a deep clone of the input.
func CloneRefOfSubPartitionDefinition(n *SubPartitionDefinition) *SubPartitionDefinition {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = CloneColIdent(n.Name)
	out.Options = CloneRefOfSubPartitionDefinitionOptions(n.Options)
	return &out
}

// CloneRefOfSubPartitionDefinitionOptions creates a deep clone of the input.
func CloneRefOfSubPartitionDefinitionOptions(n *SubPartitionDefinitionOptions) *SubPartitionDefinitionOptions {
	if n == nil {
		return nil
	}
	out := *n
	out.Comment = CloneRefOfLiteral(n.Comment)
	out.Engine = CloneRefOfPartitionEngine(n.Engine)
	out.DataDirectory = CloneRefOfLiteral(n.DataDirectory)
	out.IndexDirectory = CloneRefOfLiteral(n.IndexDirectory)
	out.MaxRows = CloneRefOfInt(n.MaxRows)
	out.MinRows = CloneRefOfInt(n.MinRows)
	return &out
}

// CloneSubPartitionDefinitions creates a deep clone of the input.
func CloneSubPartitionDefinitions(n SubPartitionDefinitions) SubPartitionDefinitions {
	if n == nil {
		return nil
	}
	res := make(SubPartitionDefinitions, 0, len(n))
	for _, x := range n {
		res = append(res, CloneRefOfSubPartitionDefinition(x))
	}
	return res
}

// CloneRefOfSubquery creates a deep clone of the input.
func CloneRefOfSubquery(n *Subquery) *Subquery {
	if n == nil {
		return nil
	}
	out := *n
	out.Select = CloneSelectStatement(n.Select)
	return &out
}

// CloneRefOfSubstrExpr creates a deep clone of the input.
func CloneRefOfSubstrExpr(n *SubstrExpr) *SubstrExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = CloneExpr(n.Name)
	out.From = CloneExpr(n.From)
	out.To = CloneExpr(n.To)
	return &out
}

// CloneTableExprs creates a deep clone of the input.
func CloneTableExprs(n TableExprs) TableExprs {
	if n == nil {
		return nil
	}
	res := make(TableExprs, 0, len(n))
	for _, x := range n {
		res = append(res, CloneTableExpr(x))
	}
	return res
}

// CloneTableIdent creates a deep clone of the input.
func CloneTableIdent(n TableIdent) TableIdent {
	return *CloneRefOfTableIdent(&n)
}

// CloneTableName creates a deep clone of the input.
func CloneTableName(n TableName) TableName {
	return *CloneRefOfTableName(&n)
}

// CloneTableNames creates a deep clone of the input.
func CloneTableNames(n TableNames) TableNames {
	if n == nil {
		return nil
	}
	res := make(TableNames, 0, len(n))
	for _, x := range n {
		res = append(res, CloneTableName(x))
	}
	return res
}

// CloneTableOptions creates a deep clone of the input.
func CloneTableOptions(n TableOptions) TableOptions {
	if n == nil {
		return nil
	}
	res := make(TableOptions, 0, len(n))
	for _, x := range n {
		res = append(res, CloneRefOfTableOption(x))
	}
	return res
}

// CloneRefOfTableSpec creates a deep clone of the input.
func CloneRefOfTableSpec(n *TableSpec) *TableSpec {
	if n == nil {
		return nil
	}
	out := *n
	out.Columns = CloneSliceOfRefOfColumnDefinition(n.Columns)
	out.Indexes = CloneSliceOfRefOfIndexDefinition(n.Indexes)
	out.Constraints = CloneSliceOfRefOfConstraintDefinition(n.Constraints)
	out.Options = CloneTableOptions(n.Options)
	out.PartitionOption = CloneRefOfPartitionOption(n.PartitionOption)
	return &out
}

// CloneRefOfTablespaceOperation creates a deep clone of the input.
func CloneRefOfTablespaceOperation(n *TablespaceOperation) *TablespaceOperation {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// CloneRefOfTimestampFuncExpr creates a deep clone of the input.
func CloneRefOfTimestampFuncExpr(n *TimestampFuncExpr) *TimestampFuncExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr1 = CloneExpr(n.Expr1)
	out.Expr2 = CloneExpr(n.Expr2)
	return &out
}

// CloneRefOfTrimFuncExpr creates a deep clone of the input.
func CloneRefOfTrimFuncExpr(n *TrimFuncExpr) *TrimFuncExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.TrimArg = CloneExpr(n.TrimArg)
	out.StringArg = CloneExpr(n.StringArg)
	return &out
}

// CloneRefOfTruncateTable creates a deep clone of the input.
func CloneRefOfTruncateTable(n *TruncateTable) *TruncateTable {
	if n == nil {
		return nil
	}
	out := *n
	out.Table = CloneTableName(n.Table)
	return &out
}

// CloneRefOfUnaryExpr creates a deep clone of the input.
func CloneRefOfUnaryExpr(n *UnaryExpr) *UnaryExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = CloneExpr(n.Expr)
	return &out
}

// CloneRefOfUnion creates a deep clone of the input.
func CloneRefOfUnion(n *Union) *Union {
	if n == nil {
		return nil
	}
	out := *n
	out.Left = CloneSelectStatement(n.Left)
	out.Right = CloneSelectStatement(n.Right)
	out.OrderBy = CloneOrderBy(n.OrderBy)
	out.With = CloneRefOfWith(n.With)
	out.Limit = CloneRefOfLimit(n.Limit)
	out.Into = CloneRefOfSelectInto(n.Into)
	return &out
}

// CloneRefOfUnlockTables creates a deep clone of the input.
func CloneRefOfUnlockTables(n *UnlockTables) *UnlockTables {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// CloneRefOfUpdate creates a deep clone of the input.
func CloneRefOfUpdate(n *Update) *Update {
	if n == nil {
		return nil
	}
	out := *n
	out.With = CloneRefOfWith(n.With)
	out.Comments = CloneRefOfParsedComments(n.Comments)
	out.TableExprs = CloneTableExprs(n.TableExprs)
	out.Exprs = CloneUpdateExprs(n.Exprs)
	out.Where = CloneRefOfWhere(n.Where)
	out.OrderBy = CloneOrderBy(n.OrderBy)
	out.Limit = CloneRefOfLimit(n.Limit)
	return &out
}

// CloneRefOfUpdateExpr creates a deep clone of the input.
func CloneRefOfUpdateExpr(n *UpdateExpr) *UpdateExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = CloneRefOfColName(n.Name)
	out.Expr = CloneExpr(n.Expr)
	return &out
}

// CloneUpdateExprs creates a deep clone of the input.
func CloneUpdateExprs(n UpdateExprs) UpdateExprs {
	if n == nil {
		return nil
	}
	res := make(UpdateExprs, 0, len(n))
	for _, x := range n {
		res = append(res, CloneRefOfUpdateExpr(x))
	}
	return res
}

// CloneRefOfUpdateXMLExpr creates a deep clone of the input.
func CloneRefOfUpdateXMLExpr(n *UpdateXMLExpr) *UpdateXMLExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Target = CloneExpr(n.Target)
	out.XPathExpr = CloneExpr(n.XPathExpr)
	out.NewXML = CloneExpr(n.NewXML)
	return &out
}

// CloneRefOfUse creates a deep clone of the input.
func CloneRefOfUse(n *Use) *Use {
	if n == nil {
		return nil
	}
	out := *n
	out.DBName = CloneTableIdent(n.DBName)
	return &out
}

// CloneRefOfVStream creates a deep clone of the input.
func CloneRefOfVStream(n *VStream) *VStream {
	if n == nil {
		return nil
	}
	out := *n
	out.Comments = CloneRefOfParsedComments(n.Comments)
	out.SelectExpr = CloneSelectExpr(n.SelectExpr)
	out.Table = CloneTableName(n.Table)
	out.Where = CloneRefOfWhere(n.Where)
	out.Limit = CloneRefOfLimit(n.Limit)
	return &out
}

// CloneValTuple creates a deep clone of the input.
func CloneValTuple(n ValTuple) ValTuple {
	if n == nil {
		return nil
	}
	res := make(ValTuple, 0, len(n))
	for _, x := range n {
		res = append(res, CloneExpr(x))
	}
	return res
}

// CloneRefOfValidation creates a deep clone of the input.
func CloneRefOfValidation(n *Validation) *Validation {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// CloneValues creates a deep clone of the input.
func CloneValues(n Values) Values {
	if n == nil {
		return nil
	}
	res := make(Values, 0, len(n))
	for _, x := range n {
		res = append(res, CloneValTuple(x))
	}
	return res
}

// CloneRefOfValuesFuncExpr creates a deep clone of the input.
func CloneRefOfValuesFuncExpr(n *ValuesFuncExpr) *ValuesFuncExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = CloneRefOfColName(n.Name)
	return &out
}

// CloneVindexParam creates a deep clone of the input.
func CloneVindexParam(n VindexParam) VindexParam {
	return *CloneRefOfVindexParam(&n)
}

// CloneRefOfVindexSpec creates a deep clone of the input.
func CloneRefOfVindexSpec(n *VindexSpec) *VindexSpec {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = CloneColIdent(n.Name)
	out.Type = CloneColIdent(n.Type)
	out.Params = CloneSliceOfVindexParam(n.Params)
	return &out
}

// CloneRefOfWeightStringFuncExpr creates a deep clone of the input.
func CloneRefOfWeightStringFuncExpr(n *WeightStringFuncExpr) *WeightStringFuncExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = CloneExpr(n.Expr)
	out.As = CloneRefOfConvertType(n.As)
	return &out
}

// CloneRefOfWhen creates a deep clone of the input.
func CloneRefOfWhen(n *When) *When {
	if n == nil {
		return nil
	}
	out := *n
	out.Cond = CloneExpr(n.Cond)
	out.Val = CloneExpr(n.Val)
	return &out
}

// CloneRefOfWhere creates a deep clone of the input.
func CloneRefOfWhere(n *Where) *Where {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = CloneExpr(n.Expr)
	return &out
}

// CloneRefOfWindowDefinition creates a deep clone of the input.
func CloneRefOfWindowDefinition(n *WindowDefinition) *WindowDefinition {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = CloneColIdent(n.Name)
	out.WindowSpec = CloneRefOfWindowSpecification(n.WindowSpec)
	return &out
}

// CloneWindowDefinitions creates a deep clone of the input.
func CloneWindowDefinitions(n WindowDefinitions) WindowDefinitions {
	if n == nil {
		return nil
	}
	res := make(WindowDefinitions, 0, len(n))
	for _, x := range n {
		res = append(res, CloneRefOfWindowDefinition(x))
	}
	return res
}

// CloneRefOfWindowSpecification creates a deep clone of the input.
func CloneRefOfWindowSpecification(n *WindowSpecification) *WindowSpecification {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = CloneColIdent(n.Name)
	out.PartitionClause = CloneExprs(n.PartitionClause)
	out.OrderClause = CloneOrderBy(n.OrderClause)
	out.FrameClause = CloneRefOfFrameClause(n.FrameClause)
	return &out
}

// CloneRefOfWith creates a deep clone of the input.
func CloneRefOfWith(n *With) *With {
	if n == nil {
		return nil
	}
	out := *n
	out.ctes = CloneSliceOfRefOfCommonTableExpr(n.ctes)
	return &out
}

// CloneRefOfXorExpr creates a deep clone of the input.
func CloneRefOfXorExpr(n *XorExpr) *XorExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Left = CloneExpr(n.Left)
	out.Right = CloneExpr(n.Right)
	return &out
}

// CloneAlterOption creates a deep clone of the input.
func CloneAlterOption(in AlterOption) AlterOption {
	if in == nil {
		return nil
	}
	switch in := in.(type) {
	case *AddColumns:
		return CloneRefOfAddColumns(in)
	case *AddConstraintDefinition:
		return CloneRefOfAddConstraintDefinition(in)
	case *AddIndexDefinition:
		return CloneRefOfAddIndexDefinition(in)
	case AlgorithmValue:
		return in
	case *AlterCharset:
		return CloneRefOfAlterCharset(in)
	case *AlterCheck:
		return CloneRefOfAlterCheck(in)
	case *AlterColumn:
		return CloneRefOfAlterColumn(in)
	case *AlterIndex:
		return CloneRefOfAlterIndex(in)
	case *ChangeColumn:
		return CloneRefOfChangeColumn(in)
	case *DropColumn:
		return CloneRefOfDropColumn(in)
	case *DropKey:
		return CloneRefOfDropKey(in)
	case *Force:
		return CloneRefOfForce(in)
	case *KeyState:
		return CloneRefOfKeyState(in)
	case *LockOption:
		return CloneRefOfLockOption(in)
	case *ModifyColumn:
		return CloneRefOfModifyColumn(in)
	case *OrderByOption:
		return CloneRefOfOrderByOption(in)
	case *RenameIndex:
		return CloneRefOfRenameIndex(in)
	case *RenameTableName:
		return CloneRefOfRenameTableName(in)
	case TableOptions:
		return CloneTableOptions(in)
	case *TablespaceOperation:
		return CloneRefOfTablespaceOperation(in)
	case *Validation:
		return CloneRefOfValidation(in)
	default:
		// this should never happen
		return nil
	}
}

// CloneCallable creates a deep clone of the input.
func CloneCallable(in Callable) Callable {
	if in == nil {
		return nil
	}
	switch in := in.(type) {
	case *ArgumentLessWindowExpr:
		return CloneRefOfArgumentLessWindowExpr(in)
	case *ConvertExpr:
		return CloneRefOfConvertExpr(in)
	case *ConvertUsingExpr:
		return CloneRefOfConvertUsingExpr(in)
	case *CurTimeFuncExpr:
		return CloneRefOfCurTimeFuncExpr(in)
	case *ExtractFuncExpr:
		return CloneRefOfExtractFuncExpr(in)
	case *ExtractValueExpr:
		return CloneRefOfExtractValueExpr(in)
	case *FirstOrLastValueExpr:
		return CloneRefOfFirstOrLastValueExpr(in)
	case *FuncExpr:
		return CloneRefOfFuncExpr(in)
	case *GroupConcatExpr:
		return CloneRefOfGroupConcatExpr(in)
	case *JSONArrayExpr:
		return CloneRefOfJSONArrayExpr(in)
	case *JSONAttributesExpr:
		return CloneRefOfJSONAttributesExpr(in)
	case *JSONContainsExpr:
		return CloneRefOfJSONContainsExpr(in)
	case *JSONContainsPathExpr:
		return CloneRefOfJSONContainsPathExpr(in)
	case *JSONExtractExpr:
		return CloneRefOfJSONExtractExpr(in)
	case *JSONKeysExpr:
		return CloneRefOfJSONKeysExpr(in)
	case *JSONObjectExpr:
		return CloneRefOfJSONObjectExpr(in)
	case *JSONOverlapsExpr:
		return CloneRefOfJSONOverlapsExpr(in)
	case *JSONPrettyExpr:
		return CloneRefOfJSONPrettyExpr(in)
	case *JSONQuoteExpr:
		return CloneRefOfJSONQuoteExpr(in)
	case *JSONRemoveExpr:
		return CloneRefOfJSONRemoveExpr(in)
	case *JSONSchemaValidFuncExpr:
		return CloneRefOfJSONSchemaValidFuncExpr(in)
	case *JSONSchemaValidationReportFuncExpr:
		return CloneRefOfJSONSchemaValidationReportFuncExpr(in)
	case *JSONSearchExpr:
		return CloneRefOfJSONSearchExpr(in)
	case *JSONStorageFreeExpr:
		return CloneRefOfJSONStorageFreeExpr(in)
	case *JSONStorageSizeExpr:
		return CloneRefOfJSONStorageSizeExpr(in)
	case *JSONUnquoteExpr:
		return CloneRefOfJSONUnquoteExpr(in)
	case *JSONValueExpr:
		return CloneRefOfJSONValueExpr(in)
	case *JSONValueMergeExpr:
		return CloneRefOfJSONValueMergeExpr(in)
	case *JSONValueModifierExpr:
		return CloneRefOfJSONValueModifierExpr(in)
	case *LagLeadExpr:
		return CloneRefOfLagLeadExpr(in)
	case *MatchExpr:
		return CloneRefOfMatchExpr(in)
	case *MemberOfExpr:
		return CloneRefOfMemberOfExpr(in)
	case *NTHValueExpr:
		return CloneRefOfNTHValueExpr(in)
	case *NamedWindow:
		return CloneRefOfNamedWindow(in)
	case *NtileExpr:
		return CloneRefOfNtileExpr(in)
	case *RegexpInstrExpr:
		return CloneRefOfRegexpInstrExpr(in)
	case *RegexpLikeExpr:
		return CloneRefOfRegexpLikeExpr(in)
	case *RegexpReplaceExpr:
		return CloneRefOfRegexpReplaceExpr(in)
	case *RegexpSubstrExpr:
		return CloneRefOfRegexpSubstrExpr(in)
	case *SubstrExpr:
		return CloneRefOfSubstrExpr(in)
	case *TimestampFuncExpr:
		return CloneRefOfTimestampFuncExpr(in)
	case *TrimFuncExpr:
		return CloneRefOfTrimFuncExpr(in)
	case *UpdateXMLExpr:
		return CloneRefOfUpdateXMLExpr(in)
	case *ValuesFuncExpr:
		return CloneRefOfValuesFuncExpr(in)
	case *WeightStringFuncExpr:
		return CloneRefOfWeightStringFuncExpr(in)
	default:
		// this should never happen
		return nil
	}
}

// CloneCharacteristic creates a deep clone of the input.
func CloneCharacteristic(in Characteristic) Characteristic {
	if in == nil {
		return nil
	}
	switch in := in.(type) {
	case AccessMode:
		return in
	case IsolationLevel:
		return in
	default:
		// this should never happen
		return nil
	}
}

// CloneColTuple creates a deep clone of the input.
func CloneColTuple(in ColTuple) ColTuple {
	if in == nil {
		return nil
	}
	switch in := in.(type) {
	case ListArg:
		return in
	case *Subquery:
		return CloneRefOfSubquery(in)
	case ValTuple:
		return CloneValTuple(in)
	default:
		// this should never happen
		return nil
	}
}

// CloneConstraintInfo creates a deep clone of the input.
func CloneConstraintInfo(in ConstraintInfo) ConstraintInfo {
	if in == nil {
		return nil
	}
	switch in := in.(type) {
	case *CheckConstraintDefinition:
		return CloneRefOfCheckConstraintDefinition(in)
	case *ForeignKeyDefinition:
		return CloneRefOfForeignKeyDefinition(in)
	default:
		// this should never happen
		return nil
	}
}

// CloneDBDDLStatement creates a deep clone of the input.
func CloneDBDDLStatement(in DBDDLStatement) DBDDLStatement {
	if in == nil {
		return nil
	}
	switch in := in.(type) {
	case *AlterDatabase:
		return CloneRefOfAlterDatabase(in)
	case *CreateDatabase:
		return CloneRefOfCreateDatabase(in)
	case *DropDatabase:
		return CloneRefOfDropDatabase(in)
	default:
		// this should never happen
		return nil
	}
}

// CloneDDLStatement creates a deep clone of the input.
func CloneDDLStatement(in DDLStatement) DDLStatement {
	if in == nil {
		return nil
	}
	switch in := in.(type) {
	case *AlterTable:
		return CloneRefOfAlterTable(in)
	case *AlterView:
		return CloneRefOfAlterView(in)
	case *CreateTable:
		return CloneRefOfCreateTable(in)
	case *CreateView:
		return CloneRefOfCreateView(in)
	case *DropTable:
		return CloneRefOfDropTable(in)
	case *DropView:
		return CloneRefOfDropView(in)
	case *RenameTable:
		return CloneRefOfRenameTable(in)
	case *TruncateTable:
		return CloneRefOfTruncateTable(in)
	default:
		// this should never happen
		return nil
	}
}

// CloneExplain creates a deep clone of the input.
func CloneExplain(in Explain) Explain {
	if in == nil {
		return nil
	}
	switch in := in.(type) {
	case *ExplainStmt:
		return CloneRefOfExplainStmt(in)
	case *ExplainTab:
		return CloneRefOfExplainTab(in)
	default:
		// this should never happen
		return nil
	}
}

// CloneExpr creates a deep clone of the input.
func CloneExpr(in Expr) Expr {
	if in == nil {
		return nil
	}
	switch in := in.(type) {
	case *AndExpr:
		return CloneRefOfAndExpr(in)
	case Argument:
		return in
	case *ArgumentLessWindowExpr:
		return CloneRefOfArgumentLessWindowExpr(in)
	case *BetweenExpr:
		return CloneRefOfBetweenExpr(in)
	case *BinaryExpr:
		return CloneRefOfBinaryExpr(in)
	case BoolVal:
		return in
	case *CaseExpr:
		return CloneRefOfCaseExpr(in)
	case *ColName:
		return CloneRefOfColName(in)
	case *CollateExpr:
		return CloneRefOfCollateExpr(in)
	case *ComparisonExpr:
		return CloneRefOfComparisonExpr(in)
	case *ConvertExpr:
		return CloneRefOfConvertExpr(in)
	case *ConvertUsingExpr:
		return CloneRefOfConvertUsingExpr(in)
	case *CurTimeFuncExpr:
		return CloneRefOfCurTimeFuncExpr(in)
	case *Default:
		return CloneRefOfDefault(in)
	case *ExistsExpr:
		return CloneRefOfExistsExpr(in)
	case *ExtractFuncExpr:
		return CloneRefOfExtractFuncExpr(in)
	case *ExtractValueExpr:
		return CloneRefOfExtractValueExpr(in)
	case *ExtractedSubquery:
		return CloneRefOfExtractedSubquery(in)
	case *FirstOrLastValueExpr:
		return CloneRefOfFirstOrLastValueExpr(in)
	case *FuncExpr:
		return CloneRefOfFuncExpr(in)
	case *GroupConcatExpr:
		return CloneRefOfGroupConcatExpr(in)
	case *IntervalExpr:
		return CloneRefOfIntervalExpr(in)
	case *IntroducerExpr:
		return CloneRefOfIntroducerExpr(in)
	case *IsExpr:
		return CloneRefOfIsExpr(in)
	case *JSONArrayExpr:
		return CloneRefOfJSONArrayExpr(in)
	case *JSONAttributesExpr:
		return CloneRefOfJSONAttributesExpr(in)
	case *JSONContainsExpr:
		return CloneRefOfJSONContainsExpr(in)
	case *JSONContainsPathExpr:
		return CloneRefOfJSONContainsPathExpr(in)
	case *JSONExtractExpr:
		return CloneRefOfJSONExtractExpr(in)
	case *JSONKeysExpr:
		return CloneRefOfJSONKeysExpr(in)
	case *JSONObjectExpr:
		return CloneRefOfJSONObjectExpr(in)
	case *JSONOverlapsExpr:
		return CloneRefOfJSONOverlapsExpr(in)
	case *JSONPrettyExpr:
		return CloneRefOfJSONPrettyExpr(in)
	case *JSONQuoteExpr:
		return CloneRefOfJSONQuoteExpr(in)
	case *JSONRemoveExpr:
		return CloneRefOfJSONRemoveExpr(in)
	case *JSONSchemaValidFuncExpr:
		return CloneRefOfJSONSchemaValidFuncExpr(in)
	case *JSONSchemaValidationReportFuncExpr:
		return CloneRefOfJSONSchemaValidationReportFuncExpr(in)
	case *JSONSearchExpr:
		return CloneRefOfJSONSearchExpr(in)
	case *JSONStorageFreeExpr:
		return CloneRefOfJSONStorageFreeExpr(in)
	case *JSONStorageSizeExpr:
		return CloneRefOfJSONStorageSizeExpr(in)
	case *JSONUnquoteExpr:
		return CloneRefOfJSONUnquoteExpr(in)
	case *JSONValueExpr:
		return CloneRefOfJSONValueExpr(in)
	case *JSONValueMergeExpr:
		return CloneRefOfJSONValueMergeExpr(in)
	case *JSONValueModifierExpr:
		return CloneRefOfJSONValueModifierExpr(in)
	case *LagLeadExpr:
		return CloneRefOfLagLeadExpr(in)
	case ListArg:
		return in
	case *Literal:
		return CloneRefOfLiteral(in)
	case *LockingFunc:
		return CloneRefOfLockingFunc(in)
	case *MatchExpr:
		return CloneRefOfMatchExpr(in)
	case *MemberOfExpr:
		return CloneRefOfMemberOfExpr(in)
	case *NTHValueExpr:
		return CloneRefOfNTHValueExpr(in)
	case *NamedWindow:
		return CloneRefOfNamedWindow(in)
	case *NotExpr:
		return CloneRefOfNotExpr(in)
	case *NtileExpr:
		return CloneRefOfNtileExpr(in)
	case *NullVal:
		return CloneRefOfNullVal(in)
	case *Offset:
		return CloneRefOfOffset(in)
	case *OrExpr:
		return CloneRefOfOrExpr(in)
	case *RegexpInstrExpr:
		return CloneRefOfRegexpInstrExpr(in)
	case *RegexpLikeExpr:
		return CloneRefOfRegexpLikeExpr(in)
	case *RegexpReplaceExpr:
		return CloneRefOfRegexpReplaceExpr(in)
	case *RegexpSubstrExpr:
		return CloneRefOfRegexpSubstrExpr(in)
	case *Subquery:
		return CloneRefOfSubquery(in)
	case *SubstrExpr:
		return CloneRefOfSubstrExpr(in)
	case *TimestampFuncExpr:
		return CloneRefOfTimestampFuncExpr(in)
	case *TrimFuncExpr:
		return CloneRefOfTrimFuncExpr(in)
	case *UnaryExpr:
		return CloneRefOfUnaryExpr(in)
	case *UpdateXMLExpr:
		return CloneRefOfUpdateXMLExpr(in)
	case ValTuple:
		return CloneValTuple(in)
	case *ValuesFuncExpr:
		return CloneRefOfValuesFuncExpr(in)
	case *WeightStringFuncExpr:
		return CloneRefOfWeightStringFuncExpr(in)
	case *XorExpr:
		return CloneRefOfXorExpr(in)
	default:
		// this should never happen
		return nil
	}
}

// CloneInsertRows creates a deep clone of the input.
func CloneInsertRows(in InsertRows) InsertRows {
	if in == nil {
		return nil
	}
	switch in := in.(type) {
	case *Select:
		return CloneRefOfSelect(in)
	case *Union:
		return CloneRefOfUnion(in)
	case Values:
		return CloneValues(in)
	default:
		// this should never happen
		return nil
	}
}

// CloneJSONPathParam creates a deep clone of the input.
func CloneJSONPathParam(in JSONPathParam) JSONPathParam {
	if in == nil {
		return nil
	}
	switch in := in.(type) {
	case *AndExpr:
		return CloneRefOfAndExpr(in)
	case Argument:
		return in
	case *ArgumentLessWindowExpr:
		return CloneRefOfArgumentLessWindowExpr(in)
	case *BetweenExpr:
		return CloneRefOfBetweenExpr(in)
	case *BinaryExpr:
		return CloneRefOfBinaryExpr(in)
	case BoolVal:
		return in
	case *CaseExpr:
		return CloneRefOfCaseExpr(in)
	case *ColName:
		return CloneRefOfColName(in)
	case *CollateExpr:
		return CloneRefOfCollateExpr(in)
	case *ComparisonExpr:
		return CloneRefOfComparisonExpr(in)
	case *ConvertExpr:
		return CloneRefOfConvertExpr(in)
	case *ConvertUsingExpr:
		return CloneRefOfConvertUsingExpr(in)
	case *CurTimeFuncExpr:
		return CloneRefOfCurTimeFuncExpr(in)
	case *Default:
		return CloneRefOfDefault(in)
	case *ExistsExpr:
		return CloneRefOfExistsExpr(in)
	case *ExtractFuncExpr:
		return CloneRefOfExtractFuncExpr(in)
	case *ExtractValueExpr:
		return CloneRefOfExtractValueExpr(in)
	case *ExtractedSubquery:
		return CloneRefOfExtractedSubquery(in)
	case *FirstOrLastValueExpr:
		return CloneRefOfFirstOrLastValueExpr(in)
	case *FuncExpr:
		return CloneRefOfFuncExpr(in)
	case *GroupConcatExpr:
		return CloneRefOfGroupConcatExpr(in)
	case *IntervalExpr:
		return CloneRefOfIntervalExpr(in)
	case *IntroducerExpr:
		return CloneRefOfIntroducerExpr(in)
	case *IsExpr:
		return CloneRefOfIsExpr(in)
	case *JSONArrayExpr:
		return CloneRefOfJSONArrayExpr(in)
	case *JSONAttributesExpr:
		return CloneRefOfJSONAttributesExpr(in)
	case *JSONContainsExpr:
		return CloneRefOfJSONContainsExpr(in)
	case *JSONContainsPathExpr:
		return CloneRefOfJSONContainsPathExpr(in)
	case *JSONExtractExpr:
		return CloneRefOfJSONExtractExpr(in)
	case *JSONKeysExpr:
		return CloneRefOfJSONKeysExpr(in)
	case *JSONObjectExpr:
		return CloneRefOfJSONObjectExpr(in)
	case *JSONOverlapsExpr:
		return CloneRefOfJSONOverlapsExpr(in)
	case *JSONPrettyExpr:
		return CloneRefOfJSONPrettyExpr(in)
	case *JSONQuoteExpr:
		return CloneRefOfJSONQuoteExpr(in)
	case *JSONRemoveExpr:
		return CloneRefOfJSONRemoveExpr(in)
	case *JSONSchemaValidFuncExpr:
		return CloneRefOfJSONSchemaValidFuncExpr(in)
	case *JSONSchemaValidationReportFuncExpr:
		return CloneRefOfJSONSchemaValidationReportFuncExpr(in)
	case *JSONSearchExpr:
		return CloneRefOfJSONSearchExpr(in)
	case *JSONStorageFreeExpr:
		return CloneRefOfJSONStorageFreeExpr(in)
	case *JSONStorageSizeExpr:
		return CloneRefOfJSONStorageSizeExpr(in)
	case *JSONUnquoteExpr:
		return CloneRefOfJSONUnquoteExpr(in)
	case *JSONValueExpr:
		return CloneRefOfJSONValueExpr(in)
	case *JSONValueMergeExpr:
		return CloneRefOfJSONValueMergeExpr(in)
	case *JSONValueModifierExpr:
		return CloneRefOfJSONValueModifierExpr(in)
	case *LagLeadExpr:
		return CloneRefOfLagLeadExpr(in)
	case ListArg:
		return in
	case *Literal:
		return CloneRefOfLiteral(in)
	case *LockingFunc:
		return CloneRefOfLockingFunc(in)
	case *MatchExpr:
		return CloneRefOfMatchExpr(in)
	case *MemberOfExpr:
		return CloneRefOfMemberOfExpr(in)
	case *NTHValueExpr:
		return CloneRefOfNTHValueExpr(in)
	case *NamedWindow:
		return CloneRefOfNamedWindow(in)
	case *NotExpr:
		return CloneRefOfNotExpr(in)
	case *NtileExpr:
		return CloneRefOfNtileExpr(in)
	case *NullVal:
		return CloneRefOfNullVal(in)
	case *Offset:
		return CloneRefOfOffset(in)
	case *OrExpr:
		return CloneRefOfOrExpr(in)
	case *RegexpInstrExpr:
		return CloneRefOfRegexpInstrExpr(in)
	case *RegexpLikeExpr:
		return CloneRefOfRegexpLikeExpr(in)
	case *RegexpReplaceExpr:
		return CloneRefOfRegexpReplaceExpr(in)
	case *RegexpSubstrExpr:
		return CloneRefOfRegexpSubstrExpr(in)
	case *Subquery:
		return CloneRefOfSubquery(in)
	case *SubstrExpr:
		return CloneRefOfSubstrExpr(in)
	case *TimestampFuncExpr:
		return CloneRefOfTimestampFuncExpr(in)
	case *TrimFuncExpr:
		return CloneRefOfTrimFuncExpr(in)
	case *UnaryExpr:
		return CloneRefOfUnaryExpr(in)
	case *UpdateXMLExpr:
		return CloneRefOfUpdateXMLExpr(in)
	case ValTuple:
		return CloneValTuple(in)
	case *ValuesFuncExpr:
		return CloneRefOfValuesFuncExpr(in)
	case *WeightStringFuncExpr:
		return CloneRefOfWeightStringFuncExpr(in)
	case *XorExpr:
		return CloneRefOfXorExpr(in)
	default:
		// this should never happen
		return nil
	}
}

// CloneSelectExpr creates a deep clone of the input.
func CloneSelectExpr(in SelectExpr) SelectExpr {
	if in == nil {
		return nil
	}
	switch in := in.(type) {
	case *AliasedExpr:
		return CloneRefOfAliasedExpr(in)
	case *Nextval:
		return CloneRefOfNextval(in)
	case *StarExpr:
		return CloneRefOfStarExpr(in)
	default:
		// this should never happen
		return nil
	}
}

// CloneSelectStatement creates a deep clone of the input.
func CloneSelectStatement(in SelectStatement) SelectStatement {
	if in == nil {
		return nil
	}
	switch in := in.(type) {
	case *Select:
		return CloneRefOfSelect(in)
	case *Union:
		return CloneRefOfUnion(in)
	default:
		// this should never happen
		return nil
	}
}

// CloneShowInternal creates a deep clone of the input.
func CloneShowInternal(in ShowInternal) ShowInternal {
	if in == nil {
		return nil
	}
	switch in := in.(type) {
	case *ShowBasic:
		return CloneRefOfShowBasic(in)
	case *ShowCreate:
		return CloneRefOfShowCreate(in)
	case *ShowOther:
		return CloneRefOfShowOther(in)
	default:
		// this should never happen
		return nil
	}
}

// CloneSimpleTableExpr creates a deep clone of the input.
func CloneSimpleTableExpr(in SimpleTableExpr) SimpleTableExpr {
	if in == nil {
		return nil
	}
	switch in := in.(type) {
	case *DerivedTable:
		return CloneRefOfDerivedTable(in)
	case TableName:
		return CloneTableName(in)
	default:
		// this should never happen
		return nil
	}
}

// CloneStatement creates a deep clone of the input.
func CloneStatement(in Statement) Statement {
	if in == nil {
		return nil
	}
	switch in := in.(type) {
	case *AlterDatabase:
		return CloneRefOfAlterDatabase(in)
	case *AlterMigration:
		return CloneRefOfAlterMigration(in)
	case *AlterTable:
		return CloneRefOfAlterTable(in)
	case *AlterView:
		return CloneRefOfAlterView(in)
	case *AlterVschema:
		return CloneRefOfAlterVschema(in)
	case *Begin:
		return CloneRefOfBegin(in)
	case *CallProc:
		return CloneRefOfCallProc(in)
	case *Commit:
		return CloneRefOfCommit(in)
	case *CreateDatabase:
		return CloneRefOfCreateDatabase(in)
	case *CreateTable:
		return CloneRefOfCreateTable(in)
	case *CreateView:
		return CloneRefOfCreateView(in)
	case *DeallocateStmt:
		return CloneRefOfDeallocateStmt(in)
	case *Delete:
		return CloneRefOfDelete(in)
	case *DropDatabase:
		return CloneRefOfDropDatabase(in)
	case *DropTable:
		return CloneRefOfDropTable(in)
	case *DropView:
		return CloneRefOfDropView(in)
	case *ExecuteStmt:
		return CloneRefOfExecuteStmt(in)
	case *ExplainStmt:
		return CloneRefOfExplainStmt(in)
	case *ExplainTab:
		return CloneRefOfExplainTab(in)
	case *Flush:
		return CloneRefOfFlush(in)
	case *Insert:
		return CloneRefOfInsert(in)
	case *Load:
		return CloneRefOfLoad(in)
	case *LockTables:
		return CloneRefOfLockTables(in)
	case *OtherAdmin:
		return CloneRefOfOtherAdmin(in)
	case *OtherRead:
		return CloneRefOfOtherRead(in)
	case *PrepareStmt:
		return CloneRefOfPrepareStmt(in)
	case *Release:
		return CloneRefOfRelease(in)
	case *RenameTable:
		return CloneRefOfRenameTable(in)
	case *RevertMigration:
		return CloneRefOfRevertMigration(in)
	case *Rollback:
		return CloneRefOfRollback(in)
	case *SRollback:
		return CloneRefOfSRollback(in)
	case *Savepoint:
		return CloneRefOfSavepoint(in)
	case *Select:
		return CloneRefOfSelect(in)
	case *Set:
		return CloneRefOfSet(in)
	case *SetTransaction:
		return CloneRefOfSetTransaction(in)
	case *Show:
		return CloneRefOfShow(in)
	case *ShowMigrationLogs:
		return CloneRefOfShowMigrationLogs(in)
	case *ShowThrottledApps:
		return CloneRefOfShowThrottledApps(in)
	case *Stream:
		return CloneRefOfStream(in)
	case *TruncateTable:
		return CloneRefOfTruncateTable(in)
	case *Union:
		return CloneRefOfUnion(in)
	case *UnlockTables:
		return CloneRefOfUnlockTables(in)
	case *Update:
		return CloneRefOfUpdate(in)
	case *Use:
		return CloneRefOfUse(in)
	case *VStream:
		return CloneRefOfVStream(in)
	default:
		// this should never happen
		return nil
	}
}

// CloneTableExpr creates a deep clone of the input.
func CloneTableExpr(in TableExpr) TableExpr {
	if in == nil {
		return nil
	}
	switch in := in.(type) {
	case *AliasedTableExpr:
		return CloneRefOfAliasedTableExpr(in)
	case *JSONTableExpr:
		return CloneRefOfJSONTableExpr(in)
	case *JoinTableExpr:
		return CloneRefOfJoinTableExpr(in)
	case *ParenTableExpr:
		return CloneRefOfParenTableExpr(in)
	default:
		// this should never happen
		return nil
	}
}

// CloneSliceOfRefOfColumnDefinition creates a deep clone of the input.
func CloneSliceOfRefOfColumnDefinition(n []*ColumnDefinition) []*ColumnDefinition {
	if n == nil {
		return nil
	}
	res := make([]*ColumnDefinition, 0, len(n))
	for _, x := range n {
		res = append(res, CloneRefOfColumnDefinition(x))
	}
	return res
}

// CloneRefOfBool creates a deep clone of the input.
func CloneRefOfBool(n *bool) *bool {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// CloneSliceOfDatabaseOption creates a deep clone of the input.
func CloneSliceOfDatabaseOption(n []DatabaseOption) []DatabaseOption {
	if n == nil {
		return nil
	}
	res := make([]DatabaseOption, 0, len(n))
	for _, x := range n {
		res = append(res, CloneDatabaseOption(x))
	}
	return res
}

// CloneSliceOfAlterOption creates a deep clone of the input.
func CloneSliceOfAlterOption(n []AlterOption) []AlterOption {
	if n == nil {
		return nil
	}
	res := make([]AlterOption, 0, len(n))
	for _, x := range n {
		res = append(res, CloneAlterOption(x))
	}
	return res
}

// CloneSliceOfColIdent creates a deep clone of the input.
func CloneSliceOfColIdent(n []ColIdent) []ColIdent {
	if n == nil {
		return nil
	}
	res := make([]ColIdent, 0, len(n))
	for _, x := range n {
		res = append(res, CloneColIdent(x))
	}
	return res
}

// CloneSliceOfRefOfWhen creates a deep clone of the input.
func CloneSliceOfRefOfWhen(n []*When) []*When {
	if n == nil {
		return nil
	}
	res := make([]*When, 0, len(n))
	for _, x := range n {
		res = append(res, CloneRefOfWhen(x))
	}
	return res
}

// CloneRefOfColIdent creates a deep clone of the input.
func CloneRefOfColIdent(n *ColIdent) *ColIdent {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// CloneColumnType creates a deep clone of the input.
func CloneColumnType(n ColumnType) ColumnType {
	return *CloneRefOfColumnType(&n)
}

// CloneRefOfColumnTypeOptions creates a deep clone of the input.
func CloneRefOfColumnTypeOptions(n *ColumnTypeOptions) *ColumnTypeOptions {
	if n == nil {
		return nil
	}
	out := *n
	out.Null = CloneRefOfBool(n.Null)
	out.Default = CloneExpr(n.Default)
	out.OnUpdate = CloneExpr(n.OnUpdate)
	out.As = CloneExpr(n.As)
	out.Comment = CloneRefOfLiteral(n.Comment)
	out.Reference = CloneRefOfReferenceDefinition(n.Reference)
	out.Invisible = CloneRefOfBool(n.Invisible)
	out.EngineAttribute = CloneRefOfLiteral(n.EngineAttribute)
	out.SecondaryEngineAttribute = CloneRefOfLiteral(n.SecondaryEngineAttribute)
	out.SRID = CloneRefOfLiteral(n.SRID)
	return &out
}

// CloneColumnCharset creates a deep clone of the input.
func CloneColumnCharset(n ColumnCharset) ColumnCharset {
	return *CloneRefOfColumnCharset(&n)
}

// CloneSliceOfString creates a deep clone of the input.
func CloneSliceOfString(n []string) []string {
	if n == nil {
		return nil
	}
	res := make([]string, 0, len(n))
	copy(res, n)
	return res
}

// CloneSliceOfRefOfIndexColumn creates a deep clone of the input.
func CloneSliceOfRefOfIndexColumn(n []*IndexColumn) []*IndexColumn {
	if n == nil {
		return nil
	}
	res := make([]*IndexColumn, 0, len(n))
	for _, x := range n {
		res = append(res, CloneRefOfIndexColumn(x))
	}
	return res
}

// CloneSliceOfRefOfIndexOption creates a deep clone of the input.
func CloneSliceOfRefOfIndexOption(n []*IndexOption) []*IndexOption {
	if n == nil {
		return nil
	}
	res := make([]*IndexOption, 0, len(n))
	for _, x := range n {
		res = append(res, CloneRefOfIndexOption(x))
	}
	return res
}

// CloneSliceOfJSONPathParam creates a deep clone of the input.
func CloneSliceOfJSONPathParam(n []JSONPathParam) []JSONPathParam {
	if n == nil {
		return nil
	}
	res := make([]JSONPathParam, 0, len(n))
	for _, x := range n {
		res = append(res, CloneJSONPathParam(x))
	}
	return res
}

// CloneSliceOfRefOfJSONObjectParam creates a deep clone of the input.
func CloneSliceOfRefOfJSONObjectParam(n []*JSONObjectParam) []*JSONObjectParam {
	if n == nil {
		return nil
	}
	res := make([]*JSONObjectParam, 0, len(n))
	for _, x := range n {
		res = append(res, CloneRefOfJSONObjectParam(x))
	}
	return res
}

// CloneRefOfJSONObjectParam creates a deep clone of the input.
func CloneRefOfJSONObjectParam(n *JSONObjectParam) *JSONObjectParam {
	if n == nil {
		return nil
	}
	out := *n
	out.Key = CloneExpr(n.Key)
	out.Value = CloneExpr(n.Value)
	return &out
}

// CloneSliceOfRefOfJtColumnDefinition creates a deep clone of the input.
func CloneSliceOfRefOfJtColumnDefinition(n []*JtColumnDefinition) []*JtColumnDefinition {
	if n == nil {
		return nil
	}
	res := make([]*JtColumnDefinition, 0, len(n))
	for _, x := range n {
		res = append(res, CloneRefOfJtColumnDefinition(x))
	}
	return res
}

// CloneRefOfJtOrdinalColDef creates a deep clone of the input.
func CloneRefOfJtOrdinalColDef(n *JtOrdinalColDef) *JtOrdinalColDef {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = CloneColIdent(n.Name)
	return &out
}

// CloneRefOfJtPathColDef creates a deep clone of the input.
func CloneRefOfJtPathColDef(n *JtPathColDef) *JtPathColDef {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = CloneColIdent(n.Name)
	out.Type = CloneColumnType(n.Type)
	out.Path = CloneExpr(n.Path)
	out.EmptyOnResponse = CloneRefOfJtOnResponse(n.EmptyOnResponse)
	out.ErrorOnResponse = CloneRefOfJtOnResponse(n.ErrorOnResponse)
	return &out
}

// CloneRefOfJtNestedPathColDef creates a deep clone of the input.
func CloneRefOfJtNestedPathColDef(n *JtNestedPathColDef) *JtNestedPathColDef {
	if n == nil {
		return nil
	}
	out := *n
	out.Path = CloneExpr(n.Path)
	out.Columns = CloneSliceOfRefOfJtColumnDefinition(n.Columns)
	return &out
}

// CloneTableAndLockTypes creates a deep clone of the input.
func CloneTableAndLockTypes(n TableAndLockTypes) TableAndLockTypes {
	if n == nil {
		return nil
	}
	res := make(TableAndLockTypes, 0, len(n))
	for _, x := range n {
		res = append(res, CloneRefOfTableAndLockType(x))
	}
	return res
}

// CloneComments creates a deep clone of the input.
func CloneComments(n Comments) Comments {
	if n == nil {
		return nil
	}
	res := make(Comments, 0, len(n))
	for _, x := range n {
		res = append(res, x)
	}
	return res
}

// CloneRefOfInt creates a deep clone of the input.
func CloneRefOfInt(n *int) *int {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// CloneSliceOfRefOfPartitionDefinition creates a deep clone of the input.
func CloneSliceOfRefOfPartitionDefinition(n []*PartitionDefinition) []*PartitionDefinition {
	if n == nil {
		return nil
	}
	res := make([]*PartitionDefinition, 0, len(n))
	for _, x := range n {
		res = append(res, CloneRefOfPartitionDefinition(x))
	}
	return res
}

// CloneSliceOfRefOfRenameTablePair creates a deep clone of the input.
func CloneSliceOfRefOfRenameTablePair(n []*RenameTablePair) []*RenameTablePair {
	if n == nil {
		return nil
	}
	res := make([]*RenameTablePair, 0, len(n))
	for _, x := range n {
		res = append(res, CloneRefOfRenameTablePair(x))
	}
	return res
}

// CloneRefOfRootNode creates a deep clone of the input.
func CloneRefOfRootNode(n *RootNode) *RootNode {
	if n == nil {
		return nil
	}
	out := *n
	out.SQLNode = CloneSQLNode(n.SQLNode)
	return &out
}

// CloneSliceOfTableExpr creates a deep clone of the input.
func CloneSliceOfTableExpr(n []TableExpr) []TableExpr {
	if n == nil {
		return nil
	}
	res := make([]TableExpr, 0, len(n))
	for _, x := range n {
		res = append(res, CloneTableExpr(x))
	}
	return res
}

// CloneSliceOfCharacteristic creates a deep clone of the input.
func CloneSliceOfCharacteristic(n []Characteristic) []Characteristic {
	if n == nil {
		return nil
	}
	res := make([]Characteristic, 0, len(n))
	for _, x := range n {
		res = append(res, CloneCharacteristic(x))
	}
	return res
}

// CloneRefOfTableIdent creates a deep clone of the input.
func CloneRefOfTableIdent(n *TableIdent) *TableIdent {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// CloneRefOfTableName creates a deep clone of the input.
func CloneRefOfTableName(n *TableName) *TableName {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = CloneTableIdent(n.Name)
	out.Qualifier = CloneTableIdent(n.Qualifier)
	return &out
}

// CloneRefOfTableOption creates a deep clone of the input.
func CloneRefOfTableOption(n *TableOption) *TableOption {
	if n == nil {
		return nil
	}
	out := *n
	out.Value = CloneRefOfLiteral(n.Value)
	out.Tables = CloneTableNames(n.Tables)
	return &out
}

// CloneSliceOfRefOfIndexDefinition creates a deep clone of the input.
func CloneSliceOfRefOfIndexDefinition(n []*IndexDefinition) []*IndexDefinition {
	if n == nil {
		return nil
	}
	res := make([]*IndexDefinition, 0, len(n))
	for _, x := range n {
		res = append(res, CloneRefOfIndexDefinition(x))
	}
	return res
}

// CloneSliceOfRefOfConstraintDefinition creates a deep clone of the input.
func CloneSliceOfRefOfConstraintDefinition(n []*ConstraintDefinition) []*ConstraintDefinition {
	if n == nil {
		return nil
	}
	res := make([]*ConstraintDefinition, 0, len(n))
	for _, x := range n {
		res = append(res, CloneRefOfConstraintDefinition(x))
	}
	return res
}

// CloneRefOfVindexParam creates a deep clone of the input.
func CloneRefOfVindexParam(n *VindexParam) *VindexParam {
	if n == nil {
		return nil
	}
	out := *n
	out.Key = CloneColIdent(n.Key)
	return &out
}

// CloneSliceOfVindexParam creates a deep clone of the input.
func CloneSliceOfVindexParam(n []VindexParam) []VindexParam {
	if n == nil {
		return nil
	}
	res := make([]VindexParam, 0, len(n))
	for _, x := range n {
		res = append(res, CloneVindexParam(x))
	}
	return res
}

// CloneSliceOfRefOfCommonTableExpr creates a deep clone of the input.
func CloneSliceOfRefOfCommonTableExpr(n []*CommonTableExpr) []*CommonTableExpr {
	if n == nil {
		return nil
	}
	res := make([]*CommonTableExpr, 0, len(n))
	for _, x := range n {
		res = append(res, CloneRefOfCommonTableExpr(x))
	}
	return res
}

// CloneDatabaseOption creates a deep clone of the input.
func CloneDatabaseOption(n DatabaseOption) DatabaseOption {
	return *CloneRefOfDatabaseOption(&n)
}

// CloneRefOfColumnCharset creates a deep clone of the input.
func CloneRefOfColumnCharset(n *ColumnCharset) *ColumnCharset {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// CloneRefOfIndexColumn creates a deep clone of the input.
func CloneRefOfIndexColumn(n *IndexColumn) *IndexColumn {
	if n == nil {
		return nil
	}
	out := *n
	out.Column = CloneColIdent(n.Column)
	out.Length = CloneRefOfLiteral(n.Length)
	out.Expression = CloneExpr(n.Expression)
	return &out
}

// CloneRefOfIndexOption creates a deep clone of the input.
func CloneRefOfIndexOption(n *IndexOption) *IndexOption {
	if n == nil {
		return nil
	}
	out := *n
	out.Value = CloneRefOfLiteral(n.Value)
	return &out
}

// CloneRefOfTableAndLockType creates a deep clone of the input.
func CloneRefOfTableAndLockType(n *TableAndLockType) *TableAndLockType {
	if n == nil {
		return nil
	}
	out := *n
	out.Table = CloneTableExpr(n.Table)
	return &out
}

// CloneRefOfRenameTablePair creates a deep clone of the input.
func CloneRefOfRenameTablePair(n *RenameTablePair) *RenameTablePair {
	if n == nil {
		return nil
	}
	out := *n
	out.FromTable = CloneTableName(n.FromTable)
	out.ToTable = CloneTableName(n.ToTable)
	return &out
}

// CloneRefOfDatabaseOption creates a deep clone of the input.
func CloneRefOfDatabaseOption(n *DatabaseOption) *DatabaseOption {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}
