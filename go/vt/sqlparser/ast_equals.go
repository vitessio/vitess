/*
Copyright 2023 The Vitess Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
// Code generated by ASTHelperGen. DO NOT EDIT.

package sqlparser

// SQLNode does deep equals between the two objects.
func (cmp *Comparator) SQLNode(inA, inB SQLNode) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *AddColumns:
		b, ok := inB.(*AddColumns)
		if !ok {
			return false
		}
		return cmp.RefOfAddColumns(a, b)
	case *AddConstraintDefinition:
		b, ok := inB.(*AddConstraintDefinition)
		if !ok {
			return false
		}
		return cmp.RefOfAddConstraintDefinition(a, b)
	case *AddIndexDefinition:
		b, ok := inB.(*AddIndexDefinition)
		if !ok {
			return false
		}
		return cmp.RefOfAddIndexDefinition(a, b)
	case AlgorithmValue:
		b, ok := inB.(AlgorithmValue)
		if !ok {
			return false
		}
		return a == b
	case *AliasedExpr:
		b, ok := inB.(*AliasedExpr)
		if !ok {
			return false
		}
		return cmp.RefOfAliasedExpr(a, b)
	case *AliasedTableExpr:
		b, ok := inB.(*AliasedTableExpr)
		if !ok {
			return false
		}
		return cmp.RefOfAliasedTableExpr(a, b)
	case *AlterCharset:
		b, ok := inB.(*AlterCharset)
		if !ok {
			return false
		}
		return cmp.RefOfAlterCharset(a, b)
	case *AlterCheck:
		b, ok := inB.(*AlterCheck)
		if !ok {
			return false
		}
		return cmp.RefOfAlterCheck(a, b)
	case *AlterColumn:
		b, ok := inB.(*AlterColumn)
		if !ok {
			return false
		}
		return cmp.RefOfAlterColumn(a, b)
	case *AlterDatabase:
		b, ok := inB.(*AlterDatabase)
		if !ok {
			return false
		}
		return cmp.RefOfAlterDatabase(a, b)
	case *AlterIndex:
		b, ok := inB.(*AlterIndex)
		if !ok {
			return false
		}
		return cmp.RefOfAlterIndex(a, b)
	case *AlterMigration:
		b, ok := inB.(*AlterMigration)
		if !ok {
			return false
		}
		return cmp.RefOfAlterMigration(a, b)
	case *AlterTable:
		b, ok := inB.(*AlterTable)
		if !ok {
			return false
		}
		return cmp.RefOfAlterTable(a, b)
	case *AlterView:
		b, ok := inB.(*AlterView)
		if !ok {
			return false
		}
		return cmp.RefOfAlterView(a, b)
	case *AlterVschema:
		b, ok := inB.(*AlterVschema)
		if !ok {
			return false
		}
		return cmp.RefOfAlterVschema(a, b)
	case *AndExpr:
		b, ok := inB.(*AndExpr)
		if !ok {
			return false
		}
		return cmp.RefOfAndExpr(a, b)
	case Argument:
		b, ok := inB.(Argument)
		if !ok {
			return false
		}
		return a == b
	case *ArgumentLessWindowExpr:
		b, ok := inB.(*ArgumentLessWindowExpr)
		if !ok {
			return false
		}
		return cmp.RefOfArgumentLessWindowExpr(a, b)
	case *AutoIncSpec:
		b, ok := inB.(*AutoIncSpec)
		if !ok {
			return false
		}
		return cmp.RefOfAutoIncSpec(a, b)
	case *Avg:
		b, ok := inB.(*Avg)
		if !ok {
			return false
		}
		return cmp.RefOfAvg(a, b)
	case *Begin:
		b, ok := inB.(*Begin)
		if !ok {
			return false
		}
		return cmp.RefOfBegin(a, b)
	case *BetweenExpr:
		b, ok := inB.(*BetweenExpr)
		if !ok {
			return false
		}
		return cmp.RefOfBetweenExpr(a, b)
	case *BinaryExpr:
		b, ok := inB.(*BinaryExpr)
		if !ok {
			return false
		}
		return cmp.RefOfBinaryExpr(a, b)
	case *BitAnd:
		b, ok := inB.(*BitAnd)
		if !ok {
			return false
		}
		return cmp.RefOfBitAnd(a, b)
	case *BitOr:
		b, ok := inB.(*BitOr)
		if !ok {
			return false
		}
		return cmp.RefOfBitOr(a, b)
	case *BitXor:
		b, ok := inB.(*BitXor)
		if !ok {
			return false
		}
		return cmp.RefOfBitXor(a, b)
	case BoolVal:
		b, ok := inB.(BoolVal)
		if !ok {
			return false
		}
		return a == b
	case *CallProc:
		b, ok := inB.(*CallProc)
		if !ok {
			return false
		}
		return cmp.RefOfCallProc(a, b)
	case *CaseExpr:
		b, ok := inB.(*CaseExpr)
		if !ok {
			return false
		}
		return cmp.RefOfCaseExpr(a, b)
	case *CastExpr:
		b, ok := inB.(*CastExpr)
		if !ok {
			return false
		}
		return cmp.RefOfCastExpr(a, b)
	case *ChangeColumn:
		b, ok := inB.(*ChangeColumn)
		if !ok {
			return false
		}
		return cmp.RefOfChangeColumn(a, b)
	case *CharExpr:
		b, ok := inB.(*CharExpr)
		if !ok {
			return false
		}
		return cmp.RefOfCharExpr(a, b)
	case *CheckConstraintDefinition:
		b, ok := inB.(*CheckConstraintDefinition)
		if !ok {
			return false
		}
		return cmp.RefOfCheckConstraintDefinition(a, b)
	case *ColName:
		b, ok := inB.(*ColName)
		if !ok {
			return false
		}
		return cmp.RefOfColName(a, b)
	case *CollateExpr:
		b, ok := inB.(*CollateExpr)
		if !ok {
			return false
		}
		return cmp.RefOfCollateExpr(a, b)
	case *ColumnDefinition:
		b, ok := inB.(*ColumnDefinition)
		if !ok {
			return false
		}
		return cmp.RefOfColumnDefinition(a, b)
	case *ColumnType:
		b, ok := inB.(*ColumnType)
		if !ok {
			return false
		}
		return cmp.RefOfColumnType(a, b)
	case Columns:
		b, ok := inB.(Columns)
		if !ok {
			return false
		}
		return cmp.Columns(a, b)
	case *CommentOnly:
		b, ok := inB.(*CommentOnly)
		if !ok {
			return false
		}
		return cmp.RefOfCommentOnly(a, b)
	case *Commit:
		b, ok := inB.(*Commit)
		if !ok {
			return false
		}
		return cmp.RefOfCommit(a, b)
	case *CommonTableExpr:
		b, ok := inB.(*CommonTableExpr)
		if !ok {
			return false
		}
		return cmp.RefOfCommonTableExpr(a, b)
	case *ComparisonExpr:
		b, ok := inB.(*ComparisonExpr)
		if !ok {
			return false
		}
		return cmp.RefOfComparisonExpr(a, b)
	case *ConstraintDefinition:
		b, ok := inB.(*ConstraintDefinition)
		if !ok {
			return false
		}
		return cmp.RefOfConstraintDefinition(a, b)
	case *ConvertExpr:
		b, ok := inB.(*ConvertExpr)
		if !ok {
			return false
		}
		return cmp.RefOfConvertExpr(a, b)
	case *ConvertType:
		b, ok := inB.(*ConvertType)
		if !ok {
			return false
		}
		return cmp.RefOfConvertType(a, b)
	case *ConvertUsingExpr:
		b, ok := inB.(*ConvertUsingExpr)
		if !ok {
			return false
		}
		return cmp.RefOfConvertUsingExpr(a, b)
	case *Count:
		b, ok := inB.(*Count)
		if !ok {
			return false
		}
		return cmp.RefOfCount(a, b)
	case *CountStar:
		b, ok := inB.(*CountStar)
		if !ok {
			return false
		}
		return cmp.RefOfCountStar(a, b)
	case *CreateDatabase:
		b, ok := inB.(*CreateDatabase)
		if !ok {
			return false
		}
		return cmp.RefOfCreateDatabase(a, b)
	case *CreateTable:
		b, ok := inB.(*CreateTable)
		if !ok {
			return false
		}
		return cmp.RefOfCreateTable(a, b)
	case *CreateView:
		b, ok := inB.(*CreateView)
		if !ok {
			return false
		}
		return cmp.RefOfCreateView(a, b)
	case *CurTimeFuncExpr:
		b, ok := inB.(*CurTimeFuncExpr)
		if !ok {
			return false
		}
		return cmp.RefOfCurTimeFuncExpr(a, b)
	case *DeallocateStmt:
		b, ok := inB.(*DeallocateStmt)
		if !ok {
			return false
		}
		return cmp.RefOfDeallocateStmt(a, b)
	case *Default:
		b, ok := inB.(*Default)
		if !ok {
			return false
		}
		return cmp.RefOfDefault(a, b)
	case *Definer:
		b, ok := inB.(*Definer)
		if !ok {
			return false
		}
		return cmp.RefOfDefiner(a, b)
	case *Delete:
		b, ok := inB.(*Delete)
		if !ok {
			return false
		}
		return cmp.RefOfDelete(a, b)
	case *DerivedTable:
		b, ok := inB.(*DerivedTable)
		if !ok {
			return false
		}
		return cmp.RefOfDerivedTable(a, b)
	case *DropColumn:
		b, ok := inB.(*DropColumn)
		if !ok {
			return false
		}
		return cmp.RefOfDropColumn(a, b)
	case *DropDatabase:
		b, ok := inB.(*DropDatabase)
		if !ok {
			return false
		}
		return cmp.RefOfDropDatabase(a, b)
	case *DropKey:
		b, ok := inB.(*DropKey)
		if !ok {
			return false
		}
		return cmp.RefOfDropKey(a, b)
	case *DropTable:
		b, ok := inB.(*DropTable)
		if !ok {
			return false
		}
		return cmp.RefOfDropTable(a, b)
	case *DropView:
		b, ok := inB.(*DropView)
		if !ok {
			return false
		}
		return cmp.RefOfDropView(a, b)
	case *ExecuteStmt:
		b, ok := inB.(*ExecuteStmt)
		if !ok {
			return false
		}
		return cmp.RefOfExecuteStmt(a, b)
	case *ExistsExpr:
		b, ok := inB.(*ExistsExpr)
		if !ok {
			return false
		}
		return cmp.RefOfExistsExpr(a, b)
	case *ExplainStmt:
		b, ok := inB.(*ExplainStmt)
		if !ok {
			return false
		}
		return cmp.RefOfExplainStmt(a, b)
	case *ExplainTab:
		b, ok := inB.(*ExplainTab)
		if !ok {
			return false
		}
		return cmp.RefOfExplainTab(a, b)
	case Exprs:
		b, ok := inB.(Exprs)
		if !ok {
			return false
		}
		return cmp.Exprs(a, b)
	case *ExtractFuncExpr:
		b, ok := inB.(*ExtractFuncExpr)
		if !ok {
			return false
		}
		return cmp.RefOfExtractFuncExpr(a, b)
	case *ExtractValueExpr:
		b, ok := inB.(*ExtractValueExpr)
		if !ok {
			return false
		}
		return cmp.RefOfExtractValueExpr(a, b)
	case *ExtractedSubquery:
		b, ok := inB.(*ExtractedSubquery)
		if !ok {
			return false
		}
		return cmp.RefOfExtractedSubquery(a, b)
	case *FirstOrLastValueExpr:
		b, ok := inB.(*FirstOrLastValueExpr)
		if !ok {
			return false
		}
		return cmp.RefOfFirstOrLastValueExpr(a, b)
	case *Flush:
		b, ok := inB.(*Flush)
		if !ok {
			return false
		}
		return cmp.RefOfFlush(a, b)
	case *Force:
		b, ok := inB.(*Force)
		if !ok {
			return false
		}
		return cmp.RefOfForce(a, b)
	case *ForeignKeyDefinition:
		b, ok := inB.(*ForeignKeyDefinition)
		if !ok {
			return false
		}
		return cmp.RefOfForeignKeyDefinition(a, b)
	case *FrameClause:
		b, ok := inB.(*FrameClause)
		if !ok {
			return false
		}
		return cmp.RefOfFrameClause(a, b)
	case *FramePoint:
		b, ok := inB.(*FramePoint)
		if !ok {
			return false
		}
		return cmp.RefOfFramePoint(a, b)
	case *FromFirstLastClause:
		b, ok := inB.(*FromFirstLastClause)
		if !ok {
			return false
		}
		return cmp.RefOfFromFirstLastClause(a, b)
	case *FuncExpr:
		b, ok := inB.(*FuncExpr)
		if !ok {
			return false
		}
		return cmp.RefOfFuncExpr(a, b)
	case *GTIDFuncExpr:
		b, ok := inB.(*GTIDFuncExpr)
		if !ok {
			return false
		}
		return cmp.RefOfGTIDFuncExpr(a, b)
	case GroupBy:
		b, ok := inB.(GroupBy)
		if !ok {
			return false
		}
		return cmp.GroupBy(a, b)
	case *GroupConcatExpr:
		b, ok := inB.(*GroupConcatExpr)
		if !ok {
			return false
		}
		return cmp.RefOfGroupConcatExpr(a, b)
	case IdentifierCI:
		b, ok := inB.(IdentifierCI)
		if !ok {
			return false
		}
		return cmp.IdentifierCI(a, b)
	case IdentifierCS:
		b, ok := inB.(IdentifierCS)
		if !ok {
			return false
		}
		return cmp.IdentifierCS(a, b)
	case *IndexDefinition:
		b, ok := inB.(*IndexDefinition)
		if !ok {
			return false
		}
		return cmp.RefOfIndexDefinition(a, b)
	case *IndexHint:
		b, ok := inB.(*IndexHint)
		if !ok {
			return false
		}
		return cmp.RefOfIndexHint(a, b)
	case IndexHints:
		b, ok := inB.(IndexHints)
		if !ok {
			return false
		}
		return cmp.IndexHints(a, b)
	case *IndexInfo:
		b, ok := inB.(*IndexInfo)
		if !ok {
			return false
		}
		return cmp.RefOfIndexInfo(a, b)
	case *Insert:
		b, ok := inB.(*Insert)
		if !ok {
			return false
		}
		return cmp.RefOfInsert(a, b)
	case *InsertExpr:
		b, ok := inB.(*InsertExpr)
		if !ok {
			return false
		}
		return cmp.RefOfInsertExpr(a, b)
	case *IntervalExpr:
		b, ok := inB.(*IntervalExpr)
		if !ok {
			return false
		}
		return cmp.RefOfIntervalExpr(a, b)
	case *IntervalFuncExpr:
		b, ok := inB.(*IntervalFuncExpr)
		if !ok {
			return false
		}
		return cmp.RefOfIntervalFuncExpr(a, b)
	case *IntroducerExpr:
		b, ok := inB.(*IntroducerExpr)
		if !ok {
			return false
		}
		return cmp.RefOfIntroducerExpr(a, b)
	case *IsExpr:
		b, ok := inB.(*IsExpr)
		if !ok {
			return false
		}
		return cmp.RefOfIsExpr(a, b)
	case *JSONArrayExpr:
		b, ok := inB.(*JSONArrayExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONArrayExpr(a, b)
	case *JSONAttributesExpr:
		b, ok := inB.(*JSONAttributesExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONAttributesExpr(a, b)
	case *JSONContainsExpr:
		b, ok := inB.(*JSONContainsExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONContainsExpr(a, b)
	case *JSONContainsPathExpr:
		b, ok := inB.(*JSONContainsPathExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONContainsPathExpr(a, b)
	case *JSONExtractExpr:
		b, ok := inB.(*JSONExtractExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONExtractExpr(a, b)
	case *JSONKeysExpr:
		b, ok := inB.(*JSONKeysExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONKeysExpr(a, b)
	case *JSONObjectExpr:
		b, ok := inB.(*JSONObjectExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONObjectExpr(a, b)
	case *JSONObjectParam:
		b, ok := inB.(*JSONObjectParam)
		if !ok {
			return false
		}
		return cmp.RefOfJSONObjectParam(a, b)
	case *JSONOverlapsExpr:
		b, ok := inB.(*JSONOverlapsExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONOverlapsExpr(a, b)
	case *JSONPrettyExpr:
		b, ok := inB.(*JSONPrettyExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONPrettyExpr(a, b)
	case *JSONQuoteExpr:
		b, ok := inB.(*JSONQuoteExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONQuoteExpr(a, b)
	case *JSONRemoveExpr:
		b, ok := inB.(*JSONRemoveExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONRemoveExpr(a, b)
	case *JSONSchemaValidFuncExpr:
		b, ok := inB.(*JSONSchemaValidFuncExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONSchemaValidFuncExpr(a, b)
	case *JSONSchemaValidationReportFuncExpr:
		b, ok := inB.(*JSONSchemaValidationReportFuncExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONSchemaValidationReportFuncExpr(a, b)
	case *JSONSearchExpr:
		b, ok := inB.(*JSONSearchExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONSearchExpr(a, b)
	case *JSONStorageFreeExpr:
		b, ok := inB.(*JSONStorageFreeExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONStorageFreeExpr(a, b)
	case *JSONStorageSizeExpr:
		b, ok := inB.(*JSONStorageSizeExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONStorageSizeExpr(a, b)
	case *JSONTableExpr:
		b, ok := inB.(*JSONTableExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONTableExpr(a, b)
	case *JSONUnquoteExpr:
		b, ok := inB.(*JSONUnquoteExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONUnquoteExpr(a, b)
	case *JSONValueExpr:
		b, ok := inB.(*JSONValueExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONValueExpr(a, b)
	case *JSONValueMergeExpr:
		b, ok := inB.(*JSONValueMergeExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONValueMergeExpr(a, b)
	case *JSONValueModifierExpr:
		b, ok := inB.(*JSONValueModifierExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONValueModifierExpr(a, b)
	case *JoinCondition:
		b, ok := inB.(*JoinCondition)
		if !ok {
			return false
		}
		return cmp.RefOfJoinCondition(a, b)
	case *JoinTableExpr:
		b, ok := inB.(*JoinTableExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJoinTableExpr(a, b)
	case *JtColumnDefinition:
		b, ok := inB.(*JtColumnDefinition)
		if !ok {
			return false
		}
		return cmp.RefOfJtColumnDefinition(a, b)
	case *JtOnResponse:
		b, ok := inB.(*JtOnResponse)
		if !ok {
			return false
		}
		return cmp.RefOfJtOnResponse(a, b)
	case *KeyState:
		b, ok := inB.(*KeyState)
		if !ok {
			return false
		}
		return cmp.RefOfKeyState(a, b)
	case *LagLeadExpr:
		b, ok := inB.(*LagLeadExpr)
		if !ok {
			return false
		}
		return cmp.RefOfLagLeadExpr(a, b)
	case *Limit:
		b, ok := inB.(*Limit)
		if !ok {
			return false
		}
		return cmp.RefOfLimit(a, b)
	case ListArg:
		b, ok := inB.(ListArg)
		if !ok {
			return false
		}
		return a == b
	case *Literal:
		b, ok := inB.(*Literal)
		if !ok {
			return false
		}
		return cmp.RefOfLiteral(a, b)
	case *Load:
		b, ok := inB.(*Load)
		if !ok {
			return false
		}
		return cmp.RefOfLoad(a, b)
	case *LocateExpr:
		b, ok := inB.(*LocateExpr)
		if !ok {
			return false
		}
		return cmp.RefOfLocateExpr(a, b)
	case *LockOption:
		b, ok := inB.(*LockOption)
		if !ok {
			return false
		}
		return cmp.RefOfLockOption(a, b)
	case *LockTables:
		b, ok := inB.(*LockTables)
		if !ok {
			return false
		}
		return cmp.RefOfLockTables(a, b)
	case *LockingFunc:
		b, ok := inB.(*LockingFunc)
		if !ok {
			return false
		}
		return cmp.RefOfLockingFunc(a, b)
	case MatchAction:
		b, ok := inB.(MatchAction)
		if !ok {
			return false
		}
		return a == b
	case *MatchExpr:
		b, ok := inB.(*MatchExpr)
		if !ok {
			return false
		}
		return cmp.RefOfMatchExpr(a, b)
	case *Max:
		b, ok := inB.(*Max)
		if !ok {
			return false
		}
		return cmp.RefOfMax(a, b)
	case *MemberOfExpr:
		b, ok := inB.(*MemberOfExpr)
		if !ok {
			return false
		}
		return cmp.RefOfMemberOfExpr(a, b)
	case *Min:
		b, ok := inB.(*Min)
		if !ok {
			return false
		}
		return cmp.RefOfMin(a, b)
	case *ModifyColumn:
		b, ok := inB.(*ModifyColumn)
		if !ok {
			return false
		}
		return cmp.RefOfModifyColumn(a, b)
	case *NTHValueExpr:
		b, ok := inB.(*NTHValueExpr)
		if !ok {
			return false
		}
		return cmp.RefOfNTHValueExpr(a, b)
	case *NamedWindow:
		b, ok := inB.(*NamedWindow)
		if !ok {
			return false
		}
		return cmp.RefOfNamedWindow(a, b)
	case NamedWindows:
		b, ok := inB.(NamedWindows)
		if !ok {
			return false
		}
		return cmp.NamedWindows(a, b)
	case *Nextval:
		b, ok := inB.(*Nextval)
		if !ok {
			return false
		}
		return cmp.RefOfNextval(a, b)
	case *NotExpr:
		b, ok := inB.(*NotExpr)
		if !ok {
			return false
		}
		return cmp.RefOfNotExpr(a, b)
	case *NtileExpr:
		b, ok := inB.(*NtileExpr)
		if !ok {
			return false
		}
		return cmp.RefOfNtileExpr(a, b)
	case *NullTreatmentClause:
		b, ok := inB.(*NullTreatmentClause)
		if !ok {
			return false
		}
		return cmp.RefOfNullTreatmentClause(a, b)
	case *NullVal:
		b, ok := inB.(*NullVal)
		if !ok {
			return false
		}
		return cmp.RefOfNullVal(a, b)
	case *Offset:
		b, ok := inB.(*Offset)
		if !ok {
			return false
		}
		return cmp.RefOfOffset(a, b)
	case OnDup:
		b, ok := inB.(OnDup)
		if !ok {
			return false
		}
		return cmp.OnDup(a, b)
	case *OptLike:
		b, ok := inB.(*OptLike)
		if !ok {
			return false
		}
		return cmp.RefOfOptLike(a, b)
	case *OrExpr:
		b, ok := inB.(*OrExpr)
		if !ok {
			return false
		}
		return cmp.RefOfOrExpr(a, b)
	case *Order:
		b, ok := inB.(*Order)
		if !ok {
			return false
		}
		return cmp.RefOfOrder(a, b)
	case OrderBy:
		b, ok := inB.(OrderBy)
		if !ok {
			return false
		}
		return cmp.OrderBy(a, b)
	case *OrderByOption:
		b, ok := inB.(*OrderByOption)
		if !ok {
			return false
		}
		return cmp.RefOfOrderByOption(a, b)
	case *OtherAdmin:
		b, ok := inB.(*OtherAdmin)
		if !ok {
			return false
		}
		return cmp.RefOfOtherAdmin(a, b)
	case *OtherRead:
		b, ok := inB.(*OtherRead)
		if !ok {
			return false
		}
		return cmp.RefOfOtherRead(a, b)
	case *OverClause:
		b, ok := inB.(*OverClause)
		if !ok {
			return false
		}
		return cmp.RefOfOverClause(a, b)
	case *ParenTableExpr:
		b, ok := inB.(*ParenTableExpr)
		if !ok {
			return false
		}
		return cmp.RefOfParenTableExpr(a, b)
	case *ParsedComments:
		b, ok := inB.(*ParsedComments)
		if !ok {
			return false
		}
		return cmp.RefOfParsedComments(a, b)
	case *PartitionDefinition:
		b, ok := inB.(*PartitionDefinition)
		if !ok {
			return false
		}
		return cmp.RefOfPartitionDefinition(a, b)
	case *PartitionDefinitionOptions:
		b, ok := inB.(*PartitionDefinitionOptions)
		if !ok {
			return false
		}
		return cmp.RefOfPartitionDefinitionOptions(a, b)
	case *PartitionEngine:
		b, ok := inB.(*PartitionEngine)
		if !ok {
			return false
		}
		return cmp.RefOfPartitionEngine(a, b)
	case *PartitionOption:
		b, ok := inB.(*PartitionOption)
		if !ok {
			return false
		}
		return cmp.RefOfPartitionOption(a, b)
	case *PartitionSpec:
		b, ok := inB.(*PartitionSpec)
		if !ok {
			return false
		}
		return cmp.RefOfPartitionSpec(a, b)
	case *PartitionValueRange:
		b, ok := inB.(*PartitionValueRange)
		if !ok {
			return false
		}
		return cmp.RefOfPartitionValueRange(a, b)
	case Partitions:
		b, ok := inB.(Partitions)
		if !ok {
			return false
		}
		return cmp.Partitions(a, b)
	case *PerformanceSchemaFuncExpr:
		b, ok := inB.(*PerformanceSchemaFuncExpr)
		if !ok {
			return false
		}
		return cmp.RefOfPerformanceSchemaFuncExpr(a, b)
	case *PrepareStmt:
		b, ok := inB.(*PrepareStmt)
		if !ok {
			return false
		}
		return cmp.RefOfPrepareStmt(a, b)
	case ReferenceAction:
		b, ok := inB.(ReferenceAction)
		if !ok {
			return false
		}
		return a == b
	case *ReferenceDefinition:
		b, ok := inB.(*ReferenceDefinition)
		if !ok {
			return false
		}
		return cmp.RefOfReferenceDefinition(a, b)
	case *RegexpInstrExpr:
		b, ok := inB.(*RegexpInstrExpr)
		if !ok {
			return false
		}
		return cmp.RefOfRegexpInstrExpr(a, b)
	case *RegexpLikeExpr:
		b, ok := inB.(*RegexpLikeExpr)
		if !ok {
			return false
		}
		return cmp.RefOfRegexpLikeExpr(a, b)
	case *RegexpReplaceExpr:
		b, ok := inB.(*RegexpReplaceExpr)
		if !ok {
			return false
		}
		return cmp.RefOfRegexpReplaceExpr(a, b)
	case *RegexpSubstrExpr:
		b, ok := inB.(*RegexpSubstrExpr)
		if !ok {
			return false
		}
		return cmp.RefOfRegexpSubstrExpr(a, b)
	case *Release:
		b, ok := inB.(*Release)
		if !ok {
			return false
		}
		return cmp.RefOfRelease(a, b)
	case *RenameColumn:
		b, ok := inB.(*RenameColumn)
		if !ok {
			return false
		}
		return cmp.RefOfRenameColumn(a, b)
	case *RenameIndex:
		b, ok := inB.(*RenameIndex)
		if !ok {
			return false
		}
		return cmp.RefOfRenameIndex(a, b)
	case *RenameTable:
		b, ok := inB.(*RenameTable)
		if !ok {
			return false
		}
		return cmp.RefOfRenameTable(a, b)
	case *RenameTableName:
		b, ok := inB.(*RenameTableName)
		if !ok {
			return false
		}
		return cmp.RefOfRenameTableName(a, b)
	case *RevertMigration:
		b, ok := inB.(*RevertMigration)
		if !ok {
			return false
		}
		return cmp.RefOfRevertMigration(a, b)
	case *Rollback:
		b, ok := inB.(*Rollback)
		if !ok {
			return false
		}
		return cmp.RefOfRollback(a, b)
	case RootNode:
		b, ok := inB.(RootNode)
		if !ok {
			return false
		}
		return cmp.RootNode(a, b)
	case *SRollback:
		b, ok := inB.(*SRollback)
		if !ok {
			return false
		}
		return cmp.RefOfSRollback(a, b)
	case *Savepoint:
		b, ok := inB.(*Savepoint)
		if !ok {
			return false
		}
		return cmp.RefOfSavepoint(a, b)
	case *Select:
		b, ok := inB.(*Select)
		if !ok {
			return false
		}
		return cmp.RefOfSelect(a, b)
	case SelectExprs:
		b, ok := inB.(SelectExprs)
		if !ok {
			return false
		}
		return cmp.SelectExprs(a, b)
	case *SelectInto:
		b, ok := inB.(*SelectInto)
		if !ok {
			return false
		}
		return cmp.RefOfSelectInto(a, b)
	case *Set:
		b, ok := inB.(*Set)
		if !ok {
			return false
		}
		return cmp.RefOfSet(a, b)
	case *SetExpr:
		b, ok := inB.(*SetExpr)
		if !ok {
			return false
		}
		return cmp.RefOfSetExpr(a, b)
	case SetExprs:
		b, ok := inB.(SetExprs)
		if !ok {
			return false
		}
		return cmp.SetExprs(a, b)
	case *Show:
		b, ok := inB.(*Show)
		if !ok {
			return false
		}
		return cmp.RefOfShow(a, b)
	case *ShowBasic:
		b, ok := inB.(*ShowBasic)
		if !ok {
			return false
		}
		return cmp.RefOfShowBasic(a, b)
	case *ShowCreate:
		b, ok := inB.(*ShowCreate)
		if !ok {
			return false
		}
		return cmp.RefOfShowCreate(a, b)
	case *ShowFilter:
		b, ok := inB.(*ShowFilter)
		if !ok {
			return false
		}
		return cmp.RefOfShowFilter(a, b)
	case *ShowMigrationLogs:
		b, ok := inB.(*ShowMigrationLogs)
		if !ok {
			return false
		}
		return cmp.RefOfShowMigrationLogs(a, b)
	case *ShowOther:
		b, ok := inB.(*ShowOther)
		if !ok {
			return false
		}
		return cmp.RefOfShowOther(a, b)
	case *ShowThrottledApps:
		b, ok := inB.(*ShowThrottledApps)
		if !ok {
			return false
		}
		return cmp.RefOfShowThrottledApps(a, b)
	case *ShowThrottlerStatus:
		b, ok := inB.(*ShowThrottlerStatus)
		if !ok {
			return false
		}
		return cmp.RefOfShowThrottlerStatus(a, b)
	case *StarExpr:
		b, ok := inB.(*StarExpr)
		if !ok {
			return false
		}
		return cmp.RefOfStarExpr(a, b)
	case *Std:
		b, ok := inB.(*Std)
		if !ok {
			return false
		}
		return cmp.RefOfStd(a, b)
	case *StdDev:
		b, ok := inB.(*StdDev)
		if !ok {
			return false
		}
		return cmp.RefOfStdDev(a, b)
	case *StdPop:
		b, ok := inB.(*StdPop)
		if !ok {
			return false
		}
		return cmp.RefOfStdPop(a, b)
	case *StdSamp:
		b, ok := inB.(*StdSamp)
		if !ok {
			return false
		}
		return cmp.RefOfStdSamp(a, b)
	case *Stream:
		b, ok := inB.(*Stream)
		if !ok {
			return false
		}
		return cmp.RefOfStream(a, b)
	case *SubPartition:
		b, ok := inB.(*SubPartition)
		if !ok {
			return false
		}
		return cmp.RefOfSubPartition(a, b)
	case *SubPartitionDefinition:
		b, ok := inB.(*SubPartitionDefinition)
		if !ok {
			return false
		}
		return cmp.RefOfSubPartitionDefinition(a, b)
	case *SubPartitionDefinitionOptions:
		b, ok := inB.(*SubPartitionDefinitionOptions)
		if !ok {
			return false
		}
		return cmp.RefOfSubPartitionDefinitionOptions(a, b)
	case SubPartitionDefinitions:
		b, ok := inB.(SubPartitionDefinitions)
		if !ok {
			return false
		}
		return cmp.SubPartitionDefinitions(a, b)
	case *Subquery:
		b, ok := inB.(*Subquery)
		if !ok {
			return false
		}
		return cmp.RefOfSubquery(a, b)
	case *SubstrExpr:
		b, ok := inB.(*SubstrExpr)
		if !ok {
			return false
		}
		return cmp.RefOfSubstrExpr(a, b)
	case *Sum:
		b, ok := inB.(*Sum)
		if !ok {
			return false
		}
		return cmp.RefOfSum(a, b)
	case TableExprs:
		b, ok := inB.(TableExprs)
		if !ok {
			return false
		}
		return cmp.TableExprs(a, b)
	case TableName:
		b, ok := inB.(TableName)
		if !ok {
			return false
		}
		return cmp.TableName(a, b)
	case TableNames:
		b, ok := inB.(TableNames)
		if !ok {
			return false
		}
		return cmp.TableNames(a, b)
	case TableOptions:
		b, ok := inB.(TableOptions)
		if !ok {
			return false
		}
		return cmp.TableOptions(a, b)
	case *TableSpec:
		b, ok := inB.(*TableSpec)
		if !ok {
			return false
		}
		return cmp.RefOfTableSpec(a, b)
	case *TablespaceOperation:
		b, ok := inB.(*TablespaceOperation)
		if !ok {
			return false
		}
		return cmp.RefOfTablespaceOperation(a, b)
	case *TimestampFuncExpr:
		b, ok := inB.(*TimestampFuncExpr)
		if !ok {
			return false
		}
		return cmp.RefOfTimestampFuncExpr(a, b)
	case *TrimFuncExpr:
		b, ok := inB.(*TrimFuncExpr)
		if !ok {
			return false
		}
		return cmp.RefOfTrimFuncExpr(a, b)
	case *TruncateTable:
		b, ok := inB.(*TruncateTable)
		if !ok {
			return false
		}
		return cmp.RefOfTruncateTable(a, b)
	case *UnaryExpr:
		b, ok := inB.(*UnaryExpr)
		if !ok {
			return false
		}
		return cmp.RefOfUnaryExpr(a, b)
	case *Union:
		b, ok := inB.(*Union)
		if !ok {
			return false
		}
		return cmp.RefOfUnion(a, b)
	case *UnlockTables:
		b, ok := inB.(*UnlockTables)
		if !ok {
			return false
		}
		return cmp.RefOfUnlockTables(a, b)
	case *Update:
		b, ok := inB.(*Update)
		if !ok {
			return false
		}
		return cmp.RefOfUpdate(a, b)
	case *UpdateExpr:
		b, ok := inB.(*UpdateExpr)
		if !ok {
			return false
		}
		return cmp.RefOfUpdateExpr(a, b)
	case UpdateExprs:
		b, ok := inB.(UpdateExprs)
		if !ok {
			return false
		}
		return cmp.UpdateExprs(a, b)
	case *UpdateXMLExpr:
		b, ok := inB.(*UpdateXMLExpr)
		if !ok {
			return false
		}
		return cmp.RefOfUpdateXMLExpr(a, b)
	case *Use:
		b, ok := inB.(*Use)
		if !ok {
			return false
		}
		return cmp.RefOfUse(a, b)
	case *VExplainStmt:
		b, ok := inB.(*VExplainStmt)
		if !ok {
			return false
		}
		return cmp.RefOfVExplainStmt(a, b)
	case *VStream:
		b, ok := inB.(*VStream)
		if !ok {
			return false
		}
		return cmp.RefOfVStream(a, b)
	case ValTuple:
		b, ok := inB.(ValTuple)
		if !ok {
			return false
		}
		return cmp.ValTuple(a, b)
	case *Validation:
		b, ok := inB.(*Validation)
		if !ok {
			return false
		}
		return cmp.RefOfValidation(a, b)
	case Values:
		b, ok := inB.(Values)
		if !ok {
			return false
		}
		return cmp.Values(a, b)
	case *ValuesFuncExpr:
		b, ok := inB.(*ValuesFuncExpr)
		if !ok {
			return false
		}
		return cmp.RefOfValuesFuncExpr(a, b)
	case *VarPop:
		b, ok := inB.(*VarPop)
		if !ok {
			return false
		}
		return cmp.RefOfVarPop(a, b)
	case *VarSamp:
		b, ok := inB.(*VarSamp)
		if !ok {
			return false
		}
		return cmp.RefOfVarSamp(a, b)
	case *Variable:
		b, ok := inB.(*Variable)
		if !ok {
			return false
		}
		return cmp.RefOfVariable(a, b)
	case *Variance:
		b, ok := inB.(*Variance)
		if !ok {
			return false
		}
		return cmp.RefOfVariance(a, b)
	case VindexParam:
		b, ok := inB.(VindexParam)
		if !ok {
			return false
		}
		return cmp.VindexParam(a, b)
	case *VindexSpec:
		b, ok := inB.(*VindexSpec)
		if !ok {
			return false
		}
		return cmp.RefOfVindexSpec(a, b)
	case *WeightStringFuncExpr:
		b, ok := inB.(*WeightStringFuncExpr)
		if !ok {
			return false
		}
		return cmp.RefOfWeightStringFuncExpr(a, b)
	case *When:
		b, ok := inB.(*When)
		if !ok {
			return false
		}
		return cmp.RefOfWhen(a, b)
	case *Where:
		b, ok := inB.(*Where)
		if !ok {
			return false
		}
		return cmp.RefOfWhere(a, b)
	case *WindowDefinition:
		b, ok := inB.(*WindowDefinition)
		if !ok {
			return false
		}
		return cmp.RefOfWindowDefinition(a, b)
	case WindowDefinitions:
		b, ok := inB.(WindowDefinitions)
		if !ok {
			return false
		}
		return cmp.WindowDefinitions(a, b)
	case *WindowSpecification:
		b, ok := inB.(*WindowSpecification)
		if !ok {
			return false
		}
		return cmp.RefOfWindowSpecification(a, b)
	case *With:
		b, ok := inB.(*With)
		if !ok {
			return false
		}
		return cmp.RefOfWith(a, b)
	case *XorExpr:
		b, ok := inB.(*XorExpr)
		if !ok {
			return false
		}
		return cmp.RefOfXorExpr(a, b)
	default:
		// this should never happen
		return false
	}
}

// RefOfAddColumns does deep equals between the two objects.
func (cmp *Comparator) RefOfAddColumns(a, b *AddColumns) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.First == b.First &&
		cmp.SliceOfRefOfColumnDefinition(a.Columns, b.Columns) &&
		cmp.RefOfColName(a.After, b.After)
}

// RefOfAddConstraintDefinition does deep equals between the two objects.
func (cmp *Comparator) RefOfAddConstraintDefinition(a, b *AddConstraintDefinition) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.RefOfConstraintDefinition(a.ConstraintDefinition, b.ConstraintDefinition)
}

// RefOfAddIndexDefinition does deep equals between the two objects.
func (cmp *Comparator) RefOfAddIndexDefinition(a, b *AddIndexDefinition) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.RefOfIndexDefinition(a.IndexDefinition, b.IndexDefinition)
}

// RefOfAliasedExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfAliasedExpr(a, b *AliasedExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.Expr, b.Expr) &&
		cmp.IdentifierCI(a.As, b.As)
}

// RefOfAliasedTableExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfAliasedTableExpr(a, b *AliasedTableExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.SimpleTableExpr(a.Expr, b.Expr) &&
		cmp.Partitions(a.Partitions, b.Partitions) &&
		cmp.IdentifierCS(a.As, b.As) &&
		cmp.IndexHints(a.Hints, b.Hints) &&
		cmp.Columns(a.Columns, b.Columns)
}

// RefOfAlterCharset does deep equals between the two objects.
func (cmp *Comparator) RefOfAlterCharset(a, b *AlterCharset) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.CharacterSet == b.CharacterSet &&
		a.Collate == b.Collate
}

// RefOfAlterCheck does deep equals between the two objects.
func (cmp *Comparator) RefOfAlterCheck(a, b *AlterCheck) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Enforced == b.Enforced &&
		cmp.IdentifierCI(a.Name, b.Name)
}

// RefOfAlterColumn does deep equals between the two objects.
func (cmp *Comparator) RefOfAlterColumn(a, b *AlterColumn) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.DropDefault == b.DropDefault &&
		cmp.RefOfColName(a.Column, b.Column) &&
		cmp.Expr(a.DefaultVal, b.DefaultVal) &&
		cmp.RefOfBool(a.Invisible, b.Invisible)
}

// RefOfAlterDatabase does deep equals between the two objects.
func (cmp *Comparator) RefOfAlterDatabase(a, b *AlterDatabase) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.UpdateDataDirectory == b.UpdateDataDirectory &&
		a.FullyParsed == b.FullyParsed &&
		cmp.IdentifierCS(a.DBName, b.DBName) &&
		cmp.SliceOfDatabaseOption(a.AlterOptions, b.AlterOptions)
}

// RefOfAlterIndex does deep equals between the two objects.
func (cmp *Comparator) RefOfAlterIndex(a, b *AlterIndex) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Invisible == b.Invisible &&
		cmp.IdentifierCI(a.Name, b.Name)
}

// RefOfAlterMigration does deep equals between the two objects.
func (cmp *Comparator) RefOfAlterMigration(a, b *AlterMigration) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.UUID == b.UUID &&
		a.Expire == b.Expire &&
		a.Shards == b.Shards &&
		a.Type == b.Type &&
		cmp.RefOfLiteral(a.Ratio, b.Ratio)
}

// RefOfAlterTable does deep equals between the two objects.
func (cmp *Comparator) RefOfAlterTable(a, b *AlterTable) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.FullyParsed == b.FullyParsed &&
		cmp.TableName(a.Table, b.Table) &&
		cmp.SliceOfAlterOption(a.AlterOptions, b.AlterOptions) &&
		cmp.RefOfPartitionSpec(a.PartitionSpec, b.PartitionSpec) &&
		cmp.RefOfPartitionOption(a.PartitionOption, b.PartitionOption) &&
		cmp.RefOfParsedComments(a.Comments, b.Comments)
}

// RefOfAlterView does deep equals between the two objects.
func (cmp *Comparator) RefOfAlterView(a, b *AlterView) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Algorithm == b.Algorithm &&
		a.Security == b.Security &&
		a.CheckOption == b.CheckOption &&
		cmp.TableName(a.ViewName, b.ViewName) &&
		cmp.RefOfDefiner(a.Definer, b.Definer) &&
		cmp.Columns(a.Columns, b.Columns) &&
		cmp.SelectStatement(a.Select, b.Select) &&
		cmp.RefOfParsedComments(a.Comments, b.Comments)
}

// RefOfAlterVschema does deep equals between the two objects.
func (cmp *Comparator) RefOfAlterVschema(a, b *AlterVschema) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Action == b.Action &&
		cmp.TableName(a.Table, b.Table) &&
		cmp.RefOfVindexSpec(a.VindexSpec, b.VindexSpec) &&
		cmp.SliceOfIdentifierCI(a.VindexCols, b.VindexCols) &&
		cmp.RefOfAutoIncSpec(a.AutoIncSpec, b.AutoIncSpec)
}

// RefOfAndExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfAndExpr(a, b *AndExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.Left, b.Left) &&
		cmp.Expr(a.Right, b.Right)
}

// RefOfArgumentLessWindowExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfArgumentLessWindowExpr(a, b *ArgumentLessWindowExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		cmp.RefOfOverClause(a.OverClause, b.OverClause)
}

// RefOfAutoIncSpec does deep equals between the two objects.
func (cmp *Comparator) RefOfAutoIncSpec(a, b *AutoIncSpec) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.IdentifierCI(a.Column, b.Column) &&
		cmp.TableName(a.Sequence, b.Sequence)
}

// RefOfAvg does deep equals between the two objects.
func (cmp *Comparator) RefOfAvg(a, b *Avg) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Distinct == b.Distinct &&
		cmp.Expr(a.Arg, b.Arg)
}

// RefOfBegin does deep equals between the two objects.
func (cmp *Comparator) RefOfBegin(a, b *Begin) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.SliceOfTxAccessMode(a.TxAccessModes, b.TxAccessModes)
}

// RefOfBetweenExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfBetweenExpr(a, b *BetweenExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.IsBetween == b.IsBetween &&
		cmp.Expr(a.Left, b.Left) &&
		cmp.Expr(a.From, b.From) &&
		cmp.Expr(a.To, b.To)
}

// RefOfBinaryExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfBinaryExpr(a, b *BinaryExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Operator == b.Operator &&
		cmp.Expr(a.Left, b.Left) &&
		cmp.Expr(a.Right, b.Right)
}

// RefOfBitAnd does deep equals between the two objects.
func (cmp *Comparator) RefOfBitAnd(a, b *BitAnd) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.Arg, b.Arg)
}

// RefOfBitOr does deep equals between the two objects.
func (cmp *Comparator) RefOfBitOr(a, b *BitOr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.Arg, b.Arg)
}

// RefOfBitXor does deep equals between the two objects.
func (cmp *Comparator) RefOfBitXor(a, b *BitXor) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.Arg, b.Arg)
}

// RefOfCallProc does deep equals between the two objects.
func (cmp *Comparator) RefOfCallProc(a, b *CallProc) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.TableName(a.Name, b.Name) &&
		cmp.Exprs(a.Params, b.Params)
}

// RefOfCaseExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfCaseExpr(a, b *CaseExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.Expr, b.Expr) &&
		cmp.SliceOfRefOfWhen(a.Whens, b.Whens) &&
		cmp.Expr(a.Else, b.Else)
}

// RefOfCastExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfCastExpr(a, b *CastExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Array == b.Array &&
		cmp.Expr(a.Expr, b.Expr) &&
		cmp.RefOfConvertType(a.Type, b.Type)
}

// RefOfChangeColumn does deep equals between the two objects.
func (cmp *Comparator) RefOfChangeColumn(a, b *ChangeColumn) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.First == b.First &&
		cmp.RefOfColName(a.OldColumn, b.OldColumn) &&
		cmp.RefOfColumnDefinition(a.NewColDefinition, b.NewColDefinition) &&
		cmp.RefOfColName(a.After, b.After)
}

// RefOfCharExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfCharExpr(a, b *CharExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Charset == b.Charset &&
		cmp.Exprs(a.Exprs, b.Exprs)
}

// RefOfCheckConstraintDefinition does deep equals between the two objects.
func (cmp *Comparator) RefOfCheckConstraintDefinition(a, b *CheckConstraintDefinition) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Enforced == b.Enforced &&
		cmp.Expr(a.Expr, b.Expr)
}

// RefOfColName does deep equals between the two objects.
func (cmp *Comparator) RefOfColName(a, b *ColName) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	if cmp.RefOfColName_ != nil {
		return cmp.RefOfColName_(a, b)
	}
	return cmp.IdentifierCI(a.Name, b.Name) &&
		cmp.TableName(a.Qualifier, b.Qualifier)
}

// RefOfCollateExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfCollateExpr(a, b *CollateExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Collation == b.Collation &&
		cmp.Expr(a.Expr, b.Expr)
}

// RefOfColumnDefinition does deep equals between the two objects.
func (cmp *Comparator) RefOfColumnDefinition(a, b *ColumnDefinition) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.IdentifierCI(a.Name, b.Name) &&
		cmp.RefOfColumnType(a.Type, b.Type)
}

// RefOfColumnType does deep equals between the two objects.
func (cmp *Comparator) RefOfColumnType(a, b *ColumnType) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		a.Unsigned == b.Unsigned &&
		a.Zerofill == b.Zerofill &&
		cmp.RefOfColumnTypeOptions(a.Options, b.Options) &&
		cmp.RefOfLiteral(a.Length, b.Length) &&
		cmp.RefOfLiteral(a.Scale, b.Scale) &&
		cmp.ColumnCharset(a.Charset, b.Charset) &&
		cmp.SliceOfString(a.EnumValues, b.EnumValues)
}

// Columns does deep equals between the two objects.
func (cmp *Comparator) Columns(a, b Columns) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !cmp.IdentifierCI(a[i], b[i]) {
			return false
		}
	}
	return true
}

// RefOfCommentOnly does deep equals between the two objects.
func (cmp *Comparator) RefOfCommentOnly(a, b *CommentOnly) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.SliceOfString(a.Comments, b.Comments)
}

// RefOfCommit does deep equals between the two objects.
func (cmp *Comparator) RefOfCommit(a, b *Commit) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return true
}

// RefOfCommonTableExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfCommonTableExpr(a, b *CommonTableExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.IdentifierCS(a.ID, b.ID) &&
		cmp.Columns(a.Columns, b.Columns) &&
		cmp.RefOfSubquery(a.Subquery, b.Subquery)
}

// RefOfComparisonExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfComparisonExpr(a, b *ComparisonExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Operator == b.Operator &&
		cmp.Expr(a.Left, b.Left) &&
		cmp.Expr(a.Right, b.Right) &&
		cmp.Expr(a.Escape, b.Escape)
}

// RefOfConstraintDefinition does deep equals between the two objects.
func (cmp *Comparator) RefOfConstraintDefinition(a, b *ConstraintDefinition) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.IdentifierCI(a.Name, b.Name) &&
		cmp.ConstraintInfo(a.Details, b.Details)
}

// RefOfConvertExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfConvertExpr(a, b *ConvertExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.Expr, b.Expr) &&
		cmp.RefOfConvertType(a.Type, b.Type)
}

// RefOfConvertType does deep equals between the two objects.
func (cmp *Comparator) RefOfConvertType(a, b *ConvertType) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		cmp.RefOfLiteral(a.Length, b.Length) &&
		cmp.RefOfLiteral(a.Scale, b.Scale) &&
		cmp.ColumnCharset(a.Charset, b.Charset)
}

// RefOfConvertUsingExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfConvertUsingExpr(a, b *ConvertUsingExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		cmp.Expr(a.Expr, b.Expr)
}

// RefOfCount does deep equals between the two objects.
func (cmp *Comparator) RefOfCount(a, b *Count) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Distinct == b.Distinct &&
		cmp.Exprs(a.Args, b.Args)
}

// RefOfCountStar does deep equals between the two objects.
func (cmp *Comparator) RefOfCountStar(a, b *CountStar) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return true
}

// RefOfCreateDatabase does deep equals between the two objects.
func (cmp *Comparator) RefOfCreateDatabase(a, b *CreateDatabase) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.IfNotExists == b.IfNotExists &&
		a.FullyParsed == b.FullyParsed &&
		cmp.RefOfParsedComments(a.Comments, b.Comments) &&
		cmp.IdentifierCS(a.DBName, b.DBName) &&
		cmp.SliceOfDatabaseOption(a.CreateOptions, b.CreateOptions)
}

// RefOfCreateTable does deep equals between the two objects.
func (cmp *Comparator) RefOfCreateTable(a, b *CreateTable) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Temp == b.Temp &&
		a.IfNotExists == b.IfNotExists &&
		a.FullyParsed == b.FullyParsed &&
		cmp.TableName(a.Table, b.Table) &&
		cmp.RefOfTableSpec(a.TableSpec, b.TableSpec) &&
		cmp.RefOfOptLike(a.OptLike, b.OptLike) &&
		cmp.RefOfParsedComments(a.Comments, b.Comments)
}

// RefOfCreateView does deep equals between the two objects.
func (cmp *Comparator) RefOfCreateView(a, b *CreateView) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Algorithm == b.Algorithm &&
		a.Security == b.Security &&
		a.CheckOption == b.CheckOption &&
		a.IsReplace == b.IsReplace &&
		cmp.TableName(a.ViewName, b.ViewName) &&
		cmp.RefOfDefiner(a.Definer, b.Definer) &&
		cmp.Columns(a.Columns, b.Columns) &&
		cmp.SelectStatement(a.Select, b.Select) &&
		cmp.RefOfParsedComments(a.Comments, b.Comments)
}

// RefOfCurTimeFuncExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfCurTimeFuncExpr(a, b *CurTimeFuncExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.IdentifierCI(a.Name, b.Name) &&
		cmp.Expr(a.Fsp, b.Fsp)
}

// RefOfDeallocateStmt does deep equals between the two objects.
func (cmp *Comparator) RefOfDeallocateStmt(a, b *DeallocateStmt) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		cmp.RefOfParsedComments(a.Comments, b.Comments) &&
		cmp.IdentifierCI(a.Name, b.Name)
}

// RefOfDefault does deep equals between the two objects.
func (cmp *Comparator) RefOfDefault(a, b *Default) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.ColName == b.ColName
}

// RefOfDefiner does deep equals between the two objects.
func (cmp *Comparator) RefOfDefiner(a, b *Definer) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Name == b.Name &&
		a.Address == b.Address
}

// RefOfDelete does deep equals between the two objects.
func (cmp *Comparator) RefOfDelete(a, b *Delete) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.RefOfWith(a.With, b.With) &&
		a.Ignore == b.Ignore &&
		cmp.RefOfParsedComments(a.Comments, b.Comments) &&
		cmp.TableNames(a.Targets, b.Targets) &&
		cmp.TableExprs(a.TableExprs, b.TableExprs) &&
		cmp.Partitions(a.Partitions, b.Partitions) &&
		cmp.RefOfWhere(a.Where, b.Where) &&
		cmp.OrderBy(a.OrderBy, b.OrderBy) &&
		cmp.RefOfLimit(a.Limit, b.Limit)
}

// RefOfDerivedTable does deep equals between the two objects.
func (cmp *Comparator) RefOfDerivedTable(a, b *DerivedTable) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Lateral == b.Lateral &&
		cmp.SelectStatement(a.Select, b.Select)
}

// RefOfDropColumn does deep equals between the two objects.
func (cmp *Comparator) RefOfDropColumn(a, b *DropColumn) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.RefOfColName(a.Name, b.Name)
}

// RefOfDropDatabase does deep equals between the two objects.
func (cmp *Comparator) RefOfDropDatabase(a, b *DropDatabase) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.IfExists == b.IfExists &&
		cmp.RefOfParsedComments(a.Comments, b.Comments) &&
		cmp.IdentifierCS(a.DBName, b.DBName)
}

// RefOfDropKey does deep equals between the two objects.
func (cmp *Comparator) RefOfDropKey(a, b *DropKey) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		cmp.IdentifierCI(a.Name, b.Name)
}

// RefOfDropTable does deep equals between the two objects.
func (cmp *Comparator) RefOfDropTable(a, b *DropTable) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Temp == b.Temp &&
		a.IfExists == b.IfExists &&
		cmp.TableNames(a.FromTables, b.FromTables) &&
		cmp.RefOfParsedComments(a.Comments, b.Comments)
}

// RefOfDropView does deep equals between the two objects.
func (cmp *Comparator) RefOfDropView(a, b *DropView) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.IfExists == b.IfExists &&
		cmp.TableNames(a.FromTables, b.FromTables) &&
		cmp.RefOfParsedComments(a.Comments, b.Comments)
}

// RefOfExecuteStmt does deep equals between the two objects.
func (cmp *Comparator) RefOfExecuteStmt(a, b *ExecuteStmt) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.IdentifierCI(a.Name, b.Name) &&
		cmp.RefOfParsedComments(a.Comments, b.Comments) &&
		cmp.SliceOfRefOfVariable(a.Arguments, b.Arguments)
}

// RefOfExistsExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfExistsExpr(a, b *ExistsExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.RefOfSubquery(a.Subquery, b.Subquery)
}

// RefOfExplainStmt does deep equals between the two objects.
func (cmp *Comparator) RefOfExplainStmt(a, b *ExplainStmt) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		cmp.Statement(a.Statement, b.Statement) &&
		cmp.RefOfParsedComments(a.Comments, b.Comments)
}

// RefOfExplainTab does deep equals between the two objects.
func (cmp *Comparator) RefOfExplainTab(a, b *ExplainTab) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Wild == b.Wild &&
		cmp.TableName(a.Table, b.Table)
}

// Exprs does deep equals between the two objects.
func (cmp *Comparator) Exprs(a, b Exprs) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !cmp.Expr(a[i], b[i]) {
			return false
		}
	}
	return true
}

// RefOfExtractFuncExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfExtractFuncExpr(a, b *ExtractFuncExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.IntervalTypes == b.IntervalTypes &&
		cmp.Expr(a.Expr, b.Expr)
}

// RefOfExtractValueExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfExtractValueExpr(a, b *ExtractValueExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.Fragment, b.Fragment) &&
		cmp.Expr(a.XPathExpr, b.XPathExpr)
}

// RefOfExtractedSubquery does deep equals between the two objects.
func (cmp *Comparator) RefOfExtractedSubquery(a, b *ExtractedSubquery) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.OpCode == b.OpCode &&
		a.NeedsRewrite == b.NeedsRewrite &&
		a.hasValuesArg == b.hasValuesArg &&
		a.argName == b.argName &&
		cmp.Expr(a.Original, b.Original) &&
		cmp.RefOfSubquery(a.Subquery, b.Subquery) &&
		cmp.Expr(a.OtherSide, b.OtherSide) &&
		cmp.Expr(a.alternative, b.alternative)
}

// RefOfFirstOrLastValueExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfFirstOrLastValueExpr(a, b *FirstOrLastValueExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		cmp.Expr(a.Expr, b.Expr) &&
		cmp.RefOfNullTreatmentClause(a.NullTreatmentClause, b.NullTreatmentClause) &&
		cmp.RefOfOverClause(a.OverClause, b.OverClause)
}

// RefOfFlush does deep equals between the two objects.
func (cmp *Comparator) RefOfFlush(a, b *Flush) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.IsLocal == b.IsLocal &&
		a.WithLock == b.WithLock &&
		a.ForExport == b.ForExport &&
		cmp.SliceOfString(a.FlushOptions, b.FlushOptions) &&
		cmp.TableNames(a.TableNames, b.TableNames)
}

// RefOfForce does deep equals between the two objects.
func (cmp *Comparator) RefOfForce(a, b *Force) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return true
}

// RefOfForeignKeyDefinition does deep equals between the two objects.
func (cmp *Comparator) RefOfForeignKeyDefinition(a, b *ForeignKeyDefinition) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Columns(a.Source, b.Source) &&
		cmp.IdentifierCI(a.IndexName, b.IndexName) &&
		cmp.RefOfReferenceDefinition(a.ReferenceDefinition, b.ReferenceDefinition)
}

// RefOfFrameClause does deep equals between the two objects.
func (cmp *Comparator) RefOfFrameClause(a, b *FrameClause) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Unit == b.Unit &&
		cmp.RefOfFramePoint(a.Start, b.Start) &&
		cmp.RefOfFramePoint(a.End, b.End)
}

// RefOfFramePoint does deep equals between the two objects.
func (cmp *Comparator) RefOfFramePoint(a, b *FramePoint) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		cmp.Expr(a.Expr, b.Expr)
}

// RefOfFromFirstLastClause does deep equals between the two objects.
func (cmp *Comparator) RefOfFromFirstLastClause(a, b *FromFirstLastClause) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type
}

// RefOfFuncExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfFuncExpr(a, b *FuncExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.IdentifierCS(a.Qualifier, b.Qualifier) &&
		cmp.IdentifierCI(a.Name, b.Name) &&
		cmp.SelectExprs(a.Exprs, b.Exprs)
}

// RefOfGTIDFuncExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfGTIDFuncExpr(a, b *GTIDFuncExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		cmp.Expr(a.Set1, b.Set1) &&
		cmp.Expr(a.Set2, b.Set2) &&
		cmp.Expr(a.Timeout, b.Timeout) &&
		cmp.Expr(a.Channel, b.Channel)
}

// GroupBy does deep equals between the two objects.
func (cmp *Comparator) GroupBy(a, b GroupBy) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !cmp.Expr(a[i], b[i]) {
			return false
		}
	}
	return true
}

// RefOfGroupConcatExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfGroupConcatExpr(a, b *GroupConcatExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Distinct == b.Distinct &&
		a.Separator == b.Separator &&
		cmp.Exprs(a.Exprs, b.Exprs) &&
		cmp.OrderBy(a.OrderBy, b.OrderBy) &&
		cmp.RefOfLimit(a.Limit, b.Limit)
}

// IdentifierCI does deep equals between the two objects.
func (cmp *Comparator) IdentifierCI(a, b IdentifierCI) bool {
	return a.val == b.val &&
		a.lowered == b.lowered
}

// IdentifierCS does deep equals between the two objects.
func (cmp *Comparator) IdentifierCS(a, b IdentifierCS) bool {
	return a.v == b.v
}

// RefOfIndexDefinition does deep equals between the two objects.
func (cmp *Comparator) RefOfIndexDefinition(a, b *IndexDefinition) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.RefOfIndexInfo(a.Info, b.Info) &&
		cmp.SliceOfRefOfIndexColumn(a.Columns, b.Columns) &&
		cmp.SliceOfRefOfIndexOption(a.Options, b.Options)
}

// RefOfIndexHint does deep equals between the two objects.
func (cmp *Comparator) RefOfIndexHint(a, b *IndexHint) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		a.ForType == b.ForType &&
		cmp.SliceOfIdentifierCI(a.Indexes, b.Indexes)
}

// IndexHints does deep equals between the two objects.
func (cmp *Comparator) IndexHints(a, b IndexHints) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !cmp.RefOfIndexHint(a[i], b[i]) {
			return false
		}
	}
	return true
}

// RefOfIndexInfo does deep equals between the two objects.
func (cmp *Comparator) RefOfIndexInfo(a, b *IndexInfo) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		a.Primary == b.Primary &&
		a.Spatial == b.Spatial &&
		a.Fulltext == b.Fulltext &&
		a.Unique == b.Unique &&
		cmp.IdentifierCI(a.Name, b.Name) &&
		cmp.IdentifierCI(a.ConstraintName, b.ConstraintName)
}

// RefOfInsert does deep equals between the two objects.
func (cmp *Comparator) RefOfInsert(a, b *Insert) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Action == b.Action &&
		cmp.RefOfParsedComments(a.Comments, b.Comments) &&
		a.Ignore == b.Ignore &&
		cmp.TableName(a.Table, b.Table) &&
		cmp.Partitions(a.Partitions, b.Partitions) &&
		cmp.Columns(a.Columns, b.Columns) &&
		cmp.InsertRows(a.Rows, b.Rows) &&
		cmp.OnDup(a.OnDup, b.OnDup)
}

// RefOfInsertExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfInsertExpr(a, b *InsertExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.Str, b.Str) &&
		cmp.Expr(a.Pos, b.Pos) &&
		cmp.Expr(a.Len, b.Len) &&
		cmp.Expr(a.NewStr, b.NewStr)
}

// RefOfIntervalExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfIntervalExpr(a, b *IntervalExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Unit == b.Unit &&
		cmp.Expr(a.Expr, b.Expr)
}

// RefOfIntervalFuncExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfIntervalFuncExpr(a, b *IntervalFuncExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.Expr, b.Expr) &&
		cmp.Exprs(a.Exprs, b.Exprs)
}

// RefOfIntroducerExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfIntroducerExpr(a, b *IntroducerExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.CharacterSet == b.CharacterSet &&
		cmp.Expr(a.Expr, b.Expr)
}

// RefOfIsExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfIsExpr(a, b *IsExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.Left, b.Left) &&
		a.Right == b.Right
}

// RefOfJSONArrayExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfJSONArrayExpr(a, b *JSONArrayExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Exprs(a.Params, b.Params)
}

// RefOfJSONAttributesExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfJSONAttributesExpr(a, b *JSONAttributesExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		cmp.Expr(a.JSONDoc, b.JSONDoc) &&
		cmp.Expr(a.Path, b.Path)
}

// RefOfJSONContainsExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfJSONContainsExpr(a, b *JSONContainsExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.Target, b.Target) &&
		cmp.Expr(a.Candidate, b.Candidate) &&
		cmp.SliceOfExpr(a.PathList, b.PathList)
}

// RefOfJSONContainsPathExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfJSONContainsPathExpr(a, b *JSONContainsPathExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.JSONDoc, b.JSONDoc) &&
		cmp.Expr(a.OneOrAll, b.OneOrAll) &&
		cmp.SliceOfExpr(a.PathList, b.PathList)
}

// RefOfJSONExtractExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfJSONExtractExpr(a, b *JSONExtractExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.JSONDoc, b.JSONDoc) &&
		cmp.SliceOfExpr(a.PathList, b.PathList)
}

// RefOfJSONKeysExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfJSONKeysExpr(a, b *JSONKeysExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.JSONDoc, b.JSONDoc) &&
		cmp.Expr(a.Path, b.Path)
}

// RefOfJSONObjectExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfJSONObjectExpr(a, b *JSONObjectExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.SliceOfRefOfJSONObjectParam(a.Params, b.Params)
}

// RefOfJSONObjectParam does deep equals between the two objects.
func (cmp *Comparator) RefOfJSONObjectParam(a, b *JSONObjectParam) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.Key, b.Key) &&
		cmp.Expr(a.Value, b.Value)
}

// RefOfJSONOverlapsExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfJSONOverlapsExpr(a, b *JSONOverlapsExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.JSONDoc1, b.JSONDoc1) &&
		cmp.Expr(a.JSONDoc2, b.JSONDoc2)
}

// RefOfJSONPrettyExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfJSONPrettyExpr(a, b *JSONPrettyExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.JSONVal, b.JSONVal)
}

// RefOfJSONQuoteExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfJSONQuoteExpr(a, b *JSONQuoteExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.StringArg, b.StringArg)
}

// RefOfJSONRemoveExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfJSONRemoveExpr(a, b *JSONRemoveExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.JSONDoc, b.JSONDoc) &&
		cmp.Exprs(a.PathList, b.PathList)
}

// RefOfJSONSchemaValidFuncExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfJSONSchemaValidFuncExpr(a, b *JSONSchemaValidFuncExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.Schema, b.Schema) &&
		cmp.Expr(a.Document, b.Document)
}

// RefOfJSONSchemaValidationReportFuncExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfJSONSchemaValidationReportFuncExpr(a, b *JSONSchemaValidationReportFuncExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.Schema, b.Schema) &&
		cmp.Expr(a.Document, b.Document)
}

// RefOfJSONSearchExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfJSONSearchExpr(a, b *JSONSearchExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.JSONDoc, b.JSONDoc) &&
		cmp.Expr(a.OneOrAll, b.OneOrAll) &&
		cmp.Expr(a.SearchStr, b.SearchStr) &&
		cmp.Expr(a.EscapeChar, b.EscapeChar) &&
		cmp.SliceOfExpr(a.PathList, b.PathList)
}

// RefOfJSONStorageFreeExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfJSONStorageFreeExpr(a, b *JSONStorageFreeExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.JSONVal, b.JSONVal)
}

// RefOfJSONStorageSizeExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfJSONStorageSizeExpr(a, b *JSONStorageSizeExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.JSONVal, b.JSONVal)
}

// RefOfJSONTableExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfJSONTableExpr(a, b *JSONTableExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.Expr, b.Expr) &&
		cmp.IdentifierCS(a.Alias, b.Alias) &&
		cmp.Expr(a.Filter, b.Filter) &&
		cmp.SliceOfRefOfJtColumnDefinition(a.Columns, b.Columns)
}

// RefOfJSONUnquoteExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfJSONUnquoteExpr(a, b *JSONUnquoteExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.JSONValue, b.JSONValue)
}

// RefOfJSONValueExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfJSONValueExpr(a, b *JSONValueExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.JSONDoc, b.JSONDoc) &&
		cmp.Expr(a.Path, b.Path) &&
		cmp.RefOfConvertType(a.ReturningType, b.ReturningType) &&
		cmp.RefOfJtOnResponse(a.EmptyOnResponse, b.EmptyOnResponse) &&
		cmp.RefOfJtOnResponse(a.ErrorOnResponse, b.ErrorOnResponse)
}

// RefOfJSONValueMergeExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfJSONValueMergeExpr(a, b *JSONValueMergeExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		cmp.Expr(a.JSONDoc, b.JSONDoc) &&
		cmp.Exprs(a.JSONDocList, b.JSONDocList)
}

// RefOfJSONValueModifierExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfJSONValueModifierExpr(a, b *JSONValueModifierExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		cmp.Expr(a.JSONDoc, b.JSONDoc) &&
		cmp.SliceOfRefOfJSONObjectParam(a.Params, b.Params)
}

// RefOfJoinCondition does deep equals between the two objects.
func (cmp *Comparator) RefOfJoinCondition(a, b *JoinCondition) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.On, b.On) &&
		cmp.Columns(a.Using, b.Using)
}

// RefOfJoinTableExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfJoinTableExpr(a, b *JoinTableExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.TableExpr(a.LeftExpr, b.LeftExpr) &&
		a.Join == b.Join &&
		cmp.TableExpr(a.RightExpr, b.RightExpr) &&
		cmp.RefOfJoinCondition(a.Condition, b.Condition)
}

// RefOfJtColumnDefinition does deep equals between the two objects.
func (cmp *Comparator) RefOfJtColumnDefinition(a, b *JtColumnDefinition) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.RefOfJtOrdinalColDef(a.JtOrdinal, b.JtOrdinal) &&
		cmp.RefOfJtPathColDef(a.JtPath, b.JtPath) &&
		cmp.RefOfJtNestedPathColDef(a.JtNestedPath, b.JtNestedPath)
}

// RefOfJtOnResponse does deep equals between the two objects.
func (cmp *Comparator) RefOfJtOnResponse(a, b *JtOnResponse) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.ResponseType == b.ResponseType &&
		cmp.Expr(a.Expr, b.Expr)
}

// RefOfKeyState does deep equals between the two objects.
func (cmp *Comparator) RefOfKeyState(a, b *KeyState) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Enable == b.Enable
}

// RefOfLagLeadExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfLagLeadExpr(a, b *LagLeadExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		cmp.Expr(a.Expr, b.Expr) &&
		cmp.Expr(a.N, b.N) &&
		cmp.Expr(a.Default, b.Default) &&
		cmp.RefOfOverClause(a.OverClause, b.OverClause) &&
		cmp.RefOfNullTreatmentClause(a.NullTreatmentClause, b.NullTreatmentClause)
}

// RefOfLimit does deep equals between the two objects.
func (cmp *Comparator) RefOfLimit(a, b *Limit) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.Offset, b.Offset) &&
		cmp.Expr(a.Rowcount, b.Rowcount)
}

// RefOfLiteral does deep equals between the two objects.
func (cmp *Comparator) RefOfLiteral(a, b *Literal) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Val == b.Val &&
		a.Type == b.Type
}

// RefOfLoad does deep equals between the two objects.
func (cmp *Comparator) RefOfLoad(a, b *Load) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return true
}

// RefOfLocateExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfLocateExpr(a, b *LocateExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.SubStr, b.SubStr) &&
		cmp.Expr(a.Str, b.Str) &&
		cmp.Expr(a.Pos, b.Pos)
}

// RefOfLockOption does deep equals between the two objects.
func (cmp *Comparator) RefOfLockOption(a, b *LockOption) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type
}

// RefOfLockTables does deep equals between the two objects.
func (cmp *Comparator) RefOfLockTables(a, b *LockTables) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.TableAndLockTypes(a.Tables, b.Tables)
}

// RefOfLockingFunc does deep equals between the two objects.
func (cmp *Comparator) RefOfLockingFunc(a, b *LockingFunc) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		cmp.Expr(a.Name, b.Name) &&
		cmp.Expr(a.Timeout, b.Timeout)
}

// RefOfMatchExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfMatchExpr(a, b *MatchExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.SliceOfRefOfColName(a.Columns, b.Columns) &&
		cmp.Expr(a.Expr, b.Expr) &&
		a.Option == b.Option
}

// RefOfMax does deep equals between the two objects.
func (cmp *Comparator) RefOfMax(a, b *Max) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Distinct == b.Distinct &&
		cmp.Expr(a.Arg, b.Arg)
}

// RefOfMemberOfExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfMemberOfExpr(a, b *MemberOfExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.Value, b.Value) &&
		cmp.Expr(a.JSONArr, b.JSONArr)
}

// RefOfMin does deep equals between the two objects.
func (cmp *Comparator) RefOfMin(a, b *Min) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Distinct == b.Distinct &&
		cmp.Expr(a.Arg, b.Arg)
}

// RefOfModifyColumn does deep equals between the two objects.
func (cmp *Comparator) RefOfModifyColumn(a, b *ModifyColumn) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.First == b.First &&
		cmp.RefOfColumnDefinition(a.NewColDefinition, b.NewColDefinition) &&
		cmp.RefOfColName(a.After, b.After)
}

// RefOfNTHValueExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfNTHValueExpr(a, b *NTHValueExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.Expr, b.Expr) &&
		cmp.Expr(a.N, b.N) &&
		cmp.RefOfOverClause(a.OverClause, b.OverClause) &&
		cmp.RefOfFromFirstLastClause(a.FromFirstLastClause, b.FromFirstLastClause) &&
		cmp.RefOfNullTreatmentClause(a.NullTreatmentClause, b.NullTreatmentClause)
}

// RefOfNamedWindow does deep equals between the two objects.
func (cmp *Comparator) RefOfNamedWindow(a, b *NamedWindow) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.WindowDefinitions(a.Windows, b.Windows)
}

// NamedWindows does deep equals between the two objects.
func (cmp *Comparator) NamedWindows(a, b NamedWindows) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !cmp.RefOfNamedWindow(a[i], b[i]) {
			return false
		}
	}
	return true
}

// RefOfNextval does deep equals between the two objects.
func (cmp *Comparator) RefOfNextval(a, b *Nextval) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.Expr, b.Expr)
}

// RefOfNotExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfNotExpr(a, b *NotExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.Expr, b.Expr)
}

// RefOfNtileExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfNtileExpr(a, b *NtileExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.N, b.N) &&
		cmp.RefOfOverClause(a.OverClause, b.OverClause)
}

// RefOfNullTreatmentClause does deep equals between the two objects.
func (cmp *Comparator) RefOfNullTreatmentClause(a, b *NullTreatmentClause) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type
}

// RefOfNullVal does deep equals between the two objects.
func (cmp *Comparator) RefOfNullVal(a, b *NullVal) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return true
}

// RefOfOffset does deep equals between the two objects.
func (cmp *Comparator) RefOfOffset(a, b *Offset) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.V == b.V &&
		a.Original == b.Original
}

// OnDup does deep equals between the two objects.
func (cmp *Comparator) OnDup(a, b OnDup) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !cmp.RefOfUpdateExpr(a[i], b[i]) {
			return false
		}
	}
	return true
}

// RefOfOptLike does deep equals between the two objects.
func (cmp *Comparator) RefOfOptLike(a, b *OptLike) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.TableName(a.LikeTable, b.LikeTable)
}

// RefOfOrExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfOrExpr(a, b *OrExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.Left, b.Left) &&
		cmp.Expr(a.Right, b.Right)
}

// RefOfOrder does deep equals between the two objects.
func (cmp *Comparator) RefOfOrder(a, b *Order) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.Expr, b.Expr) &&
		a.Direction == b.Direction
}

// OrderBy does deep equals between the two objects.
func (cmp *Comparator) OrderBy(a, b OrderBy) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !cmp.RefOfOrder(a[i], b[i]) {
			return false
		}
	}
	return true
}

// RefOfOrderByOption does deep equals between the two objects.
func (cmp *Comparator) RefOfOrderByOption(a, b *OrderByOption) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Columns(a.Cols, b.Cols)
}

// RefOfOtherAdmin does deep equals between the two objects.
func (cmp *Comparator) RefOfOtherAdmin(a, b *OtherAdmin) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return true
}

// RefOfOtherRead does deep equals between the two objects.
func (cmp *Comparator) RefOfOtherRead(a, b *OtherRead) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return true
}

// RefOfOverClause does deep equals between the two objects.
func (cmp *Comparator) RefOfOverClause(a, b *OverClause) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.IdentifierCI(a.WindowName, b.WindowName) &&
		cmp.RefOfWindowSpecification(a.WindowSpec, b.WindowSpec)
}

// RefOfParenTableExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfParenTableExpr(a, b *ParenTableExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.TableExprs(a.Exprs, b.Exprs)
}

// RefOfParsedComments does deep equals between the two objects.
func (cmp *Comparator) RefOfParsedComments(a, b *ParsedComments) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Comments(a.comments, b.comments)
}

// RefOfPartitionDefinition does deep equals between the two objects.
func (cmp *Comparator) RefOfPartitionDefinition(a, b *PartitionDefinition) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.IdentifierCI(a.Name, b.Name) &&
		cmp.RefOfPartitionDefinitionOptions(a.Options, b.Options)
}

// RefOfPartitionDefinitionOptions does deep equals between the two objects.
func (cmp *Comparator) RefOfPartitionDefinitionOptions(a, b *PartitionDefinitionOptions) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.TableSpace == b.TableSpace &&
		cmp.RefOfPartitionValueRange(a.ValueRange, b.ValueRange) &&
		cmp.RefOfLiteral(a.Comment, b.Comment) &&
		cmp.RefOfPartitionEngine(a.Engine, b.Engine) &&
		cmp.RefOfLiteral(a.DataDirectory, b.DataDirectory) &&
		cmp.RefOfLiteral(a.IndexDirectory, b.IndexDirectory) &&
		cmp.RefOfInt(a.MaxRows, b.MaxRows) &&
		cmp.RefOfInt(a.MinRows, b.MinRows) &&
		cmp.SubPartitionDefinitions(a.SubPartitionDefinitions, b.SubPartitionDefinitions)
}

// RefOfPartitionEngine does deep equals between the two objects.
func (cmp *Comparator) RefOfPartitionEngine(a, b *PartitionEngine) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Storage == b.Storage &&
		a.Name == b.Name
}

// RefOfPartitionOption does deep equals between the two objects.
func (cmp *Comparator) RefOfPartitionOption(a, b *PartitionOption) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.IsLinear == b.IsLinear &&
		a.KeyAlgorithm == b.KeyAlgorithm &&
		a.Partitions == b.Partitions &&
		a.Type == b.Type &&
		cmp.Columns(a.ColList, b.ColList) &&
		cmp.Expr(a.Expr, b.Expr) &&
		cmp.RefOfSubPartition(a.SubPartition, b.SubPartition) &&
		cmp.SliceOfRefOfPartitionDefinition(a.Definitions, b.Definitions)
}

// RefOfPartitionSpec does deep equals between the two objects.
func (cmp *Comparator) RefOfPartitionSpec(a, b *PartitionSpec) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.IsAll == b.IsAll &&
		a.WithoutValidation == b.WithoutValidation &&
		a.Action == b.Action &&
		cmp.Partitions(a.Names, b.Names) &&
		cmp.RefOfLiteral(a.Number, b.Number) &&
		cmp.TableName(a.TableName, b.TableName) &&
		cmp.SliceOfRefOfPartitionDefinition(a.Definitions, b.Definitions)
}

// RefOfPartitionValueRange does deep equals between the two objects.
func (cmp *Comparator) RefOfPartitionValueRange(a, b *PartitionValueRange) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Maxvalue == b.Maxvalue &&
		a.Type == b.Type &&
		cmp.ValTuple(a.Range, b.Range)
}

// Partitions does deep equals between the two objects.
func (cmp *Comparator) Partitions(a, b Partitions) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !cmp.IdentifierCI(a[i], b[i]) {
			return false
		}
	}
	return true
}

// RefOfPerformanceSchemaFuncExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfPerformanceSchemaFuncExpr(a, b *PerformanceSchemaFuncExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		cmp.Expr(a.Argument, b.Argument)
}

// RefOfPrepareStmt does deep equals between the two objects.
func (cmp *Comparator) RefOfPrepareStmt(a, b *PrepareStmt) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.IdentifierCI(a.Name, b.Name) &&
		cmp.Expr(a.Statement, b.Statement) &&
		cmp.RefOfParsedComments(a.Comments, b.Comments)
}

// RefOfReferenceDefinition does deep equals between the two objects.
func (cmp *Comparator) RefOfReferenceDefinition(a, b *ReferenceDefinition) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.TableName(a.ReferencedTable, b.ReferencedTable) &&
		cmp.Columns(a.ReferencedColumns, b.ReferencedColumns) &&
		a.Match == b.Match &&
		a.OnDelete == b.OnDelete &&
		a.OnUpdate == b.OnUpdate
}

// RefOfRegexpInstrExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfRegexpInstrExpr(a, b *RegexpInstrExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.Expr, b.Expr) &&
		cmp.Expr(a.Pattern, b.Pattern) &&
		cmp.Expr(a.Position, b.Position) &&
		cmp.Expr(a.Occurrence, b.Occurrence) &&
		cmp.Expr(a.ReturnOption, b.ReturnOption) &&
		cmp.Expr(a.MatchType, b.MatchType)
}

// RefOfRegexpLikeExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfRegexpLikeExpr(a, b *RegexpLikeExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.Expr, b.Expr) &&
		cmp.Expr(a.Pattern, b.Pattern) &&
		cmp.Expr(a.MatchType, b.MatchType)
}

// RefOfRegexpReplaceExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfRegexpReplaceExpr(a, b *RegexpReplaceExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.Expr, b.Expr) &&
		cmp.Expr(a.Pattern, b.Pattern) &&
		cmp.Expr(a.Repl, b.Repl) &&
		cmp.Expr(a.Occurrence, b.Occurrence) &&
		cmp.Expr(a.Position, b.Position) &&
		cmp.Expr(a.MatchType, b.MatchType)
}

// RefOfRegexpSubstrExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfRegexpSubstrExpr(a, b *RegexpSubstrExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.Expr, b.Expr) &&
		cmp.Expr(a.Pattern, b.Pattern) &&
		cmp.Expr(a.Occurrence, b.Occurrence) &&
		cmp.Expr(a.Position, b.Position) &&
		cmp.Expr(a.MatchType, b.MatchType)
}

// RefOfRelease does deep equals between the two objects.
func (cmp *Comparator) RefOfRelease(a, b *Release) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.IdentifierCI(a.Name, b.Name)
}

// RefOfRenameColumn does deep equals between the two objects.
func (cmp *Comparator) RefOfRenameColumn(a, b *RenameColumn) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.RefOfColName(a.OldName, b.OldName) &&
		cmp.RefOfColName(a.NewName, b.NewName)
}

// RefOfRenameIndex does deep equals between the two objects.
func (cmp *Comparator) RefOfRenameIndex(a, b *RenameIndex) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.IdentifierCI(a.OldName, b.OldName) &&
		cmp.IdentifierCI(a.NewName, b.NewName)
}

// RefOfRenameTable does deep equals between the two objects.
func (cmp *Comparator) RefOfRenameTable(a, b *RenameTable) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.SliceOfRefOfRenameTablePair(a.TablePairs, b.TablePairs)
}

// RefOfRenameTableName does deep equals between the two objects.
func (cmp *Comparator) RefOfRenameTableName(a, b *RenameTableName) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.TableName(a.Table, b.Table)
}

// RefOfRevertMigration does deep equals between the two objects.
func (cmp *Comparator) RefOfRevertMigration(a, b *RevertMigration) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.UUID == b.UUID &&
		cmp.RefOfParsedComments(a.Comments, b.Comments)
}

// RefOfRollback does deep equals between the two objects.
func (cmp *Comparator) RefOfRollback(a, b *Rollback) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return true
}

// RootNode does deep equals between the two objects.
func (cmp *Comparator) RootNode(a, b RootNode) bool {
	return cmp.SQLNode(a.SQLNode, b.SQLNode)
}

// RefOfSRollback does deep equals between the two objects.
func (cmp *Comparator) RefOfSRollback(a, b *SRollback) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.IdentifierCI(a.Name, b.Name)
}

// RefOfSavepoint does deep equals between the two objects.
func (cmp *Comparator) RefOfSavepoint(a, b *Savepoint) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.IdentifierCI(a.Name, b.Name)
}

// RefOfSelect does deep equals between the two objects.
func (cmp *Comparator) RefOfSelect(a, b *Select) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Distinct == b.Distinct &&
		a.StraightJoinHint == b.StraightJoinHint &&
		a.SQLCalcFoundRows == b.SQLCalcFoundRows &&
		cmp.RefOfBool(a.Cache, b.Cache) &&
		cmp.SliceOfTableExpr(a.From, b.From) &&
		cmp.RefOfParsedComments(a.Comments, b.Comments) &&
		cmp.SelectExprs(a.SelectExprs, b.SelectExprs) &&
		cmp.RefOfWhere(a.Where, b.Where) &&
		cmp.RefOfWith(a.With, b.With) &&
		cmp.GroupBy(a.GroupBy, b.GroupBy) &&
		cmp.RefOfWhere(a.Having, b.Having) &&
		cmp.NamedWindows(a.Windows, b.Windows) &&
		cmp.OrderBy(a.OrderBy, b.OrderBy) &&
		cmp.RefOfLimit(a.Limit, b.Limit) &&
		a.Lock == b.Lock &&
		cmp.RefOfSelectInto(a.Into, b.Into)
}

// SelectExprs does deep equals between the two objects.
func (cmp *Comparator) SelectExprs(a, b SelectExprs) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !cmp.SelectExpr(a[i], b[i]) {
			return false
		}
	}
	return true
}

// RefOfSelectInto does deep equals between the two objects.
func (cmp *Comparator) RefOfSelectInto(a, b *SelectInto) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.FileName == b.FileName &&
		a.FormatOption == b.FormatOption &&
		a.ExportOption == b.ExportOption &&
		a.Manifest == b.Manifest &&
		a.Overwrite == b.Overwrite &&
		a.Type == b.Type &&
		cmp.ColumnCharset(a.Charset, b.Charset)
}

// RefOfSet does deep equals between the two objects.
func (cmp *Comparator) RefOfSet(a, b *Set) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.RefOfParsedComments(a.Comments, b.Comments) &&
		cmp.SetExprs(a.Exprs, b.Exprs)
}

// RefOfSetExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfSetExpr(a, b *SetExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.RefOfVariable(a.Var, b.Var) &&
		cmp.Expr(a.Expr, b.Expr)
}

// SetExprs does deep equals between the two objects.
func (cmp *Comparator) SetExprs(a, b SetExprs) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !cmp.RefOfSetExpr(a[i], b[i]) {
			return false
		}
	}
	return true
}

// RefOfShow does deep equals between the two objects.
func (cmp *Comparator) RefOfShow(a, b *Show) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.ShowInternal(a.Internal, b.Internal)
}

// RefOfShowBasic does deep equals between the two objects.
func (cmp *Comparator) RefOfShowBasic(a, b *ShowBasic) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Full == b.Full &&
		a.Command == b.Command &&
		cmp.TableName(a.Tbl, b.Tbl) &&
		cmp.IdentifierCS(a.DbName, b.DbName) &&
		cmp.RefOfShowFilter(a.Filter, b.Filter)
}

// RefOfShowCreate does deep equals between the two objects.
func (cmp *Comparator) RefOfShowCreate(a, b *ShowCreate) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Command == b.Command &&
		cmp.TableName(a.Op, b.Op)
}

// RefOfShowFilter does deep equals between the two objects.
func (cmp *Comparator) RefOfShowFilter(a, b *ShowFilter) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Like == b.Like &&
		cmp.Expr(a.Filter, b.Filter)
}

// RefOfShowMigrationLogs does deep equals between the two objects.
func (cmp *Comparator) RefOfShowMigrationLogs(a, b *ShowMigrationLogs) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.UUID == b.UUID &&
		cmp.RefOfParsedComments(a.Comments, b.Comments)
}

// RefOfShowOther does deep equals between the two objects.
func (cmp *Comparator) RefOfShowOther(a, b *ShowOther) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Command == b.Command
}

// RefOfShowThrottledApps does deep equals between the two objects.
func (cmp *Comparator) RefOfShowThrottledApps(a, b *ShowThrottledApps) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Comments(a.Comments, b.Comments)
}

// RefOfShowThrottlerStatus does deep equals between the two objects.
func (cmp *Comparator) RefOfShowThrottlerStatus(a, b *ShowThrottlerStatus) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Comments(a.Comments, b.Comments)
}

// RefOfStarExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfStarExpr(a, b *StarExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.TableName(a.TableName, b.TableName)
}

// RefOfStd does deep equals between the two objects.
func (cmp *Comparator) RefOfStd(a, b *Std) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.Arg, b.Arg)
}

// RefOfStdDev does deep equals between the two objects.
func (cmp *Comparator) RefOfStdDev(a, b *StdDev) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.Arg, b.Arg)
}

// RefOfStdPop does deep equals between the two objects.
func (cmp *Comparator) RefOfStdPop(a, b *StdPop) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.Arg, b.Arg)
}

// RefOfStdSamp does deep equals between the two objects.
func (cmp *Comparator) RefOfStdSamp(a, b *StdSamp) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.Arg, b.Arg)
}

// RefOfStream does deep equals between the two objects.
func (cmp *Comparator) RefOfStream(a, b *Stream) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.RefOfParsedComments(a.Comments, b.Comments) &&
		cmp.SelectExpr(a.SelectExpr, b.SelectExpr) &&
		cmp.TableName(a.Table, b.Table)
}

// RefOfSubPartition does deep equals between the two objects.
func (cmp *Comparator) RefOfSubPartition(a, b *SubPartition) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.IsLinear == b.IsLinear &&
		a.KeyAlgorithm == b.KeyAlgorithm &&
		a.SubPartitions == b.SubPartitions &&
		a.Type == b.Type &&
		cmp.Columns(a.ColList, b.ColList) &&
		cmp.Expr(a.Expr, b.Expr)
}

// RefOfSubPartitionDefinition does deep equals between the two objects.
func (cmp *Comparator) RefOfSubPartitionDefinition(a, b *SubPartitionDefinition) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.IdentifierCI(a.Name, b.Name) &&
		cmp.RefOfSubPartitionDefinitionOptions(a.Options, b.Options)
}

// RefOfSubPartitionDefinitionOptions does deep equals between the two objects.
func (cmp *Comparator) RefOfSubPartitionDefinitionOptions(a, b *SubPartitionDefinitionOptions) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.TableSpace == b.TableSpace &&
		cmp.RefOfLiteral(a.Comment, b.Comment) &&
		cmp.RefOfPartitionEngine(a.Engine, b.Engine) &&
		cmp.RefOfLiteral(a.DataDirectory, b.DataDirectory) &&
		cmp.RefOfLiteral(a.IndexDirectory, b.IndexDirectory) &&
		cmp.RefOfInt(a.MaxRows, b.MaxRows) &&
		cmp.RefOfInt(a.MinRows, b.MinRows)
}

// SubPartitionDefinitions does deep equals between the two objects.
func (cmp *Comparator) SubPartitionDefinitions(a, b SubPartitionDefinitions) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !cmp.RefOfSubPartitionDefinition(a[i], b[i]) {
			return false
		}
	}
	return true
}

// RefOfSubquery does deep equals between the two objects.
func (cmp *Comparator) RefOfSubquery(a, b *Subquery) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.SelectStatement(a.Select, b.Select)
}

// RefOfSubstrExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfSubstrExpr(a, b *SubstrExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.Name, b.Name) &&
		cmp.Expr(a.From, b.From) &&
		cmp.Expr(a.To, b.To)
}

// RefOfSum does deep equals between the two objects.
func (cmp *Comparator) RefOfSum(a, b *Sum) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Distinct == b.Distinct &&
		cmp.Expr(a.Arg, b.Arg)
}

// TableExprs does deep equals between the two objects.
func (cmp *Comparator) TableExprs(a, b TableExprs) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !cmp.TableExpr(a[i], b[i]) {
			return false
		}
	}
	return true
}

// TableName does deep equals between the two objects.
func (cmp *Comparator) TableName(a, b TableName) bool {
	return cmp.IdentifierCS(a.Name, b.Name) &&
		cmp.IdentifierCS(a.Qualifier, b.Qualifier)
}

// TableNames does deep equals between the two objects.
func (cmp *Comparator) TableNames(a, b TableNames) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !cmp.TableName(a[i], b[i]) {
			return false
		}
	}
	return true
}

// TableOptions does deep equals between the two objects.
func (cmp *Comparator) TableOptions(a, b TableOptions) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !cmp.RefOfTableOption(a[i], b[i]) {
			return false
		}
	}
	return true
}

// RefOfTableSpec does deep equals between the two objects.
func (cmp *Comparator) RefOfTableSpec(a, b *TableSpec) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.SliceOfRefOfColumnDefinition(a.Columns, b.Columns) &&
		cmp.SliceOfRefOfIndexDefinition(a.Indexes, b.Indexes) &&
		cmp.SliceOfRefOfConstraintDefinition(a.Constraints, b.Constraints) &&
		cmp.TableOptions(a.Options, b.Options) &&
		cmp.RefOfPartitionOption(a.PartitionOption, b.PartitionOption)
}

// RefOfTablespaceOperation does deep equals between the two objects.
func (cmp *Comparator) RefOfTablespaceOperation(a, b *TablespaceOperation) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Import == b.Import
}

// RefOfTimestampFuncExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfTimestampFuncExpr(a, b *TimestampFuncExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Name == b.Name &&
		a.Unit == b.Unit &&
		cmp.Expr(a.Expr1, b.Expr1) &&
		cmp.Expr(a.Expr2, b.Expr2)
}

// RefOfTrimFuncExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfTrimFuncExpr(a, b *TrimFuncExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.TrimFuncType == b.TrimFuncType &&
		a.Type == b.Type &&
		cmp.Expr(a.TrimArg, b.TrimArg) &&
		cmp.Expr(a.StringArg, b.StringArg)
}

// RefOfTruncateTable does deep equals between the two objects.
func (cmp *Comparator) RefOfTruncateTable(a, b *TruncateTable) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.TableName(a.Table, b.Table)
}

// RefOfUnaryExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfUnaryExpr(a, b *UnaryExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Operator == b.Operator &&
		cmp.Expr(a.Expr, b.Expr)
}

// RefOfUnion does deep equals between the two objects.
func (cmp *Comparator) RefOfUnion(a, b *Union) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Distinct == b.Distinct &&
		cmp.SelectStatement(a.Left, b.Left) &&
		cmp.SelectStatement(a.Right, b.Right) &&
		cmp.OrderBy(a.OrderBy, b.OrderBy) &&
		cmp.RefOfWith(a.With, b.With) &&
		cmp.RefOfLimit(a.Limit, b.Limit) &&
		a.Lock == b.Lock &&
		cmp.RefOfSelectInto(a.Into, b.Into)
}

// RefOfUnlockTables does deep equals between the two objects.
func (cmp *Comparator) RefOfUnlockTables(a, b *UnlockTables) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return true
}

// RefOfUpdate does deep equals between the two objects.
func (cmp *Comparator) RefOfUpdate(a, b *Update) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.RefOfWith(a.With, b.With) &&
		cmp.RefOfParsedComments(a.Comments, b.Comments) &&
		a.Ignore == b.Ignore &&
		cmp.TableExprs(a.TableExprs, b.TableExprs) &&
		cmp.UpdateExprs(a.Exprs, b.Exprs) &&
		cmp.RefOfWhere(a.Where, b.Where) &&
		cmp.OrderBy(a.OrderBy, b.OrderBy) &&
		cmp.RefOfLimit(a.Limit, b.Limit)
}

// RefOfUpdateExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfUpdateExpr(a, b *UpdateExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.RefOfColName(a.Name, b.Name) &&
		cmp.Expr(a.Expr, b.Expr)
}

// UpdateExprs does deep equals between the two objects.
func (cmp *Comparator) UpdateExprs(a, b UpdateExprs) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !cmp.RefOfUpdateExpr(a[i], b[i]) {
			return false
		}
	}
	return true
}

// RefOfUpdateXMLExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfUpdateXMLExpr(a, b *UpdateXMLExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.Target, b.Target) &&
		cmp.Expr(a.XPathExpr, b.XPathExpr) &&
		cmp.Expr(a.NewXML, b.NewXML)
}

// RefOfUse does deep equals between the two objects.
func (cmp *Comparator) RefOfUse(a, b *Use) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.IdentifierCS(a.DBName, b.DBName)
}

// RefOfVExplainStmt does deep equals between the two objects.
func (cmp *Comparator) RefOfVExplainStmt(a, b *VExplainStmt) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		cmp.Statement(a.Statement, b.Statement) &&
		cmp.RefOfParsedComments(a.Comments, b.Comments)
}

// RefOfVStream does deep equals between the two objects.
func (cmp *Comparator) RefOfVStream(a, b *VStream) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.RefOfParsedComments(a.Comments, b.Comments) &&
		cmp.SelectExpr(a.SelectExpr, b.SelectExpr) &&
		cmp.TableName(a.Table, b.Table) &&
		cmp.RefOfWhere(a.Where, b.Where) &&
		cmp.RefOfLimit(a.Limit, b.Limit)
}

// ValTuple does deep equals between the two objects.
func (cmp *Comparator) ValTuple(a, b ValTuple) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !cmp.Expr(a[i], b[i]) {
			return false
		}
	}
	return true
}

// RefOfValidation does deep equals between the two objects.
func (cmp *Comparator) RefOfValidation(a, b *Validation) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.With == b.With
}

// Values does deep equals between the two objects.
func (cmp *Comparator) Values(a, b Values) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !cmp.ValTuple(a[i], b[i]) {
			return false
		}
	}
	return true
}

// RefOfValuesFuncExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfValuesFuncExpr(a, b *ValuesFuncExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.RefOfColName(a.Name, b.Name)
}

// RefOfVarPop does deep equals between the two objects.
func (cmp *Comparator) RefOfVarPop(a, b *VarPop) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.Arg, b.Arg)
}

// RefOfVarSamp does deep equals between the two objects.
func (cmp *Comparator) RefOfVarSamp(a, b *VarSamp) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.Arg, b.Arg)
}

// RefOfVariable does deep equals between the two objects.
func (cmp *Comparator) RefOfVariable(a, b *Variable) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Scope == b.Scope &&
		cmp.IdentifierCI(a.Name, b.Name)
}

// RefOfVariance does deep equals between the two objects.
func (cmp *Comparator) RefOfVariance(a, b *Variance) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.Arg, b.Arg)
}

// VindexParam does deep equals between the two objects.
func (cmp *Comparator) VindexParam(a, b VindexParam) bool {
	return a.Val == b.Val &&
		cmp.IdentifierCI(a.Key, b.Key)
}

// RefOfVindexSpec does deep equals between the two objects.
func (cmp *Comparator) RefOfVindexSpec(a, b *VindexSpec) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.IdentifierCI(a.Name, b.Name) &&
		cmp.IdentifierCI(a.Type, b.Type) &&
		cmp.SliceOfVindexParam(a.Params, b.Params)
}

// RefOfWeightStringFuncExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfWeightStringFuncExpr(a, b *WeightStringFuncExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.Expr, b.Expr) &&
		cmp.RefOfConvertType(a.As, b.As)
}

// RefOfWhen does deep equals between the two objects.
func (cmp *Comparator) RefOfWhen(a, b *When) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.Cond, b.Cond) &&
		cmp.Expr(a.Val, b.Val)
}

// RefOfWhere does deep equals between the two objects.
func (cmp *Comparator) RefOfWhere(a, b *Where) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		cmp.Expr(a.Expr, b.Expr)
}

// RefOfWindowDefinition does deep equals between the two objects.
func (cmp *Comparator) RefOfWindowDefinition(a, b *WindowDefinition) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.IdentifierCI(a.Name, b.Name) &&
		cmp.RefOfWindowSpecification(a.WindowSpec, b.WindowSpec)
}

// WindowDefinitions does deep equals between the two objects.
func (cmp *Comparator) WindowDefinitions(a, b WindowDefinitions) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !cmp.RefOfWindowDefinition(a[i], b[i]) {
			return false
		}
	}
	return true
}

// RefOfWindowSpecification does deep equals between the two objects.
func (cmp *Comparator) RefOfWindowSpecification(a, b *WindowSpecification) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.IdentifierCI(a.Name, b.Name) &&
		cmp.Exprs(a.PartitionClause, b.PartitionClause) &&
		cmp.OrderBy(a.OrderClause, b.OrderClause) &&
		cmp.RefOfFrameClause(a.FrameClause, b.FrameClause)
}

// RefOfWith does deep equals between the two objects.
func (cmp *Comparator) RefOfWith(a, b *With) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Recursive == b.Recursive &&
		cmp.SliceOfRefOfCommonTableExpr(a.ctes, b.ctes)
}

// RefOfXorExpr does deep equals between the two objects.
func (cmp *Comparator) RefOfXorExpr(a, b *XorExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.Left, b.Left) &&
		cmp.Expr(a.Right, b.Right)
}

// AggrFunc does deep equals between the two objects.
func (cmp *Comparator) AggrFunc(inA, inB AggrFunc) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *Avg:
		b, ok := inB.(*Avg)
		if !ok {
			return false
		}
		return cmp.RefOfAvg(a, b)
	case *BitAnd:
		b, ok := inB.(*BitAnd)
		if !ok {
			return false
		}
		return cmp.RefOfBitAnd(a, b)
	case *BitOr:
		b, ok := inB.(*BitOr)
		if !ok {
			return false
		}
		return cmp.RefOfBitOr(a, b)
	case *BitXor:
		b, ok := inB.(*BitXor)
		if !ok {
			return false
		}
		return cmp.RefOfBitXor(a, b)
	case *Count:
		b, ok := inB.(*Count)
		if !ok {
			return false
		}
		return cmp.RefOfCount(a, b)
	case *CountStar:
		b, ok := inB.(*CountStar)
		if !ok {
			return false
		}
		return cmp.RefOfCountStar(a, b)
	case *GroupConcatExpr:
		b, ok := inB.(*GroupConcatExpr)
		if !ok {
			return false
		}
		return cmp.RefOfGroupConcatExpr(a, b)
	case *Max:
		b, ok := inB.(*Max)
		if !ok {
			return false
		}
		return cmp.RefOfMax(a, b)
	case *Min:
		b, ok := inB.(*Min)
		if !ok {
			return false
		}
		return cmp.RefOfMin(a, b)
	case *Std:
		b, ok := inB.(*Std)
		if !ok {
			return false
		}
		return cmp.RefOfStd(a, b)
	case *StdDev:
		b, ok := inB.(*StdDev)
		if !ok {
			return false
		}
		return cmp.RefOfStdDev(a, b)
	case *StdPop:
		b, ok := inB.(*StdPop)
		if !ok {
			return false
		}
		return cmp.RefOfStdPop(a, b)
	case *StdSamp:
		b, ok := inB.(*StdSamp)
		if !ok {
			return false
		}
		return cmp.RefOfStdSamp(a, b)
	case *Sum:
		b, ok := inB.(*Sum)
		if !ok {
			return false
		}
		return cmp.RefOfSum(a, b)
	case *VarPop:
		b, ok := inB.(*VarPop)
		if !ok {
			return false
		}
		return cmp.RefOfVarPop(a, b)
	case *VarSamp:
		b, ok := inB.(*VarSamp)
		if !ok {
			return false
		}
		return cmp.RefOfVarSamp(a, b)
	case *Variance:
		b, ok := inB.(*Variance)
		if !ok {
			return false
		}
		return cmp.RefOfVariance(a, b)
	default:
		// this should never happen
		return false
	}
}

// AlterOption does deep equals between the two objects.
func (cmp *Comparator) AlterOption(inA, inB AlterOption) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *AddColumns:
		b, ok := inB.(*AddColumns)
		if !ok {
			return false
		}
		return cmp.RefOfAddColumns(a, b)
	case *AddConstraintDefinition:
		b, ok := inB.(*AddConstraintDefinition)
		if !ok {
			return false
		}
		return cmp.RefOfAddConstraintDefinition(a, b)
	case *AddIndexDefinition:
		b, ok := inB.(*AddIndexDefinition)
		if !ok {
			return false
		}
		return cmp.RefOfAddIndexDefinition(a, b)
	case AlgorithmValue:
		b, ok := inB.(AlgorithmValue)
		if !ok {
			return false
		}
		return a == b
	case *AlterCharset:
		b, ok := inB.(*AlterCharset)
		if !ok {
			return false
		}
		return cmp.RefOfAlterCharset(a, b)
	case *AlterCheck:
		b, ok := inB.(*AlterCheck)
		if !ok {
			return false
		}
		return cmp.RefOfAlterCheck(a, b)
	case *AlterColumn:
		b, ok := inB.(*AlterColumn)
		if !ok {
			return false
		}
		return cmp.RefOfAlterColumn(a, b)
	case *AlterIndex:
		b, ok := inB.(*AlterIndex)
		if !ok {
			return false
		}
		return cmp.RefOfAlterIndex(a, b)
	case *ChangeColumn:
		b, ok := inB.(*ChangeColumn)
		if !ok {
			return false
		}
		return cmp.RefOfChangeColumn(a, b)
	case *DropColumn:
		b, ok := inB.(*DropColumn)
		if !ok {
			return false
		}
		return cmp.RefOfDropColumn(a, b)
	case *DropKey:
		b, ok := inB.(*DropKey)
		if !ok {
			return false
		}
		return cmp.RefOfDropKey(a, b)
	case *Force:
		b, ok := inB.(*Force)
		if !ok {
			return false
		}
		return cmp.RefOfForce(a, b)
	case *KeyState:
		b, ok := inB.(*KeyState)
		if !ok {
			return false
		}
		return cmp.RefOfKeyState(a, b)
	case *LockOption:
		b, ok := inB.(*LockOption)
		if !ok {
			return false
		}
		return cmp.RefOfLockOption(a, b)
	case *ModifyColumn:
		b, ok := inB.(*ModifyColumn)
		if !ok {
			return false
		}
		return cmp.RefOfModifyColumn(a, b)
	case *OrderByOption:
		b, ok := inB.(*OrderByOption)
		if !ok {
			return false
		}
		return cmp.RefOfOrderByOption(a, b)
	case *RenameColumn:
		b, ok := inB.(*RenameColumn)
		if !ok {
			return false
		}
		return cmp.RefOfRenameColumn(a, b)
	case *RenameIndex:
		b, ok := inB.(*RenameIndex)
		if !ok {
			return false
		}
		return cmp.RefOfRenameIndex(a, b)
	case *RenameTableName:
		b, ok := inB.(*RenameTableName)
		if !ok {
			return false
		}
		return cmp.RefOfRenameTableName(a, b)
	case TableOptions:
		b, ok := inB.(TableOptions)
		if !ok {
			return false
		}
		return cmp.TableOptions(a, b)
	case *TablespaceOperation:
		b, ok := inB.(*TablespaceOperation)
		if !ok {
			return false
		}
		return cmp.RefOfTablespaceOperation(a, b)
	case *Validation:
		b, ok := inB.(*Validation)
		if !ok {
			return false
		}
		return cmp.RefOfValidation(a, b)
	default:
		// this should never happen
		return false
	}
}

// Callable does deep equals between the two objects.
func (cmp *Comparator) Callable(inA, inB Callable) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *ArgumentLessWindowExpr:
		b, ok := inB.(*ArgumentLessWindowExpr)
		if !ok {
			return false
		}
		return cmp.RefOfArgumentLessWindowExpr(a, b)
	case *Avg:
		b, ok := inB.(*Avg)
		if !ok {
			return false
		}
		return cmp.RefOfAvg(a, b)
	case *CharExpr:
		b, ok := inB.(*CharExpr)
		if !ok {
			return false
		}
		return cmp.RefOfCharExpr(a, b)
	case *ConvertExpr:
		b, ok := inB.(*ConvertExpr)
		if !ok {
			return false
		}
		return cmp.RefOfConvertExpr(a, b)
	case *ConvertUsingExpr:
		b, ok := inB.(*ConvertUsingExpr)
		if !ok {
			return false
		}
		return cmp.RefOfConvertUsingExpr(a, b)
	case *Count:
		b, ok := inB.(*Count)
		if !ok {
			return false
		}
		return cmp.RefOfCount(a, b)
	case *CountStar:
		b, ok := inB.(*CountStar)
		if !ok {
			return false
		}
		return cmp.RefOfCountStar(a, b)
	case *CurTimeFuncExpr:
		b, ok := inB.(*CurTimeFuncExpr)
		if !ok {
			return false
		}
		return cmp.RefOfCurTimeFuncExpr(a, b)
	case *ExtractFuncExpr:
		b, ok := inB.(*ExtractFuncExpr)
		if !ok {
			return false
		}
		return cmp.RefOfExtractFuncExpr(a, b)
	case *ExtractValueExpr:
		b, ok := inB.(*ExtractValueExpr)
		if !ok {
			return false
		}
		return cmp.RefOfExtractValueExpr(a, b)
	case *FirstOrLastValueExpr:
		b, ok := inB.(*FirstOrLastValueExpr)
		if !ok {
			return false
		}
		return cmp.RefOfFirstOrLastValueExpr(a, b)
	case *FuncExpr:
		b, ok := inB.(*FuncExpr)
		if !ok {
			return false
		}
		return cmp.RefOfFuncExpr(a, b)
	case *GTIDFuncExpr:
		b, ok := inB.(*GTIDFuncExpr)
		if !ok {
			return false
		}
		return cmp.RefOfGTIDFuncExpr(a, b)
	case *GroupConcatExpr:
		b, ok := inB.(*GroupConcatExpr)
		if !ok {
			return false
		}
		return cmp.RefOfGroupConcatExpr(a, b)
	case *InsertExpr:
		b, ok := inB.(*InsertExpr)
		if !ok {
			return false
		}
		return cmp.RefOfInsertExpr(a, b)
	case *IntervalFuncExpr:
		b, ok := inB.(*IntervalFuncExpr)
		if !ok {
			return false
		}
		return cmp.RefOfIntervalFuncExpr(a, b)
	case *JSONArrayExpr:
		b, ok := inB.(*JSONArrayExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONArrayExpr(a, b)
	case *JSONAttributesExpr:
		b, ok := inB.(*JSONAttributesExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONAttributesExpr(a, b)
	case *JSONContainsExpr:
		b, ok := inB.(*JSONContainsExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONContainsExpr(a, b)
	case *JSONContainsPathExpr:
		b, ok := inB.(*JSONContainsPathExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONContainsPathExpr(a, b)
	case *JSONExtractExpr:
		b, ok := inB.(*JSONExtractExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONExtractExpr(a, b)
	case *JSONKeysExpr:
		b, ok := inB.(*JSONKeysExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONKeysExpr(a, b)
	case *JSONObjectExpr:
		b, ok := inB.(*JSONObjectExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONObjectExpr(a, b)
	case *JSONOverlapsExpr:
		b, ok := inB.(*JSONOverlapsExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONOverlapsExpr(a, b)
	case *JSONPrettyExpr:
		b, ok := inB.(*JSONPrettyExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONPrettyExpr(a, b)
	case *JSONQuoteExpr:
		b, ok := inB.(*JSONQuoteExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONQuoteExpr(a, b)
	case *JSONRemoveExpr:
		b, ok := inB.(*JSONRemoveExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONRemoveExpr(a, b)
	case *JSONSchemaValidFuncExpr:
		b, ok := inB.(*JSONSchemaValidFuncExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONSchemaValidFuncExpr(a, b)
	case *JSONSchemaValidationReportFuncExpr:
		b, ok := inB.(*JSONSchemaValidationReportFuncExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONSchemaValidationReportFuncExpr(a, b)
	case *JSONSearchExpr:
		b, ok := inB.(*JSONSearchExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONSearchExpr(a, b)
	case *JSONStorageFreeExpr:
		b, ok := inB.(*JSONStorageFreeExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONStorageFreeExpr(a, b)
	case *JSONStorageSizeExpr:
		b, ok := inB.(*JSONStorageSizeExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONStorageSizeExpr(a, b)
	case *JSONUnquoteExpr:
		b, ok := inB.(*JSONUnquoteExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONUnquoteExpr(a, b)
	case *JSONValueExpr:
		b, ok := inB.(*JSONValueExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONValueExpr(a, b)
	case *JSONValueMergeExpr:
		b, ok := inB.(*JSONValueMergeExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONValueMergeExpr(a, b)
	case *JSONValueModifierExpr:
		b, ok := inB.(*JSONValueModifierExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONValueModifierExpr(a, b)
	case *LagLeadExpr:
		b, ok := inB.(*LagLeadExpr)
		if !ok {
			return false
		}
		return cmp.RefOfLagLeadExpr(a, b)
	case *LocateExpr:
		b, ok := inB.(*LocateExpr)
		if !ok {
			return false
		}
		return cmp.RefOfLocateExpr(a, b)
	case *MatchExpr:
		b, ok := inB.(*MatchExpr)
		if !ok {
			return false
		}
		return cmp.RefOfMatchExpr(a, b)
	case *Max:
		b, ok := inB.(*Max)
		if !ok {
			return false
		}
		return cmp.RefOfMax(a, b)
	case *MemberOfExpr:
		b, ok := inB.(*MemberOfExpr)
		if !ok {
			return false
		}
		return cmp.RefOfMemberOfExpr(a, b)
	case *Min:
		b, ok := inB.(*Min)
		if !ok {
			return false
		}
		return cmp.RefOfMin(a, b)
	case *NTHValueExpr:
		b, ok := inB.(*NTHValueExpr)
		if !ok {
			return false
		}
		return cmp.RefOfNTHValueExpr(a, b)
	case *NamedWindow:
		b, ok := inB.(*NamedWindow)
		if !ok {
			return false
		}
		return cmp.RefOfNamedWindow(a, b)
	case *NtileExpr:
		b, ok := inB.(*NtileExpr)
		if !ok {
			return false
		}
		return cmp.RefOfNtileExpr(a, b)
	case *PerformanceSchemaFuncExpr:
		b, ok := inB.(*PerformanceSchemaFuncExpr)
		if !ok {
			return false
		}
		return cmp.RefOfPerformanceSchemaFuncExpr(a, b)
	case *RegexpInstrExpr:
		b, ok := inB.(*RegexpInstrExpr)
		if !ok {
			return false
		}
		return cmp.RefOfRegexpInstrExpr(a, b)
	case *RegexpLikeExpr:
		b, ok := inB.(*RegexpLikeExpr)
		if !ok {
			return false
		}
		return cmp.RefOfRegexpLikeExpr(a, b)
	case *RegexpReplaceExpr:
		b, ok := inB.(*RegexpReplaceExpr)
		if !ok {
			return false
		}
		return cmp.RefOfRegexpReplaceExpr(a, b)
	case *RegexpSubstrExpr:
		b, ok := inB.(*RegexpSubstrExpr)
		if !ok {
			return false
		}
		return cmp.RefOfRegexpSubstrExpr(a, b)
	case *SubstrExpr:
		b, ok := inB.(*SubstrExpr)
		if !ok {
			return false
		}
		return cmp.RefOfSubstrExpr(a, b)
	case *Sum:
		b, ok := inB.(*Sum)
		if !ok {
			return false
		}
		return cmp.RefOfSum(a, b)
	case *TimestampFuncExpr:
		b, ok := inB.(*TimestampFuncExpr)
		if !ok {
			return false
		}
		return cmp.RefOfTimestampFuncExpr(a, b)
	case *TrimFuncExpr:
		b, ok := inB.(*TrimFuncExpr)
		if !ok {
			return false
		}
		return cmp.RefOfTrimFuncExpr(a, b)
	case *UpdateXMLExpr:
		b, ok := inB.(*UpdateXMLExpr)
		if !ok {
			return false
		}
		return cmp.RefOfUpdateXMLExpr(a, b)
	case *ValuesFuncExpr:
		b, ok := inB.(*ValuesFuncExpr)
		if !ok {
			return false
		}
		return cmp.RefOfValuesFuncExpr(a, b)
	case *WeightStringFuncExpr:
		b, ok := inB.(*WeightStringFuncExpr)
		if !ok {
			return false
		}
		return cmp.RefOfWeightStringFuncExpr(a, b)
	default:
		// this should never happen
		return false
	}
}

// ColTuple does deep equals between the two objects.
func (cmp *Comparator) ColTuple(inA, inB ColTuple) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case ListArg:
		b, ok := inB.(ListArg)
		if !ok {
			return false
		}
		return a == b
	case *Subquery:
		b, ok := inB.(*Subquery)
		if !ok {
			return false
		}
		return cmp.RefOfSubquery(a, b)
	case ValTuple:
		b, ok := inB.(ValTuple)
		if !ok {
			return false
		}
		return cmp.ValTuple(a, b)
	default:
		// this should never happen
		return false
	}
}

// ConstraintInfo does deep equals between the two objects.
func (cmp *Comparator) ConstraintInfo(inA, inB ConstraintInfo) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *CheckConstraintDefinition:
		b, ok := inB.(*CheckConstraintDefinition)
		if !ok {
			return false
		}
		return cmp.RefOfCheckConstraintDefinition(a, b)
	case *ForeignKeyDefinition:
		b, ok := inB.(*ForeignKeyDefinition)
		if !ok {
			return false
		}
		return cmp.RefOfForeignKeyDefinition(a, b)
	default:
		// this should never happen
		return false
	}
}

// DBDDLStatement does deep equals between the two objects.
func (cmp *Comparator) DBDDLStatement(inA, inB DBDDLStatement) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *AlterDatabase:
		b, ok := inB.(*AlterDatabase)
		if !ok {
			return false
		}
		return cmp.RefOfAlterDatabase(a, b)
	case *CreateDatabase:
		b, ok := inB.(*CreateDatabase)
		if !ok {
			return false
		}
		return cmp.RefOfCreateDatabase(a, b)
	case *DropDatabase:
		b, ok := inB.(*DropDatabase)
		if !ok {
			return false
		}
		return cmp.RefOfDropDatabase(a, b)
	default:
		// this should never happen
		return false
	}
}

// DDLStatement does deep equals between the two objects.
func (cmp *Comparator) DDLStatement(inA, inB DDLStatement) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *AlterTable:
		b, ok := inB.(*AlterTable)
		if !ok {
			return false
		}
		return cmp.RefOfAlterTable(a, b)
	case *AlterView:
		b, ok := inB.(*AlterView)
		if !ok {
			return false
		}
		return cmp.RefOfAlterView(a, b)
	case *CreateTable:
		b, ok := inB.(*CreateTable)
		if !ok {
			return false
		}
		return cmp.RefOfCreateTable(a, b)
	case *CreateView:
		b, ok := inB.(*CreateView)
		if !ok {
			return false
		}
		return cmp.RefOfCreateView(a, b)
	case *DropTable:
		b, ok := inB.(*DropTable)
		if !ok {
			return false
		}
		return cmp.RefOfDropTable(a, b)
	case *DropView:
		b, ok := inB.(*DropView)
		if !ok {
			return false
		}
		return cmp.RefOfDropView(a, b)
	case *RenameTable:
		b, ok := inB.(*RenameTable)
		if !ok {
			return false
		}
		return cmp.RefOfRenameTable(a, b)
	case *TruncateTable:
		b, ok := inB.(*TruncateTable)
		if !ok {
			return false
		}
		return cmp.RefOfTruncateTable(a, b)
	default:
		// this should never happen
		return false
	}
}

// Explain does deep equals between the two objects.
func (cmp *Comparator) Explain(inA, inB Explain) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *ExplainStmt:
		b, ok := inB.(*ExplainStmt)
		if !ok {
			return false
		}
		return cmp.RefOfExplainStmt(a, b)
	case *ExplainTab:
		b, ok := inB.(*ExplainTab)
		if !ok {
			return false
		}
		return cmp.RefOfExplainTab(a, b)
	default:
		// this should never happen
		return false
	}
}

// Expr does deep equals between the two objects.
func (cmp *Comparator) Expr(inA, inB Expr) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *AndExpr:
		b, ok := inB.(*AndExpr)
		if !ok {
			return false
		}
		return cmp.RefOfAndExpr(a, b)
	case Argument:
		b, ok := inB.(Argument)
		if !ok {
			return false
		}
		return a == b
	case *ArgumentLessWindowExpr:
		b, ok := inB.(*ArgumentLessWindowExpr)
		if !ok {
			return false
		}
		return cmp.RefOfArgumentLessWindowExpr(a, b)
	case *Avg:
		b, ok := inB.(*Avg)
		if !ok {
			return false
		}
		return cmp.RefOfAvg(a, b)
	case *BetweenExpr:
		b, ok := inB.(*BetweenExpr)
		if !ok {
			return false
		}
		return cmp.RefOfBetweenExpr(a, b)
	case *BinaryExpr:
		b, ok := inB.(*BinaryExpr)
		if !ok {
			return false
		}
		return cmp.RefOfBinaryExpr(a, b)
	case *BitAnd:
		b, ok := inB.(*BitAnd)
		if !ok {
			return false
		}
		return cmp.RefOfBitAnd(a, b)
	case *BitOr:
		b, ok := inB.(*BitOr)
		if !ok {
			return false
		}
		return cmp.RefOfBitOr(a, b)
	case *BitXor:
		b, ok := inB.(*BitXor)
		if !ok {
			return false
		}
		return cmp.RefOfBitXor(a, b)
	case BoolVal:
		b, ok := inB.(BoolVal)
		if !ok {
			return false
		}
		return a == b
	case *CaseExpr:
		b, ok := inB.(*CaseExpr)
		if !ok {
			return false
		}
		return cmp.RefOfCaseExpr(a, b)
	case *CastExpr:
		b, ok := inB.(*CastExpr)
		if !ok {
			return false
		}
		return cmp.RefOfCastExpr(a, b)
	case *CharExpr:
		b, ok := inB.(*CharExpr)
		if !ok {
			return false
		}
		return cmp.RefOfCharExpr(a, b)
	case *ColName:
		b, ok := inB.(*ColName)
		if !ok {
			return false
		}
		return cmp.RefOfColName(a, b)
	case *CollateExpr:
		b, ok := inB.(*CollateExpr)
		if !ok {
			return false
		}
		return cmp.RefOfCollateExpr(a, b)
	case *ComparisonExpr:
		b, ok := inB.(*ComparisonExpr)
		if !ok {
			return false
		}
		return cmp.RefOfComparisonExpr(a, b)
	case *ConvertExpr:
		b, ok := inB.(*ConvertExpr)
		if !ok {
			return false
		}
		return cmp.RefOfConvertExpr(a, b)
	case *ConvertUsingExpr:
		b, ok := inB.(*ConvertUsingExpr)
		if !ok {
			return false
		}
		return cmp.RefOfConvertUsingExpr(a, b)
	case *Count:
		b, ok := inB.(*Count)
		if !ok {
			return false
		}
		return cmp.RefOfCount(a, b)
	case *CountStar:
		b, ok := inB.(*CountStar)
		if !ok {
			return false
		}
		return cmp.RefOfCountStar(a, b)
	case *CurTimeFuncExpr:
		b, ok := inB.(*CurTimeFuncExpr)
		if !ok {
			return false
		}
		return cmp.RefOfCurTimeFuncExpr(a, b)
	case *Default:
		b, ok := inB.(*Default)
		if !ok {
			return false
		}
		return cmp.RefOfDefault(a, b)
	case *ExistsExpr:
		b, ok := inB.(*ExistsExpr)
		if !ok {
			return false
		}
		return cmp.RefOfExistsExpr(a, b)
	case *ExtractFuncExpr:
		b, ok := inB.(*ExtractFuncExpr)
		if !ok {
			return false
		}
		return cmp.RefOfExtractFuncExpr(a, b)
	case *ExtractValueExpr:
		b, ok := inB.(*ExtractValueExpr)
		if !ok {
			return false
		}
		return cmp.RefOfExtractValueExpr(a, b)
	case *ExtractedSubquery:
		b, ok := inB.(*ExtractedSubquery)
		if !ok {
			return false
		}
		return cmp.RefOfExtractedSubquery(a, b)
	case *FirstOrLastValueExpr:
		b, ok := inB.(*FirstOrLastValueExpr)
		if !ok {
			return false
		}
		return cmp.RefOfFirstOrLastValueExpr(a, b)
	case *FuncExpr:
		b, ok := inB.(*FuncExpr)
		if !ok {
			return false
		}
		return cmp.RefOfFuncExpr(a, b)
	case *GTIDFuncExpr:
		b, ok := inB.(*GTIDFuncExpr)
		if !ok {
			return false
		}
		return cmp.RefOfGTIDFuncExpr(a, b)
	case *GroupConcatExpr:
		b, ok := inB.(*GroupConcatExpr)
		if !ok {
			return false
		}
		return cmp.RefOfGroupConcatExpr(a, b)
	case *InsertExpr:
		b, ok := inB.(*InsertExpr)
		if !ok {
			return false
		}
		return cmp.RefOfInsertExpr(a, b)
	case *IntervalExpr:
		b, ok := inB.(*IntervalExpr)
		if !ok {
			return false
		}
		return cmp.RefOfIntervalExpr(a, b)
	case *IntervalFuncExpr:
		b, ok := inB.(*IntervalFuncExpr)
		if !ok {
			return false
		}
		return cmp.RefOfIntervalFuncExpr(a, b)
	case *IntroducerExpr:
		b, ok := inB.(*IntroducerExpr)
		if !ok {
			return false
		}
		return cmp.RefOfIntroducerExpr(a, b)
	case *IsExpr:
		b, ok := inB.(*IsExpr)
		if !ok {
			return false
		}
		return cmp.RefOfIsExpr(a, b)
	case *JSONArrayExpr:
		b, ok := inB.(*JSONArrayExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONArrayExpr(a, b)
	case *JSONAttributesExpr:
		b, ok := inB.(*JSONAttributesExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONAttributesExpr(a, b)
	case *JSONContainsExpr:
		b, ok := inB.(*JSONContainsExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONContainsExpr(a, b)
	case *JSONContainsPathExpr:
		b, ok := inB.(*JSONContainsPathExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONContainsPathExpr(a, b)
	case *JSONExtractExpr:
		b, ok := inB.(*JSONExtractExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONExtractExpr(a, b)
	case *JSONKeysExpr:
		b, ok := inB.(*JSONKeysExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONKeysExpr(a, b)
	case *JSONObjectExpr:
		b, ok := inB.(*JSONObjectExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONObjectExpr(a, b)
	case *JSONOverlapsExpr:
		b, ok := inB.(*JSONOverlapsExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONOverlapsExpr(a, b)
	case *JSONPrettyExpr:
		b, ok := inB.(*JSONPrettyExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONPrettyExpr(a, b)
	case *JSONQuoteExpr:
		b, ok := inB.(*JSONQuoteExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONQuoteExpr(a, b)
	case *JSONRemoveExpr:
		b, ok := inB.(*JSONRemoveExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONRemoveExpr(a, b)
	case *JSONSchemaValidFuncExpr:
		b, ok := inB.(*JSONSchemaValidFuncExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONSchemaValidFuncExpr(a, b)
	case *JSONSchemaValidationReportFuncExpr:
		b, ok := inB.(*JSONSchemaValidationReportFuncExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONSchemaValidationReportFuncExpr(a, b)
	case *JSONSearchExpr:
		b, ok := inB.(*JSONSearchExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONSearchExpr(a, b)
	case *JSONStorageFreeExpr:
		b, ok := inB.(*JSONStorageFreeExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONStorageFreeExpr(a, b)
	case *JSONStorageSizeExpr:
		b, ok := inB.(*JSONStorageSizeExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONStorageSizeExpr(a, b)
	case *JSONUnquoteExpr:
		b, ok := inB.(*JSONUnquoteExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONUnquoteExpr(a, b)
	case *JSONValueExpr:
		b, ok := inB.(*JSONValueExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONValueExpr(a, b)
	case *JSONValueMergeExpr:
		b, ok := inB.(*JSONValueMergeExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONValueMergeExpr(a, b)
	case *JSONValueModifierExpr:
		b, ok := inB.(*JSONValueModifierExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONValueModifierExpr(a, b)
	case *LagLeadExpr:
		b, ok := inB.(*LagLeadExpr)
		if !ok {
			return false
		}
		return cmp.RefOfLagLeadExpr(a, b)
	case ListArg:
		b, ok := inB.(ListArg)
		if !ok {
			return false
		}
		return a == b
	case *Literal:
		b, ok := inB.(*Literal)
		if !ok {
			return false
		}
		return cmp.RefOfLiteral(a, b)
	case *LocateExpr:
		b, ok := inB.(*LocateExpr)
		if !ok {
			return false
		}
		return cmp.RefOfLocateExpr(a, b)
	case *LockingFunc:
		b, ok := inB.(*LockingFunc)
		if !ok {
			return false
		}
		return cmp.RefOfLockingFunc(a, b)
	case *MatchExpr:
		b, ok := inB.(*MatchExpr)
		if !ok {
			return false
		}
		return cmp.RefOfMatchExpr(a, b)
	case *Max:
		b, ok := inB.(*Max)
		if !ok {
			return false
		}
		return cmp.RefOfMax(a, b)
	case *MemberOfExpr:
		b, ok := inB.(*MemberOfExpr)
		if !ok {
			return false
		}
		return cmp.RefOfMemberOfExpr(a, b)
	case *Min:
		b, ok := inB.(*Min)
		if !ok {
			return false
		}
		return cmp.RefOfMin(a, b)
	case *NTHValueExpr:
		b, ok := inB.(*NTHValueExpr)
		if !ok {
			return false
		}
		return cmp.RefOfNTHValueExpr(a, b)
	case *NamedWindow:
		b, ok := inB.(*NamedWindow)
		if !ok {
			return false
		}
		return cmp.RefOfNamedWindow(a, b)
	case *NotExpr:
		b, ok := inB.(*NotExpr)
		if !ok {
			return false
		}
		return cmp.RefOfNotExpr(a, b)
	case *NtileExpr:
		b, ok := inB.(*NtileExpr)
		if !ok {
			return false
		}
		return cmp.RefOfNtileExpr(a, b)
	case *NullVal:
		b, ok := inB.(*NullVal)
		if !ok {
			return false
		}
		return cmp.RefOfNullVal(a, b)
	case *Offset:
		b, ok := inB.(*Offset)
		if !ok {
			return false
		}
		return cmp.RefOfOffset(a, b)
	case *OrExpr:
		b, ok := inB.(*OrExpr)
		if !ok {
			return false
		}
		return cmp.RefOfOrExpr(a, b)
	case *PerformanceSchemaFuncExpr:
		b, ok := inB.(*PerformanceSchemaFuncExpr)
		if !ok {
			return false
		}
		return cmp.RefOfPerformanceSchemaFuncExpr(a, b)
	case *RegexpInstrExpr:
		b, ok := inB.(*RegexpInstrExpr)
		if !ok {
			return false
		}
		return cmp.RefOfRegexpInstrExpr(a, b)
	case *RegexpLikeExpr:
		b, ok := inB.(*RegexpLikeExpr)
		if !ok {
			return false
		}
		return cmp.RefOfRegexpLikeExpr(a, b)
	case *RegexpReplaceExpr:
		b, ok := inB.(*RegexpReplaceExpr)
		if !ok {
			return false
		}
		return cmp.RefOfRegexpReplaceExpr(a, b)
	case *RegexpSubstrExpr:
		b, ok := inB.(*RegexpSubstrExpr)
		if !ok {
			return false
		}
		return cmp.RefOfRegexpSubstrExpr(a, b)
	case *Std:
		b, ok := inB.(*Std)
		if !ok {
			return false
		}
		return cmp.RefOfStd(a, b)
	case *StdDev:
		b, ok := inB.(*StdDev)
		if !ok {
			return false
		}
		return cmp.RefOfStdDev(a, b)
	case *StdPop:
		b, ok := inB.(*StdPop)
		if !ok {
			return false
		}
		return cmp.RefOfStdPop(a, b)
	case *StdSamp:
		b, ok := inB.(*StdSamp)
		if !ok {
			return false
		}
		return cmp.RefOfStdSamp(a, b)
	case *Subquery:
		b, ok := inB.(*Subquery)
		if !ok {
			return false
		}
		return cmp.RefOfSubquery(a, b)
	case *SubstrExpr:
		b, ok := inB.(*SubstrExpr)
		if !ok {
			return false
		}
		return cmp.RefOfSubstrExpr(a, b)
	case *Sum:
		b, ok := inB.(*Sum)
		if !ok {
			return false
		}
		return cmp.RefOfSum(a, b)
	case *TimestampFuncExpr:
		b, ok := inB.(*TimestampFuncExpr)
		if !ok {
			return false
		}
		return cmp.RefOfTimestampFuncExpr(a, b)
	case *TrimFuncExpr:
		b, ok := inB.(*TrimFuncExpr)
		if !ok {
			return false
		}
		return cmp.RefOfTrimFuncExpr(a, b)
	case *UnaryExpr:
		b, ok := inB.(*UnaryExpr)
		if !ok {
			return false
		}
		return cmp.RefOfUnaryExpr(a, b)
	case *UpdateXMLExpr:
		b, ok := inB.(*UpdateXMLExpr)
		if !ok {
			return false
		}
		return cmp.RefOfUpdateXMLExpr(a, b)
	case ValTuple:
		b, ok := inB.(ValTuple)
		if !ok {
			return false
		}
		return cmp.ValTuple(a, b)
	case *ValuesFuncExpr:
		b, ok := inB.(*ValuesFuncExpr)
		if !ok {
			return false
		}
		return cmp.RefOfValuesFuncExpr(a, b)
	case *VarPop:
		b, ok := inB.(*VarPop)
		if !ok {
			return false
		}
		return cmp.RefOfVarPop(a, b)
	case *VarSamp:
		b, ok := inB.(*VarSamp)
		if !ok {
			return false
		}
		return cmp.RefOfVarSamp(a, b)
	case *Variable:
		b, ok := inB.(*Variable)
		if !ok {
			return false
		}
		return cmp.RefOfVariable(a, b)
	case *Variance:
		b, ok := inB.(*Variance)
		if !ok {
			return false
		}
		return cmp.RefOfVariance(a, b)
	case *WeightStringFuncExpr:
		b, ok := inB.(*WeightStringFuncExpr)
		if !ok {
			return false
		}
		return cmp.RefOfWeightStringFuncExpr(a, b)
	case *XorExpr:
		b, ok := inB.(*XorExpr)
		if !ok {
			return false
		}
		return cmp.RefOfXorExpr(a, b)
	default:
		// this should never happen
		return false
	}
}

// InsertRows does deep equals between the two objects.
func (cmp *Comparator) InsertRows(inA, inB InsertRows) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *Select:
		b, ok := inB.(*Select)
		if !ok {
			return false
		}
		return cmp.RefOfSelect(a, b)
	case *Union:
		b, ok := inB.(*Union)
		if !ok {
			return false
		}
		return cmp.RefOfUnion(a, b)
	case Values:
		b, ok := inB.(Values)
		if !ok {
			return false
		}
		return cmp.Values(a, b)
	default:
		// this should never happen
		return false
	}
}

// SelectExpr does deep equals between the two objects.
func (cmp *Comparator) SelectExpr(inA, inB SelectExpr) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *AliasedExpr:
		b, ok := inB.(*AliasedExpr)
		if !ok {
			return false
		}
		return cmp.RefOfAliasedExpr(a, b)
	case *Nextval:
		b, ok := inB.(*Nextval)
		if !ok {
			return false
		}
		return cmp.RefOfNextval(a, b)
	case *StarExpr:
		b, ok := inB.(*StarExpr)
		if !ok {
			return false
		}
		return cmp.RefOfStarExpr(a, b)
	default:
		// this should never happen
		return false
	}
}

// SelectStatement does deep equals between the two objects.
func (cmp *Comparator) SelectStatement(inA, inB SelectStatement) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *Select:
		b, ok := inB.(*Select)
		if !ok {
			return false
		}
		return cmp.RefOfSelect(a, b)
	case *Union:
		b, ok := inB.(*Union)
		if !ok {
			return false
		}
		return cmp.RefOfUnion(a, b)
	default:
		// this should never happen
		return false
	}
}

// ShowInternal does deep equals between the two objects.
func (cmp *Comparator) ShowInternal(inA, inB ShowInternal) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *ShowBasic:
		b, ok := inB.(*ShowBasic)
		if !ok {
			return false
		}
		return cmp.RefOfShowBasic(a, b)
	case *ShowCreate:
		b, ok := inB.(*ShowCreate)
		if !ok {
			return false
		}
		return cmp.RefOfShowCreate(a, b)
	case *ShowOther:
		b, ok := inB.(*ShowOther)
		if !ok {
			return false
		}
		return cmp.RefOfShowOther(a, b)
	default:
		// this should never happen
		return false
	}
}

// SimpleTableExpr does deep equals between the two objects.
func (cmp *Comparator) SimpleTableExpr(inA, inB SimpleTableExpr) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *DerivedTable:
		b, ok := inB.(*DerivedTable)
		if !ok {
			return false
		}
		return cmp.RefOfDerivedTable(a, b)
	case TableName:
		b, ok := inB.(TableName)
		if !ok {
			return false
		}
		return cmp.TableName(a, b)
	default:
		// this should never happen
		return false
	}
}

// Statement does deep equals between the two objects.
func (cmp *Comparator) Statement(inA, inB Statement) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *AlterDatabase:
		b, ok := inB.(*AlterDatabase)
		if !ok {
			return false
		}
		return cmp.RefOfAlterDatabase(a, b)
	case *AlterMigration:
		b, ok := inB.(*AlterMigration)
		if !ok {
			return false
		}
		return cmp.RefOfAlterMigration(a, b)
	case *AlterTable:
		b, ok := inB.(*AlterTable)
		if !ok {
			return false
		}
		return cmp.RefOfAlterTable(a, b)
	case *AlterView:
		b, ok := inB.(*AlterView)
		if !ok {
			return false
		}
		return cmp.RefOfAlterView(a, b)
	case *AlterVschema:
		b, ok := inB.(*AlterVschema)
		if !ok {
			return false
		}
		return cmp.RefOfAlterVschema(a, b)
	case *Begin:
		b, ok := inB.(*Begin)
		if !ok {
			return false
		}
		return cmp.RefOfBegin(a, b)
	case *CallProc:
		b, ok := inB.(*CallProc)
		if !ok {
			return false
		}
		return cmp.RefOfCallProc(a, b)
	case *CommentOnly:
		b, ok := inB.(*CommentOnly)
		if !ok {
			return false
		}
		return cmp.RefOfCommentOnly(a, b)
	case *Commit:
		b, ok := inB.(*Commit)
		if !ok {
			return false
		}
		return cmp.RefOfCommit(a, b)
	case *CreateDatabase:
		b, ok := inB.(*CreateDatabase)
		if !ok {
			return false
		}
		return cmp.RefOfCreateDatabase(a, b)
	case *CreateTable:
		b, ok := inB.(*CreateTable)
		if !ok {
			return false
		}
		return cmp.RefOfCreateTable(a, b)
	case *CreateView:
		b, ok := inB.(*CreateView)
		if !ok {
			return false
		}
		return cmp.RefOfCreateView(a, b)
	case *DeallocateStmt:
		b, ok := inB.(*DeallocateStmt)
		if !ok {
			return false
		}
		return cmp.RefOfDeallocateStmt(a, b)
	case *Delete:
		b, ok := inB.(*Delete)
		if !ok {
			return false
		}
		return cmp.RefOfDelete(a, b)
	case *DropDatabase:
		b, ok := inB.(*DropDatabase)
		if !ok {
			return false
		}
		return cmp.RefOfDropDatabase(a, b)
	case *DropTable:
		b, ok := inB.(*DropTable)
		if !ok {
			return false
		}
		return cmp.RefOfDropTable(a, b)
	case *DropView:
		b, ok := inB.(*DropView)
		if !ok {
			return false
		}
		return cmp.RefOfDropView(a, b)
	case *ExecuteStmt:
		b, ok := inB.(*ExecuteStmt)
		if !ok {
			return false
		}
		return cmp.RefOfExecuteStmt(a, b)
	case *ExplainStmt:
		b, ok := inB.(*ExplainStmt)
		if !ok {
			return false
		}
		return cmp.RefOfExplainStmt(a, b)
	case *ExplainTab:
		b, ok := inB.(*ExplainTab)
		if !ok {
			return false
		}
		return cmp.RefOfExplainTab(a, b)
	case *Flush:
		b, ok := inB.(*Flush)
		if !ok {
			return false
		}
		return cmp.RefOfFlush(a, b)
	case *Insert:
		b, ok := inB.(*Insert)
		if !ok {
			return false
		}
		return cmp.RefOfInsert(a, b)
	case *Load:
		b, ok := inB.(*Load)
		if !ok {
			return false
		}
		return cmp.RefOfLoad(a, b)
	case *LockTables:
		b, ok := inB.(*LockTables)
		if !ok {
			return false
		}
		return cmp.RefOfLockTables(a, b)
	case *OtherAdmin:
		b, ok := inB.(*OtherAdmin)
		if !ok {
			return false
		}
		return cmp.RefOfOtherAdmin(a, b)
	case *OtherRead:
		b, ok := inB.(*OtherRead)
		if !ok {
			return false
		}
		return cmp.RefOfOtherRead(a, b)
	case *PrepareStmt:
		b, ok := inB.(*PrepareStmt)
		if !ok {
			return false
		}
		return cmp.RefOfPrepareStmt(a, b)
	case *Release:
		b, ok := inB.(*Release)
		if !ok {
			return false
		}
		return cmp.RefOfRelease(a, b)
	case *RenameTable:
		b, ok := inB.(*RenameTable)
		if !ok {
			return false
		}
		return cmp.RefOfRenameTable(a, b)
	case *RevertMigration:
		b, ok := inB.(*RevertMigration)
		if !ok {
			return false
		}
		return cmp.RefOfRevertMigration(a, b)
	case *Rollback:
		b, ok := inB.(*Rollback)
		if !ok {
			return false
		}
		return cmp.RefOfRollback(a, b)
	case *SRollback:
		b, ok := inB.(*SRollback)
		if !ok {
			return false
		}
		return cmp.RefOfSRollback(a, b)
	case *Savepoint:
		b, ok := inB.(*Savepoint)
		if !ok {
			return false
		}
		return cmp.RefOfSavepoint(a, b)
	case *Select:
		b, ok := inB.(*Select)
		if !ok {
			return false
		}
		return cmp.RefOfSelect(a, b)
	case *Set:
		b, ok := inB.(*Set)
		if !ok {
			return false
		}
		return cmp.RefOfSet(a, b)
	case *Show:
		b, ok := inB.(*Show)
		if !ok {
			return false
		}
		return cmp.RefOfShow(a, b)
	case *ShowMigrationLogs:
		b, ok := inB.(*ShowMigrationLogs)
		if !ok {
			return false
		}
		return cmp.RefOfShowMigrationLogs(a, b)
	case *ShowThrottledApps:
		b, ok := inB.(*ShowThrottledApps)
		if !ok {
			return false
		}
		return cmp.RefOfShowThrottledApps(a, b)
	case *ShowThrottlerStatus:
		b, ok := inB.(*ShowThrottlerStatus)
		if !ok {
			return false
		}
		return cmp.RefOfShowThrottlerStatus(a, b)
	case *Stream:
		b, ok := inB.(*Stream)
		if !ok {
			return false
		}
		return cmp.RefOfStream(a, b)
	case *TruncateTable:
		b, ok := inB.(*TruncateTable)
		if !ok {
			return false
		}
		return cmp.RefOfTruncateTable(a, b)
	case *Union:
		b, ok := inB.(*Union)
		if !ok {
			return false
		}
		return cmp.RefOfUnion(a, b)
	case *UnlockTables:
		b, ok := inB.(*UnlockTables)
		if !ok {
			return false
		}
		return cmp.RefOfUnlockTables(a, b)
	case *Update:
		b, ok := inB.(*Update)
		if !ok {
			return false
		}
		return cmp.RefOfUpdate(a, b)
	case *Use:
		b, ok := inB.(*Use)
		if !ok {
			return false
		}
		return cmp.RefOfUse(a, b)
	case *VExplainStmt:
		b, ok := inB.(*VExplainStmt)
		if !ok {
			return false
		}
		return cmp.RefOfVExplainStmt(a, b)
	case *VStream:
		b, ok := inB.(*VStream)
		if !ok {
			return false
		}
		return cmp.RefOfVStream(a, b)
	default:
		// this should never happen
		return false
	}
}

// TableExpr does deep equals between the two objects.
func (cmp *Comparator) TableExpr(inA, inB TableExpr) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *AliasedTableExpr:
		b, ok := inB.(*AliasedTableExpr)
		if !ok {
			return false
		}
		return cmp.RefOfAliasedTableExpr(a, b)
	case *JSONTableExpr:
		b, ok := inB.(*JSONTableExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJSONTableExpr(a, b)
	case *JoinTableExpr:
		b, ok := inB.(*JoinTableExpr)
		if !ok {
			return false
		}
		return cmp.RefOfJoinTableExpr(a, b)
	case *ParenTableExpr:
		b, ok := inB.(*ParenTableExpr)
		if !ok {
			return false
		}
		return cmp.RefOfParenTableExpr(a, b)
	default:
		// this should never happen
		return false
	}
}

// SliceOfRefOfColumnDefinition does deep equals between the two objects.
func (cmp *Comparator) SliceOfRefOfColumnDefinition(a, b []*ColumnDefinition) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !cmp.RefOfColumnDefinition(a[i], b[i]) {
			return false
		}
	}
	return true
}

// RefOfBool does deep equals between the two objects.
func (cmp *Comparator) RefOfBool(a, b *bool) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return *a == *b
}

// SliceOfDatabaseOption does deep equals between the two objects.
func (cmp *Comparator) SliceOfDatabaseOption(a, b []DatabaseOption) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !cmp.DatabaseOption(a[i], b[i]) {
			return false
		}
	}
	return true
}

// SliceOfAlterOption does deep equals between the two objects.
func (cmp *Comparator) SliceOfAlterOption(a, b []AlterOption) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !cmp.AlterOption(a[i], b[i]) {
			return false
		}
	}
	return true
}

// SliceOfIdentifierCI does deep equals between the two objects.
func (cmp *Comparator) SliceOfIdentifierCI(a, b []IdentifierCI) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !cmp.IdentifierCI(a[i], b[i]) {
			return false
		}
	}
	return true
}

// SliceOfTxAccessMode does deep equals between the two objects.
func (cmp *Comparator) SliceOfTxAccessMode(a, b []TxAccessMode) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}

// SliceOfRefOfWhen does deep equals between the two objects.
func (cmp *Comparator) SliceOfRefOfWhen(a, b []*When) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !cmp.RefOfWhen(a[i], b[i]) {
			return false
		}
	}
	return true
}

// RefOfColumnTypeOptions does deep equals between the two objects.
func (cmp *Comparator) RefOfColumnTypeOptions(a, b *ColumnTypeOptions) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Autoincrement == b.Autoincrement &&
		a.Collate == b.Collate &&
		cmp.RefOfBool(a.Null, b.Null) &&
		cmp.Expr(a.Default, b.Default) &&
		cmp.Expr(a.OnUpdate, b.OnUpdate) &&
		cmp.Expr(a.As, b.As) &&
		cmp.RefOfLiteral(a.Comment, b.Comment) &&
		a.Storage == b.Storage &&
		cmp.RefOfReferenceDefinition(a.Reference, b.Reference) &&
		a.KeyOpt == b.KeyOpt &&
		cmp.RefOfBool(a.Invisible, b.Invisible) &&
		a.Format == b.Format &&
		cmp.RefOfLiteral(a.EngineAttribute, b.EngineAttribute) &&
		cmp.RefOfLiteral(a.SecondaryEngineAttribute, b.SecondaryEngineAttribute) &&
		cmp.RefOfLiteral(a.SRID, b.SRID)
}

// ColumnCharset does deep equals between the two objects.
func (cmp *Comparator) ColumnCharset(a, b ColumnCharset) bool {
	return a.Name == b.Name &&
		a.Binary == b.Binary
}

// SliceOfString does deep equals between the two objects.
func (cmp *Comparator) SliceOfString(a, b []string) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}

// SliceOfRefOfVariable does deep equals between the two objects.
func (cmp *Comparator) SliceOfRefOfVariable(a, b []*Variable) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !cmp.RefOfVariable(a[i], b[i]) {
			return false
		}
	}
	return true
}

// RefOfIdentifierCI does deep equals between the two objects.
func (cmp *Comparator) RefOfIdentifierCI(a, b *IdentifierCI) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.val == b.val &&
		a.lowered == b.lowered
}

// RefOfIdentifierCS does deep equals between the two objects.
func (cmp *Comparator) RefOfIdentifierCS(a, b *IdentifierCS) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.v == b.v
}

// SliceOfRefOfIndexColumn does deep equals between the two objects.
func (cmp *Comparator) SliceOfRefOfIndexColumn(a, b []*IndexColumn) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !cmp.RefOfIndexColumn(a[i], b[i]) {
			return false
		}
	}
	return true
}

// SliceOfRefOfIndexOption does deep equals between the two objects.
func (cmp *Comparator) SliceOfRefOfIndexOption(a, b []*IndexOption) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !cmp.RefOfIndexOption(a[i], b[i]) {
			return false
		}
	}
	return true
}

// SliceOfExpr does deep equals between the two objects.
func (cmp *Comparator) SliceOfExpr(a, b []Expr) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !cmp.Expr(a[i], b[i]) {
			return false
		}
	}
	return true
}

// SliceOfRefOfJSONObjectParam does deep equals between the two objects.
func (cmp *Comparator) SliceOfRefOfJSONObjectParam(a, b []*JSONObjectParam) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !cmp.RefOfJSONObjectParam(a[i], b[i]) {
			return false
		}
	}
	return true
}

// SliceOfRefOfJtColumnDefinition does deep equals between the two objects.
func (cmp *Comparator) SliceOfRefOfJtColumnDefinition(a, b []*JtColumnDefinition) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !cmp.RefOfJtColumnDefinition(a[i], b[i]) {
			return false
		}
	}
	return true
}

// RefOfJtOrdinalColDef does deep equals between the two objects.
func (cmp *Comparator) RefOfJtOrdinalColDef(a, b *JtOrdinalColDef) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.IdentifierCI(a.Name, b.Name)
}

// RefOfJtPathColDef does deep equals between the two objects.
func (cmp *Comparator) RefOfJtPathColDef(a, b *JtPathColDef) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.JtColExists == b.JtColExists &&
		cmp.IdentifierCI(a.Name, b.Name) &&
		cmp.RefOfColumnType(a.Type, b.Type) &&
		cmp.Expr(a.Path, b.Path) &&
		cmp.RefOfJtOnResponse(a.EmptyOnResponse, b.EmptyOnResponse) &&
		cmp.RefOfJtOnResponse(a.ErrorOnResponse, b.ErrorOnResponse)
}

// RefOfJtNestedPathColDef does deep equals between the two objects.
func (cmp *Comparator) RefOfJtNestedPathColDef(a, b *JtNestedPathColDef) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.Expr(a.Path, b.Path) &&
		cmp.SliceOfRefOfJtColumnDefinition(a.Columns, b.Columns)
}

// TableAndLockTypes does deep equals between the two objects.
func (cmp *Comparator) TableAndLockTypes(a, b TableAndLockTypes) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !cmp.RefOfTableAndLockType(a[i], b[i]) {
			return false
		}
	}
	return true
}

// SliceOfRefOfColName does deep equals between the two objects.
func (cmp *Comparator) SliceOfRefOfColName(a, b []*ColName) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !cmp.RefOfColName(a[i], b[i]) {
			return false
		}
	}
	return true
}

// Comments does deep equals between the two objects.
func (cmp *Comparator) Comments(a, b Comments) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}

// RefOfInt does deep equals between the two objects.
func (cmp *Comparator) RefOfInt(a, b *int) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return *a == *b
}

// SliceOfRefOfPartitionDefinition does deep equals between the two objects.
func (cmp *Comparator) SliceOfRefOfPartitionDefinition(a, b []*PartitionDefinition) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !cmp.RefOfPartitionDefinition(a[i], b[i]) {
			return false
		}
	}
	return true
}

// SliceOfRefOfRenameTablePair does deep equals between the two objects.
func (cmp *Comparator) SliceOfRefOfRenameTablePair(a, b []*RenameTablePair) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !cmp.RefOfRenameTablePair(a[i], b[i]) {
			return false
		}
	}
	return true
}

// RefOfRootNode does deep equals between the two objects.
func (cmp *Comparator) RefOfRootNode(a, b *RootNode) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.SQLNode(a.SQLNode, b.SQLNode)
}

// SliceOfTableExpr does deep equals between the two objects.
func (cmp *Comparator) SliceOfTableExpr(a, b []TableExpr) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !cmp.TableExpr(a[i], b[i]) {
			return false
		}
	}
	return true
}

// RefOfTableName does deep equals between the two objects.
func (cmp *Comparator) RefOfTableName(a, b *TableName) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.IdentifierCS(a.Name, b.Name) &&
		cmp.IdentifierCS(a.Qualifier, b.Qualifier)
}

// RefOfTableOption does deep equals between the two objects.
func (cmp *Comparator) RefOfTableOption(a, b *TableOption) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Name == b.Name &&
		a.String == b.String &&
		a.CaseSensitive == b.CaseSensitive &&
		cmp.RefOfLiteral(a.Value, b.Value) &&
		cmp.TableNames(a.Tables, b.Tables)
}

// SliceOfRefOfIndexDefinition does deep equals between the two objects.
func (cmp *Comparator) SliceOfRefOfIndexDefinition(a, b []*IndexDefinition) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !cmp.RefOfIndexDefinition(a[i], b[i]) {
			return false
		}
	}
	return true
}

// SliceOfRefOfConstraintDefinition does deep equals between the two objects.
func (cmp *Comparator) SliceOfRefOfConstraintDefinition(a, b []*ConstraintDefinition) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !cmp.RefOfConstraintDefinition(a[i], b[i]) {
			return false
		}
	}
	return true
}

// RefOfVindexParam does deep equals between the two objects.
func (cmp *Comparator) RefOfVindexParam(a, b *VindexParam) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Val == b.Val &&
		cmp.IdentifierCI(a.Key, b.Key)
}

// SliceOfVindexParam does deep equals between the two objects.
func (cmp *Comparator) SliceOfVindexParam(a, b []VindexParam) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !cmp.VindexParam(a[i], b[i]) {
			return false
		}
	}
	return true
}

// SliceOfRefOfCommonTableExpr does deep equals between the two objects.
func (cmp *Comparator) SliceOfRefOfCommonTableExpr(a, b []*CommonTableExpr) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !cmp.RefOfCommonTableExpr(a[i], b[i]) {
			return false
		}
	}
	return true
}

// DatabaseOption does deep equals between the two objects.
func (cmp *Comparator) DatabaseOption(a, b DatabaseOption) bool {
	return a.IsDefault == b.IsDefault &&
		a.Value == b.Value &&
		a.Type == b.Type
}

// RefOfColumnCharset does deep equals between the two objects.
func (cmp *Comparator) RefOfColumnCharset(a, b *ColumnCharset) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Name == b.Name &&
		a.Binary == b.Binary
}

// RefOfIndexColumn does deep equals between the two objects.
func (cmp *Comparator) RefOfIndexColumn(a, b *IndexColumn) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.IdentifierCI(a.Column, b.Column) &&
		cmp.RefOfLiteral(a.Length, b.Length) &&
		cmp.Expr(a.Expression, b.Expression) &&
		a.Direction == b.Direction
}

// RefOfIndexOption does deep equals between the two objects.
func (cmp *Comparator) RefOfIndexOption(a, b *IndexOption) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Name == b.Name &&
		a.String == b.String &&
		cmp.RefOfLiteral(a.Value, b.Value)
}

// RefOfTableAndLockType does deep equals between the two objects.
func (cmp *Comparator) RefOfTableAndLockType(a, b *TableAndLockType) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.TableExpr(a.Table, b.Table) &&
		a.Lock == b.Lock
}

// RefOfRenameTablePair does deep equals between the two objects.
func (cmp *Comparator) RefOfRenameTablePair(a, b *RenameTablePair) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return cmp.TableName(a.FromTable, b.FromTable) &&
		cmp.TableName(a.ToTable, b.ToTable)
}

// RefOfDatabaseOption does deep equals between the two objects.
func (cmp *Comparator) RefOfDatabaseOption(a, b *DatabaseOption) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.IsDefault == b.IsDefault &&
		a.Value == b.Value &&
		a.Type == b.Type
}

type Comparator struct {
	RefOfColName_ func(a, b *ColName) bool
}
