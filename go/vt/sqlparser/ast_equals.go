/*
Copyright 2021 The Vitess Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
// Code generated by ASTHelperGen. DO NOT EDIT.

package sqlparser

// EqualsSQLNode does deep equals between the two objects.
func EqualsSQLNode(inA, inB SQLNode, f ASTComparison) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *AddColumns:
		b, ok := inB.(*AddColumns)
		if !ok {
			return false
		}
		return EqualsRefOfAddColumns(a, b, f)
	case *AddConstraintDefinition:
		b, ok := inB.(*AddConstraintDefinition)
		if !ok {
			return false
		}
		return EqualsRefOfAddConstraintDefinition(a, b, f)
	case *AddIndexDefinition:
		b, ok := inB.(*AddIndexDefinition)
		if !ok {
			return false
		}
		return EqualsRefOfAddIndexDefinition(a, b, f)
	case AlgorithmValue:
		b, ok := inB.(AlgorithmValue)
		if !ok {
			return false
		}
		return a == b
	case *AliasedExpr:
		b, ok := inB.(*AliasedExpr)
		if !ok {
			return false
		}
		return EqualsRefOfAliasedExpr(a, b, f)
	case *AliasedTableExpr:
		b, ok := inB.(*AliasedTableExpr)
		if !ok {
			return false
		}
		return EqualsRefOfAliasedTableExpr(a, b, f)
	case *AlterCharset:
		b, ok := inB.(*AlterCharset)
		if !ok {
			return false
		}
		return EqualsRefOfAlterCharset(a, b, f)
	case *AlterCheck:
		b, ok := inB.(*AlterCheck)
		if !ok {
			return false
		}
		return EqualsRefOfAlterCheck(a, b, f)
	case *AlterColumn:
		b, ok := inB.(*AlterColumn)
		if !ok {
			return false
		}
		return EqualsRefOfAlterColumn(a, b, f)
	case *AlterDatabase:
		b, ok := inB.(*AlterDatabase)
		if !ok {
			return false
		}
		return EqualsRefOfAlterDatabase(a, b, f)
	case *AlterIndex:
		b, ok := inB.(*AlterIndex)
		if !ok {
			return false
		}
		return EqualsRefOfAlterIndex(a, b, f)
	case *AlterMigration:
		b, ok := inB.(*AlterMigration)
		if !ok {
			return false
		}
		return EqualsRefOfAlterMigration(a, b, f)
	case *AlterTable:
		b, ok := inB.(*AlterTable)
		if !ok {
			return false
		}
		return EqualsRefOfAlterTable(a, b, f)
	case *AlterView:
		b, ok := inB.(*AlterView)
		if !ok {
			return false
		}
		return EqualsRefOfAlterView(a, b, f)
	case *AlterVschema:
		b, ok := inB.(*AlterVschema)
		if !ok {
			return false
		}
		return EqualsRefOfAlterVschema(a, b, f)
	case *AndExpr:
		b, ok := inB.(*AndExpr)
		if !ok {
			return false
		}
		return EqualsRefOfAndExpr(a, b, f)
	case Argument:
		b, ok := inB.(Argument)
		if !ok {
			return false
		}
		return a == b
	case *ArgumentLessWindowExpr:
		b, ok := inB.(*ArgumentLessWindowExpr)
		if !ok {
			return false
		}
		return EqualsRefOfArgumentLessWindowExpr(a, b, f)
	case *AutoIncSpec:
		b, ok := inB.(*AutoIncSpec)
		if !ok {
			return false
		}
		return EqualsRefOfAutoIncSpec(a, b, f)
	case *Avg:
		b, ok := inB.(*Avg)
		if !ok {
			return false
		}
		return EqualsRefOfAvg(a, b, f)
	case *Begin:
		b, ok := inB.(*Begin)
		if !ok {
			return false
		}
		return EqualsRefOfBegin(a, b, f)
	case *BetweenExpr:
		b, ok := inB.(*BetweenExpr)
		if !ok {
			return false
		}
		return EqualsRefOfBetweenExpr(a, b, f)
	case *BinaryExpr:
		b, ok := inB.(*BinaryExpr)
		if !ok {
			return false
		}
		return EqualsRefOfBinaryExpr(a, b, f)
	case *BitAnd:
		b, ok := inB.(*BitAnd)
		if !ok {
			return false
		}
		return EqualsRefOfBitAnd(a, b, f)
	case *BitOr:
		b, ok := inB.(*BitOr)
		if !ok {
			return false
		}
		return EqualsRefOfBitOr(a, b, f)
	case *BitXor:
		b, ok := inB.(*BitXor)
		if !ok {
			return false
		}
		return EqualsRefOfBitXor(a, b, f)
	case BoolVal:
		b, ok := inB.(BoolVal)
		if !ok {
			return false
		}
		return a == b
	case *CallProc:
		b, ok := inB.(*CallProc)
		if !ok {
			return false
		}
		return EqualsRefOfCallProc(a, b, f)
	case *CaseExpr:
		b, ok := inB.(*CaseExpr)
		if !ok {
			return false
		}
		return EqualsRefOfCaseExpr(a, b, f)
	case *CastExpr:
		b, ok := inB.(*CastExpr)
		if !ok {
			return false
		}
		return EqualsRefOfCastExpr(a, b, f)
	case *ChangeColumn:
		b, ok := inB.(*ChangeColumn)
		if !ok {
			return false
		}
		return EqualsRefOfChangeColumn(a, b, f)
	case *CharExpr:
		b, ok := inB.(*CharExpr)
		if !ok {
			return false
		}
		return EqualsRefOfCharExpr(a, b, f)
	case *CheckConstraintDefinition:
		b, ok := inB.(*CheckConstraintDefinition)
		if !ok {
			return false
		}
		return EqualsRefOfCheckConstraintDefinition(a, b, f)
	case *ColName:
		b, ok := inB.(*ColName)
		if !ok {
			return false
		}
		return EqualsRefOfColName(a, b, f)
	case *CollateExpr:
		b, ok := inB.(*CollateExpr)
		if !ok {
			return false
		}
		return EqualsRefOfCollateExpr(a, b, f)
	case *ColumnDefinition:
		b, ok := inB.(*ColumnDefinition)
		if !ok {
			return false
		}
		return EqualsRefOfColumnDefinition(a, b, f)
	case *ColumnType:
		b, ok := inB.(*ColumnType)
		if !ok {
			return false
		}
		return EqualsRefOfColumnType(a, b, f)
	case Columns:
		b, ok := inB.(Columns)
		if !ok {
			return false
		}
		return EqualsColumns(a, b, f)
	case *CommentOnly:
		b, ok := inB.(*CommentOnly)
		if !ok {
			return false
		}
		return EqualsRefOfCommentOnly(a, b, f)
	case *Commit:
		b, ok := inB.(*Commit)
		if !ok {
			return false
		}
		return EqualsRefOfCommit(a, b, f)
	case *CommonTableExpr:
		b, ok := inB.(*CommonTableExpr)
		if !ok {
			return false
		}
		return EqualsRefOfCommonTableExpr(a, b, f)
	case *ComparisonExpr:
		b, ok := inB.(*ComparisonExpr)
		if !ok {
			return false
		}
		return EqualsRefOfComparisonExpr(a, b, f)
	case *ConstraintDefinition:
		b, ok := inB.(*ConstraintDefinition)
		if !ok {
			return false
		}
		return EqualsRefOfConstraintDefinition(a, b, f)
	case *ConvertExpr:
		b, ok := inB.(*ConvertExpr)
		if !ok {
			return false
		}
		return EqualsRefOfConvertExpr(a, b, f)
	case *ConvertType:
		b, ok := inB.(*ConvertType)
		if !ok {
			return false
		}
		return EqualsRefOfConvertType(a, b, f)
	case *ConvertUsingExpr:
		b, ok := inB.(*ConvertUsingExpr)
		if !ok {
			return false
		}
		return EqualsRefOfConvertUsingExpr(a, b, f)
	case *Count:
		b, ok := inB.(*Count)
		if !ok {
			return false
		}
		return EqualsRefOfCount(a, b, f)
	case *CountStar:
		b, ok := inB.(*CountStar)
		if !ok {
			return false
		}
		return EqualsRefOfCountStar(a, b, f)
	case *CreateDatabase:
		b, ok := inB.(*CreateDatabase)
		if !ok {
			return false
		}
		return EqualsRefOfCreateDatabase(a, b, f)
	case *CreateTable:
		b, ok := inB.(*CreateTable)
		if !ok {
			return false
		}
		return EqualsRefOfCreateTable(a, b, f)
	case *CreateView:
		b, ok := inB.(*CreateView)
		if !ok {
			return false
		}
		return EqualsRefOfCreateView(a, b, f)
	case *CurTimeFuncExpr:
		b, ok := inB.(*CurTimeFuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfCurTimeFuncExpr(a, b, f)
	case *DeallocateStmt:
		b, ok := inB.(*DeallocateStmt)
		if !ok {
			return false
		}
		return EqualsRefOfDeallocateStmt(a, b, f)
	case *Default:
		b, ok := inB.(*Default)
		if !ok {
			return false
		}
		return EqualsRefOfDefault(a, b, f)
	case *Definer:
		b, ok := inB.(*Definer)
		if !ok {
			return false
		}
		return EqualsRefOfDefiner(a, b, f)
	case *Delete:
		b, ok := inB.(*Delete)
		if !ok {
			return false
		}
		return EqualsRefOfDelete(a, b, f)
	case *DerivedTable:
		b, ok := inB.(*DerivedTable)
		if !ok {
			return false
		}
		return EqualsRefOfDerivedTable(a, b, f)
	case *DropColumn:
		b, ok := inB.(*DropColumn)
		if !ok {
			return false
		}
		return EqualsRefOfDropColumn(a, b, f)
	case *DropDatabase:
		b, ok := inB.(*DropDatabase)
		if !ok {
			return false
		}
		return EqualsRefOfDropDatabase(a, b, f)
	case *DropKey:
		b, ok := inB.(*DropKey)
		if !ok {
			return false
		}
		return EqualsRefOfDropKey(a, b, f)
	case *DropTable:
		b, ok := inB.(*DropTable)
		if !ok {
			return false
		}
		return EqualsRefOfDropTable(a, b, f)
	case *DropView:
		b, ok := inB.(*DropView)
		if !ok {
			return false
		}
		return EqualsRefOfDropView(a, b, f)
	case *ExecuteStmt:
		b, ok := inB.(*ExecuteStmt)
		if !ok {
			return false
		}
		return EqualsRefOfExecuteStmt(a, b, f)
	case *ExistsExpr:
		b, ok := inB.(*ExistsExpr)
		if !ok {
			return false
		}
		return EqualsRefOfExistsExpr(a, b, f)
	case *ExplainStmt:
		b, ok := inB.(*ExplainStmt)
		if !ok {
			return false
		}
		return EqualsRefOfExplainStmt(a, b, f)
	case *ExplainTab:
		b, ok := inB.(*ExplainTab)
		if !ok {
			return false
		}
		return EqualsRefOfExplainTab(a, b, f)
	case Exprs:
		b, ok := inB.(Exprs)
		if !ok {
			return false
		}
		return EqualsExprs(a, b, f)
	case *ExtractFuncExpr:
		b, ok := inB.(*ExtractFuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfExtractFuncExpr(a, b, f)
	case *ExtractValueExpr:
		b, ok := inB.(*ExtractValueExpr)
		if !ok {
			return false
		}
		return EqualsRefOfExtractValueExpr(a, b, f)
	case *ExtractedSubquery:
		b, ok := inB.(*ExtractedSubquery)
		if !ok {
			return false
		}
		return EqualsRefOfExtractedSubquery(a, b, f)
	case *FirstOrLastValueExpr:
		b, ok := inB.(*FirstOrLastValueExpr)
		if !ok {
			return false
		}
		return EqualsRefOfFirstOrLastValueExpr(a, b, f)
	case *Flush:
		b, ok := inB.(*Flush)
		if !ok {
			return false
		}
		return EqualsRefOfFlush(a, b, f)
	case *Force:
		b, ok := inB.(*Force)
		if !ok {
			return false
		}
		return EqualsRefOfForce(a, b, f)
	case *ForeignKeyDefinition:
		b, ok := inB.(*ForeignKeyDefinition)
		if !ok {
			return false
		}
		return EqualsRefOfForeignKeyDefinition(a, b, f)
	case *FrameClause:
		b, ok := inB.(*FrameClause)
		if !ok {
			return false
		}
		return EqualsRefOfFrameClause(a, b, f)
	case *FramePoint:
		b, ok := inB.(*FramePoint)
		if !ok {
			return false
		}
		return EqualsRefOfFramePoint(a, b, f)
	case *FromFirstLastClause:
		b, ok := inB.(*FromFirstLastClause)
		if !ok {
			return false
		}
		return EqualsRefOfFromFirstLastClause(a, b, f)
	case *FuncExpr:
		b, ok := inB.(*FuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfFuncExpr(a, b, f)
	case *GTIDFuncExpr:
		b, ok := inB.(*GTIDFuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfGTIDFuncExpr(a, b, f)
	case GroupBy:
		b, ok := inB.(GroupBy)
		if !ok {
			return false
		}
		return EqualsGroupBy(a, b, f)
	case *GroupConcatExpr:
		b, ok := inB.(*GroupConcatExpr)
		if !ok {
			return false
		}
		return EqualsRefOfGroupConcatExpr(a, b, f)
	case IdentifierCI:
		b, ok := inB.(IdentifierCI)
		if !ok {
			return false
		}
		return EqualsIdentifierCI(a, b, f)
	case IdentifierCS:
		b, ok := inB.(IdentifierCS)
		if !ok {
			return false
		}
		return EqualsIdentifierCS(a, b, f)
	case *IndexDefinition:
		b, ok := inB.(*IndexDefinition)
		if !ok {
			return false
		}
		return EqualsRefOfIndexDefinition(a, b, f)
	case *IndexHint:
		b, ok := inB.(*IndexHint)
		if !ok {
			return false
		}
		return EqualsRefOfIndexHint(a, b, f)
	case IndexHints:
		b, ok := inB.(IndexHints)
		if !ok {
			return false
		}
		return EqualsIndexHints(a, b, f)
	case *IndexInfo:
		b, ok := inB.(*IndexInfo)
		if !ok {
			return false
		}
		return EqualsRefOfIndexInfo(a, b, f)
	case *Insert:
		b, ok := inB.(*Insert)
		if !ok {
			return false
		}
		return EqualsRefOfInsert(a, b, f)
	case *InsertExpr:
		b, ok := inB.(*InsertExpr)
		if !ok {
			return false
		}
		return EqualsRefOfInsertExpr(a, b, f)
	case *IntervalExpr:
		b, ok := inB.(*IntervalExpr)
		if !ok {
			return false
		}
		return EqualsRefOfIntervalExpr(a, b, f)
	case *IntervalFuncExpr:
		b, ok := inB.(*IntervalFuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfIntervalFuncExpr(a, b, f)
	case *IntroducerExpr:
		b, ok := inB.(*IntroducerExpr)
		if !ok {
			return false
		}
		return EqualsRefOfIntroducerExpr(a, b, f)
	case *IsExpr:
		b, ok := inB.(*IsExpr)
		if !ok {
			return false
		}
		return EqualsRefOfIsExpr(a, b, f)
	case *JSONArrayExpr:
		b, ok := inB.(*JSONArrayExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONArrayExpr(a, b, f)
	case *JSONAttributesExpr:
		b, ok := inB.(*JSONAttributesExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONAttributesExpr(a, b, f)
	case *JSONContainsExpr:
		b, ok := inB.(*JSONContainsExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONContainsExpr(a, b, f)
	case *JSONContainsPathExpr:
		b, ok := inB.(*JSONContainsPathExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONContainsPathExpr(a, b, f)
	case *JSONExtractExpr:
		b, ok := inB.(*JSONExtractExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONExtractExpr(a, b, f)
	case *JSONKeysExpr:
		b, ok := inB.(*JSONKeysExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONKeysExpr(a, b, f)
	case *JSONObjectExpr:
		b, ok := inB.(*JSONObjectExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONObjectExpr(a, b, f)
	case JSONObjectParam:
		b, ok := inB.(JSONObjectParam)
		if !ok {
			return false
		}
		return EqualsJSONObjectParam(a, b, f)
	case *JSONOverlapsExpr:
		b, ok := inB.(*JSONOverlapsExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONOverlapsExpr(a, b, f)
	case *JSONPrettyExpr:
		b, ok := inB.(*JSONPrettyExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONPrettyExpr(a, b, f)
	case *JSONQuoteExpr:
		b, ok := inB.(*JSONQuoteExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONQuoteExpr(a, b, f)
	case *JSONRemoveExpr:
		b, ok := inB.(*JSONRemoveExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONRemoveExpr(a, b, f)
	case *JSONSchemaValidFuncExpr:
		b, ok := inB.(*JSONSchemaValidFuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONSchemaValidFuncExpr(a, b, f)
	case *JSONSchemaValidationReportFuncExpr:
		b, ok := inB.(*JSONSchemaValidationReportFuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONSchemaValidationReportFuncExpr(a, b, f)
	case *JSONSearchExpr:
		b, ok := inB.(*JSONSearchExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONSearchExpr(a, b, f)
	case *JSONStorageFreeExpr:
		b, ok := inB.(*JSONStorageFreeExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONStorageFreeExpr(a, b, f)
	case *JSONStorageSizeExpr:
		b, ok := inB.(*JSONStorageSizeExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONStorageSizeExpr(a, b, f)
	case *JSONTableExpr:
		b, ok := inB.(*JSONTableExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONTableExpr(a, b, f)
	case *JSONUnquoteExpr:
		b, ok := inB.(*JSONUnquoteExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONUnquoteExpr(a, b, f)
	case *JSONValueExpr:
		b, ok := inB.(*JSONValueExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONValueExpr(a, b, f)
	case *JSONValueMergeExpr:
		b, ok := inB.(*JSONValueMergeExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONValueMergeExpr(a, b, f)
	case *JSONValueModifierExpr:
		b, ok := inB.(*JSONValueModifierExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONValueModifierExpr(a, b, f)
	case *JoinCondition:
		b, ok := inB.(*JoinCondition)
		if !ok {
			return false
		}
		return EqualsRefOfJoinCondition(a, b, f)
	case *JoinTableExpr:
		b, ok := inB.(*JoinTableExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJoinTableExpr(a, b, f)
	case *JtColumnDefinition:
		b, ok := inB.(*JtColumnDefinition)
		if !ok {
			return false
		}
		return EqualsRefOfJtColumnDefinition(a, b, f)
	case *JtOnResponse:
		b, ok := inB.(*JtOnResponse)
		if !ok {
			return false
		}
		return EqualsRefOfJtOnResponse(a, b, f)
	case *KeyState:
		b, ok := inB.(*KeyState)
		if !ok {
			return false
		}
		return EqualsRefOfKeyState(a, b, f)
	case *LagLeadExpr:
		b, ok := inB.(*LagLeadExpr)
		if !ok {
			return false
		}
		return EqualsRefOfLagLeadExpr(a, b, f)
	case *Limit:
		b, ok := inB.(*Limit)
		if !ok {
			return false
		}
		return EqualsRefOfLimit(a, b, f)
	case ListArg:
		b, ok := inB.(ListArg)
		if !ok {
			return false
		}
		return a == b
	case *Literal:
		b, ok := inB.(*Literal)
		if !ok {
			return false
		}
		return EqualsRefOfLiteral(a, b, f)
	case *Load:
		b, ok := inB.(*Load)
		if !ok {
			return false
		}
		return EqualsRefOfLoad(a, b, f)
	case *LocateExpr:
		b, ok := inB.(*LocateExpr)
		if !ok {
			return false
		}
		return EqualsRefOfLocateExpr(a, b, f)
	case *LockOption:
		b, ok := inB.(*LockOption)
		if !ok {
			return false
		}
		return EqualsRefOfLockOption(a, b, f)
	case *LockTables:
		b, ok := inB.(*LockTables)
		if !ok {
			return false
		}
		return EqualsRefOfLockTables(a, b, f)
	case *LockingFunc:
		b, ok := inB.(*LockingFunc)
		if !ok {
			return false
		}
		return EqualsRefOfLockingFunc(a, b, f)
	case MatchAction:
		b, ok := inB.(MatchAction)
		if !ok {
			return false
		}
		return a == b
	case *MatchExpr:
		b, ok := inB.(*MatchExpr)
		if !ok {
			return false
		}
		return EqualsRefOfMatchExpr(a, b, f)
	case *Max:
		b, ok := inB.(*Max)
		if !ok {
			return false
		}
		return EqualsRefOfMax(a, b, f)
	case *MemberOfExpr:
		b, ok := inB.(*MemberOfExpr)
		if !ok {
			return false
		}
		return EqualsRefOfMemberOfExpr(a, b, f)
	case *Min:
		b, ok := inB.(*Min)
		if !ok {
			return false
		}
		return EqualsRefOfMin(a, b, f)
	case *ModifyColumn:
		b, ok := inB.(*ModifyColumn)
		if !ok {
			return false
		}
		return EqualsRefOfModifyColumn(a, b, f)
	case *NTHValueExpr:
		b, ok := inB.(*NTHValueExpr)
		if !ok {
			return false
		}
		return EqualsRefOfNTHValueExpr(a, b, f)
	case *NamedWindow:
		b, ok := inB.(*NamedWindow)
		if !ok {
			return false
		}
		return EqualsRefOfNamedWindow(a, b, f)
	case NamedWindows:
		b, ok := inB.(NamedWindows)
		if !ok {
			return false
		}
		return EqualsNamedWindows(a, b, f)
	case *Nextval:
		b, ok := inB.(*Nextval)
		if !ok {
			return false
		}
		return EqualsRefOfNextval(a, b, f)
	case *NotExpr:
		b, ok := inB.(*NotExpr)
		if !ok {
			return false
		}
		return EqualsRefOfNotExpr(a, b, f)
	case *NtileExpr:
		b, ok := inB.(*NtileExpr)
		if !ok {
			return false
		}
		return EqualsRefOfNtileExpr(a, b, f)
	case *NullTreatmentClause:
		b, ok := inB.(*NullTreatmentClause)
		if !ok {
			return false
		}
		return EqualsRefOfNullTreatmentClause(a, b, f)
	case *NullVal:
		b, ok := inB.(*NullVal)
		if !ok {
			return false
		}
		return EqualsRefOfNullVal(a, b, f)
	case *Offset:
		b, ok := inB.(*Offset)
		if !ok {
			return false
		}
		return EqualsRefOfOffset(a, b, f)
	case OnDup:
		b, ok := inB.(OnDup)
		if !ok {
			return false
		}
		return EqualsOnDup(a, b, f)
	case *OptLike:
		b, ok := inB.(*OptLike)
		if !ok {
			return false
		}
		return EqualsRefOfOptLike(a, b, f)
	case *OrExpr:
		b, ok := inB.(*OrExpr)
		if !ok {
			return false
		}
		return EqualsRefOfOrExpr(a, b, f)
	case *Order:
		b, ok := inB.(*Order)
		if !ok {
			return false
		}
		return EqualsRefOfOrder(a, b, f)
	case OrderBy:
		b, ok := inB.(OrderBy)
		if !ok {
			return false
		}
		return EqualsOrderBy(a, b, f)
	case *OrderByOption:
		b, ok := inB.(*OrderByOption)
		if !ok {
			return false
		}
		return EqualsRefOfOrderByOption(a, b, f)
	case *OtherAdmin:
		b, ok := inB.(*OtherAdmin)
		if !ok {
			return false
		}
		return EqualsRefOfOtherAdmin(a, b, f)
	case *OtherRead:
		b, ok := inB.(*OtherRead)
		if !ok {
			return false
		}
		return EqualsRefOfOtherRead(a, b, f)
	case *OverClause:
		b, ok := inB.(*OverClause)
		if !ok {
			return false
		}
		return EqualsRefOfOverClause(a, b, f)
	case *ParenTableExpr:
		b, ok := inB.(*ParenTableExpr)
		if !ok {
			return false
		}
		return EqualsRefOfParenTableExpr(a, b, f)
	case *ParsedComments:
		b, ok := inB.(*ParsedComments)
		if !ok {
			return false
		}
		return EqualsRefOfParsedComments(a, b, f)
	case *PartitionDefinition:
		b, ok := inB.(*PartitionDefinition)
		if !ok {
			return false
		}
		return EqualsRefOfPartitionDefinition(a, b, f)
	case *PartitionDefinitionOptions:
		b, ok := inB.(*PartitionDefinitionOptions)
		if !ok {
			return false
		}
		return EqualsRefOfPartitionDefinitionOptions(a, b, f)
	case *PartitionEngine:
		b, ok := inB.(*PartitionEngine)
		if !ok {
			return false
		}
		return EqualsRefOfPartitionEngine(a, b, f)
	case *PartitionOption:
		b, ok := inB.(*PartitionOption)
		if !ok {
			return false
		}
		return EqualsRefOfPartitionOption(a, b, f)
	case *PartitionSpec:
		b, ok := inB.(*PartitionSpec)
		if !ok {
			return false
		}
		return EqualsRefOfPartitionSpec(a, b, f)
	case *PartitionValueRange:
		b, ok := inB.(*PartitionValueRange)
		if !ok {
			return false
		}
		return EqualsRefOfPartitionValueRange(a, b, f)
	case Partitions:
		b, ok := inB.(Partitions)
		if !ok {
			return false
		}
		return EqualsPartitions(a, b, f)
	case *PerformanceSchemaFuncExpr:
		b, ok := inB.(*PerformanceSchemaFuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfPerformanceSchemaFuncExpr(a, b, f)
	case *PrepareStmt:
		b, ok := inB.(*PrepareStmt)
		if !ok {
			return false
		}
		return EqualsRefOfPrepareStmt(a, b, f)
	case ReferenceAction:
		b, ok := inB.(ReferenceAction)
		if !ok {
			return false
		}
		return a == b
	case *ReferenceDefinition:
		b, ok := inB.(*ReferenceDefinition)
		if !ok {
			return false
		}
		return EqualsRefOfReferenceDefinition(a, b, f)
	case *RegexpInstrExpr:
		b, ok := inB.(*RegexpInstrExpr)
		if !ok {
			return false
		}
		return EqualsRefOfRegexpInstrExpr(a, b, f)
	case *RegexpLikeExpr:
		b, ok := inB.(*RegexpLikeExpr)
		if !ok {
			return false
		}
		return EqualsRefOfRegexpLikeExpr(a, b, f)
	case *RegexpReplaceExpr:
		b, ok := inB.(*RegexpReplaceExpr)
		if !ok {
			return false
		}
		return EqualsRefOfRegexpReplaceExpr(a, b, f)
	case *RegexpSubstrExpr:
		b, ok := inB.(*RegexpSubstrExpr)
		if !ok {
			return false
		}
		return EqualsRefOfRegexpSubstrExpr(a, b, f)
	case *Release:
		b, ok := inB.(*Release)
		if !ok {
			return false
		}
		return EqualsRefOfRelease(a, b, f)
	case *RenameColumn:
		b, ok := inB.(*RenameColumn)
		if !ok {
			return false
		}
		return EqualsRefOfRenameColumn(a, b, f)
	case *RenameIndex:
		b, ok := inB.(*RenameIndex)
		if !ok {
			return false
		}
		return EqualsRefOfRenameIndex(a, b, f)
	case *RenameTable:
		b, ok := inB.(*RenameTable)
		if !ok {
			return false
		}
		return EqualsRefOfRenameTable(a, b, f)
	case *RenameTableName:
		b, ok := inB.(*RenameTableName)
		if !ok {
			return false
		}
		return EqualsRefOfRenameTableName(a, b, f)
	case *RevertMigration:
		b, ok := inB.(*RevertMigration)
		if !ok {
			return false
		}
		return EqualsRefOfRevertMigration(a, b, f)
	case *Rollback:
		b, ok := inB.(*Rollback)
		if !ok {
			return false
		}
		return EqualsRefOfRollback(a, b, f)
	case RootNode:
		b, ok := inB.(RootNode)
		if !ok {
			return false
		}
		return EqualsRootNode(a, b, f)
	case *SRollback:
		b, ok := inB.(*SRollback)
		if !ok {
			return false
		}
		return EqualsRefOfSRollback(a, b, f)
	case *Savepoint:
		b, ok := inB.(*Savepoint)
		if !ok {
			return false
		}
		return EqualsRefOfSavepoint(a, b, f)
	case *Select:
		b, ok := inB.(*Select)
		if !ok {
			return false
		}
		return EqualsRefOfSelect(a, b, f)
	case SelectExprs:
		b, ok := inB.(SelectExprs)
		if !ok {
			return false
		}
		return EqualsSelectExprs(a, b, f)
	case *SelectInto:
		b, ok := inB.(*SelectInto)
		if !ok {
			return false
		}
		return EqualsRefOfSelectInto(a, b, f)
	case *Set:
		b, ok := inB.(*Set)
		if !ok {
			return false
		}
		return EqualsRefOfSet(a, b, f)
	case *SetExpr:
		b, ok := inB.(*SetExpr)
		if !ok {
			return false
		}
		return EqualsRefOfSetExpr(a, b, f)
	case SetExprs:
		b, ok := inB.(SetExprs)
		if !ok {
			return false
		}
		return EqualsSetExprs(a, b, f)
	case *Show:
		b, ok := inB.(*Show)
		if !ok {
			return false
		}
		return EqualsRefOfShow(a, b, f)
	case *ShowBasic:
		b, ok := inB.(*ShowBasic)
		if !ok {
			return false
		}
		return EqualsRefOfShowBasic(a, b, f)
	case *ShowCreate:
		b, ok := inB.(*ShowCreate)
		if !ok {
			return false
		}
		return EqualsRefOfShowCreate(a, b, f)
	case *ShowFilter:
		b, ok := inB.(*ShowFilter)
		if !ok {
			return false
		}
		return EqualsRefOfShowFilter(a, b, f)
	case *ShowMigrationLogs:
		b, ok := inB.(*ShowMigrationLogs)
		if !ok {
			return false
		}
		return EqualsRefOfShowMigrationLogs(a, b, f)
	case *ShowOther:
		b, ok := inB.(*ShowOther)
		if !ok {
			return false
		}
		return EqualsRefOfShowOther(a, b, f)
	case *ShowThrottledApps:
		b, ok := inB.(*ShowThrottledApps)
		if !ok {
			return false
		}
		return EqualsRefOfShowThrottledApps(a, b, f)
	case *ShowThrottlerStatus:
		b, ok := inB.(*ShowThrottlerStatus)
		if !ok {
			return false
		}
		return EqualsRefOfShowThrottlerStatus(a, b, f)
	case *StarExpr:
		b, ok := inB.(*StarExpr)
		if !ok {
			return false
		}
		return EqualsRefOfStarExpr(a, b, f)
	case *Std:
		b, ok := inB.(*Std)
		if !ok {
			return false
		}
		return EqualsRefOfStd(a, b, f)
	case *StdDev:
		b, ok := inB.(*StdDev)
		if !ok {
			return false
		}
		return EqualsRefOfStdDev(a, b, f)
	case *StdPop:
		b, ok := inB.(*StdPop)
		if !ok {
			return false
		}
		return EqualsRefOfStdPop(a, b, f)
	case *StdSamp:
		b, ok := inB.(*StdSamp)
		if !ok {
			return false
		}
		return EqualsRefOfStdSamp(a, b, f)
	case *Stream:
		b, ok := inB.(*Stream)
		if !ok {
			return false
		}
		return EqualsRefOfStream(a, b, f)
	case *SubPartition:
		b, ok := inB.(*SubPartition)
		if !ok {
			return false
		}
		return EqualsRefOfSubPartition(a, b, f)
	case *SubPartitionDefinition:
		b, ok := inB.(*SubPartitionDefinition)
		if !ok {
			return false
		}
		return EqualsRefOfSubPartitionDefinition(a, b, f)
	case *SubPartitionDefinitionOptions:
		b, ok := inB.(*SubPartitionDefinitionOptions)
		if !ok {
			return false
		}
		return EqualsRefOfSubPartitionDefinitionOptions(a, b, f)
	case SubPartitionDefinitions:
		b, ok := inB.(SubPartitionDefinitions)
		if !ok {
			return false
		}
		return EqualsSubPartitionDefinitions(a, b, f)
	case *Subquery:
		b, ok := inB.(*Subquery)
		if !ok {
			return false
		}
		return EqualsRefOfSubquery(a, b, f)
	case *SubstrExpr:
		b, ok := inB.(*SubstrExpr)
		if !ok {
			return false
		}
		return EqualsRefOfSubstrExpr(a, b, f)
	case *Sum:
		b, ok := inB.(*Sum)
		if !ok {
			return false
		}
		return EqualsRefOfSum(a, b, f)
	case TableExprs:
		b, ok := inB.(TableExprs)
		if !ok {
			return false
		}
		return EqualsTableExprs(a, b, f)
	case TableName:
		b, ok := inB.(TableName)
		if !ok {
			return false
		}
		return EqualsTableName(a, b, f)
	case TableNames:
		b, ok := inB.(TableNames)
		if !ok {
			return false
		}
		return EqualsTableNames(a, b, f)
	case TableOptions:
		b, ok := inB.(TableOptions)
		if !ok {
			return false
		}
		return EqualsTableOptions(a, b, f)
	case *TableSpec:
		b, ok := inB.(*TableSpec)
		if !ok {
			return false
		}
		return EqualsRefOfTableSpec(a, b, f)
	case *TablespaceOperation:
		b, ok := inB.(*TablespaceOperation)
		if !ok {
			return false
		}
		return EqualsRefOfTablespaceOperation(a, b, f)
	case *TimestampFuncExpr:
		b, ok := inB.(*TimestampFuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfTimestampFuncExpr(a, b, f)
	case *TrimFuncExpr:
		b, ok := inB.(*TrimFuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfTrimFuncExpr(a, b, f)
	case *TruncateTable:
		b, ok := inB.(*TruncateTable)
		if !ok {
			return false
		}
		return EqualsRefOfTruncateTable(a, b, f)
	case *UnaryExpr:
		b, ok := inB.(*UnaryExpr)
		if !ok {
			return false
		}
		return EqualsRefOfUnaryExpr(a, b, f)
	case *Union:
		b, ok := inB.(*Union)
		if !ok {
			return false
		}
		return EqualsRefOfUnion(a, b, f)
	case *UnlockTables:
		b, ok := inB.(*UnlockTables)
		if !ok {
			return false
		}
		return EqualsRefOfUnlockTables(a, b, f)
	case *Update:
		b, ok := inB.(*Update)
		if !ok {
			return false
		}
		return EqualsRefOfUpdate(a, b, f)
	case *UpdateExpr:
		b, ok := inB.(*UpdateExpr)
		if !ok {
			return false
		}
		return EqualsRefOfUpdateExpr(a, b, f)
	case UpdateExprs:
		b, ok := inB.(UpdateExprs)
		if !ok {
			return false
		}
		return EqualsUpdateExprs(a, b, f)
	case *UpdateXMLExpr:
		b, ok := inB.(*UpdateXMLExpr)
		if !ok {
			return false
		}
		return EqualsRefOfUpdateXMLExpr(a, b, f)
	case *Use:
		b, ok := inB.(*Use)
		if !ok {
			return false
		}
		return EqualsRefOfUse(a, b, f)
	case *VStream:
		b, ok := inB.(*VStream)
		if !ok {
			return false
		}
		return EqualsRefOfVStream(a, b, f)
	case ValTuple:
		b, ok := inB.(ValTuple)
		if !ok {
			return false
		}
		return EqualsValTuple(a, b, f)
	case *Validation:
		b, ok := inB.(*Validation)
		if !ok {
			return false
		}
		return EqualsRefOfValidation(a, b, f)
	case Values:
		b, ok := inB.(Values)
		if !ok {
			return false
		}
		return EqualsValues(a, b, f)
	case *ValuesFuncExpr:
		b, ok := inB.(*ValuesFuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfValuesFuncExpr(a, b, f)
	case *VarPop:
		b, ok := inB.(*VarPop)
		if !ok {
			return false
		}
		return EqualsRefOfVarPop(a, b, f)
	case *VarSamp:
		b, ok := inB.(*VarSamp)
		if !ok {
			return false
		}
		return EqualsRefOfVarSamp(a, b, f)
	case *Variable:
		b, ok := inB.(*Variable)
		if !ok {
			return false
		}
		return EqualsRefOfVariable(a, b, f)
	case *Variance:
		b, ok := inB.(*Variance)
		if !ok {
			return false
		}
		return EqualsRefOfVariance(a, b, f)
	case VindexParam:
		b, ok := inB.(VindexParam)
		if !ok {
			return false
		}
		return EqualsVindexParam(a, b, f)
	case *VindexSpec:
		b, ok := inB.(*VindexSpec)
		if !ok {
			return false
		}
		return EqualsRefOfVindexSpec(a, b, f)
	case *WeightStringFuncExpr:
		b, ok := inB.(*WeightStringFuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfWeightStringFuncExpr(a, b, f)
	case *When:
		b, ok := inB.(*When)
		if !ok {
			return false
		}
		return EqualsRefOfWhen(a, b, f)
	case *Where:
		b, ok := inB.(*Where)
		if !ok {
			return false
		}
		return EqualsRefOfWhere(a, b, f)
	case *WindowDefinition:
		b, ok := inB.(*WindowDefinition)
		if !ok {
			return false
		}
		return EqualsRefOfWindowDefinition(a, b, f)
	case WindowDefinitions:
		b, ok := inB.(WindowDefinitions)
		if !ok {
			return false
		}
		return EqualsWindowDefinitions(a, b, f)
	case *WindowSpecification:
		b, ok := inB.(*WindowSpecification)
		if !ok {
			return false
		}
		return EqualsRefOfWindowSpecification(a, b, f)
	case *With:
		b, ok := inB.(*With)
		if !ok {
			return false
		}
		return EqualsRefOfWith(a, b, f)
	case *XorExpr:
		b, ok := inB.(*XorExpr)
		if !ok {
			return false
		}
		return EqualsRefOfXorExpr(a, b, f)
	default:
		// this should never happen
		return false
	}
}

// EqualsRefOfAddColumns does deep equals between the two objects.
func EqualsRefOfAddColumns(a, b *AddColumns, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.First == b.First &&
		EqualsSliceOfRefOfColumnDefinition(a.Columns, b.Columns, f) &&
		EqualsRefOfColName(a.After, b.After, f)
}

// EqualsRefOfAddConstraintDefinition does deep equals between the two objects.
func EqualsRefOfAddConstraintDefinition(a, b *AddConstraintDefinition, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsRefOfConstraintDefinition(a.ConstraintDefinition, b.ConstraintDefinition, f)
}

// EqualsRefOfAddIndexDefinition does deep equals between the two objects.
func EqualsRefOfAddIndexDefinition(a, b *AddIndexDefinition, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsRefOfIndexDefinition(a.IndexDefinition, b.IndexDefinition, f)
}

// EqualsRefOfAliasedExpr does deep equals between the two objects.
func EqualsRefOfAliasedExpr(a, b *AliasedExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Expr, b.Expr, f) &&
		EqualsIdentifierCI(a.As, b.As, f)
}

// EqualsRefOfAliasedTableExpr does deep equals between the two objects.
func EqualsRefOfAliasedTableExpr(a, b *AliasedTableExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsSimpleTableExpr(a.Expr, b.Expr, f) &&
		EqualsPartitions(a.Partitions, b.Partitions, f) &&
		EqualsIdentifierCS(a.As, b.As, f) &&
		EqualsIndexHints(a.Hints, b.Hints, f) &&
		EqualsColumns(a.Columns, b.Columns, f)
}

// EqualsRefOfAlterCharset does deep equals between the two objects.
func EqualsRefOfAlterCharset(a, b *AlterCharset, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.CharacterSet == b.CharacterSet &&
		a.Collate == b.Collate
}

// EqualsRefOfAlterCheck does deep equals between the two objects.
func EqualsRefOfAlterCheck(a, b *AlterCheck, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Enforced == b.Enforced &&
		EqualsIdentifierCI(a.Name, b.Name, f)
}

// EqualsRefOfAlterColumn does deep equals between the two objects.
func EqualsRefOfAlterColumn(a, b *AlterColumn, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.DropDefault == b.DropDefault &&
		EqualsRefOfColName(a.Column, b.Column, f) &&
		EqualsExpr(a.DefaultVal, b.DefaultVal, f) &&
		EqualsRefOfBool(a.Invisible, b.Invisible, f)
}

// EqualsRefOfAlterDatabase does deep equals between the two objects.
func EqualsRefOfAlterDatabase(a, b *AlterDatabase, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.UpdateDataDirectory == b.UpdateDataDirectory &&
		a.FullyParsed == b.FullyParsed &&
		EqualsIdentifierCS(a.DBName, b.DBName, f) &&
		EqualsSliceOfDatabaseOption(a.AlterOptions, b.AlterOptions, f)
}

// EqualsRefOfAlterIndex does deep equals between the two objects.
func EqualsRefOfAlterIndex(a, b *AlterIndex, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Invisible == b.Invisible &&
		EqualsIdentifierCI(a.Name, b.Name, f)
}

// EqualsRefOfAlterMigration does deep equals between the two objects.
func EqualsRefOfAlterMigration(a, b *AlterMigration, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.UUID == b.UUID &&
		a.Expire == b.Expire &&
		a.Shards == b.Shards &&
		a.Type == b.Type &&
		EqualsRefOfLiteral(a.Ratio, b.Ratio, f)
}

// EqualsRefOfAlterTable does deep equals between the two objects.
func EqualsRefOfAlterTable(a, b *AlterTable, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.FullyParsed == b.FullyParsed &&
		EqualsTableName(a.Table, b.Table, f) &&
		EqualsSliceOfAlterOption(a.AlterOptions, b.AlterOptions, f) &&
		EqualsRefOfPartitionSpec(a.PartitionSpec, b.PartitionSpec, f) &&
		EqualsRefOfPartitionOption(a.PartitionOption, b.PartitionOption, f) &&
		EqualsRefOfParsedComments(a.Comments, b.Comments, f)
}

// EqualsRefOfAlterView does deep equals between the two objects.
func EqualsRefOfAlterView(a, b *AlterView, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Algorithm == b.Algorithm &&
		a.Security == b.Security &&
		a.CheckOption == b.CheckOption &&
		EqualsTableName(a.ViewName, b.ViewName, f) &&
		EqualsRefOfDefiner(a.Definer, b.Definer, f) &&
		EqualsColumns(a.Columns, b.Columns, f) &&
		EqualsSelectStatement(a.Select, b.Select, f) &&
		EqualsRefOfParsedComments(a.Comments, b.Comments, f)
}

// EqualsRefOfAlterVschema does deep equals between the two objects.
func EqualsRefOfAlterVschema(a, b *AlterVschema, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Action == b.Action &&
		EqualsTableName(a.Table, b.Table, f) &&
		EqualsRefOfVindexSpec(a.VindexSpec, b.VindexSpec, f) &&
		EqualsSliceOfIdentifierCI(a.VindexCols, b.VindexCols, f) &&
		EqualsRefOfAutoIncSpec(a.AutoIncSpec, b.AutoIncSpec, f)
}

// EqualsRefOfAndExpr does deep equals between the two objects.
func EqualsRefOfAndExpr(a, b *AndExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Left, b.Left, f) &&
		EqualsExpr(a.Right, b.Right, f)
}

// EqualsRefOfArgumentLessWindowExpr does deep equals between the two objects.
func EqualsRefOfArgumentLessWindowExpr(a, b *ArgumentLessWindowExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		EqualsRefOfOverClause(a.OverClause, b.OverClause, f)
}

// EqualsRefOfAutoIncSpec does deep equals between the two objects.
func EqualsRefOfAutoIncSpec(a, b *AutoIncSpec, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsIdentifierCI(a.Column, b.Column, f) &&
		EqualsTableName(a.Sequence, b.Sequence, f)
}

// EqualsRefOfAvg does deep equals between the two objects.
func EqualsRefOfAvg(a, b *Avg, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Distinct == b.Distinct &&
		EqualsExpr(a.Arg, b.Arg, f)
}

// EqualsRefOfBegin does deep equals between the two objects.
func EqualsRefOfBegin(a, b *Begin, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsSliceOfTxAccessMode(a.TxAccessModes, b.TxAccessModes, f)
}

// EqualsRefOfBetweenExpr does deep equals between the two objects.
func EqualsRefOfBetweenExpr(a, b *BetweenExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.IsBetween == b.IsBetween &&
		EqualsExpr(a.Left, b.Left, f) &&
		EqualsExpr(a.From, b.From, f) &&
		EqualsExpr(a.To, b.To, f)
}

// EqualsRefOfBinaryExpr does deep equals between the two objects.
func EqualsRefOfBinaryExpr(a, b *BinaryExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Operator == b.Operator &&
		EqualsExpr(a.Left, b.Left, f) &&
		EqualsExpr(a.Right, b.Right, f)
}

// EqualsRefOfBitAnd does deep equals between the two objects.
func EqualsRefOfBitAnd(a, b *BitAnd, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Arg, b.Arg, f)
}

// EqualsRefOfBitOr does deep equals between the two objects.
func EqualsRefOfBitOr(a, b *BitOr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Arg, b.Arg, f)
}

// EqualsRefOfBitXor does deep equals between the two objects.
func EqualsRefOfBitXor(a, b *BitXor, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Arg, b.Arg, f)
}

// EqualsRefOfCallProc does deep equals between the two objects.
func EqualsRefOfCallProc(a, b *CallProc, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsTableName(a.Name, b.Name, f) &&
		EqualsExprs(a.Params, b.Params, f)
}

// EqualsRefOfCaseExpr does deep equals between the two objects.
func EqualsRefOfCaseExpr(a, b *CaseExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Expr, b.Expr, f) &&
		EqualsSliceOfRefOfWhen(a.Whens, b.Whens, f) &&
		EqualsExpr(a.Else, b.Else, f)
}

// EqualsRefOfCastExpr does deep equals between the two objects.
func EqualsRefOfCastExpr(a, b *CastExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Array == b.Array &&
		EqualsExpr(a.Expr, b.Expr, f) &&
		EqualsRefOfConvertType(a.Type, b.Type, f)
}

// EqualsRefOfChangeColumn does deep equals between the two objects.
func EqualsRefOfChangeColumn(a, b *ChangeColumn, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.First == b.First &&
		EqualsRefOfColName(a.OldColumn, b.OldColumn, f) &&
		EqualsRefOfColumnDefinition(a.NewColDefinition, b.NewColDefinition, f) &&
		EqualsRefOfColName(a.After, b.After, f)
}

// EqualsRefOfCharExpr does deep equals between the two objects.
func EqualsRefOfCharExpr(a, b *CharExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Charset == b.Charset &&
		EqualsExprs(a.Exprs, b.Exprs, f)
}

// EqualsRefOfCheckConstraintDefinition does deep equals between the two objects.
func EqualsRefOfCheckConstraintDefinition(a, b *CheckConstraintDefinition, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Enforced == b.Enforced &&
		EqualsExpr(a.Expr, b.Expr, f)
}

// EqualsRefOfColName does deep equals between the two objects.
func EqualsRefOfColName(a, b *ColName, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	if f != nil {
		return f.ColNames(a, b)
	}
	return EqualsIdentifierCI(a.Name, b.Name, f) &&
		EqualsTableName(a.Qualifier, b.Qualifier, f)
}

// EqualsRefOfCollateExpr does deep equals between the two objects.
func EqualsRefOfCollateExpr(a, b *CollateExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Collation == b.Collation &&
		EqualsExpr(a.Expr, b.Expr, f)
}

// EqualsRefOfColumnDefinition does deep equals between the two objects.
func EqualsRefOfColumnDefinition(a, b *ColumnDefinition, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsIdentifierCI(a.Name, b.Name, f) &&
		EqualsColumnType(a.Type, b.Type, f)
}

// EqualsRefOfColumnType does deep equals between the two objects.
func EqualsRefOfColumnType(a, b *ColumnType, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		a.Unsigned == b.Unsigned &&
		a.Zerofill == b.Zerofill &&
		EqualsRefOfColumnTypeOptions(a.Options, b.Options, f) &&
		EqualsRefOfLiteral(a.Length, b.Length, f) &&
		EqualsRefOfLiteral(a.Scale, b.Scale, f) &&
		EqualsColumnCharset(a.Charset, b.Charset, f) &&
		EqualsSliceOfString(a.EnumValues, b.EnumValues, f)
}

// EqualsColumns does deep equals between the two objects.
func EqualsColumns(a, b Columns, f ASTComparison) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsIdentifierCI(a[i], b[i], f) {
			return false
		}
	}
	return true
}

// EqualsRefOfCommentOnly does deep equals between the two objects.
func EqualsRefOfCommentOnly(a, b *CommentOnly, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsSliceOfString(a.Comments, b.Comments, f)
}

// EqualsRefOfCommit does deep equals between the two objects.
func EqualsRefOfCommit(a, b *Commit, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return true
}

// EqualsRefOfCommonTableExpr does deep equals between the two objects.
func EqualsRefOfCommonTableExpr(a, b *CommonTableExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsIdentifierCS(a.ID, b.ID, f) &&
		EqualsColumns(a.Columns, b.Columns, f) &&
		EqualsRefOfSubquery(a.Subquery, b.Subquery, f)
}

// EqualsRefOfComparisonExpr does deep equals between the two objects.
func EqualsRefOfComparisonExpr(a, b *ComparisonExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Operator == b.Operator &&
		EqualsExpr(a.Left, b.Left, f) &&
		EqualsExpr(a.Right, b.Right, f) &&
		EqualsExpr(a.Escape, b.Escape, f)
}

// EqualsRefOfConstraintDefinition does deep equals between the two objects.
func EqualsRefOfConstraintDefinition(a, b *ConstraintDefinition, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsIdentifierCI(a.Name, b.Name, f) &&
		EqualsConstraintInfo(a.Details, b.Details, f)
}

// EqualsRefOfConvertExpr does deep equals between the two objects.
func EqualsRefOfConvertExpr(a, b *ConvertExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Expr, b.Expr, f) &&
		EqualsRefOfConvertType(a.Type, b.Type, f)
}

// EqualsRefOfConvertType does deep equals between the two objects.
func EqualsRefOfConvertType(a, b *ConvertType, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		EqualsRefOfLiteral(a.Length, b.Length, f) &&
		EqualsRefOfLiteral(a.Scale, b.Scale, f) &&
		EqualsColumnCharset(a.Charset, b.Charset, f)
}

// EqualsRefOfConvertUsingExpr does deep equals between the two objects.
func EqualsRefOfConvertUsingExpr(a, b *ConvertUsingExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		EqualsExpr(a.Expr, b.Expr, f)
}

// EqualsRefOfCount does deep equals between the two objects.
func EqualsRefOfCount(a, b *Count, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Distinct == b.Distinct &&
		EqualsExprs(a.Args, b.Args, f)
}

// EqualsRefOfCountStar does deep equals between the two objects.
func EqualsRefOfCountStar(a, b *CountStar, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return true
}

// EqualsRefOfCreateDatabase does deep equals between the two objects.
func EqualsRefOfCreateDatabase(a, b *CreateDatabase, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.IfNotExists == b.IfNotExists &&
		a.FullyParsed == b.FullyParsed &&
		EqualsRefOfParsedComments(a.Comments, b.Comments, f) &&
		EqualsIdentifierCS(a.DBName, b.DBName, f) &&
		EqualsSliceOfDatabaseOption(a.CreateOptions, b.CreateOptions, f)
}

// EqualsRefOfCreateTable does deep equals between the two objects.
func EqualsRefOfCreateTable(a, b *CreateTable, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Temp == b.Temp &&
		a.IfNotExists == b.IfNotExists &&
		a.FullyParsed == b.FullyParsed &&
		EqualsTableName(a.Table, b.Table, f) &&
		EqualsRefOfTableSpec(a.TableSpec, b.TableSpec, f) &&
		EqualsRefOfOptLike(a.OptLike, b.OptLike, f) &&
		EqualsRefOfParsedComments(a.Comments, b.Comments, f)
}

// EqualsRefOfCreateView does deep equals between the two objects.
func EqualsRefOfCreateView(a, b *CreateView, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Algorithm == b.Algorithm &&
		a.Security == b.Security &&
		a.CheckOption == b.CheckOption &&
		a.IsReplace == b.IsReplace &&
		EqualsTableName(a.ViewName, b.ViewName, f) &&
		EqualsRefOfDefiner(a.Definer, b.Definer, f) &&
		EqualsColumns(a.Columns, b.Columns, f) &&
		EqualsSelectStatement(a.Select, b.Select, f) &&
		EqualsRefOfParsedComments(a.Comments, b.Comments, f)
}

// EqualsRefOfCurTimeFuncExpr does deep equals between the two objects.
func EqualsRefOfCurTimeFuncExpr(a, b *CurTimeFuncExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsIdentifierCI(a.Name, b.Name, f) &&
		EqualsExpr(a.Fsp, b.Fsp, f)
}

// EqualsRefOfDeallocateStmt does deep equals between the two objects.
func EqualsRefOfDeallocateStmt(a, b *DeallocateStmt, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		EqualsRefOfParsedComments(a.Comments, b.Comments, f) &&
		EqualsIdentifierCI(a.Name, b.Name, f)
}

// EqualsRefOfDefault does deep equals between the two objects.
func EqualsRefOfDefault(a, b *Default, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.ColName == b.ColName
}

// EqualsRefOfDefiner does deep equals between the two objects.
func EqualsRefOfDefiner(a, b *Definer, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Name == b.Name &&
		a.Address == b.Address
}

// EqualsRefOfDelete does deep equals between the two objects.
func EqualsRefOfDelete(a, b *Delete, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsRefOfWith(a.With, b.With, f) &&
		a.Ignore == b.Ignore &&
		EqualsRefOfParsedComments(a.Comments, b.Comments, f) &&
		EqualsTableNames(a.Targets, b.Targets, f) &&
		EqualsTableExprs(a.TableExprs, b.TableExprs, f) &&
		EqualsPartitions(a.Partitions, b.Partitions, f) &&
		EqualsRefOfWhere(a.Where, b.Where, f) &&
		EqualsOrderBy(a.OrderBy, b.OrderBy, f) &&
		EqualsRefOfLimit(a.Limit, b.Limit, f)
}

// EqualsRefOfDerivedTable does deep equals between the two objects.
func EqualsRefOfDerivedTable(a, b *DerivedTable, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Lateral == b.Lateral &&
		EqualsSelectStatement(a.Select, b.Select, f)
}

// EqualsRefOfDropColumn does deep equals between the two objects.
func EqualsRefOfDropColumn(a, b *DropColumn, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsRefOfColName(a.Name, b.Name, f)
}

// EqualsRefOfDropDatabase does deep equals between the two objects.
func EqualsRefOfDropDatabase(a, b *DropDatabase, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.IfExists == b.IfExists &&
		EqualsRefOfParsedComments(a.Comments, b.Comments, f) &&
		EqualsIdentifierCS(a.DBName, b.DBName, f)
}

// EqualsRefOfDropKey does deep equals between the two objects.
func EqualsRefOfDropKey(a, b *DropKey, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		EqualsIdentifierCI(a.Name, b.Name, f)
}

// EqualsRefOfDropTable does deep equals between the two objects.
func EqualsRefOfDropTable(a, b *DropTable, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Temp == b.Temp &&
		a.IfExists == b.IfExists &&
		EqualsTableNames(a.FromTables, b.FromTables, f) &&
		EqualsRefOfParsedComments(a.Comments, b.Comments, f)
}

// EqualsRefOfDropView does deep equals between the two objects.
func EqualsRefOfDropView(a, b *DropView, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.IfExists == b.IfExists &&
		EqualsTableNames(a.FromTables, b.FromTables, f) &&
		EqualsRefOfParsedComments(a.Comments, b.Comments, f)
}

// EqualsRefOfExecuteStmt does deep equals between the two objects.
func EqualsRefOfExecuteStmt(a, b *ExecuteStmt, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsIdentifierCI(a.Name, b.Name, f) &&
		EqualsRefOfParsedComments(a.Comments, b.Comments, f) &&
		EqualsSliceOfRefOfVariable(a.Arguments, b.Arguments, f)
}

// EqualsRefOfExistsExpr does deep equals between the two objects.
func EqualsRefOfExistsExpr(a, b *ExistsExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsRefOfSubquery(a.Subquery, b.Subquery, f)
}

// EqualsRefOfExplainStmt does deep equals between the two objects.
func EqualsRefOfExplainStmt(a, b *ExplainStmt, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		EqualsStatement(a.Statement, b.Statement, f) &&
		EqualsRefOfParsedComments(a.Comments, b.Comments, f)
}

// EqualsRefOfExplainTab does deep equals between the two objects.
func EqualsRefOfExplainTab(a, b *ExplainTab, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Wild == b.Wild &&
		EqualsTableName(a.Table, b.Table, f)
}

// EqualsExprs does deep equals between the two objects.
func EqualsExprs(a, b Exprs, f ASTComparison) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsExpr(a[i], b[i], f) {
			return false
		}
	}
	return true
}

// EqualsRefOfExtractFuncExpr does deep equals between the two objects.
func EqualsRefOfExtractFuncExpr(a, b *ExtractFuncExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.IntervalTypes == b.IntervalTypes &&
		EqualsExpr(a.Expr, b.Expr, f)
}

// EqualsRefOfExtractValueExpr does deep equals between the two objects.
func EqualsRefOfExtractValueExpr(a, b *ExtractValueExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Fragment, b.Fragment, f) &&
		EqualsExpr(a.XPathExpr, b.XPathExpr, f)
}

// EqualsRefOfExtractedSubquery does deep equals between the two objects.
func EqualsRefOfExtractedSubquery(a, b *ExtractedSubquery, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.OpCode == b.OpCode &&
		a.NeedsRewrite == b.NeedsRewrite &&
		a.hasValuesArg == b.hasValuesArg &&
		a.argName == b.argName &&
		EqualsExpr(a.Original, b.Original, f) &&
		EqualsRefOfSubquery(a.Subquery, b.Subquery, f) &&
		EqualsExpr(a.OtherSide, b.OtherSide, f) &&
		EqualsExpr(a.alternative, b.alternative, f)
}

// EqualsRefOfFirstOrLastValueExpr does deep equals between the two objects.
func EqualsRefOfFirstOrLastValueExpr(a, b *FirstOrLastValueExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		EqualsExpr(a.Expr, b.Expr, f) &&
		EqualsRefOfNullTreatmentClause(a.NullTreatmentClause, b.NullTreatmentClause, f) &&
		EqualsRefOfOverClause(a.OverClause, b.OverClause, f)
}

// EqualsRefOfFlush does deep equals between the two objects.
func EqualsRefOfFlush(a, b *Flush, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.IsLocal == b.IsLocal &&
		a.WithLock == b.WithLock &&
		a.ForExport == b.ForExport &&
		EqualsSliceOfString(a.FlushOptions, b.FlushOptions, f) &&
		EqualsTableNames(a.TableNames, b.TableNames, f)
}

// EqualsRefOfForce does deep equals between the two objects.
func EqualsRefOfForce(a, b *Force, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return true
}

// EqualsRefOfForeignKeyDefinition does deep equals between the two objects.
func EqualsRefOfForeignKeyDefinition(a, b *ForeignKeyDefinition, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsColumns(a.Source, b.Source, f) &&
		EqualsIdentifierCI(a.IndexName, b.IndexName, f) &&
		EqualsRefOfReferenceDefinition(a.ReferenceDefinition, b.ReferenceDefinition, f)
}

// EqualsRefOfFrameClause does deep equals between the two objects.
func EqualsRefOfFrameClause(a, b *FrameClause, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Unit == b.Unit &&
		EqualsRefOfFramePoint(a.Start, b.Start, f) &&
		EqualsRefOfFramePoint(a.End, b.End, f)
}

// EqualsRefOfFramePoint does deep equals between the two objects.
func EqualsRefOfFramePoint(a, b *FramePoint, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		EqualsExpr(a.Expr, b.Expr, f)
}

// EqualsRefOfFromFirstLastClause does deep equals between the two objects.
func EqualsRefOfFromFirstLastClause(a, b *FromFirstLastClause, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type
}

// EqualsRefOfFuncExpr does deep equals between the two objects.
func EqualsRefOfFuncExpr(a, b *FuncExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsIdentifierCS(a.Qualifier, b.Qualifier, f) &&
		EqualsIdentifierCI(a.Name, b.Name, f) &&
		EqualsSelectExprs(a.Exprs, b.Exprs, f)
}

// EqualsRefOfGTIDFuncExpr does deep equals between the two objects.
func EqualsRefOfGTIDFuncExpr(a, b *GTIDFuncExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		EqualsExpr(a.Set1, b.Set1, f) &&
		EqualsExpr(a.Set2, b.Set2, f) &&
		EqualsExpr(a.Timeout, b.Timeout, f) &&
		EqualsExpr(a.Channel, b.Channel, f)
}

// EqualsGroupBy does deep equals between the two objects.
func EqualsGroupBy(a, b GroupBy, f ASTComparison) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsExpr(a[i], b[i], f) {
			return false
		}
	}
	return true
}

// EqualsRefOfGroupConcatExpr does deep equals between the two objects.
func EqualsRefOfGroupConcatExpr(a, b *GroupConcatExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Distinct == b.Distinct &&
		a.Separator == b.Separator &&
		EqualsExprs(a.Exprs, b.Exprs, f) &&
		EqualsOrderBy(a.OrderBy, b.OrderBy, f) &&
		EqualsRefOfLimit(a.Limit, b.Limit, f)
}

// EqualsIdentifierCI does deep equals between the two objects.
func EqualsIdentifierCI(a, b IdentifierCI, f ASTComparison) bool {
	return a.val == b.val &&
		a.lowered == b.lowered
}

// EqualsIdentifierCS does deep equals between the two objects.
func EqualsIdentifierCS(a, b IdentifierCS, f ASTComparison) bool {
	return a.v == b.v
}

// EqualsRefOfIndexDefinition does deep equals between the two objects.
func EqualsRefOfIndexDefinition(a, b *IndexDefinition, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsRefOfIndexInfo(a.Info, b.Info, f) &&
		EqualsSliceOfRefOfIndexColumn(a.Columns, b.Columns, f) &&
		EqualsSliceOfRefOfIndexOption(a.Options, b.Options, f)
}

// EqualsRefOfIndexHint does deep equals between the two objects.
func EqualsRefOfIndexHint(a, b *IndexHint, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		a.ForType == b.ForType &&
		EqualsSliceOfIdentifierCI(a.Indexes, b.Indexes, f)
}

// EqualsIndexHints does deep equals between the two objects.
func EqualsIndexHints(a, b IndexHints, f ASTComparison) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsRefOfIndexHint(a[i], b[i], f) {
			return false
		}
	}
	return true
}

// EqualsRefOfIndexInfo does deep equals between the two objects.
func EqualsRefOfIndexInfo(a, b *IndexInfo, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		a.Primary == b.Primary &&
		a.Spatial == b.Spatial &&
		a.Fulltext == b.Fulltext &&
		a.Unique == b.Unique &&
		EqualsIdentifierCI(a.Name, b.Name, f) &&
		EqualsIdentifierCI(a.ConstraintName, b.ConstraintName, f)
}

// EqualsRefOfInsert does deep equals between the two objects.
func EqualsRefOfInsert(a, b *Insert, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Action == b.Action &&
		EqualsRefOfParsedComments(a.Comments, b.Comments, f) &&
		a.Ignore == b.Ignore &&
		EqualsTableName(a.Table, b.Table, f) &&
		EqualsPartitions(a.Partitions, b.Partitions, f) &&
		EqualsColumns(a.Columns, b.Columns, f) &&
		EqualsInsertRows(a.Rows, b.Rows, f) &&
		EqualsOnDup(a.OnDup, b.OnDup, f)
}

// EqualsRefOfInsertExpr does deep equals between the two objects.
func EqualsRefOfInsertExpr(a, b *InsertExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Str, b.Str, f) &&
		EqualsExpr(a.Pos, b.Pos, f) &&
		EqualsExpr(a.Len, b.Len, f) &&
		EqualsExpr(a.NewStr, b.NewStr, f)
}

// EqualsRefOfIntervalExpr does deep equals between the two objects.
func EqualsRefOfIntervalExpr(a, b *IntervalExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Unit == b.Unit &&
		EqualsExpr(a.Expr, b.Expr, f)
}

// EqualsRefOfIntervalFuncExpr does deep equals between the two objects.
func EqualsRefOfIntervalFuncExpr(a, b *IntervalFuncExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Expr, b.Expr, f) &&
		EqualsExprs(a.Exprs, b.Exprs, f)
}

// EqualsRefOfIntroducerExpr does deep equals between the two objects.
func EqualsRefOfIntroducerExpr(a, b *IntroducerExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.CharacterSet == b.CharacterSet &&
		EqualsExpr(a.Expr, b.Expr, f)
}

// EqualsRefOfIsExpr does deep equals between the two objects.
func EqualsRefOfIsExpr(a, b *IsExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Left, b.Left, f) &&
		a.Right == b.Right
}

// EqualsRefOfJSONArrayExpr does deep equals between the two objects.
func EqualsRefOfJSONArrayExpr(a, b *JSONArrayExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExprs(a.Params, b.Params, f)
}

// EqualsRefOfJSONAttributesExpr does deep equals between the two objects.
func EqualsRefOfJSONAttributesExpr(a, b *JSONAttributesExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		EqualsExpr(a.JSONDoc, b.JSONDoc, f) &&
		EqualsExpr(a.Path, b.Path, f)
}

// EqualsRefOfJSONContainsExpr does deep equals between the two objects.
func EqualsRefOfJSONContainsExpr(a, b *JSONContainsExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Target, b.Target, f) &&
		EqualsExpr(a.Candidate, b.Candidate, f) &&
		EqualsSliceOfExpr(a.PathList, b.PathList, f)
}

// EqualsRefOfJSONContainsPathExpr does deep equals between the two objects.
func EqualsRefOfJSONContainsPathExpr(a, b *JSONContainsPathExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.JSONDoc, b.JSONDoc, f) &&
		EqualsExpr(a.OneOrAll, b.OneOrAll, f) &&
		EqualsSliceOfExpr(a.PathList, b.PathList, f)
}

// EqualsRefOfJSONExtractExpr does deep equals between the two objects.
func EqualsRefOfJSONExtractExpr(a, b *JSONExtractExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.JSONDoc, b.JSONDoc, f) &&
		EqualsSliceOfExpr(a.PathList, b.PathList, f)
}

// EqualsRefOfJSONKeysExpr does deep equals between the two objects.
func EqualsRefOfJSONKeysExpr(a, b *JSONKeysExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.JSONDoc, b.JSONDoc, f) &&
		EqualsExpr(a.Path, b.Path, f)
}

// EqualsRefOfJSONObjectExpr does deep equals between the two objects.
func EqualsRefOfJSONObjectExpr(a, b *JSONObjectExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsSliceOfRefOfJSONObjectParam(a.Params, b.Params, f)
}

// EqualsJSONObjectParam does deep equals between the two objects.
func EqualsJSONObjectParam(a, b JSONObjectParam, f ASTComparison) bool {
	return EqualsExpr(a.Key, b.Key, f) &&
		EqualsExpr(a.Value, b.Value, f)
}

// EqualsRefOfJSONOverlapsExpr does deep equals between the two objects.
func EqualsRefOfJSONOverlapsExpr(a, b *JSONOverlapsExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.JSONDoc1, b.JSONDoc1, f) &&
		EqualsExpr(a.JSONDoc2, b.JSONDoc2, f)
}

// EqualsRefOfJSONPrettyExpr does deep equals between the two objects.
func EqualsRefOfJSONPrettyExpr(a, b *JSONPrettyExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.JSONVal, b.JSONVal, f)
}

// EqualsRefOfJSONQuoteExpr does deep equals between the two objects.
func EqualsRefOfJSONQuoteExpr(a, b *JSONQuoteExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.StringArg, b.StringArg, f)
}

// EqualsRefOfJSONRemoveExpr does deep equals between the two objects.
func EqualsRefOfJSONRemoveExpr(a, b *JSONRemoveExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.JSONDoc, b.JSONDoc, f) &&
		EqualsExprs(a.PathList, b.PathList, f)
}

// EqualsRefOfJSONSchemaValidFuncExpr does deep equals between the two objects.
func EqualsRefOfJSONSchemaValidFuncExpr(a, b *JSONSchemaValidFuncExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Schema, b.Schema, f) &&
		EqualsExpr(a.Document, b.Document, f)
}

// EqualsRefOfJSONSchemaValidationReportFuncExpr does deep equals between the two objects.
func EqualsRefOfJSONSchemaValidationReportFuncExpr(a, b *JSONSchemaValidationReportFuncExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Schema, b.Schema, f) &&
		EqualsExpr(a.Document, b.Document, f)
}

// EqualsRefOfJSONSearchExpr does deep equals between the two objects.
func EqualsRefOfJSONSearchExpr(a, b *JSONSearchExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.JSONDoc, b.JSONDoc, f) &&
		EqualsExpr(a.OneOrAll, b.OneOrAll, f) &&
		EqualsExpr(a.SearchStr, b.SearchStr, f) &&
		EqualsExpr(a.EscapeChar, b.EscapeChar, f) &&
		EqualsSliceOfExpr(a.PathList, b.PathList, f)
}

// EqualsRefOfJSONStorageFreeExpr does deep equals between the two objects.
func EqualsRefOfJSONStorageFreeExpr(a, b *JSONStorageFreeExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.JSONVal, b.JSONVal, f)
}

// EqualsRefOfJSONStorageSizeExpr does deep equals between the two objects.
func EqualsRefOfJSONStorageSizeExpr(a, b *JSONStorageSizeExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.JSONVal, b.JSONVal, f)
}

// EqualsRefOfJSONTableExpr does deep equals between the two objects.
func EqualsRefOfJSONTableExpr(a, b *JSONTableExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Expr, b.Expr, f) &&
		EqualsIdentifierCS(a.Alias, b.Alias, f) &&
		EqualsExpr(a.Filter, b.Filter, f) &&
		EqualsSliceOfRefOfJtColumnDefinition(a.Columns, b.Columns, f)
}

// EqualsRefOfJSONUnquoteExpr does deep equals between the two objects.
func EqualsRefOfJSONUnquoteExpr(a, b *JSONUnquoteExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.JSONValue, b.JSONValue, f)
}

// EqualsRefOfJSONValueExpr does deep equals between the two objects.
func EqualsRefOfJSONValueExpr(a, b *JSONValueExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.JSONDoc, b.JSONDoc, f) &&
		EqualsExpr(a.Path, b.Path, f) &&
		EqualsRefOfConvertType(a.ReturningType, b.ReturningType, f) &&
		EqualsRefOfJtOnResponse(a.EmptyOnResponse, b.EmptyOnResponse, f) &&
		EqualsRefOfJtOnResponse(a.ErrorOnResponse, b.ErrorOnResponse, f)
}

// EqualsRefOfJSONValueMergeExpr does deep equals between the two objects.
func EqualsRefOfJSONValueMergeExpr(a, b *JSONValueMergeExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		EqualsExpr(a.JSONDoc, b.JSONDoc, f) &&
		EqualsExprs(a.JSONDocList, b.JSONDocList, f)
}

// EqualsRefOfJSONValueModifierExpr does deep equals between the two objects.
func EqualsRefOfJSONValueModifierExpr(a, b *JSONValueModifierExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		EqualsExpr(a.JSONDoc, b.JSONDoc, f) &&
		EqualsSliceOfRefOfJSONObjectParam(a.Params, b.Params, f)
}

// EqualsRefOfJoinCondition does deep equals between the two objects.
func EqualsRefOfJoinCondition(a, b *JoinCondition, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.On, b.On, f) &&
		EqualsColumns(a.Using, b.Using, f)
}

// EqualsRefOfJoinTableExpr does deep equals between the two objects.
func EqualsRefOfJoinTableExpr(a, b *JoinTableExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsTableExpr(a.LeftExpr, b.LeftExpr, f) &&
		a.Join == b.Join &&
		EqualsTableExpr(a.RightExpr, b.RightExpr, f) &&
		EqualsRefOfJoinCondition(a.Condition, b.Condition, f)
}

// EqualsRefOfJtColumnDefinition does deep equals between the two objects.
func EqualsRefOfJtColumnDefinition(a, b *JtColumnDefinition, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsRefOfJtOrdinalColDef(a.JtOrdinal, b.JtOrdinal, f) &&
		EqualsRefOfJtPathColDef(a.JtPath, b.JtPath, f) &&
		EqualsRefOfJtNestedPathColDef(a.JtNestedPath, b.JtNestedPath, f)
}

// EqualsRefOfJtOnResponse does deep equals between the two objects.
func EqualsRefOfJtOnResponse(a, b *JtOnResponse, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.ResponseType == b.ResponseType &&
		EqualsExpr(a.Expr, b.Expr, f)
}

// EqualsRefOfKeyState does deep equals between the two objects.
func EqualsRefOfKeyState(a, b *KeyState, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Enable == b.Enable
}

// EqualsRefOfLagLeadExpr does deep equals between the two objects.
func EqualsRefOfLagLeadExpr(a, b *LagLeadExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		EqualsExpr(a.Expr, b.Expr, f) &&
		EqualsExpr(a.N, b.N, f) &&
		EqualsExpr(a.Default, b.Default, f) &&
		EqualsRefOfOverClause(a.OverClause, b.OverClause, f) &&
		EqualsRefOfNullTreatmentClause(a.NullTreatmentClause, b.NullTreatmentClause, f)
}

// EqualsRefOfLimit does deep equals between the two objects.
func EqualsRefOfLimit(a, b *Limit, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Offset, b.Offset, f) &&
		EqualsExpr(a.Rowcount, b.Rowcount, f)
}

// EqualsRefOfLiteral does deep equals between the two objects.
func EqualsRefOfLiteral(a, b *Literal, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Val == b.Val &&
		a.Type == b.Type
}

// EqualsRefOfLoad does deep equals between the two objects.
func EqualsRefOfLoad(a, b *Load, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return true
}

// EqualsRefOfLocateExpr does deep equals between the two objects.
func EqualsRefOfLocateExpr(a, b *LocateExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.SubStr, b.SubStr, f) &&
		EqualsExpr(a.Str, b.Str, f) &&
		EqualsExpr(a.Pos, b.Pos, f)
}

// EqualsRefOfLockOption does deep equals between the two objects.
func EqualsRefOfLockOption(a, b *LockOption, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type
}

// EqualsRefOfLockTables does deep equals between the two objects.
func EqualsRefOfLockTables(a, b *LockTables, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsTableAndLockTypes(a.Tables, b.Tables, f)
}

// EqualsRefOfLockingFunc does deep equals between the two objects.
func EqualsRefOfLockingFunc(a, b *LockingFunc, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		EqualsExpr(a.Name, b.Name, f) &&
		EqualsExpr(a.Timeout, b.Timeout, f)
}

// EqualsRefOfMatchExpr does deep equals between the two objects.
func EqualsRefOfMatchExpr(a, b *MatchExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsSliceOfRefOfColName(a.Columns, b.Columns, f) &&
		EqualsExpr(a.Expr, b.Expr, f) &&
		a.Option == b.Option
}

// EqualsRefOfMax does deep equals between the two objects.
func EqualsRefOfMax(a, b *Max, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Distinct == b.Distinct &&
		EqualsExpr(a.Arg, b.Arg, f)
}

// EqualsRefOfMemberOfExpr does deep equals between the two objects.
func EqualsRefOfMemberOfExpr(a, b *MemberOfExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Value, b.Value, f) &&
		EqualsExpr(a.JSONArr, b.JSONArr, f)
}

// EqualsRefOfMin does deep equals between the two objects.
func EqualsRefOfMin(a, b *Min, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Distinct == b.Distinct &&
		EqualsExpr(a.Arg, b.Arg, f)
}

// EqualsRefOfModifyColumn does deep equals between the two objects.
func EqualsRefOfModifyColumn(a, b *ModifyColumn, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.First == b.First &&
		EqualsRefOfColumnDefinition(a.NewColDefinition, b.NewColDefinition, f) &&
		EqualsRefOfColName(a.After, b.After, f)
}

// EqualsRefOfNTHValueExpr does deep equals between the two objects.
func EqualsRefOfNTHValueExpr(a, b *NTHValueExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Expr, b.Expr, f) &&
		EqualsExpr(a.N, b.N, f) &&
		EqualsRefOfOverClause(a.OverClause, b.OverClause, f) &&
		EqualsRefOfFromFirstLastClause(a.FromFirstLastClause, b.FromFirstLastClause, f) &&
		EqualsRefOfNullTreatmentClause(a.NullTreatmentClause, b.NullTreatmentClause, f)
}

// EqualsRefOfNamedWindow does deep equals between the two objects.
func EqualsRefOfNamedWindow(a, b *NamedWindow, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsWindowDefinitions(a.Windows, b.Windows, f)
}

// EqualsNamedWindows does deep equals between the two objects.
func EqualsNamedWindows(a, b NamedWindows, f ASTComparison) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsRefOfNamedWindow(a[i], b[i], f) {
			return false
		}
	}
	return true
}

// EqualsRefOfNextval does deep equals between the two objects.
func EqualsRefOfNextval(a, b *Nextval, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Expr, b.Expr, f)
}

// EqualsRefOfNotExpr does deep equals between the two objects.
func EqualsRefOfNotExpr(a, b *NotExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Expr, b.Expr, f)
}

// EqualsRefOfNtileExpr does deep equals between the two objects.
func EqualsRefOfNtileExpr(a, b *NtileExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.N, b.N, f) &&
		EqualsRefOfOverClause(a.OverClause, b.OverClause, f)
}

// EqualsRefOfNullTreatmentClause does deep equals between the two objects.
func EqualsRefOfNullTreatmentClause(a, b *NullTreatmentClause, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type
}

// EqualsRefOfNullVal does deep equals between the two objects.
func EqualsRefOfNullVal(a, b *NullVal, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return true
}

// EqualsRefOfOffset does deep equals between the two objects.
func EqualsRefOfOffset(a, b *Offset, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.V == b.V &&
		a.Original == b.Original
}

// EqualsOnDup does deep equals between the two objects.
func EqualsOnDup(a, b OnDup, f ASTComparison) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsRefOfUpdateExpr(a[i], b[i], f) {
			return false
		}
	}
	return true
}

// EqualsRefOfOptLike does deep equals between the two objects.
func EqualsRefOfOptLike(a, b *OptLike, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsTableName(a.LikeTable, b.LikeTable, f)
}

// EqualsRefOfOrExpr does deep equals between the two objects.
func EqualsRefOfOrExpr(a, b *OrExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Left, b.Left, f) &&
		EqualsExpr(a.Right, b.Right, f)
}

// EqualsRefOfOrder does deep equals between the two objects.
func EqualsRefOfOrder(a, b *Order, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Expr, b.Expr, f) &&
		a.Direction == b.Direction
}

// EqualsOrderBy does deep equals between the two objects.
func EqualsOrderBy(a, b OrderBy, f ASTComparison) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsRefOfOrder(a[i], b[i], f) {
			return false
		}
	}
	return true
}

// EqualsRefOfOrderByOption does deep equals between the two objects.
func EqualsRefOfOrderByOption(a, b *OrderByOption, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsColumns(a.Cols, b.Cols, f)
}

// EqualsRefOfOtherAdmin does deep equals between the two objects.
func EqualsRefOfOtherAdmin(a, b *OtherAdmin, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return true
}

// EqualsRefOfOtherRead does deep equals between the two objects.
func EqualsRefOfOtherRead(a, b *OtherRead, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return true
}

// EqualsRefOfOverClause does deep equals between the two objects.
func EqualsRefOfOverClause(a, b *OverClause, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsIdentifierCI(a.WindowName, b.WindowName, f) &&
		EqualsRefOfWindowSpecification(a.WindowSpec, b.WindowSpec, f)
}

// EqualsRefOfParenTableExpr does deep equals between the two objects.
func EqualsRefOfParenTableExpr(a, b *ParenTableExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsTableExprs(a.Exprs, b.Exprs, f)
}

// EqualsRefOfParsedComments does deep equals between the two objects.
func EqualsRefOfParsedComments(a, b *ParsedComments, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsComments(a.comments, b.comments, f)
}

// EqualsRefOfPartitionDefinition does deep equals between the two objects.
func EqualsRefOfPartitionDefinition(a, b *PartitionDefinition, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsIdentifierCI(a.Name, b.Name, f) &&
		EqualsRefOfPartitionDefinitionOptions(a.Options, b.Options, f)
}

// EqualsRefOfPartitionDefinitionOptions does deep equals between the two objects.
func EqualsRefOfPartitionDefinitionOptions(a, b *PartitionDefinitionOptions, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.TableSpace == b.TableSpace &&
		EqualsRefOfPartitionValueRange(a.ValueRange, b.ValueRange, f) &&
		EqualsRefOfLiteral(a.Comment, b.Comment, f) &&
		EqualsRefOfPartitionEngine(a.Engine, b.Engine, f) &&
		EqualsRefOfLiteral(a.DataDirectory, b.DataDirectory, f) &&
		EqualsRefOfLiteral(a.IndexDirectory, b.IndexDirectory, f) &&
		EqualsRefOfInt(a.MaxRows, b.MaxRows, f) &&
		EqualsRefOfInt(a.MinRows, b.MinRows, f) &&
		EqualsSubPartitionDefinitions(a.SubPartitionDefinitions, b.SubPartitionDefinitions, f)
}

// EqualsRefOfPartitionEngine does deep equals between the two objects.
func EqualsRefOfPartitionEngine(a, b *PartitionEngine, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Storage == b.Storage &&
		a.Name == b.Name
}

// EqualsRefOfPartitionOption does deep equals between the two objects.
func EqualsRefOfPartitionOption(a, b *PartitionOption, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.IsLinear == b.IsLinear &&
		a.KeyAlgorithm == b.KeyAlgorithm &&
		a.Partitions == b.Partitions &&
		a.Type == b.Type &&
		EqualsColumns(a.ColList, b.ColList, f) &&
		EqualsExpr(a.Expr, b.Expr, f) &&
		EqualsRefOfSubPartition(a.SubPartition, b.SubPartition, f) &&
		EqualsSliceOfRefOfPartitionDefinition(a.Definitions, b.Definitions, f)
}

// EqualsRefOfPartitionSpec does deep equals between the two objects.
func EqualsRefOfPartitionSpec(a, b *PartitionSpec, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.IsAll == b.IsAll &&
		a.WithoutValidation == b.WithoutValidation &&
		a.Action == b.Action &&
		EqualsPartitions(a.Names, b.Names, f) &&
		EqualsRefOfLiteral(a.Number, b.Number, f) &&
		EqualsTableName(a.TableName, b.TableName, f) &&
		EqualsSliceOfRefOfPartitionDefinition(a.Definitions, b.Definitions, f)
}

// EqualsRefOfPartitionValueRange does deep equals between the two objects.
func EqualsRefOfPartitionValueRange(a, b *PartitionValueRange, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Maxvalue == b.Maxvalue &&
		a.Type == b.Type &&
		EqualsValTuple(a.Range, b.Range, f)
}

// EqualsPartitions does deep equals between the two objects.
func EqualsPartitions(a, b Partitions, f ASTComparison) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsIdentifierCI(a[i], b[i], f) {
			return false
		}
	}
	return true
}

// EqualsRefOfPerformanceSchemaFuncExpr does deep equals between the two objects.
func EqualsRefOfPerformanceSchemaFuncExpr(a, b *PerformanceSchemaFuncExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		EqualsExpr(a.Argument, b.Argument, f)
}

// EqualsRefOfPrepareStmt does deep equals between the two objects.
func EqualsRefOfPrepareStmt(a, b *PrepareStmt, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsIdentifierCI(a.Name, b.Name, f) &&
		EqualsExpr(a.Statement, b.Statement, f) &&
		EqualsRefOfParsedComments(a.Comments, b.Comments, f)
}

// EqualsRefOfReferenceDefinition does deep equals between the two objects.
func EqualsRefOfReferenceDefinition(a, b *ReferenceDefinition, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsTableName(a.ReferencedTable, b.ReferencedTable, f) &&
		EqualsColumns(a.ReferencedColumns, b.ReferencedColumns, f) &&
		a.Match == b.Match &&
		a.OnDelete == b.OnDelete &&
		a.OnUpdate == b.OnUpdate
}

// EqualsRefOfRegexpInstrExpr does deep equals between the two objects.
func EqualsRefOfRegexpInstrExpr(a, b *RegexpInstrExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Expr, b.Expr, f) &&
		EqualsExpr(a.Pattern, b.Pattern, f) &&
		EqualsExpr(a.Position, b.Position, f) &&
		EqualsExpr(a.Occurrence, b.Occurrence, f) &&
		EqualsExpr(a.ReturnOption, b.ReturnOption, f) &&
		EqualsExpr(a.MatchType, b.MatchType, f)
}

// EqualsRefOfRegexpLikeExpr does deep equals between the two objects.
func EqualsRefOfRegexpLikeExpr(a, b *RegexpLikeExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Expr, b.Expr, f) &&
		EqualsExpr(a.Pattern, b.Pattern, f) &&
		EqualsExpr(a.MatchType, b.MatchType, f)
}

// EqualsRefOfRegexpReplaceExpr does deep equals between the two objects.
func EqualsRefOfRegexpReplaceExpr(a, b *RegexpReplaceExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Expr, b.Expr, f) &&
		EqualsExpr(a.Pattern, b.Pattern, f) &&
		EqualsExpr(a.Repl, b.Repl, f) &&
		EqualsExpr(a.Occurrence, b.Occurrence, f) &&
		EqualsExpr(a.Position, b.Position, f) &&
		EqualsExpr(a.MatchType, b.MatchType, f)
}

// EqualsRefOfRegexpSubstrExpr does deep equals between the two objects.
func EqualsRefOfRegexpSubstrExpr(a, b *RegexpSubstrExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Expr, b.Expr, f) &&
		EqualsExpr(a.Pattern, b.Pattern, f) &&
		EqualsExpr(a.Occurrence, b.Occurrence, f) &&
		EqualsExpr(a.Position, b.Position, f) &&
		EqualsExpr(a.MatchType, b.MatchType, f)
}

// EqualsRefOfRelease does deep equals between the two objects.
func EqualsRefOfRelease(a, b *Release, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsIdentifierCI(a.Name, b.Name, f)
}

// EqualsRefOfRenameColumn does deep equals between the two objects.
func EqualsRefOfRenameColumn(a, b *RenameColumn, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsRefOfColName(a.OldName, b.OldName, f) &&
		EqualsRefOfColName(a.NewName, b.NewName, f)
}

// EqualsRefOfRenameIndex does deep equals between the two objects.
func EqualsRefOfRenameIndex(a, b *RenameIndex, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsIdentifierCI(a.OldName, b.OldName, f) &&
		EqualsIdentifierCI(a.NewName, b.NewName, f)
}

// EqualsRefOfRenameTable does deep equals between the two objects.
func EqualsRefOfRenameTable(a, b *RenameTable, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsSliceOfRefOfRenameTablePair(a.TablePairs, b.TablePairs, f)
}

// EqualsRefOfRenameTableName does deep equals between the two objects.
func EqualsRefOfRenameTableName(a, b *RenameTableName, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsTableName(a.Table, b.Table, f)
}

// EqualsRefOfRevertMigration does deep equals between the two objects.
func EqualsRefOfRevertMigration(a, b *RevertMigration, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.UUID == b.UUID &&
		EqualsRefOfParsedComments(a.Comments, b.Comments, f)
}

// EqualsRefOfRollback does deep equals between the two objects.
func EqualsRefOfRollback(a, b *Rollback, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return true
}

// EqualsRootNode does deep equals between the two objects.
func EqualsRootNode(a, b RootNode, f ASTComparison) bool {
	return EqualsSQLNode(a.SQLNode, b.SQLNode, f)
}

// EqualsRefOfSRollback does deep equals between the two objects.
func EqualsRefOfSRollback(a, b *SRollback, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsIdentifierCI(a.Name, b.Name, f)
}

// EqualsRefOfSavepoint does deep equals between the two objects.
func EqualsRefOfSavepoint(a, b *Savepoint, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsIdentifierCI(a.Name, b.Name, f)
}

// EqualsRefOfSelect does deep equals between the two objects.
func EqualsRefOfSelect(a, b *Select, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Distinct == b.Distinct &&
		a.StraightJoinHint == b.StraightJoinHint &&
		a.SQLCalcFoundRows == b.SQLCalcFoundRows &&
		EqualsRefOfBool(a.Cache, b.Cache, f) &&
		EqualsSliceOfTableExpr(a.From, b.From, f) &&
		EqualsRefOfParsedComments(a.Comments, b.Comments, f) &&
		EqualsSelectExprs(a.SelectExprs, b.SelectExprs, f) &&
		EqualsRefOfWhere(a.Where, b.Where, f) &&
		EqualsRefOfWith(a.With, b.With, f) &&
		EqualsGroupBy(a.GroupBy, b.GroupBy, f) &&
		EqualsRefOfWhere(a.Having, b.Having, f) &&
		EqualsNamedWindows(a.Windows, b.Windows, f) &&
		EqualsOrderBy(a.OrderBy, b.OrderBy, f) &&
		EqualsRefOfLimit(a.Limit, b.Limit, f) &&
		a.Lock == b.Lock &&
		EqualsRefOfSelectInto(a.Into, b.Into, f)
}

// EqualsSelectExprs does deep equals between the two objects.
func EqualsSelectExprs(a, b SelectExprs, f ASTComparison) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsSelectExpr(a[i], b[i], f) {
			return false
		}
	}
	return true
}

// EqualsRefOfSelectInto does deep equals between the two objects.
func EqualsRefOfSelectInto(a, b *SelectInto, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.FileName == b.FileName &&
		a.FormatOption == b.FormatOption &&
		a.ExportOption == b.ExportOption &&
		a.Manifest == b.Manifest &&
		a.Overwrite == b.Overwrite &&
		a.Type == b.Type &&
		EqualsColumnCharset(a.Charset, b.Charset, f)
}

// EqualsRefOfSet does deep equals between the two objects.
func EqualsRefOfSet(a, b *Set, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsRefOfParsedComments(a.Comments, b.Comments, f) &&
		EqualsSetExprs(a.Exprs, b.Exprs, f)
}

// EqualsRefOfSetExpr does deep equals between the two objects.
func EqualsRefOfSetExpr(a, b *SetExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsRefOfVariable(a.Var, b.Var, f) &&
		EqualsExpr(a.Expr, b.Expr, f)
}

// EqualsSetExprs does deep equals between the two objects.
func EqualsSetExprs(a, b SetExprs, f ASTComparison) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsRefOfSetExpr(a[i], b[i], f) {
			return false
		}
	}
	return true
}

// EqualsRefOfShow does deep equals between the two objects.
func EqualsRefOfShow(a, b *Show, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsShowInternal(a.Internal, b.Internal, f)
}

// EqualsRefOfShowBasic does deep equals between the two objects.
func EqualsRefOfShowBasic(a, b *ShowBasic, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Full == b.Full &&
		a.Command == b.Command &&
		EqualsTableName(a.Tbl, b.Tbl, f) &&
		EqualsIdentifierCS(a.DbName, b.DbName, f) &&
		EqualsRefOfShowFilter(a.Filter, b.Filter, f)
}

// EqualsRefOfShowCreate does deep equals between the two objects.
func EqualsRefOfShowCreate(a, b *ShowCreate, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Command == b.Command &&
		EqualsTableName(a.Op, b.Op, f)
}

// EqualsRefOfShowFilter does deep equals between the two objects.
func EqualsRefOfShowFilter(a, b *ShowFilter, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Like == b.Like &&
		EqualsExpr(a.Filter, b.Filter, f)
}

// EqualsRefOfShowMigrationLogs does deep equals between the two objects.
func EqualsRefOfShowMigrationLogs(a, b *ShowMigrationLogs, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.UUID == b.UUID &&
		EqualsRefOfParsedComments(a.Comments, b.Comments, f)
}

// EqualsRefOfShowOther does deep equals between the two objects.
func EqualsRefOfShowOther(a, b *ShowOther, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Command == b.Command
}

// EqualsRefOfShowThrottledApps does deep equals between the two objects.
func EqualsRefOfShowThrottledApps(a, b *ShowThrottledApps, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsComments(a.Comments, b.Comments, f)
}

// EqualsRefOfShowThrottlerStatus does deep equals between the two objects.
func EqualsRefOfShowThrottlerStatus(a, b *ShowThrottlerStatus, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsComments(a.Comments, b.Comments, f)
}

// EqualsRefOfStarExpr does deep equals between the two objects.
func EqualsRefOfStarExpr(a, b *StarExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsTableName(a.TableName, b.TableName, f)
}

// EqualsRefOfStd does deep equals between the two objects.
func EqualsRefOfStd(a, b *Std, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Arg, b.Arg, f)
}

// EqualsRefOfStdDev does deep equals between the two objects.
func EqualsRefOfStdDev(a, b *StdDev, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Arg, b.Arg, f)
}

// EqualsRefOfStdPop does deep equals between the two objects.
func EqualsRefOfStdPop(a, b *StdPop, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Arg, b.Arg, f)
}

// EqualsRefOfStdSamp does deep equals between the two objects.
func EqualsRefOfStdSamp(a, b *StdSamp, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Arg, b.Arg, f)
}

// EqualsRefOfStream does deep equals between the two objects.
func EqualsRefOfStream(a, b *Stream, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsRefOfParsedComments(a.Comments, b.Comments, f) &&
		EqualsSelectExpr(a.SelectExpr, b.SelectExpr, f) &&
		EqualsTableName(a.Table, b.Table, f)
}

// EqualsRefOfSubPartition does deep equals between the two objects.
func EqualsRefOfSubPartition(a, b *SubPartition, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.IsLinear == b.IsLinear &&
		a.KeyAlgorithm == b.KeyAlgorithm &&
		a.SubPartitions == b.SubPartitions &&
		a.Type == b.Type &&
		EqualsColumns(a.ColList, b.ColList, f) &&
		EqualsExpr(a.Expr, b.Expr, f)
}

// EqualsRefOfSubPartitionDefinition does deep equals between the two objects.
func EqualsRefOfSubPartitionDefinition(a, b *SubPartitionDefinition, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsIdentifierCI(a.Name, b.Name, f) &&
		EqualsRefOfSubPartitionDefinitionOptions(a.Options, b.Options, f)
}

// EqualsRefOfSubPartitionDefinitionOptions does deep equals between the two objects.
func EqualsRefOfSubPartitionDefinitionOptions(a, b *SubPartitionDefinitionOptions, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.TableSpace == b.TableSpace &&
		EqualsRefOfLiteral(a.Comment, b.Comment, f) &&
		EqualsRefOfPartitionEngine(a.Engine, b.Engine, f) &&
		EqualsRefOfLiteral(a.DataDirectory, b.DataDirectory, f) &&
		EqualsRefOfLiteral(a.IndexDirectory, b.IndexDirectory, f) &&
		EqualsRefOfInt(a.MaxRows, b.MaxRows, f) &&
		EqualsRefOfInt(a.MinRows, b.MinRows, f)
}

// EqualsSubPartitionDefinitions does deep equals between the two objects.
func EqualsSubPartitionDefinitions(a, b SubPartitionDefinitions, f ASTComparison) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsRefOfSubPartitionDefinition(a[i], b[i], f) {
			return false
		}
	}
	return true
}

// EqualsRefOfSubquery does deep equals between the two objects.
func EqualsRefOfSubquery(a, b *Subquery, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsSelectStatement(a.Select, b.Select, f)
}

// EqualsRefOfSubstrExpr does deep equals between the two objects.
func EqualsRefOfSubstrExpr(a, b *SubstrExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Name, b.Name, f) &&
		EqualsExpr(a.From, b.From, f) &&
		EqualsExpr(a.To, b.To, f)
}

// EqualsRefOfSum does deep equals between the two objects.
func EqualsRefOfSum(a, b *Sum, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Distinct == b.Distinct &&
		EqualsExpr(a.Arg, b.Arg, f)
}

// EqualsTableExprs does deep equals between the two objects.
func EqualsTableExprs(a, b TableExprs, f ASTComparison) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsTableExpr(a[i], b[i], f) {
			return false
		}
	}
	return true
}

// EqualsTableName does deep equals between the two objects.
func EqualsTableName(a, b TableName, f ASTComparison) bool {
	return EqualsIdentifierCS(a.Name, b.Name, f) &&
		EqualsIdentifierCS(a.Qualifier, b.Qualifier, f)
}

// EqualsTableNames does deep equals between the two objects.
func EqualsTableNames(a, b TableNames, f ASTComparison) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsTableName(a[i], b[i], f) {
			return false
		}
	}
	return true
}

// EqualsTableOptions does deep equals between the two objects.
func EqualsTableOptions(a, b TableOptions, f ASTComparison) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsRefOfTableOption(a[i], b[i], f) {
			return false
		}
	}
	return true
}

// EqualsRefOfTableSpec does deep equals between the two objects.
func EqualsRefOfTableSpec(a, b *TableSpec, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsSliceOfRefOfColumnDefinition(a.Columns, b.Columns, f) &&
		EqualsSliceOfRefOfIndexDefinition(a.Indexes, b.Indexes, f) &&
		EqualsSliceOfRefOfConstraintDefinition(a.Constraints, b.Constraints, f) &&
		EqualsTableOptions(a.Options, b.Options, f) &&
		EqualsRefOfPartitionOption(a.PartitionOption, b.PartitionOption, f)
}

// EqualsRefOfTablespaceOperation does deep equals between the two objects.
func EqualsRefOfTablespaceOperation(a, b *TablespaceOperation, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Import == b.Import
}

// EqualsRefOfTimestampFuncExpr does deep equals between the two objects.
func EqualsRefOfTimestampFuncExpr(a, b *TimestampFuncExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Name == b.Name &&
		a.Unit == b.Unit &&
		EqualsExpr(a.Expr1, b.Expr1, f) &&
		EqualsExpr(a.Expr2, b.Expr2, f)
}

// EqualsRefOfTrimFuncExpr does deep equals between the two objects.
func EqualsRefOfTrimFuncExpr(a, b *TrimFuncExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.TrimFuncType == b.TrimFuncType &&
		a.Type == b.Type &&
		EqualsExpr(a.TrimArg, b.TrimArg, f) &&
		EqualsExpr(a.StringArg, b.StringArg, f)
}

// EqualsRefOfTruncateTable does deep equals between the two objects.
func EqualsRefOfTruncateTable(a, b *TruncateTable, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsTableName(a.Table, b.Table, f)
}

// EqualsRefOfUnaryExpr does deep equals between the two objects.
func EqualsRefOfUnaryExpr(a, b *UnaryExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Operator == b.Operator &&
		EqualsExpr(a.Expr, b.Expr, f)
}

// EqualsRefOfUnion does deep equals between the two objects.
func EqualsRefOfUnion(a, b *Union, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Distinct == b.Distinct &&
		EqualsSelectStatement(a.Left, b.Left, f) &&
		EqualsSelectStatement(a.Right, b.Right, f) &&
		EqualsOrderBy(a.OrderBy, b.OrderBy, f) &&
		EqualsRefOfWith(a.With, b.With, f) &&
		EqualsRefOfLimit(a.Limit, b.Limit, f) &&
		a.Lock == b.Lock &&
		EqualsRefOfSelectInto(a.Into, b.Into, f)
}

// EqualsRefOfUnlockTables does deep equals between the two objects.
func EqualsRefOfUnlockTables(a, b *UnlockTables, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return true
}

// EqualsRefOfUpdate does deep equals between the two objects.
func EqualsRefOfUpdate(a, b *Update, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsRefOfWith(a.With, b.With, f) &&
		EqualsRefOfParsedComments(a.Comments, b.Comments, f) &&
		a.Ignore == b.Ignore &&
		EqualsTableExprs(a.TableExprs, b.TableExprs, f) &&
		EqualsUpdateExprs(a.Exprs, b.Exprs, f) &&
		EqualsRefOfWhere(a.Where, b.Where, f) &&
		EqualsOrderBy(a.OrderBy, b.OrderBy, f) &&
		EqualsRefOfLimit(a.Limit, b.Limit, f)
}

// EqualsRefOfUpdateExpr does deep equals between the two objects.
func EqualsRefOfUpdateExpr(a, b *UpdateExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsRefOfColName(a.Name, b.Name, f) &&
		EqualsExpr(a.Expr, b.Expr, f)
}

// EqualsUpdateExprs does deep equals between the two objects.
func EqualsUpdateExprs(a, b UpdateExprs, f ASTComparison) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsRefOfUpdateExpr(a[i], b[i], f) {
			return false
		}
	}
	return true
}

// EqualsRefOfUpdateXMLExpr does deep equals between the two objects.
func EqualsRefOfUpdateXMLExpr(a, b *UpdateXMLExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Target, b.Target, f) &&
		EqualsExpr(a.XPathExpr, b.XPathExpr, f) &&
		EqualsExpr(a.NewXML, b.NewXML, f)
}

// EqualsRefOfUse does deep equals between the two objects.
func EqualsRefOfUse(a, b *Use, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsIdentifierCS(a.DBName, b.DBName, f)
}

// EqualsRefOfVStream does deep equals between the two objects.
func EqualsRefOfVStream(a, b *VStream, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsRefOfParsedComments(a.Comments, b.Comments, f) &&
		EqualsSelectExpr(a.SelectExpr, b.SelectExpr, f) &&
		EqualsTableName(a.Table, b.Table, f) &&
		EqualsRefOfWhere(a.Where, b.Where, f) &&
		EqualsRefOfLimit(a.Limit, b.Limit, f)
}

// EqualsValTuple does deep equals between the two objects.
func EqualsValTuple(a, b ValTuple, f ASTComparison) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsExpr(a[i], b[i], f) {
			return false
		}
	}
	return true
}

// EqualsRefOfValidation does deep equals between the two objects.
func EqualsRefOfValidation(a, b *Validation, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.With == b.With
}

// EqualsValues does deep equals between the two objects.
func EqualsValues(a, b Values, f ASTComparison) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsValTuple(a[i], b[i], f) {
			return false
		}
	}
	return true
}

// EqualsRefOfValuesFuncExpr does deep equals between the two objects.
func EqualsRefOfValuesFuncExpr(a, b *ValuesFuncExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsRefOfColName(a.Name, b.Name, f)
}

// EqualsRefOfVarPop does deep equals between the two objects.
func EqualsRefOfVarPop(a, b *VarPop, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Arg, b.Arg, f)
}

// EqualsRefOfVarSamp does deep equals between the two objects.
func EqualsRefOfVarSamp(a, b *VarSamp, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Arg, b.Arg, f)
}

// EqualsRefOfVariable does deep equals between the two objects.
func EqualsRefOfVariable(a, b *Variable, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Scope == b.Scope &&
		EqualsIdentifierCI(a.Name, b.Name, f)
}

// EqualsRefOfVariance does deep equals between the two objects.
func EqualsRefOfVariance(a, b *Variance, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Arg, b.Arg, f)
}

// EqualsVindexParam does deep equals between the two objects.
func EqualsVindexParam(a, b VindexParam, f ASTComparison) bool {
	return a.Val == b.Val &&
		EqualsIdentifierCI(a.Key, b.Key, f)
}

// EqualsRefOfVindexSpec does deep equals between the two objects.
func EqualsRefOfVindexSpec(a, b *VindexSpec, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsIdentifierCI(a.Name, b.Name, f) &&
		EqualsIdentifierCI(a.Type, b.Type, f) &&
		EqualsSliceOfVindexParam(a.Params, b.Params, f)
}

// EqualsRefOfWeightStringFuncExpr does deep equals between the two objects.
func EqualsRefOfWeightStringFuncExpr(a, b *WeightStringFuncExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Expr, b.Expr, f) &&
		EqualsRefOfConvertType(a.As, b.As, f)
}

// EqualsRefOfWhen does deep equals between the two objects.
func EqualsRefOfWhen(a, b *When, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Cond, b.Cond, f) &&
		EqualsExpr(a.Val, b.Val, f)
}

// EqualsRefOfWhere does deep equals between the two objects.
func EqualsRefOfWhere(a, b *Where, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		EqualsExpr(a.Expr, b.Expr, f)
}

// EqualsRefOfWindowDefinition does deep equals between the two objects.
func EqualsRefOfWindowDefinition(a, b *WindowDefinition, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsIdentifierCI(a.Name, b.Name, f) &&
		EqualsRefOfWindowSpecification(a.WindowSpec, b.WindowSpec, f)
}

// EqualsWindowDefinitions does deep equals between the two objects.
func EqualsWindowDefinitions(a, b WindowDefinitions, f ASTComparison) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsRefOfWindowDefinition(a[i], b[i], f) {
			return false
		}
	}
	return true
}

// EqualsRefOfWindowSpecification does deep equals between the two objects.
func EqualsRefOfWindowSpecification(a, b *WindowSpecification, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsIdentifierCI(a.Name, b.Name, f) &&
		EqualsExprs(a.PartitionClause, b.PartitionClause, f) &&
		EqualsOrderBy(a.OrderClause, b.OrderClause, f) &&
		EqualsRefOfFrameClause(a.FrameClause, b.FrameClause, f)
}

// EqualsRefOfWith does deep equals between the two objects.
func EqualsRefOfWith(a, b *With, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Recursive == b.Recursive &&
		EqualsSliceOfRefOfCommonTableExpr(a.ctes, b.ctes, f)
}

// EqualsRefOfXorExpr does deep equals between the two objects.
func EqualsRefOfXorExpr(a, b *XorExpr, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Left, b.Left, f) &&
		EqualsExpr(a.Right, b.Right, f)
}

// EqualsAggrFunc does deep equals between the two objects.
func EqualsAggrFunc(inA, inB AggrFunc, f ASTComparison) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *Avg:
		b, ok := inB.(*Avg)
		if !ok {
			return false
		}
		return EqualsRefOfAvg(a, b, f)
	case *BitAnd:
		b, ok := inB.(*BitAnd)
		if !ok {
			return false
		}
		return EqualsRefOfBitAnd(a, b, f)
	case *BitOr:
		b, ok := inB.(*BitOr)
		if !ok {
			return false
		}
		return EqualsRefOfBitOr(a, b, f)
	case *BitXor:
		b, ok := inB.(*BitXor)
		if !ok {
			return false
		}
		return EqualsRefOfBitXor(a, b, f)
	case *Count:
		b, ok := inB.(*Count)
		if !ok {
			return false
		}
		return EqualsRefOfCount(a, b, f)
	case *CountStar:
		b, ok := inB.(*CountStar)
		if !ok {
			return false
		}
		return EqualsRefOfCountStar(a, b, f)
	case *GroupConcatExpr:
		b, ok := inB.(*GroupConcatExpr)
		if !ok {
			return false
		}
		return EqualsRefOfGroupConcatExpr(a, b, f)
	case *Max:
		b, ok := inB.(*Max)
		if !ok {
			return false
		}
		return EqualsRefOfMax(a, b, f)
	case *Min:
		b, ok := inB.(*Min)
		if !ok {
			return false
		}
		return EqualsRefOfMin(a, b, f)
	case *Std:
		b, ok := inB.(*Std)
		if !ok {
			return false
		}
		return EqualsRefOfStd(a, b, f)
	case *StdDev:
		b, ok := inB.(*StdDev)
		if !ok {
			return false
		}
		return EqualsRefOfStdDev(a, b, f)
	case *StdPop:
		b, ok := inB.(*StdPop)
		if !ok {
			return false
		}
		return EqualsRefOfStdPop(a, b, f)
	case *StdSamp:
		b, ok := inB.(*StdSamp)
		if !ok {
			return false
		}
		return EqualsRefOfStdSamp(a, b, f)
	case *Sum:
		b, ok := inB.(*Sum)
		if !ok {
			return false
		}
		return EqualsRefOfSum(a, b, f)
	case *VarPop:
		b, ok := inB.(*VarPop)
		if !ok {
			return false
		}
		return EqualsRefOfVarPop(a, b, f)
	case *VarSamp:
		b, ok := inB.(*VarSamp)
		if !ok {
			return false
		}
		return EqualsRefOfVarSamp(a, b, f)
	case *Variance:
		b, ok := inB.(*Variance)
		if !ok {
			return false
		}
		return EqualsRefOfVariance(a, b, f)
	default:
		// this should never happen
		return false
	}
}

// EqualsAlterOption does deep equals between the two objects.
func EqualsAlterOption(inA, inB AlterOption, f ASTComparison) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *AddColumns:
		b, ok := inB.(*AddColumns)
		if !ok {
			return false
		}
		return EqualsRefOfAddColumns(a, b, f)
	case *AddConstraintDefinition:
		b, ok := inB.(*AddConstraintDefinition)
		if !ok {
			return false
		}
		return EqualsRefOfAddConstraintDefinition(a, b, f)
	case *AddIndexDefinition:
		b, ok := inB.(*AddIndexDefinition)
		if !ok {
			return false
		}
		return EqualsRefOfAddIndexDefinition(a, b, f)
	case AlgorithmValue:
		b, ok := inB.(AlgorithmValue)
		if !ok {
			return false
		}
		return a == b
	case *AlterCharset:
		b, ok := inB.(*AlterCharset)
		if !ok {
			return false
		}
		return EqualsRefOfAlterCharset(a, b, f)
	case *AlterCheck:
		b, ok := inB.(*AlterCheck)
		if !ok {
			return false
		}
		return EqualsRefOfAlterCheck(a, b, f)
	case *AlterColumn:
		b, ok := inB.(*AlterColumn)
		if !ok {
			return false
		}
		return EqualsRefOfAlterColumn(a, b, f)
	case *AlterIndex:
		b, ok := inB.(*AlterIndex)
		if !ok {
			return false
		}
		return EqualsRefOfAlterIndex(a, b, f)
	case *ChangeColumn:
		b, ok := inB.(*ChangeColumn)
		if !ok {
			return false
		}
		return EqualsRefOfChangeColumn(a, b, f)
	case *DropColumn:
		b, ok := inB.(*DropColumn)
		if !ok {
			return false
		}
		return EqualsRefOfDropColumn(a, b, f)
	case *DropKey:
		b, ok := inB.(*DropKey)
		if !ok {
			return false
		}
		return EqualsRefOfDropKey(a, b, f)
	case *Force:
		b, ok := inB.(*Force)
		if !ok {
			return false
		}
		return EqualsRefOfForce(a, b, f)
	case *KeyState:
		b, ok := inB.(*KeyState)
		if !ok {
			return false
		}
		return EqualsRefOfKeyState(a, b, f)
	case *LockOption:
		b, ok := inB.(*LockOption)
		if !ok {
			return false
		}
		return EqualsRefOfLockOption(a, b, f)
	case *ModifyColumn:
		b, ok := inB.(*ModifyColumn)
		if !ok {
			return false
		}
		return EqualsRefOfModifyColumn(a, b, f)
	case *OrderByOption:
		b, ok := inB.(*OrderByOption)
		if !ok {
			return false
		}
		return EqualsRefOfOrderByOption(a, b, f)
	case *RenameColumn:
		b, ok := inB.(*RenameColumn)
		if !ok {
			return false
		}
		return EqualsRefOfRenameColumn(a, b, f)
	case *RenameIndex:
		b, ok := inB.(*RenameIndex)
		if !ok {
			return false
		}
		return EqualsRefOfRenameIndex(a, b, f)
	case *RenameTableName:
		b, ok := inB.(*RenameTableName)
		if !ok {
			return false
		}
		return EqualsRefOfRenameTableName(a, b, f)
	case TableOptions:
		b, ok := inB.(TableOptions)
		if !ok {
			return false
		}
		return EqualsTableOptions(a, b, f)
	case *TablespaceOperation:
		b, ok := inB.(*TablespaceOperation)
		if !ok {
			return false
		}
		return EqualsRefOfTablespaceOperation(a, b, f)
	case *Validation:
		b, ok := inB.(*Validation)
		if !ok {
			return false
		}
		return EqualsRefOfValidation(a, b, f)
	default:
		// this should never happen
		return false
	}
}

// EqualsCallable does deep equals between the two objects.
func EqualsCallable(inA, inB Callable, f ASTComparison) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *ArgumentLessWindowExpr:
		b, ok := inB.(*ArgumentLessWindowExpr)
		if !ok {
			return false
		}
		return EqualsRefOfArgumentLessWindowExpr(a, b, f)
	case *Avg:
		b, ok := inB.(*Avg)
		if !ok {
			return false
		}
		return EqualsRefOfAvg(a, b, f)
	case *CharExpr:
		b, ok := inB.(*CharExpr)
		if !ok {
			return false
		}
		return EqualsRefOfCharExpr(a, b, f)
	case *ConvertExpr:
		b, ok := inB.(*ConvertExpr)
		if !ok {
			return false
		}
		return EqualsRefOfConvertExpr(a, b, f)
	case *ConvertUsingExpr:
		b, ok := inB.(*ConvertUsingExpr)
		if !ok {
			return false
		}
		return EqualsRefOfConvertUsingExpr(a, b, f)
	case *Count:
		b, ok := inB.(*Count)
		if !ok {
			return false
		}
		return EqualsRefOfCount(a, b, f)
	case *CountStar:
		b, ok := inB.(*CountStar)
		if !ok {
			return false
		}
		return EqualsRefOfCountStar(a, b, f)
	case *CurTimeFuncExpr:
		b, ok := inB.(*CurTimeFuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfCurTimeFuncExpr(a, b, f)
	case *ExtractFuncExpr:
		b, ok := inB.(*ExtractFuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfExtractFuncExpr(a, b, f)
	case *ExtractValueExpr:
		b, ok := inB.(*ExtractValueExpr)
		if !ok {
			return false
		}
		return EqualsRefOfExtractValueExpr(a, b, f)
	case *FirstOrLastValueExpr:
		b, ok := inB.(*FirstOrLastValueExpr)
		if !ok {
			return false
		}
		return EqualsRefOfFirstOrLastValueExpr(a, b, f)
	case *FuncExpr:
		b, ok := inB.(*FuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfFuncExpr(a, b, f)
	case *GTIDFuncExpr:
		b, ok := inB.(*GTIDFuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfGTIDFuncExpr(a, b, f)
	case *GroupConcatExpr:
		b, ok := inB.(*GroupConcatExpr)
		if !ok {
			return false
		}
		return EqualsRefOfGroupConcatExpr(a, b, f)
	case *InsertExpr:
		b, ok := inB.(*InsertExpr)
		if !ok {
			return false
		}
		return EqualsRefOfInsertExpr(a, b, f)
	case *IntervalFuncExpr:
		b, ok := inB.(*IntervalFuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfIntervalFuncExpr(a, b, f)
	case *JSONArrayExpr:
		b, ok := inB.(*JSONArrayExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONArrayExpr(a, b, f)
	case *JSONAttributesExpr:
		b, ok := inB.(*JSONAttributesExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONAttributesExpr(a, b, f)
	case *JSONContainsExpr:
		b, ok := inB.(*JSONContainsExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONContainsExpr(a, b, f)
	case *JSONContainsPathExpr:
		b, ok := inB.(*JSONContainsPathExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONContainsPathExpr(a, b, f)
	case *JSONExtractExpr:
		b, ok := inB.(*JSONExtractExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONExtractExpr(a, b, f)
	case *JSONKeysExpr:
		b, ok := inB.(*JSONKeysExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONKeysExpr(a, b, f)
	case *JSONObjectExpr:
		b, ok := inB.(*JSONObjectExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONObjectExpr(a, b, f)
	case *JSONOverlapsExpr:
		b, ok := inB.(*JSONOverlapsExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONOverlapsExpr(a, b, f)
	case *JSONPrettyExpr:
		b, ok := inB.(*JSONPrettyExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONPrettyExpr(a, b, f)
	case *JSONQuoteExpr:
		b, ok := inB.(*JSONQuoteExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONQuoteExpr(a, b, f)
	case *JSONRemoveExpr:
		b, ok := inB.(*JSONRemoveExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONRemoveExpr(a, b, f)
	case *JSONSchemaValidFuncExpr:
		b, ok := inB.(*JSONSchemaValidFuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONSchemaValidFuncExpr(a, b, f)
	case *JSONSchemaValidationReportFuncExpr:
		b, ok := inB.(*JSONSchemaValidationReportFuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONSchemaValidationReportFuncExpr(a, b, f)
	case *JSONSearchExpr:
		b, ok := inB.(*JSONSearchExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONSearchExpr(a, b, f)
	case *JSONStorageFreeExpr:
		b, ok := inB.(*JSONStorageFreeExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONStorageFreeExpr(a, b, f)
	case *JSONStorageSizeExpr:
		b, ok := inB.(*JSONStorageSizeExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONStorageSizeExpr(a, b, f)
	case *JSONUnquoteExpr:
		b, ok := inB.(*JSONUnquoteExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONUnquoteExpr(a, b, f)
	case *JSONValueExpr:
		b, ok := inB.(*JSONValueExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONValueExpr(a, b, f)
	case *JSONValueMergeExpr:
		b, ok := inB.(*JSONValueMergeExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONValueMergeExpr(a, b, f)
	case *JSONValueModifierExpr:
		b, ok := inB.(*JSONValueModifierExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONValueModifierExpr(a, b, f)
	case *LagLeadExpr:
		b, ok := inB.(*LagLeadExpr)
		if !ok {
			return false
		}
		return EqualsRefOfLagLeadExpr(a, b, f)
	case *LocateExpr:
		b, ok := inB.(*LocateExpr)
		if !ok {
			return false
		}
		return EqualsRefOfLocateExpr(a, b, f)
	case *MatchExpr:
		b, ok := inB.(*MatchExpr)
		if !ok {
			return false
		}
		return EqualsRefOfMatchExpr(a, b, f)
	case *Max:
		b, ok := inB.(*Max)
		if !ok {
			return false
		}
		return EqualsRefOfMax(a, b, f)
	case *MemberOfExpr:
		b, ok := inB.(*MemberOfExpr)
		if !ok {
			return false
		}
		return EqualsRefOfMemberOfExpr(a, b, f)
	case *Min:
		b, ok := inB.(*Min)
		if !ok {
			return false
		}
		return EqualsRefOfMin(a, b, f)
	case *NTHValueExpr:
		b, ok := inB.(*NTHValueExpr)
		if !ok {
			return false
		}
		return EqualsRefOfNTHValueExpr(a, b, f)
	case *NamedWindow:
		b, ok := inB.(*NamedWindow)
		if !ok {
			return false
		}
		return EqualsRefOfNamedWindow(a, b, f)
	case *NtileExpr:
		b, ok := inB.(*NtileExpr)
		if !ok {
			return false
		}
		return EqualsRefOfNtileExpr(a, b, f)
	case *PerformanceSchemaFuncExpr:
		b, ok := inB.(*PerformanceSchemaFuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfPerformanceSchemaFuncExpr(a, b, f)
	case *RegexpInstrExpr:
		b, ok := inB.(*RegexpInstrExpr)
		if !ok {
			return false
		}
		return EqualsRefOfRegexpInstrExpr(a, b, f)
	case *RegexpLikeExpr:
		b, ok := inB.(*RegexpLikeExpr)
		if !ok {
			return false
		}
		return EqualsRefOfRegexpLikeExpr(a, b, f)
	case *RegexpReplaceExpr:
		b, ok := inB.(*RegexpReplaceExpr)
		if !ok {
			return false
		}
		return EqualsRefOfRegexpReplaceExpr(a, b, f)
	case *RegexpSubstrExpr:
		b, ok := inB.(*RegexpSubstrExpr)
		if !ok {
			return false
		}
		return EqualsRefOfRegexpSubstrExpr(a, b, f)
	case *SubstrExpr:
		b, ok := inB.(*SubstrExpr)
		if !ok {
			return false
		}
		return EqualsRefOfSubstrExpr(a, b, f)
	case *Sum:
		b, ok := inB.(*Sum)
		if !ok {
			return false
		}
		return EqualsRefOfSum(a, b, f)
	case *TimestampFuncExpr:
		b, ok := inB.(*TimestampFuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfTimestampFuncExpr(a, b, f)
	case *TrimFuncExpr:
		b, ok := inB.(*TrimFuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfTrimFuncExpr(a, b, f)
	case *UpdateXMLExpr:
		b, ok := inB.(*UpdateXMLExpr)
		if !ok {
			return false
		}
		return EqualsRefOfUpdateXMLExpr(a, b, f)
	case *ValuesFuncExpr:
		b, ok := inB.(*ValuesFuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfValuesFuncExpr(a, b, f)
	case *WeightStringFuncExpr:
		b, ok := inB.(*WeightStringFuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfWeightStringFuncExpr(a, b, f)
	default:
		// this should never happen
		return false
	}
}

// EqualsColTuple does deep equals between the two objects.
func EqualsColTuple(inA, inB ColTuple, f ASTComparison) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case ListArg:
		b, ok := inB.(ListArg)
		if !ok {
			return false
		}
		return a == b
	case *Subquery:
		b, ok := inB.(*Subquery)
		if !ok {
			return false
		}
		return EqualsRefOfSubquery(a, b, f)
	case ValTuple:
		b, ok := inB.(ValTuple)
		if !ok {
			return false
		}
		return EqualsValTuple(a, b, f)
	default:
		// this should never happen
		return false
	}
}

// EqualsConstraintInfo does deep equals between the two objects.
func EqualsConstraintInfo(inA, inB ConstraintInfo, f ASTComparison) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *CheckConstraintDefinition:
		b, ok := inB.(*CheckConstraintDefinition)
		if !ok {
			return false
		}
		return EqualsRefOfCheckConstraintDefinition(a, b, f)
	case *ForeignKeyDefinition:
		b, ok := inB.(*ForeignKeyDefinition)
		if !ok {
			return false
		}
		return EqualsRefOfForeignKeyDefinition(a, b, f)
	default:
		// this should never happen
		return false
	}
}

// EqualsDBDDLStatement does deep equals between the two objects.
func EqualsDBDDLStatement(inA, inB DBDDLStatement, f ASTComparison) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *AlterDatabase:
		b, ok := inB.(*AlterDatabase)
		if !ok {
			return false
		}
		return EqualsRefOfAlterDatabase(a, b, f)
	case *CreateDatabase:
		b, ok := inB.(*CreateDatabase)
		if !ok {
			return false
		}
		return EqualsRefOfCreateDatabase(a, b, f)
	case *DropDatabase:
		b, ok := inB.(*DropDatabase)
		if !ok {
			return false
		}
		return EqualsRefOfDropDatabase(a, b, f)
	default:
		// this should never happen
		return false
	}
}

// EqualsDDLStatement does deep equals between the two objects.
func EqualsDDLStatement(inA, inB DDLStatement, f ASTComparison) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *AlterTable:
		b, ok := inB.(*AlterTable)
		if !ok {
			return false
		}
		return EqualsRefOfAlterTable(a, b, f)
	case *AlterView:
		b, ok := inB.(*AlterView)
		if !ok {
			return false
		}
		return EqualsRefOfAlterView(a, b, f)
	case *CreateTable:
		b, ok := inB.(*CreateTable)
		if !ok {
			return false
		}
		return EqualsRefOfCreateTable(a, b, f)
	case *CreateView:
		b, ok := inB.(*CreateView)
		if !ok {
			return false
		}
		return EqualsRefOfCreateView(a, b, f)
	case *DropTable:
		b, ok := inB.(*DropTable)
		if !ok {
			return false
		}
		return EqualsRefOfDropTable(a, b, f)
	case *DropView:
		b, ok := inB.(*DropView)
		if !ok {
			return false
		}
		return EqualsRefOfDropView(a, b, f)
	case *RenameTable:
		b, ok := inB.(*RenameTable)
		if !ok {
			return false
		}
		return EqualsRefOfRenameTable(a, b, f)
	case *TruncateTable:
		b, ok := inB.(*TruncateTable)
		if !ok {
			return false
		}
		return EqualsRefOfTruncateTable(a, b, f)
	default:
		// this should never happen
		return false
	}
}

// EqualsExplain does deep equals between the two objects.
func EqualsExplain(inA, inB Explain, f ASTComparison) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *ExplainStmt:
		b, ok := inB.(*ExplainStmt)
		if !ok {
			return false
		}
		return EqualsRefOfExplainStmt(a, b, f)
	case *ExplainTab:
		b, ok := inB.(*ExplainTab)
		if !ok {
			return false
		}
		return EqualsRefOfExplainTab(a, b, f)
	default:
		// this should never happen
		return false
	}
}

// EqualsExpr does deep equals between the two objects.
func EqualsExpr(inA, inB Expr, f ASTComparison) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *AndExpr:
		b, ok := inB.(*AndExpr)
		if !ok {
			return false
		}
		return EqualsRefOfAndExpr(a, b, f)
	case Argument:
		b, ok := inB.(Argument)
		if !ok {
			return false
		}
		return a == b
	case *ArgumentLessWindowExpr:
		b, ok := inB.(*ArgumentLessWindowExpr)
		if !ok {
			return false
		}
		return EqualsRefOfArgumentLessWindowExpr(a, b, f)
	case *Avg:
		b, ok := inB.(*Avg)
		if !ok {
			return false
		}
		return EqualsRefOfAvg(a, b, f)
	case *BetweenExpr:
		b, ok := inB.(*BetweenExpr)
		if !ok {
			return false
		}
		return EqualsRefOfBetweenExpr(a, b, f)
	case *BinaryExpr:
		b, ok := inB.(*BinaryExpr)
		if !ok {
			return false
		}
		return EqualsRefOfBinaryExpr(a, b, f)
	case *BitAnd:
		b, ok := inB.(*BitAnd)
		if !ok {
			return false
		}
		return EqualsRefOfBitAnd(a, b, f)
	case *BitOr:
		b, ok := inB.(*BitOr)
		if !ok {
			return false
		}
		return EqualsRefOfBitOr(a, b, f)
	case *BitXor:
		b, ok := inB.(*BitXor)
		if !ok {
			return false
		}
		return EqualsRefOfBitXor(a, b, f)
	case BoolVal:
		b, ok := inB.(BoolVal)
		if !ok {
			return false
		}
		return a == b
	case *CaseExpr:
		b, ok := inB.(*CaseExpr)
		if !ok {
			return false
		}
		return EqualsRefOfCaseExpr(a, b, f)
	case *CastExpr:
		b, ok := inB.(*CastExpr)
		if !ok {
			return false
		}
		return EqualsRefOfCastExpr(a, b, f)
	case *CharExpr:
		b, ok := inB.(*CharExpr)
		if !ok {
			return false
		}
		return EqualsRefOfCharExpr(a, b, f)
	case *ColName:
		b, ok := inB.(*ColName)
		if !ok {
			return false
		}
		return EqualsRefOfColName(a, b, f)
	case *CollateExpr:
		b, ok := inB.(*CollateExpr)
		if !ok {
			return false
		}
		return EqualsRefOfCollateExpr(a, b, f)
	case *ComparisonExpr:
		b, ok := inB.(*ComparisonExpr)
		if !ok {
			return false
		}
		return EqualsRefOfComparisonExpr(a, b, f)
	case *ConvertExpr:
		b, ok := inB.(*ConvertExpr)
		if !ok {
			return false
		}
		return EqualsRefOfConvertExpr(a, b, f)
	case *ConvertUsingExpr:
		b, ok := inB.(*ConvertUsingExpr)
		if !ok {
			return false
		}
		return EqualsRefOfConvertUsingExpr(a, b, f)
	case *Count:
		b, ok := inB.(*Count)
		if !ok {
			return false
		}
		return EqualsRefOfCount(a, b, f)
	case *CountStar:
		b, ok := inB.(*CountStar)
		if !ok {
			return false
		}
		return EqualsRefOfCountStar(a, b, f)
	case *CurTimeFuncExpr:
		b, ok := inB.(*CurTimeFuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfCurTimeFuncExpr(a, b, f)
	case *Default:
		b, ok := inB.(*Default)
		if !ok {
			return false
		}
		return EqualsRefOfDefault(a, b, f)
	case *ExistsExpr:
		b, ok := inB.(*ExistsExpr)
		if !ok {
			return false
		}
		return EqualsRefOfExistsExpr(a, b, f)
	case *ExtractFuncExpr:
		b, ok := inB.(*ExtractFuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfExtractFuncExpr(a, b, f)
	case *ExtractValueExpr:
		b, ok := inB.(*ExtractValueExpr)
		if !ok {
			return false
		}
		return EqualsRefOfExtractValueExpr(a, b, f)
	case *ExtractedSubquery:
		b, ok := inB.(*ExtractedSubquery)
		if !ok {
			return false
		}
		return EqualsRefOfExtractedSubquery(a, b, f)
	case *FirstOrLastValueExpr:
		b, ok := inB.(*FirstOrLastValueExpr)
		if !ok {
			return false
		}
		return EqualsRefOfFirstOrLastValueExpr(a, b, f)
	case *FuncExpr:
		b, ok := inB.(*FuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfFuncExpr(a, b, f)
	case *GTIDFuncExpr:
		b, ok := inB.(*GTIDFuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfGTIDFuncExpr(a, b, f)
	case *GroupConcatExpr:
		b, ok := inB.(*GroupConcatExpr)
		if !ok {
			return false
		}
		return EqualsRefOfGroupConcatExpr(a, b, f)
	case *InsertExpr:
		b, ok := inB.(*InsertExpr)
		if !ok {
			return false
		}
		return EqualsRefOfInsertExpr(a, b, f)
	case *IntervalExpr:
		b, ok := inB.(*IntervalExpr)
		if !ok {
			return false
		}
		return EqualsRefOfIntervalExpr(a, b, f)
	case *IntervalFuncExpr:
		b, ok := inB.(*IntervalFuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfIntervalFuncExpr(a, b, f)
	case *IntroducerExpr:
		b, ok := inB.(*IntroducerExpr)
		if !ok {
			return false
		}
		return EqualsRefOfIntroducerExpr(a, b, f)
	case *IsExpr:
		b, ok := inB.(*IsExpr)
		if !ok {
			return false
		}
		return EqualsRefOfIsExpr(a, b, f)
	case *JSONArrayExpr:
		b, ok := inB.(*JSONArrayExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONArrayExpr(a, b, f)
	case *JSONAttributesExpr:
		b, ok := inB.(*JSONAttributesExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONAttributesExpr(a, b, f)
	case *JSONContainsExpr:
		b, ok := inB.(*JSONContainsExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONContainsExpr(a, b, f)
	case *JSONContainsPathExpr:
		b, ok := inB.(*JSONContainsPathExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONContainsPathExpr(a, b, f)
	case *JSONExtractExpr:
		b, ok := inB.(*JSONExtractExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONExtractExpr(a, b, f)
	case *JSONKeysExpr:
		b, ok := inB.(*JSONKeysExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONKeysExpr(a, b, f)
	case *JSONObjectExpr:
		b, ok := inB.(*JSONObjectExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONObjectExpr(a, b, f)
	case *JSONOverlapsExpr:
		b, ok := inB.(*JSONOverlapsExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONOverlapsExpr(a, b, f)
	case *JSONPrettyExpr:
		b, ok := inB.(*JSONPrettyExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONPrettyExpr(a, b, f)
	case *JSONQuoteExpr:
		b, ok := inB.(*JSONQuoteExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONQuoteExpr(a, b, f)
	case *JSONRemoveExpr:
		b, ok := inB.(*JSONRemoveExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONRemoveExpr(a, b, f)
	case *JSONSchemaValidFuncExpr:
		b, ok := inB.(*JSONSchemaValidFuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONSchemaValidFuncExpr(a, b, f)
	case *JSONSchemaValidationReportFuncExpr:
		b, ok := inB.(*JSONSchemaValidationReportFuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONSchemaValidationReportFuncExpr(a, b, f)
	case *JSONSearchExpr:
		b, ok := inB.(*JSONSearchExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONSearchExpr(a, b, f)
	case *JSONStorageFreeExpr:
		b, ok := inB.(*JSONStorageFreeExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONStorageFreeExpr(a, b, f)
	case *JSONStorageSizeExpr:
		b, ok := inB.(*JSONStorageSizeExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONStorageSizeExpr(a, b, f)
	case *JSONUnquoteExpr:
		b, ok := inB.(*JSONUnquoteExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONUnquoteExpr(a, b, f)
	case *JSONValueExpr:
		b, ok := inB.(*JSONValueExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONValueExpr(a, b, f)
	case *JSONValueMergeExpr:
		b, ok := inB.(*JSONValueMergeExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONValueMergeExpr(a, b, f)
	case *JSONValueModifierExpr:
		b, ok := inB.(*JSONValueModifierExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONValueModifierExpr(a, b, f)
	case *LagLeadExpr:
		b, ok := inB.(*LagLeadExpr)
		if !ok {
			return false
		}
		return EqualsRefOfLagLeadExpr(a, b, f)
	case ListArg:
		b, ok := inB.(ListArg)
		if !ok {
			return false
		}
		return a == b
	case *Literal:
		b, ok := inB.(*Literal)
		if !ok {
			return false
		}
		return EqualsRefOfLiteral(a, b, f)
	case *LocateExpr:
		b, ok := inB.(*LocateExpr)
		if !ok {
			return false
		}
		return EqualsRefOfLocateExpr(a, b, f)
	case *LockingFunc:
		b, ok := inB.(*LockingFunc)
		if !ok {
			return false
		}
		return EqualsRefOfLockingFunc(a, b, f)
	case *MatchExpr:
		b, ok := inB.(*MatchExpr)
		if !ok {
			return false
		}
		return EqualsRefOfMatchExpr(a, b, f)
	case *Max:
		b, ok := inB.(*Max)
		if !ok {
			return false
		}
		return EqualsRefOfMax(a, b, f)
	case *MemberOfExpr:
		b, ok := inB.(*MemberOfExpr)
		if !ok {
			return false
		}
		return EqualsRefOfMemberOfExpr(a, b, f)
	case *Min:
		b, ok := inB.(*Min)
		if !ok {
			return false
		}
		return EqualsRefOfMin(a, b, f)
	case *NTHValueExpr:
		b, ok := inB.(*NTHValueExpr)
		if !ok {
			return false
		}
		return EqualsRefOfNTHValueExpr(a, b, f)
	case *NamedWindow:
		b, ok := inB.(*NamedWindow)
		if !ok {
			return false
		}
		return EqualsRefOfNamedWindow(a, b, f)
	case *NotExpr:
		b, ok := inB.(*NotExpr)
		if !ok {
			return false
		}
		return EqualsRefOfNotExpr(a, b, f)
	case *NtileExpr:
		b, ok := inB.(*NtileExpr)
		if !ok {
			return false
		}
		return EqualsRefOfNtileExpr(a, b, f)
	case *NullVal:
		b, ok := inB.(*NullVal)
		if !ok {
			return false
		}
		return EqualsRefOfNullVal(a, b, f)
	case *Offset:
		b, ok := inB.(*Offset)
		if !ok {
			return false
		}
		return EqualsRefOfOffset(a, b, f)
	case *OrExpr:
		b, ok := inB.(*OrExpr)
		if !ok {
			return false
		}
		return EqualsRefOfOrExpr(a, b, f)
	case *PerformanceSchemaFuncExpr:
		b, ok := inB.(*PerformanceSchemaFuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfPerformanceSchemaFuncExpr(a, b, f)
	case *RegexpInstrExpr:
		b, ok := inB.(*RegexpInstrExpr)
		if !ok {
			return false
		}
		return EqualsRefOfRegexpInstrExpr(a, b, f)
	case *RegexpLikeExpr:
		b, ok := inB.(*RegexpLikeExpr)
		if !ok {
			return false
		}
		return EqualsRefOfRegexpLikeExpr(a, b, f)
	case *RegexpReplaceExpr:
		b, ok := inB.(*RegexpReplaceExpr)
		if !ok {
			return false
		}
		return EqualsRefOfRegexpReplaceExpr(a, b, f)
	case *RegexpSubstrExpr:
		b, ok := inB.(*RegexpSubstrExpr)
		if !ok {
			return false
		}
		return EqualsRefOfRegexpSubstrExpr(a, b, f)
	case *Std:
		b, ok := inB.(*Std)
		if !ok {
			return false
		}
		return EqualsRefOfStd(a, b, f)
	case *StdDev:
		b, ok := inB.(*StdDev)
		if !ok {
			return false
		}
		return EqualsRefOfStdDev(a, b, f)
	case *StdPop:
		b, ok := inB.(*StdPop)
		if !ok {
			return false
		}
		return EqualsRefOfStdPop(a, b, f)
	case *StdSamp:
		b, ok := inB.(*StdSamp)
		if !ok {
			return false
		}
		return EqualsRefOfStdSamp(a, b, f)
	case *Subquery:
		b, ok := inB.(*Subquery)
		if !ok {
			return false
		}
		return EqualsRefOfSubquery(a, b, f)
	case *SubstrExpr:
		b, ok := inB.(*SubstrExpr)
		if !ok {
			return false
		}
		return EqualsRefOfSubstrExpr(a, b, f)
	case *Sum:
		b, ok := inB.(*Sum)
		if !ok {
			return false
		}
		return EqualsRefOfSum(a, b, f)
	case *TimestampFuncExpr:
		b, ok := inB.(*TimestampFuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfTimestampFuncExpr(a, b, f)
	case *TrimFuncExpr:
		b, ok := inB.(*TrimFuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfTrimFuncExpr(a, b, f)
	case *UnaryExpr:
		b, ok := inB.(*UnaryExpr)
		if !ok {
			return false
		}
		return EqualsRefOfUnaryExpr(a, b, f)
	case *UpdateXMLExpr:
		b, ok := inB.(*UpdateXMLExpr)
		if !ok {
			return false
		}
		return EqualsRefOfUpdateXMLExpr(a, b, f)
	case ValTuple:
		b, ok := inB.(ValTuple)
		if !ok {
			return false
		}
		return EqualsValTuple(a, b, f)
	case *ValuesFuncExpr:
		b, ok := inB.(*ValuesFuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfValuesFuncExpr(a, b, f)
	case *VarPop:
		b, ok := inB.(*VarPop)
		if !ok {
			return false
		}
		return EqualsRefOfVarPop(a, b, f)
	case *VarSamp:
		b, ok := inB.(*VarSamp)
		if !ok {
			return false
		}
		return EqualsRefOfVarSamp(a, b, f)
	case *Variable:
		b, ok := inB.(*Variable)
		if !ok {
			return false
		}
		return EqualsRefOfVariable(a, b, f)
	case *Variance:
		b, ok := inB.(*Variance)
		if !ok {
			return false
		}
		return EqualsRefOfVariance(a, b, f)
	case *WeightStringFuncExpr:
		b, ok := inB.(*WeightStringFuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfWeightStringFuncExpr(a, b, f)
	case *XorExpr:
		b, ok := inB.(*XorExpr)
		if !ok {
			return false
		}
		return EqualsRefOfXorExpr(a, b, f)
	default:
		// this should never happen
		return false
	}
}

// EqualsInsertRows does deep equals between the two objects.
func EqualsInsertRows(inA, inB InsertRows, f ASTComparison) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *Select:
		b, ok := inB.(*Select)
		if !ok {
			return false
		}
		return EqualsRefOfSelect(a, b, f)
	case *Union:
		b, ok := inB.(*Union)
		if !ok {
			return false
		}
		return EqualsRefOfUnion(a, b, f)
	case Values:
		b, ok := inB.(Values)
		if !ok {
			return false
		}
		return EqualsValues(a, b, f)
	default:
		// this should never happen
		return false
	}
}

// EqualsSelectExpr does deep equals between the two objects.
func EqualsSelectExpr(inA, inB SelectExpr, f ASTComparison) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *AliasedExpr:
		b, ok := inB.(*AliasedExpr)
		if !ok {
			return false
		}
		return EqualsRefOfAliasedExpr(a, b, f)
	case *Nextval:
		b, ok := inB.(*Nextval)
		if !ok {
			return false
		}
		return EqualsRefOfNextval(a, b, f)
	case *StarExpr:
		b, ok := inB.(*StarExpr)
		if !ok {
			return false
		}
		return EqualsRefOfStarExpr(a, b, f)
	default:
		// this should never happen
		return false
	}
}

// EqualsSelectStatement does deep equals between the two objects.
func EqualsSelectStatement(inA, inB SelectStatement, f ASTComparison) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *Select:
		b, ok := inB.(*Select)
		if !ok {
			return false
		}
		return EqualsRefOfSelect(a, b, f)
	case *Union:
		b, ok := inB.(*Union)
		if !ok {
			return false
		}
		return EqualsRefOfUnion(a, b, f)
	default:
		// this should never happen
		return false
	}
}

// EqualsShowInternal does deep equals between the two objects.
func EqualsShowInternal(inA, inB ShowInternal, f ASTComparison) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *ShowBasic:
		b, ok := inB.(*ShowBasic)
		if !ok {
			return false
		}
		return EqualsRefOfShowBasic(a, b, f)
	case *ShowCreate:
		b, ok := inB.(*ShowCreate)
		if !ok {
			return false
		}
		return EqualsRefOfShowCreate(a, b, f)
	case *ShowOther:
		b, ok := inB.(*ShowOther)
		if !ok {
			return false
		}
		return EqualsRefOfShowOther(a, b, f)
	default:
		// this should never happen
		return false
	}
}

// EqualsSimpleTableExpr does deep equals between the two objects.
func EqualsSimpleTableExpr(inA, inB SimpleTableExpr, f ASTComparison) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *DerivedTable:
		b, ok := inB.(*DerivedTable)
		if !ok {
			return false
		}
		return EqualsRefOfDerivedTable(a, b, f)
	case TableName:
		b, ok := inB.(TableName)
		if !ok {
			return false
		}
		return EqualsTableName(a, b, f)
	default:
		// this should never happen
		return false
	}
}

// EqualsStatement does deep equals between the two objects.
func EqualsStatement(inA, inB Statement, f ASTComparison) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *AlterDatabase:
		b, ok := inB.(*AlterDatabase)
		if !ok {
			return false
		}
		return EqualsRefOfAlterDatabase(a, b, f)
	case *AlterMigration:
		b, ok := inB.(*AlterMigration)
		if !ok {
			return false
		}
		return EqualsRefOfAlterMigration(a, b, f)
	case *AlterTable:
		b, ok := inB.(*AlterTable)
		if !ok {
			return false
		}
		return EqualsRefOfAlterTable(a, b, f)
	case *AlterView:
		b, ok := inB.(*AlterView)
		if !ok {
			return false
		}
		return EqualsRefOfAlterView(a, b, f)
	case *AlterVschema:
		b, ok := inB.(*AlterVschema)
		if !ok {
			return false
		}
		return EqualsRefOfAlterVschema(a, b, f)
	case *Begin:
		b, ok := inB.(*Begin)
		if !ok {
			return false
		}
		return EqualsRefOfBegin(a, b, f)
	case *CallProc:
		b, ok := inB.(*CallProc)
		if !ok {
			return false
		}
		return EqualsRefOfCallProc(a, b, f)
	case *CommentOnly:
		b, ok := inB.(*CommentOnly)
		if !ok {
			return false
		}
		return EqualsRefOfCommentOnly(a, b, f)
	case *Commit:
		b, ok := inB.(*Commit)
		if !ok {
			return false
		}
		return EqualsRefOfCommit(a, b, f)
	case *CreateDatabase:
		b, ok := inB.(*CreateDatabase)
		if !ok {
			return false
		}
		return EqualsRefOfCreateDatabase(a, b, f)
	case *CreateTable:
		b, ok := inB.(*CreateTable)
		if !ok {
			return false
		}
		return EqualsRefOfCreateTable(a, b, f)
	case *CreateView:
		b, ok := inB.(*CreateView)
		if !ok {
			return false
		}
		return EqualsRefOfCreateView(a, b, f)
	case *DeallocateStmt:
		b, ok := inB.(*DeallocateStmt)
		if !ok {
			return false
		}
		return EqualsRefOfDeallocateStmt(a, b, f)
	case *Delete:
		b, ok := inB.(*Delete)
		if !ok {
			return false
		}
		return EqualsRefOfDelete(a, b, f)
	case *DropDatabase:
		b, ok := inB.(*DropDatabase)
		if !ok {
			return false
		}
		return EqualsRefOfDropDatabase(a, b, f)
	case *DropTable:
		b, ok := inB.(*DropTable)
		if !ok {
			return false
		}
		return EqualsRefOfDropTable(a, b, f)
	case *DropView:
		b, ok := inB.(*DropView)
		if !ok {
			return false
		}
		return EqualsRefOfDropView(a, b, f)
	case *ExecuteStmt:
		b, ok := inB.(*ExecuteStmt)
		if !ok {
			return false
		}
		return EqualsRefOfExecuteStmt(a, b, f)
	case *ExplainStmt:
		b, ok := inB.(*ExplainStmt)
		if !ok {
			return false
		}
		return EqualsRefOfExplainStmt(a, b, f)
	case *ExplainTab:
		b, ok := inB.(*ExplainTab)
		if !ok {
			return false
		}
		return EqualsRefOfExplainTab(a, b, f)
	case *Flush:
		b, ok := inB.(*Flush)
		if !ok {
			return false
		}
		return EqualsRefOfFlush(a, b, f)
	case *Insert:
		b, ok := inB.(*Insert)
		if !ok {
			return false
		}
		return EqualsRefOfInsert(a, b, f)
	case *Load:
		b, ok := inB.(*Load)
		if !ok {
			return false
		}
		return EqualsRefOfLoad(a, b, f)
	case *LockTables:
		b, ok := inB.(*LockTables)
		if !ok {
			return false
		}
		return EqualsRefOfLockTables(a, b, f)
	case *OtherAdmin:
		b, ok := inB.(*OtherAdmin)
		if !ok {
			return false
		}
		return EqualsRefOfOtherAdmin(a, b, f)
	case *OtherRead:
		b, ok := inB.(*OtherRead)
		if !ok {
			return false
		}
		return EqualsRefOfOtherRead(a, b, f)
	case *PrepareStmt:
		b, ok := inB.(*PrepareStmt)
		if !ok {
			return false
		}
		return EqualsRefOfPrepareStmt(a, b, f)
	case *Release:
		b, ok := inB.(*Release)
		if !ok {
			return false
		}
		return EqualsRefOfRelease(a, b, f)
	case *RenameTable:
		b, ok := inB.(*RenameTable)
		if !ok {
			return false
		}
		return EqualsRefOfRenameTable(a, b, f)
	case *RevertMigration:
		b, ok := inB.(*RevertMigration)
		if !ok {
			return false
		}
		return EqualsRefOfRevertMigration(a, b, f)
	case *Rollback:
		b, ok := inB.(*Rollback)
		if !ok {
			return false
		}
		return EqualsRefOfRollback(a, b, f)
	case *SRollback:
		b, ok := inB.(*SRollback)
		if !ok {
			return false
		}
		return EqualsRefOfSRollback(a, b, f)
	case *Savepoint:
		b, ok := inB.(*Savepoint)
		if !ok {
			return false
		}
		return EqualsRefOfSavepoint(a, b, f)
	case *Select:
		b, ok := inB.(*Select)
		if !ok {
			return false
		}
		return EqualsRefOfSelect(a, b, f)
	case *Set:
		b, ok := inB.(*Set)
		if !ok {
			return false
		}
		return EqualsRefOfSet(a, b, f)
	case *Show:
		b, ok := inB.(*Show)
		if !ok {
			return false
		}
		return EqualsRefOfShow(a, b, f)
	case *ShowMigrationLogs:
		b, ok := inB.(*ShowMigrationLogs)
		if !ok {
			return false
		}
		return EqualsRefOfShowMigrationLogs(a, b, f)
	case *ShowThrottledApps:
		b, ok := inB.(*ShowThrottledApps)
		if !ok {
			return false
		}
		return EqualsRefOfShowThrottledApps(a, b, f)
	case *ShowThrottlerStatus:
		b, ok := inB.(*ShowThrottlerStatus)
		if !ok {
			return false
		}
		return EqualsRefOfShowThrottlerStatus(a, b, f)
	case *Stream:
		b, ok := inB.(*Stream)
		if !ok {
			return false
		}
		return EqualsRefOfStream(a, b, f)
	case *TruncateTable:
		b, ok := inB.(*TruncateTable)
		if !ok {
			return false
		}
		return EqualsRefOfTruncateTable(a, b, f)
	case *Union:
		b, ok := inB.(*Union)
		if !ok {
			return false
		}
		return EqualsRefOfUnion(a, b, f)
	case *UnlockTables:
		b, ok := inB.(*UnlockTables)
		if !ok {
			return false
		}
		return EqualsRefOfUnlockTables(a, b, f)
	case *Update:
		b, ok := inB.(*Update)
		if !ok {
			return false
		}
		return EqualsRefOfUpdate(a, b, f)
	case *Use:
		b, ok := inB.(*Use)
		if !ok {
			return false
		}
		return EqualsRefOfUse(a, b, f)
	case *VStream:
		b, ok := inB.(*VStream)
		if !ok {
			return false
		}
		return EqualsRefOfVStream(a, b, f)
	default:
		// this should never happen
		return false
	}
}

// EqualsTableExpr does deep equals between the two objects.
func EqualsTableExpr(inA, inB TableExpr, f ASTComparison) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *AliasedTableExpr:
		b, ok := inB.(*AliasedTableExpr)
		if !ok {
			return false
		}
		return EqualsRefOfAliasedTableExpr(a, b, f)
	case *JSONTableExpr:
		b, ok := inB.(*JSONTableExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJSONTableExpr(a, b, f)
	case *JoinTableExpr:
		b, ok := inB.(*JoinTableExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJoinTableExpr(a, b, f)
	case *ParenTableExpr:
		b, ok := inB.(*ParenTableExpr)
		if !ok {
			return false
		}
		return EqualsRefOfParenTableExpr(a, b, f)
	default:
		// this should never happen
		return false
	}
}

// EqualsSliceOfRefOfColumnDefinition does deep equals between the two objects.
func EqualsSliceOfRefOfColumnDefinition(a, b []*ColumnDefinition, f ASTComparison) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsRefOfColumnDefinition(a[i], b[i], f) {
			return false
		}
	}
	return true
}

// EqualsRefOfBool does deep equals between the two objects.
func EqualsRefOfBool(a, b *bool, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return *a == *b
}

// EqualsSliceOfDatabaseOption does deep equals between the two objects.
func EqualsSliceOfDatabaseOption(a, b []DatabaseOption, f ASTComparison) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsDatabaseOption(a[i], b[i], f) {
			return false
		}
	}
	return true
}

// EqualsSliceOfAlterOption does deep equals between the two objects.
func EqualsSliceOfAlterOption(a, b []AlterOption, f ASTComparison) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsAlterOption(a[i], b[i], f) {
			return false
		}
	}
	return true
}

// EqualsSliceOfIdentifierCI does deep equals between the two objects.
func EqualsSliceOfIdentifierCI(a, b []IdentifierCI, f ASTComparison) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsIdentifierCI(a[i], b[i], f) {
			return false
		}
	}
	return true
}

// EqualsSliceOfTxAccessMode does deep equals between the two objects.
func EqualsSliceOfTxAccessMode(a, b []TxAccessMode, f ASTComparison) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}

// EqualsSliceOfRefOfWhen does deep equals between the two objects.
func EqualsSliceOfRefOfWhen(a, b []*When, f ASTComparison) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsRefOfWhen(a[i], b[i], f) {
			return false
		}
	}
	return true
}

// EqualsColumnType does deep equals between the two objects.
func EqualsColumnType(a, b ColumnType, f ASTComparison) bool {
	return a.Type == b.Type &&
		a.Unsigned == b.Unsigned &&
		a.Zerofill == b.Zerofill &&
		EqualsRefOfColumnTypeOptions(a.Options, b.Options, f) &&
		EqualsRefOfLiteral(a.Length, b.Length, f) &&
		EqualsRefOfLiteral(a.Scale, b.Scale, f) &&
		EqualsColumnCharset(a.Charset, b.Charset, f) &&
		EqualsSliceOfString(a.EnumValues, b.EnumValues, f)
}

// EqualsRefOfColumnTypeOptions does deep equals between the two objects.
func EqualsRefOfColumnTypeOptions(a, b *ColumnTypeOptions, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Autoincrement == b.Autoincrement &&
		a.Collate == b.Collate &&
		EqualsRefOfBool(a.Null, b.Null, f) &&
		EqualsExpr(a.Default, b.Default, f) &&
		EqualsExpr(a.OnUpdate, b.OnUpdate, f) &&
		EqualsExpr(a.As, b.As, f) &&
		EqualsRefOfLiteral(a.Comment, b.Comment, f) &&
		a.Storage == b.Storage &&
		EqualsRefOfReferenceDefinition(a.Reference, b.Reference, f) &&
		a.KeyOpt == b.KeyOpt &&
		EqualsRefOfBool(a.Invisible, b.Invisible, f) &&
		a.Format == b.Format &&
		EqualsRefOfLiteral(a.EngineAttribute, b.EngineAttribute, f) &&
		EqualsRefOfLiteral(a.SecondaryEngineAttribute, b.SecondaryEngineAttribute, f) &&
		EqualsRefOfLiteral(a.SRID, b.SRID, f)
}

// EqualsColumnCharset does deep equals between the two objects.
func EqualsColumnCharset(a, b ColumnCharset, f ASTComparison) bool {
	return a.Name == b.Name &&
		a.Binary == b.Binary
}

// EqualsSliceOfString does deep equals between the two objects.
func EqualsSliceOfString(a, b []string, f ASTComparison) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}

// EqualsSliceOfRefOfVariable does deep equals between the two objects.
func EqualsSliceOfRefOfVariable(a, b []*Variable, f ASTComparison) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsRefOfVariable(a[i], b[i], f) {
			return false
		}
	}
	return true
}

// EqualsRefOfIdentifierCI does deep equals between the two objects.
func EqualsRefOfIdentifierCI(a, b *IdentifierCI, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.val == b.val &&
		a.lowered == b.lowered
}

// EqualsRefOfIdentifierCS does deep equals between the two objects.
func EqualsRefOfIdentifierCS(a, b *IdentifierCS, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.v == b.v
}

// EqualsSliceOfRefOfIndexColumn does deep equals between the two objects.
func EqualsSliceOfRefOfIndexColumn(a, b []*IndexColumn, f ASTComparison) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsRefOfIndexColumn(a[i], b[i], f) {
			return false
		}
	}
	return true
}

// EqualsSliceOfRefOfIndexOption does deep equals between the two objects.
func EqualsSliceOfRefOfIndexOption(a, b []*IndexOption, f ASTComparison) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsRefOfIndexOption(a[i], b[i], f) {
			return false
		}
	}
	return true
}

// EqualsSliceOfExpr does deep equals between the two objects.
func EqualsSliceOfExpr(a, b []Expr, f ASTComparison) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsExpr(a[i], b[i], f) {
			return false
		}
	}
	return true
}

// EqualsSliceOfRefOfJSONObjectParam does deep equals between the two objects.
func EqualsSliceOfRefOfJSONObjectParam(a, b []*JSONObjectParam, f ASTComparison) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsRefOfJSONObjectParam(a[i], b[i], f) {
			return false
		}
	}
	return true
}

// EqualsRefOfJSONObjectParam does deep equals between the two objects.
func EqualsRefOfJSONObjectParam(a, b *JSONObjectParam, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Key, b.Key, f) &&
		EqualsExpr(a.Value, b.Value, f)
}

// EqualsSliceOfRefOfJtColumnDefinition does deep equals between the two objects.
func EqualsSliceOfRefOfJtColumnDefinition(a, b []*JtColumnDefinition, f ASTComparison) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsRefOfJtColumnDefinition(a[i], b[i], f) {
			return false
		}
	}
	return true
}

// EqualsRefOfJtOrdinalColDef does deep equals between the two objects.
func EqualsRefOfJtOrdinalColDef(a, b *JtOrdinalColDef, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsIdentifierCI(a.Name, b.Name, f)
}

// EqualsRefOfJtPathColDef does deep equals between the two objects.
func EqualsRefOfJtPathColDef(a, b *JtPathColDef, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.JtColExists == b.JtColExists &&
		EqualsIdentifierCI(a.Name, b.Name, f) &&
		EqualsColumnType(a.Type, b.Type, f) &&
		EqualsExpr(a.Path, b.Path, f) &&
		EqualsRefOfJtOnResponse(a.EmptyOnResponse, b.EmptyOnResponse, f) &&
		EqualsRefOfJtOnResponse(a.ErrorOnResponse, b.ErrorOnResponse, f)
}

// EqualsRefOfJtNestedPathColDef does deep equals between the two objects.
func EqualsRefOfJtNestedPathColDef(a, b *JtNestedPathColDef, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Path, b.Path, f) &&
		EqualsSliceOfRefOfJtColumnDefinition(a.Columns, b.Columns, f)
}

// EqualsTableAndLockTypes does deep equals between the two objects.
func EqualsTableAndLockTypes(a, b TableAndLockTypes, f ASTComparison) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsRefOfTableAndLockType(a[i], b[i], f) {
			return false
		}
	}
	return true
}

// EqualsSliceOfRefOfColName does deep equals between the two objects.
func EqualsSliceOfRefOfColName(a, b []*ColName, f ASTComparison) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsRefOfColName(a[i], b[i], f) {
			return false
		}
	}
	return true
}

// EqualsComments does deep equals between the two objects.
func EqualsComments(a, b Comments, f ASTComparison) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}

// EqualsRefOfInt does deep equals between the two objects.
func EqualsRefOfInt(a, b *int, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return *a == *b
}

// EqualsSliceOfRefOfPartitionDefinition does deep equals between the two objects.
func EqualsSliceOfRefOfPartitionDefinition(a, b []*PartitionDefinition, f ASTComparison) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsRefOfPartitionDefinition(a[i], b[i], f) {
			return false
		}
	}
	return true
}

// EqualsSliceOfRefOfRenameTablePair does deep equals between the two objects.
func EqualsSliceOfRefOfRenameTablePair(a, b []*RenameTablePair, f ASTComparison) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsRefOfRenameTablePair(a[i], b[i], f) {
			return false
		}
	}
	return true
}

// EqualsRefOfRootNode does deep equals between the two objects.
func EqualsRefOfRootNode(a, b *RootNode, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsSQLNode(a.SQLNode, b.SQLNode, f)
}

// EqualsSliceOfTableExpr does deep equals between the two objects.
func EqualsSliceOfTableExpr(a, b []TableExpr, f ASTComparison) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsTableExpr(a[i], b[i], f) {
			return false
		}
	}
	return true
}

// EqualsRefOfTableName does deep equals between the two objects.
func EqualsRefOfTableName(a, b *TableName, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsIdentifierCS(a.Name, b.Name, f) &&
		EqualsIdentifierCS(a.Qualifier, b.Qualifier, f)
}

// EqualsRefOfTableOption does deep equals between the two objects.
func EqualsRefOfTableOption(a, b *TableOption, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Name == b.Name &&
		a.String == b.String &&
		a.CaseSensitive == b.CaseSensitive &&
		EqualsRefOfLiteral(a.Value, b.Value, f) &&
		EqualsTableNames(a.Tables, b.Tables, f)
}

// EqualsSliceOfRefOfIndexDefinition does deep equals between the two objects.
func EqualsSliceOfRefOfIndexDefinition(a, b []*IndexDefinition, f ASTComparison) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsRefOfIndexDefinition(a[i], b[i], f) {
			return false
		}
	}
	return true
}

// EqualsSliceOfRefOfConstraintDefinition does deep equals between the two objects.
func EqualsSliceOfRefOfConstraintDefinition(a, b []*ConstraintDefinition, f ASTComparison) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsRefOfConstraintDefinition(a[i], b[i], f) {
			return false
		}
	}
	return true
}

// EqualsRefOfVindexParam does deep equals between the two objects.
func EqualsRefOfVindexParam(a, b *VindexParam, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Val == b.Val &&
		EqualsIdentifierCI(a.Key, b.Key, f)
}

// EqualsSliceOfVindexParam does deep equals between the two objects.
func EqualsSliceOfVindexParam(a, b []VindexParam, f ASTComparison) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsVindexParam(a[i], b[i], f) {
			return false
		}
	}
	return true
}

// EqualsSliceOfRefOfCommonTableExpr does deep equals between the two objects.
func EqualsSliceOfRefOfCommonTableExpr(a, b []*CommonTableExpr, f ASTComparison) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsRefOfCommonTableExpr(a[i], b[i], f) {
			return false
		}
	}
	return true
}

// EqualsDatabaseOption does deep equals between the two objects.
func EqualsDatabaseOption(a, b DatabaseOption, f ASTComparison) bool {
	return a.IsDefault == b.IsDefault &&
		a.Value == b.Value &&
		a.Type == b.Type
}

// EqualsRefOfColumnCharset does deep equals between the two objects.
func EqualsRefOfColumnCharset(a, b *ColumnCharset, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Name == b.Name &&
		a.Binary == b.Binary
}

// EqualsRefOfIndexColumn does deep equals between the two objects.
func EqualsRefOfIndexColumn(a, b *IndexColumn, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsIdentifierCI(a.Column, b.Column, f) &&
		EqualsRefOfLiteral(a.Length, b.Length, f) &&
		EqualsExpr(a.Expression, b.Expression, f) &&
		a.Direction == b.Direction
}

// EqualsRefOfIndexOption does deep equals between the two objects.
func EqualsRefOfIndexOption(a, b *IndexOption, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Name == b.Name &&
		a.String == b.String &&
		EqualsRefOfLiteral(a.Value, b.Value, f)
}

// EqualsRefOfTableAndLockType does deep equals between the two objects.
func EqualsRefOfTableAndLockType(a, b *TableAndLockType, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsTableExpr(a.Table, b.Table, f) &&
		a.Lock == b.Lock
}

// EqualsRefOfRenameTablePair does deep equals between the two objects.
func EqualsRefOfRenameTablePair(a, b *RenameTablePair, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsTableName(a.FromTable, b.FromTable, f) &&
		EqualsTableName(a.ToTable, b.ToTable, f)
}

// EqualsRefOfDatabaseOption does deep equals between the two objects.
func EqualsRefOfDatabaseOption(a, b *DatabaseOption, f ASTComparison) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.IsDefault == b.IsDefault &&
		a.Value == b.Value &&
		a.Type == b.Type
}
