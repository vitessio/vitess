/*
Copyright 2019 The Vitess Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package sqlparser

import (
	"fmt"
	"strings"

	"vitess.io/vitess/go/sqltypes"
)

/*
This is the Vitess AST. This file should only contain pure struct declarations,
or methods used to mark a struct as implementing an interface. All other methods
related to these structs live in ast_funcs.go
*/

// SQLNode defines the interface for all nodes
// generated by the parser.
type SQLNode interface {
	Format(buf *TrackedBuffer)
}

// Statements
type (
	// Statement represents a statement.
	Statement interface {
		iStatement()
		SQLNode
	}

	// SelectStatement any SELECT statement.
	SelectStatement interface {
		iSelectStatement()
		iStatement()
		iInsertRows()
		AddOrder(*Order)
		SetLimit(*Limit)
		SetLock(lock Lock)
		MakeDistinct()
		SQLNode
	}

	// DDLStatement represents any DDL Statement
	DDLStatement interface {
		iDDLStatement()
		IsFullyParsed() bool
		GetTable() TableName
		GetAction() DDLAction
		GetOptLike() *OptLike
		GetIfExists() bool
		GetTableSpec() *TableSpec
		GetFromTables() TableNames
		GetToTables() TableNames
		AffectedTables() TableNames
		SetTable(qualifier string, name string)
		SetFromTables(tables TableNames)
		Statement
	}

	// DBDDLStatement represents any DBDDL Statement
	DBDDLStatement interface {
		iDBDDLStatement()
		IsFullyParsed() bool
		GetDatabaseName() string
		Statement
	}

	// AlterOption is an interface that represents the various options in ALTER TABLE statements
	AlterOption interface {
		iAlterOption()
		SQLNode
	}

	// AddConstraintDefinition represents a ADD CONSTRAINT alter option
	AddConstraintDefinition struct {
		ConstraintDefinition *ConstraintDefinition
	}

	// AddIndexDefinition represents a ADD INDEX alter option
	AddIndexDefinition struct {
		IndexDefinition *IndexDefinition
	}

	// AddColumns represents a ADD COLUMN alter option
	AddColumns struct {
		Columns []*ColumnDefinition
		First   *ColName
		After   *ColName
	}

	// AlgorithmValue is the algorithm specified in the alter table command
	AlgorithmValue string

	// AlterColumn is used to add or drop defaults to columns in alter table command
	AlterColumn struct {
		Column      *ColName
		DropDefault bool
		DefaultVal  Expr
	}

	// ChangeColumn is used to change the column definition, can also rename the column in alter table command
	ChangeColumn struct {
		OldColumn        *ColName
		NewColDefinition *ColumnDefinition
		First            *ColName
		After            *ColName
	}

	// ModifyColumn is used to change the column definition in alter table command
	ModifyColumn struct {
		NewColDefinition *ColumnDefinition
		First            *ColName
		After            *ColName
	}

	// AlterCharset is used to set the default or change the character set and collation in alter table command
	AlterCharset struct {
		CharacterSet string
		Collate      string
	}

	// KeyState is used to disable or enable the keys in an alter table statement
	KeyState struct {
		Enable bool
	}

	// TablespaceOperation is used to discard or import the tablespace in an alter table statement
	TablespaceOperation struct {
		Import bool
	}

	// DropColumn is used to drop a column in an alter table statement
	DropColumn struct {
		Name *ColName
	}

	// DropKeyType is an enum that represents the type of key being dropped in an alter table statement
	DropKeyType int8

	// DropKey is used to drop a key in an alter table statement
	DropKey struct {
		Type DropKeyType
		Name string
	}

	// Force is used to specify force alter option in an alter table statement
	Force struct{}

	// LockOptionType is an enum for LockOption.Type
	LockOptionType int8

	// LockOption is used to specify the type of lock to use in an alter table statement
	LockOption struct {
		Type LockOptionType
	}

	// OrderByOption clause is used to specify the order by in an alter table statement
	OrderByOption struct {
		Cols Columns
	}

	// RenameTableName clause is used to rename the table in an alter table statement
	RenameTableName struct {
		Table TableName
	}

	// RenameIndex clause is used to rename indexes in an alter table statement
	RenameIndex struct {
		OldName string
		NewName string
	}

	// Validation clause is used to specify whether to use validation or not
	Validation struct {
		With bool
	}

	// Select represents a SELECT statement.
	Select struct {
		Cache            *bool // a reference here so it can be nil
		Distinct         bool
		StraightJoinHint bool
		SQLCalcFoundRows bool
		Comments         Comments
		SelectExprs      SelectExprs
		From             TableExprs
		Where            *Where
		GroupBy          GroupBy
		Having           *Where
		OrderBy          OrderBy
		Limit            *Limit
		Lock             Lock
		Into             *SelectInto
	}

	// SelectInto is a struct that represent the INTO part of a select query
	SelectInto struct {
		Type         SelectIntoType
		FileName     string
		Charset      string
		FormatOption string
		ExportOption string
		Manifest     string
		Overwrite    string
	}

	// SelectIntoType is an enum for SelectInto.Type
	SelectIntoType int8

	// Lock is an enum for the type of lock in the statement
	Lock int8

	// UnionSelect represents union type and select statement after first select statement.
	UnionSelect struct {
		Distinct  bool
		Statement SelectStatement
	}
	// Union represents a UNION statement.
	Union struct {
		FirstStatement SelectStatement
		UnionSelects   []*UnionSelect
		OrderBy        OrderBy
		Limit          *Limit
		Lock           Lock
	}

	// VStream represents a VSTREAM statement.
	VStream struct {
		Comments   Comments
		SelectExpr SelectExpr
		Table      TableName
		Where      *Where
		Limit      *Limit
	}

	// Stream represents a SELECT statement.
	Stream struct {
		Comments   Comments
		SelectExpr SelectExpr
		Table      TableName
	}

	// Insert represents an INSERT or REPLACE statement.
	// Per the MySQL docs, http://dev.mysql.com/doc/refman/5.7/en/replace.html
	// Replace is the counterpart to `INSERT IGNORE`, and works exactly like a
	// normal INSERT except if the row exists. In that case it first deletes
	// the row and re-inserts with new values. For that reason we keep it as an Insert struct.
	// Replaces are currently disallowed in sharded schemas because
	// of the implications the deletion part may have on vindexes.
	// If you add fields here, consider adding them to calls to validateUnshardedRoute.
	Insert struct {
		Action     InsertAction
		Comments   Comments
		Ignore     Ignore
		Table      TableName
		Partitions Partitions
		Columns    Columns
		Rows       InsertRows
		OnDup      OnDup
	}

	// Ignore represents whether ignore was specified or not
	Ignore bool

	// InsertAction is the action for insert.
	InsertAction int8

	// Update represents an UPDATE statement.
	// If you add fields here, consider adding them to calls to validateUnshardedRoute.
	Update struct {
		Comments   Comments
		Ignore     Ignore
		TableExprs TableExprs
		Exprs      UpdateExprs
		Where      *Where
		OrderBy    OrderBy
		Limit      *Limit
	}

	// Delete represents a DELETE statement.
	// If you add fields here, consider adding them to calls to validateUnshardedRoute.
	Delete struct {
		Ignore     Ignore
		Comments   Comments
		Targets    TableNames
		TableExprs TableExprs
		Partitions Partitions
		Where      *Where
		OrderBy    OrderBy
		Limit      *Limit
	}

	// Set represents a SET statement.
	Set struct {
		Comments Comments
		Exprs    SetExprs
	}

	// SetTransaction represents a SET TRANSACTION statement.
	SetTransaction struct {
		SQLNode
		Comments        Comments
		Scope           Scope
		Characteristics []Characteristic
	}

	// Scope is an enum for scope of query
	Scope int8

	// Characteristic is a transaction related change
	Characteristic interface {
		SQLNode
		iChar()
	}

	// IsolationLevel is an enum for isolation levels
	IsolationLevel int8

	// AccessMode is enum for the mode - ReadOnly or ReadWrite
	AccessMode int8

	// DropDatabase represents a DROP database statement.
	DropDatabase struct {
		DBName   string
		IfExists bool
	}

	// CollateAndCharsetType is an enum for CollateAndCharset.Type
	CollateAndCharsetType int8

	// CollateAndCharset is a struct that stores Collation or Character Set value
	CollateAndCharset struct {
		Type      CollateAndCharsetType
		IsDefault bool
		Value     string
	}

	// CreateDatabase represents a CREATE database statement.
	CreateDatabase struct {
		DBName        string
		IfNotExists   bool
		CreateOptions []CollateAndCharset
		FullyParsed   bool
	}

	// AlterDatabase represents a ALTER database statement.
	AlterDatabase struct {
		DBName              string
		UpdateDataDirectory bool
		AlterOptions        []CollateAndCharset
		FullyParsed         bool
	}

	// Flush represents a FLUSH statement.
	Flush struct {
		IsLocal      bool
		FlushOptions []string
		TableNames   TableNames
		WithLock     bool
		ForExport    bool
	}

	// RenameTablePair represents the name of the original table and what it is going to be set in a RENAME TABLE statement.
	RenameTablePair struct {
		FromTable TableName
		ToTable   TableName
	}

	// RenameTable represents a RENAME TABLE statement.
	RenameTable struct {
		TablePairs []*RenameTablePair
	}

	// TruncateTable represents a TRUNCATE TABLE statement.
	TruncateTable struct {
		Table TableName
	}

	// AlterVschema represents a ALTER VSCHEMA statement.
	AlterVschema struct {
		Action DDLAction
		Table  TableName

		// VindexSpec is set for CreateVindexDDLAction, DropVindexDDLAction, AddColVindexDDLAction, DropColVindexDDLAction.
		VindexSpec *VindexSpec

		// VindexCols is set for AddColVindexDDLAction.
		VindexCols []ColIdent

		// AutoIncSpec is set for AddAutoIncDDLAction.
		AutoIncSpec *AutoIncSpec
	}

	// AlterTable represents a ALTER TABLE statement.
	AlterTable struct {
		Table         TableName
		AlterOptions  []AlterOption
		PartitionSpec *PartitionSpec
		FullyParsed   bool
	}

	// DropTable represents a DROP TABLE statement.
	DropTable struct {
		FromTables TableNames
		// The following fields are set if a DDL was fully analyzed.
		IfExists bool
	}

	// DropView represents a DROP VIEW statement.
	DropView struct {
		FromTables TableNames
		IfExists   bool
	}

	// CreateTable represents a CREATE TABLE statement.
	CreateTable struct {
		Table       TableName
		IfNotExists bool
		TableSpec   *TableSpec
		OptLike     *OptLike
		FullyParsed bool
	}

	// CreateView represents a CREATE VIEW query
	CreateView struct {
		ViewName    TableName
		Algorithm   string
		Definer     string
		Security    string
		Columns     Columns
		Select      SelectStatement
		CheckOption string
		IsReplace   bool
	}

	// AlterView represents a ALTER VIEW query
	AlterView struct {
		ViewName    TableName
		Algorithm   string
		Definer     string
		Security    string
		Columns     Columns
		Select      SelectStatement
		CheckOption string
	}

	// DDLAction is an enum for DDL.Action
	DDLAction int8

	// Load represents a LOAD statement
	Load struct {
	}

	// ParenSelect is a parenthesized SELECT statement.
	ParenSelect struct {
		Select SelectStatement
	}

	// Show represents a show statement.
	Show struct {
		Internal ShowInternal
	}

	// Use represents a use statement.
	Use struct {
		DBName TableIdent
	}

	// Begin represents a Begin statement.
	Begin struct{}

	// Commit represents a Commit statement.
	Commit struct{}

	// Rollback represents a Rollback statement.
	Rollback struct{}

	// SRollback represents a rollback to savepoint statement.
	SRollback struct {
		Name ColIdent
	}

	// Savepoint represents a savepoint statement.
	Savepoint struct {
		Name ColIdent
	}

	// Release represents a release savepoint statement.
	Release struct {
		Name ColIdent
	}

	// Explain represents an EXPLAIN statement
	Explain struct {
		Type      ExplainType
		Statement Statement
	}

	// ExplainType is an enum for Explain.Type
	ExplainType int8

	// OtherRead represents a DESCRIBE, or EXPLAIN statement.
	// It should be used only as an indicator. It does not contain
	// the full AST for the statement.
	OtherRead struct{}

	// OtherAdmin represents a misc statement that relies on ADMIN privileges,
	// such as REPAIR, OPTIMIZE, or TRUNCATE statement.
	// It should be used only as an indicator. It does not contain
	// the full AST for the statement.
	OtherAdmin struct{}

	// LockType is an enum for Lock Types
	LockType int8

	// TableAndLockType contains table and lock association
	TableAndLockType struct {
		Table TableExpr
		Lock  LockType
	}

	// TableAndLockTypes is a slice of TableAndLockType
	TableAndLockTypes []*TableAndLockType

	// LockTables represents the lock statement
	LockTables struct {
		Tables TableAndLockTypes
	}

	// UnlockTables represents the unlock statement
	UnlockTables struct{}
)

func (*Union) iStatement()             {}
func (*Select) iStatement()            {}
func (*Stream) iStatement()            {}
func (*VStream) iStatement()           {}
func (*Insert) iStatement()            {}
func (*Update) iStatement()            {}
func (*Delete) iStatement()            {}
func (*Set) iStatement()               {}
func (*SetTransaction) iStatement()    {}
func (*DropDatabase) iStatement()      {}
func (*Flush) iStatement()             {}
func (*Show) iStatement()              {}
func (*Use) iStatement()               {}
func (*Begin) iStatement()             {}
func (*Commit) iStatement()            {}
func (*Rollback) iStatement()          {}
func (*SRollback) iStatement()         {}
func (*Savepoint) iStatement()         {}
func (*Release) iStatement()           {}
func (*Explain) iStatement()           {}
func (*OtherRead) iStatement()         {}
func (*OtherAdmin) iStatement()        {}
func (*Select) iSelectStatement()      {}
func (*Union) iSelectStatement()       {}
func (*ParenSelect) iSelectStatement() {}
func (*Load) iStatement()              {}
func (*CreateDatabase) iStatement()    {}
func (*AlterDatabase) iStatement()     {}
func (*CreateTable) iStatement()       {}
func (*CreateView) iStatement()        {}
func (*AlterView) iStatement()         {}
func (*LockTables) iStatement()        {}
func (*UnlockTables) iStatement()      {}
func (*AlterTable) iStatement()        {}
func (*AlterVschema) iStatement()      {}
func (*DropTable) iStatement()         {}
func (*DropView) iStatement()          {}
func (*TruncateTable) iStatement()     {}
func (*RenameTable) iStatement()       {}

func (*CreateView) iDDLStatement()    {}
func (*AlterView) iDDLStatement()     {}
func (*CreateTable) iDDLStatement()   {}
func (*DropTable) iDDLStatement()     {}
func (*DropView) iDDLStatement()      {}
func (*AlterTable) iDDLStatement()    {}
func (*TruncateTable) iDDLStatement() {}
func (*RenameTable) iDDLStatement()   {}

func (*AddConstraintDefinition) iAlterOption() {}
func (*AddIndexDefinition) iAlterOption()      {}
func (*AddColumns) iAlterOption()              {}
func (AlgorithmValue) iAlterOption()           {}
func (*AlterColumn) iAlterOption()             {}
func (*ChangeColumn) iAlterOption()            {}
func (*ModifyColumn) iAlterOption()            {}
func (*AlterCharset) iAlterOption()            {}
func (*KeyState) iAlterOption()                {}
func (*TablespaceOperation) iAlterOption()     {}
func (*DropColumn) iAlterOption()              {}
func (*DropKey) iAlterOption()                 {}
func (*Force) iAlterOption()                   {}
func (*LockOption) iAlterOption()              {}
func (*OrderByOption) iAlterOption()           {}
func (*RenameTableName) iAlterOption()         {}
func (*RenameIndex) iAlterOption()             {}
func (*Validation) iAlterOption()              {}
func (TableOptions) iAlterOption()             {}

// IsFullyParsed implements the DDLStatement interface
func (*TruncateTable) IsFullyParsed() bool {
	return true
}

// IsFullyParsed implements the DDLStatement interface
func (*RenameTable) IsFullyParsed() bool {
	return true
}

// IsFullyParsed implements the DDLStatement interface
func (node *CreateTable) IsFullyParsed() bool {
	return node.FullyParsed
}

// IsFullyParsed implements the DDLStatement interface
func (node *AlterTable) IsFullyParsed() bool {
	return node.FullyParsed
}

// IsFullyParsed implements the DDLStatement interface
func (node *CreateView) IsFullyParsed() bool {
	return true
}

// IsFullyParsed implements the DDLStatement interface
func (node *DropView) IsFullyParsed() bool {
	return true
}

// IsFullyParsed implements the DDLStatement interface
func (node *DropTable) IsFullyParsed() bool {
	return true
}

// IsFullyParsed implements the DDLStatement interface
func (node *AlterView) IsFullyParsed() bool {
	return true
}

// GetTable implements the DDLStatement interface
func (node *TruncateTable) GetTable() TableName {
	return node.Table
}

// GetTable implements the DDLStatement interface
func (node *CreateTable) GetTable() TableName {
	return node.Table
}

// GetTable implements the DDLStatement interface
func (node *AlterTable) GetTable() TableName {
	return node.Table
}

// GetTable implements the DDLStatement interface
func (node *CreateView) GetTable() TableName {
	return node.ViewName
}

// GetTable implements the DDLStatement interface
func (node *AlterView) GetTable() TableName {
	return node.ViewName
}

// GetTable implements the DDLStatement interface
func (node *DropView) GetTable() TableName {
	return TableName{}
}

// GetTable implements the DDLStatement interface
func (node *DropTable) GetTable() TableName {
	return TableName{}
}

// GetTable implements the DDLStatement interface
func (node *RenameTable) GetTable() TableName {
	return TableName{}
}

// GetAction implements the DDLStatement interface
func (node *TruncateTable) GetAction() DDLAction {
	return TruncateDDLAction
}

// GetAction implements the DDLStatement interface
func (node *AlterTable) GetAction() DDLAction {
	return AlterDDLAction
}

// GetAction implements the DDLStatement interface
func (node *CreateTable) GetAction() DDLAction {
	return CreateDDLAction
}

// GetAction implements the DDLStatement interface
func (node *CreateView) GetAction() DDLAction {
	return CreateDDLAction
}

// GetAction implements the DDLStatement interface
func (node *AlterView) GetAction() DDLAction {
	return AlterDDLAction
}

// GetAction implements the DDLStatement interface
func (node *RenameTable) GetAction() DDLAction {
	return RenameDDLAction
}

// GetAction implements the DDLStatement interface
func (node *DropTable) GetAction() DDLAction {
	return DropDDLAction
}

// GetAction implements the DDLStatement interface
func (node *DropView) GetAction() DDLAction {
	return DropDDLAction
}

// GetOptLike implements the DDLStatement interface
func (node *CreateTable) GetOptLike() *OptLike {
	return node.OptLike
}

// GetOptLike implements the DDLStatement interface
func (node *TruncateTable) GetOptLike() *OptLike {
	return nil
}

// GetOptLike implements the DDLStatement interface
func (node *RenameTable) GetOptLike() *OptLike {
	return nil
}

// GetOptLike implements the DDLStatement interface
func (node *AlterTable) GetOptLike() *OptLike {
	return nil
}

// GetOptLike implements the DDLStatement interface
func (node *CreateView) GetOptLike() *OptLike {
	return nil
}

// GetOptLike implements the DDLStatement interface
func (node *AlterView) GetOptLike() *OptLike {
	return nil
}

// GetOptLike implements the DDLStatement interface
func (node *DropTable) GetOptLike() *OptLike {
	return nil
}

// GetOptLike implements the DDLStatement interface
func (node *DropView) GetOptLike() *OptLike {
	return nil
}

// GetIfExists implements the DDLStatement interface
func (node *RenameTable) GetIfExists() bool {
	return false
}

// GetIfExists implements the DDLStatement interface
func (node *CreateTable) GetIfExists() bool {
	return false
}

// GetIfExists implements the DDLStatement interface
func (node *TruncateTable) GetIfExists() bool {
	return false
}

// GetIfExists implements the DDLStatement interface
func (node *AlterTable) GetIfExists() bool {
	return false
}

// GetIfExists implements the DDLStatement interface
func (node *CreateView) GetIfExists() bool {
	return false
}

// GetIfExists implements the DDLStatement interface
func (node *AlterView) GetIfExists() bool {
	return false
}

// GetIfExists implements the DDLStatement interface
func (node *DropTable) GetIfExists() bool {
	return node.IfExists
}

// GetIfExists implements the DDLStatement interface
func (node *DropView) GetIfExists() bool {
	return node.IfExists
}

// GetTableSpec implements the DDLStatement interface
func (node *CreateTable) GetTableSpec() *TableSpec {
	return node.TableSpec
}

// GetTableSpec implements the DDLStatement interface
func (node *RenameTable) GetTableSpec() *TableSpec {
	return nil
}

// GetTableSpec implements the DDLStatement interface
func (node *TruncateTable) GetTableSpec() *TableSpec {
	return nil
}

// GetTableSpec implements the DDLStatement interface
func (node *AlterTable) GetTableSpec() *TableSpec {
	return nil
}

// GetTableSpec implements the DDLStatement interface
func (node *CreateView) GetTableSpec() *TableSpec {
	return nil
}

// GetTableSpec implements the DDLStatement interface
func (node *AlterView) GetTableSpec() *TableSpec {
	return nil
}

// GetTableSpec implements the DDLStatement interface
func (node *DropTable) GetTableSpec() *TableSpec {
	return nil
}

// GetTableSpec implements the DDLStatement interface
func (node *DropView) GetTableSpec() *TableSpec {
	return nil
}

// GetFromTables implements the DDLStatement interface
func (node *RenameTable) GetFromTables() TableNames {
	var fromTables TableNames
	for _, pair := range node.TablePairs {
		fromTables = append(fromTables, pair.FromTable)
	}
	return fromTables
}

// GetFromTables implements the DDLStatement interface
func (node *TruncateTable) GetFromTables() TableNames {
	return nil
}

// GetFromTables implements the DDLStatement interface
func (node *AlterTable) GetFromTables() TableNames {
	return nil
}

// GetFromTables implements the DDLStatement interface
func (node *CreateTable) GetFromTables() TableNames {
	return nil
}

// GetFromTables implements the DDLStatement interface
func (node *CreateView) GetFromTables() TableNames {
	return nil
}

// GetFromTables implements the DDLStatement interface
func (node *DropTable) GetFromTables() TableNames {
	return node.FromTables
}

// GetFromTables implements the DDLStatement interface
func (node *DropView) GetFromTables() TableNames {
	return node.FromTables
}

// GetFromTables implements the DDLStatement interface
func (node *AlterView) GetFromTables() TableNames {
	return nil
}

// SetFromTables implements DDLStatement.
func (node *RenameTable) SetFromTables(tables TableNames) {
	if len(node.TablePairs) != len(tables) {
		return
	}
	for i := range node.TablePairs {
		node.TablePairs[i].FromTable = tables[i]
	}
}

// SetFromTables implements DDLStatement.
func (node *TruncateTable) SetFromTables(tables TableNames) {
	// irrelevant
}

// SetFromTables implements DDLStatement.
func (node *AlterTable) SetFromTables(tables TableNames) {
	// irrelevant
}

// SetFromTables implements DDLStatement.
func (node *CreateTable) SetFromTables(tables TableNames) {
	// irrelevant
}

// SetFromTables implements DDLStatement.
func (node *CreateView) SetFromTables(tables TableNames) {
	// irrelevant
}

// SetFromTables implements DDLStatement.
func (node *DropTable) SetFromTables(tables TableNames) {
	node.FromTables = tables
}

// SetFromTables implements DDLStatement.
func (node *DropView) SetFromTables(tables TableNames) {
	node.FromTables = tables
}

// SetFromTables implements DDLStatement.
func (node *AlterView) SetFromTables(tables TableNames) {
	// irrelevant
}

// GetToTables implements the DDLStatement interface
func (node *RenameTable) GetToTables() TableNames {
	var toTables TableNames
	for _, pair := range node.TablePairs {
		toTables = append(toTables, pair.ToTable)
	}
	return toTables
}

// GetToTables implements the DDLStatement interface
func (node *TruncateTable) GetToTables() TableNames {
	return nil
}

// GetToTables implements the DDLStatement interface
func (node *AlterTable) GetToTables() TableNames {
	for _, option := range node.AlterOptions {
		switch altOption := option.(type) {
		case *RenameTableName:
			return TableNames{altOption.Table}
		}
	}
	return nil
}

// GetToTables implements the DDLStatement interface
func (node *CreateView) GetToTables() TableNames {
	return nil
}

// GetToTables implements the DDLStatement interface
func (node *AlterView) GetToTables() TableNames {
	return nil
}

// GetToTables implements the DDLStatement interface
func (node *CreateTable) GetToTables() TableNames {
	return nil
}

// GetToTables implements the DDLStatement interface
func (node *DropTable) GetToTables() TableNames {
	return nil
}

// GetToTables implements the DDLStatement interface
func (node *DropView) GetToTables() TableNames {
	return nil
}

// AffectedTables returns the list table names affected by the DDLStatement.
func (node *RenameTable) AffectedTables() TableNames {
	list := make(TableNames, 0, 2*len(node.TablePairs))
	for _, pair := range node.TablePairs {
		list = append(list, pair.FromTable)
		list = append(list, pair.ToTable)
	}
	return list
}

// AffectedTables returns the list table names affected by the DDLStatement.
func (node *AlterTable) AffectedTables() TableNames {
	affectedTables := TableNames{node.Table}
	for _, option := range node.AlterOptions {
		switch altOption := option.(type) {
		case *RenameTableName:
			affectedTables = append(affectedTables, altOption.Table)
		}
	}
	return affectedTables
}

// AffectedTables implements DDLStatement.
func (node *TruncateTable) AffectedTables() TableNames {
	return TableNames{node.Table}
}

// AffectedTables implements DDLStatement.
func (node *CreateTable) AffectedTables() TableNames {
	return TableNames{node.Table}
}

// AffectedTables implements DDLStatement.
func (node *CreateView) AffectedTables() TableNames {
	return TableNames{node.ViewName}
}

// AffectedTables implements DDLStatement.
func (node *AlterView) AffectedTables() TableNames {
	return TableNames{node.ViewName}
}

// AffectedTables returns the list table names affected by the DDLStatement.
func (node *DropTable) AffectedTables() TableNames {
	return node.FromTables
}

// AffectedTables returns the list table names affected by the DDLStatement.
func (node *DropView) AffectedTables() TableNames {
	return node.FromTables
}

// SetTable implements DDLStatement.
func (node *TruncateTable) SetTable(qualifier string, name string) {
	node.Table.Qualifier = NewTableIdent(qualifier)
	node.Table.Name = NewTableIdent(name)
}

// SetTable implements DDLStatement.
func (node *AlterTable) SetTable(qualifier string, name string) {
	node.Table.Qualifier = NewTableIdent(qualifier)
	node.Table.Name = NewTableIdent(name)
}

// SetTable implements DDLStatement.
func (node *CreateTable) SetTable(qualifier string, name string) {
	node.Table.Qualifier = NewTableIdent(qualifier)
	node.Table.Name = NewTableIdent(name)
}

// SetTable implements DDLStatement.
func (node *CreateView) SetTable(qualifier string, name string) {
	node.ViewName.Qualifier = NewTableIdent(qualifier)
	node.ViewName.Name = NewTableIdent(name)
}

// SetTable implements DDLStatement.
func (node *AlterView) SetTable(qualifier string, name string) {
	node.ViewName.Qualifier = NewTableIdent(qualifier)
	node.ViewName.Name = NewTableIdent(name)
}

// SetTable implements DDLStatement.
func (node *RenameTable) SetTable(qualifier string, name string) {}

// SetTable implements DDLStatement.
func (node *DropTable) SetTable(qualifier string, name string) {}

// SetTable implements DDLStatement.
func (node *DropView) SetTable(qualifier string, name string) {}

func (*DropDatabase) iDBDDLStatement()   {}
func (*CreateDatabase) iDBDDLStatement() {}
func (*AlterDatabase) iDBDDLStatement()  {}

// IsFullyParsed implements the DBDDLStatement interface
func (node *DropDatabase) IsFullyParsed() bool {
	return true
}

// IsFullyParsed implements the DBDDLStatement interface
func (node *CreateDatabase) IsFullyParsed() bool {
	return node.FullyParsed
}

// IsFullyParsed implements the DBDDLStatement interface
func (node *AlterDatabase) IsFullyParsed() bool {
	return node.FullyParsed
}

// GetDatabaseName implements the DBDDLStatement interface
func (node *DropDatabase) GetDatabaseName() string {
	return node.DBName
}

// GetDatabaseName implements the DBDDLStatement interface
func (node *CreateDatabase) GetDatabaseName() string {
	return node.DBName
}

// GetDatabaseName implements the DBDDLStatement interface
func (node *AlterDatabase) GetDatabaseName() string {
	return node.DBName
}

// ParenSelect can actually not be a top level statement,
// but we have to allow it because it's a requirement
// of SelectStatement.
func (*ParenSelect) iStatement() {}

type (

	// ShowInternal will represent all the show statement types.
	ShowInternal interface {
		isShowInternal()
		SQLNode
	}

	// ShowLegacy is of ShowInternal type, holds the legacy show ast struct.
	ShowLegacy struct {
		Extended               string
		Type                   string
		OnTable                TableName
		Table                  TableName
		ShowTablesOpt          *ShowTablesOpt
		Scope                  Scope
		ShowCollationFilterOpt Expr
	}

	// ShowColumns is of ShowInternal type, holds the show columns statement.
	ShowColumns struct {
		Full   string
		Table  TableName
		DbName string
		Filter *ShowFilter
	}

	// ShowTableStatus is of ShowInternal type, holds SHOW TABLE STATUS queries.
	ShowTableStatus struct {
		DatabaseName string
		Filter       *ShowFilter
	}

	// ShowCommandType represents the show statement type.
	ShowCommandType int8

	// ShowBasic is of ShowInternal type, holds Simple SHOW queries with a filter.
	ShowBasic struct {
		Command ShowCommandType
		Filter  *ShowFilter
	}
)

func (*ShowLegacy) isShowInternal()      {}
func (*ShowColumns) isShowInternal()     {}
func (*ShowTableStatus) isShowInternal() {}
func (*ShowBasic) isShowInternal()       {}

// InsertRows represents the rows for an INSERT statement.
type InsertRows interface {
	iInsertRows()
	SQLNode
}

func (*Select) iInsertRows()      {}
func (*Union) iInsertRows()       {}
func (Values) iInsertRows()       {}
func (*ParenSelect) iInsertRows() {}

// OptLike works for create table xxx like xxx
type OptLike struct {
	LikeTable TableName
}

// PartitionSpec describe partition actions (for alter statements)
type PartitionSpec struct {
	Action            PartitionSpecAction
	Names             Partitions
	Number            *Literal
	IsAll             bool
	TableName         TableName
	WithoutValidation bool
	Definitions       []*PartitionDefinition
}

// PartitionSpecAction is an enum for PartitionSpec.Action
type PartitionSpecAction int8

// PartitionDefinition describes a very minimal partition definition
type PartitionDefinition struct {
	Name     ColIdent
	Limit    Expr
	Maxvalue bool
}

// TableOptions specifies a list of table options
type TableOptions []*TableOption

// TableSpec describes the structure of a table from a CREATE TABLE statement
type TableSpec struct {
	Columns     []*ColumnDefinition
	Indexes     []*IndexDefinition
	Constraints []*ConstraintDefinition
	Options     TableOptions
}

// ColumnDefinition describes a column in a CREATE TABLE statement
type ColumnDefinition struct {
	Name ColIdent
	// TODO: Should this not be a reference?
	Type ColumnType
}

// ColumnType represents a sql type in a CREATE TABLE statement
// All optional fields are nil if not specified
type ColumnType struct {
	// The base type string
	Type string

	// Generic field options.
	NotNull       bool
	Autoincrement bool
	Default       Expr
	OnUpdate      Expr
	Comment       *Literal

	// Numeric field options
	Length   *Literal
	Unsigned bool
	Zerofill bool
	Scale    *Literal

	// Text field options
	Charset string
	Collate string

	// Enum values
	EnumValues []string

	// Key specification
	KeyOpt ColumnKeyOption
}

// IndexDefinition describes an index in a CREATE TABLE statement
type IndexDefinition struct {
	Info    *IndexInfo
	Columns []*IndexColumn
	Options []*IndexOption
}

// IndexInfo describes the name and type of an index in a CREATE TABLE statement
type IndexInfo struct {
	Type           string
	Name           ColIdent
	ConstraintName ColIdent
	Primary        bool
	Spatial        bool
	Fulltext       bool
	Unique         bool
}

// VindexSpec defines a vindex for a CREATE VINDEX or DROP VINDEX statement
type VindexSpec struct {
	Name   ColIdent
	Type   ColIdent
	Params []VindexParam
}

// AutoIncSpec defines and autoincrement value for a ADD AUTO_INCREMENT statement
type AutoIncSpec struct {
	Column   ColIdent
	Sequence TableName
}

// VindexParam defines a key/value parameter for a CREATE VINDEX statement
type VindexParam struct {
	Key ColIdent
	Val string
}

// ConstraintDefinition describes a constraint in a CREATE TABLE statement
type ConstraintDefinition struct {
	Name    string
	Details ConstraintInfo
}

type (
	// ConstraintInfo details a constraint in a CREATE TABLE statement
	ConstraintInfo interface {
		SQLNode
		iConstraintInfo()
	}

	// ForeignKeyDefinition describes a foreign key in a CREATE TABLE statement
	ForeignKeyDefinition struct {
		Source            Columns
		ReferencedTable   TableName
		ReferencedColumns Columns
		OnDelete          ReferenceAction
		OnUpdate          ReferenceAction
	}

	// CheckConstraintDefinition describes a check constraint in a CREATE TABLE statement
	CheckConstraintDefinition struct {
		Expr     Expr
		Enforced bool
	}
)

// ShowFilter is show tables filter
type ShowFilter struct {
	Like   string
	Filter Expr
}

// Comments represents a list of comments.
type Comments [][]byte

// SelectExprs represents SELECT expressions.
type SelectExprs []SelectExpr

type (
	// SelectExpr represents a SELECT expression.
	SelectExpr interface {
		iSelectExpr()
		SQLNode
	}

	// StarExpr defines a '*' or 'table.*' expression.
	StarExpr struct {
		TableName TableName
	}

	// AliasedExpr defines an aliased SELECT expression.
	AliasedExpr struct {
		Expr Expr
		As   ColIdent
	}

	// Nextval defines the NEXT VALUE expression.
	Nextval struct {
		Expr Expr
	}
)

func (*StarExpr) iSelectExpr()    {}
func (*AliasedExpr) iSelectExpr() {}
func (Nextval) iSelectExpr()      {}

// Columns represents an insert column list.
type Columns []ColIdent

// Partitions is a type alias for Columns so we can handle printing efficiently
type Partitions Columns

// TableExprs represents a list of table expressions.
type TableExprs []TableExpr

type (
	// TableExpr represents a table expression.
	TableExpr interface {
		iTableExpr()
		SQLNode
	}

	// AliasedTableExpr represents a table expression
	// coupled with an optional alias or index hint.
	// If As is empty, no alias was used.
	AliasedTableExpr struct {
		Expr       SimpleTableExpr
		Partitions Partitions
		As         TableIdent
		Hints      *IndexHints
	}

	// JoinTableExpr represents a TableExpr that's a JOIN operation.
	JoinTableExpr struct {
		LeftExpr  TableExpr
		Join      JoinType
		RightExpr TableExpr
		Condition JoinCondition
	}

	// JoinType represents the type of Join for JoinTableExpr
	JoinType int8

	// ParenTableExpr represents a parenthesized list of TableExpr.
	ParenTableExpr struct {
		Exprs TableExprs
	}
)

func (*AliasedTableExpr) iTableExpr() {}
func (*ParenTableExpr) iTableExpr()   {}
func (*JoinTableExpr) iTableExpr()    {}

type (
	// SimpleTableExpr represents a simple table expression.
	SimpleTableExpr interface {
		iSimpleTableExpr()
		SQLNode
	}

	// TableName represents a table  name.
	// Qualifier, if specified, represents a database or keyspace.
	// TableName is a value struct whose fields are case sensitive.
	// This means two TableName vars can be compared for equality
	// and a TableName can also be used as key in a map.
	TableName struct {
		Name, Qualifier TableIdent
	}

	// Subquery represents a subquery used as an value expression.
	Subquery struct {
		Select SelectStatement
	}

	// DerivedTable represents a subquery used as a table expression.
	DerivedTable struct {
		Select SelectStatement
	}
)

func (TableName) iSimpleTableExpr()     {}
func (*DerivedTable) iSimpleTableExpr() {}

// TableNames is a list of TableName.
type TableNames []TableName

// JoinCondition represents the join conditions (either a ON or USING clause)
// of a JoinTableExpr.
type JoinCondition struct {
	On    Expr
	Using Columns
}

// IndexHints represents a list of index hints.
type IndexHints struct {
	Type    IndexHintsType
	Indexes []ColIdent
}

// IndexHintsType is an enum for IndexHints.Type
type IndexHintsType int8

// Where represents a WHERE or HAVING clause.
type Where struct {
	Type WhereType
	Expr Expr
}

// WhereType is an enum for Where.Type
type WhereType int8

// *********** Expressions
type (
	// Expr represents an expression.
	Expr interface {
		iExpr()
		SQLNode
	}

	// AndExpr represents an AND expression.
	AndExpr struct {
		Left, Right Expr
	}

	// OrExpr represents an OR expression.
	OrExpr struct {
		Left, Right Expr
	}

	// XorExpr represents an XOR expression.
	XorExpr struct {
		Left, Right Expr
	}

	// NotExpr represents a NOT expression.
	NotExpr struct {
		Expr Expr
	}

	// ComparisonExpr represents a two-value comparison expression.
	ComparisonExpr struct {
		Operator    ComparisonExprOperator
		Left, Right Expr
		Escape      Expr
	}

	// ComparisonExprOperator is an enum for ComparisonExpr.Operator
	ComparisonExprOperator int8

	// RangeCond represents a BETWEEN or a NOT BETWEEN expression.
	RangeCond struct {
		Operator RangeCondOperator
		Left     Expr
		From, To Expr
	}

	// RangeCondOperator is an enum for RangeCond.Operator
	RangeCondOperator int8

	// IsExpr represents an IS ... or an IS NOT ... expression.
	IsExpr struct {
		Operator IsExprOperator
		Expr     Expr
	}

	// IsExprOperator is an enum for IsExpr.Operator
	IsExprOperator int8

	// ExistsExpr represents an EXISTS expression.
	ExistsExpr struct {
		Subquery *Subquery
	}

	// Literal represents a fixed value.
	Literal struct {
		Type ValType
		Val  []byte
	}

	// Argument represents bindvariable expression
	Argument []byte

	// NullVal represents a NULL value.
	NullVal struct{}

	// BoolVal is true or false.
	BoolVal bool

	// ColName represents a column name.
	ColName struct {
		// Metadata is not populated by the parser.
		// It's a placeholder for analyzers to store
		// additional data, typically info about which
		// table or column this node references.
		Metadata  interface{}
		Name      ColIdent
		Qualifier TableName
	}

	// ColTuple represents a list of column values.
	// It can be ValTuple, Subquery, ListArg.
	ColTuple interface {
		iColTuple()
		Expr
	}

	// ListArg represents a named list argument.
	ListArg []byte

	// ValTuple represents a tuple of actual values.
	ValTuple Exprs

	// BinaryExpr represents a binary value expression.
	BinaryExpr struct {
		Operator    BinaryExprOperator
		Left, Right Expr
	}

	// BinaryExprOperator is an enum for BinaryExpr.Operator
	BinaryExprOperator int8

	// UnaryExpr represents a unary value expression.
	UnaryExpr struct {
		Operator UnaryExprOperator
		Expr     Expr
	}

	// UnaryExprOperator is an enum for UnaryExpr.Operator
	UnaryExprOperator int8

	// IntervalExpr represents a date-time INTERVAL expression.
	IntervalExpr struct {
		Expr Expr
		Unit string
	}

	// TimestampFuncExpr represents the function and arguments for TIMESTAMP{ADD,DIFF} functions.
	TimestampFuncExpr struct {
		Name  string
		Expr1 Expr
		Expr2 Expr
		Unit  string
	}

	// CollateExpr represents dynamic collate operator.
	CollateExpr struct {
		Expr    Expr
		Charset string
	}

	// FuncExpr represents a function call.
	FuncExpr struct {
		Qualifier TableIdent
		Name      ColIdent
		Distinct  bool
		Exprs     SelectExprs
	}

	// GroupConcatExpr represents a call to GROUP_CONCAT
	GroupConcatExpr struct {
		Distinct  bool
		Exprs     SelectExprs
		OrderBy   OrderBy
		Separator string
		Limit     *Limit
	}

	// ValuesFuncExpr represents a function call.
	ValuesFuncExpr struct {
		Name *ColName
	}

	// SubstrExpr represents a call to SubstrExpr(column, value_expression) or SubstrExpr(column, value_expression,value_expression)
	// also supported syntax SubstrExpr(column from value_expression for value_expression).
	// Additionally to column names, SubstrExpr is also supported for string values, e.g.:
	// SubstrExpr('static string value', value_expression, value_expression)
	// In this case StrVal will be set instead of Name.
	SubstrExpr struct {
		Name   *ColName
		StrVal *Literal
		From   Expr
		To     Expr
	}

	// ConvertExpr represents a call to CONVERT(expr, type)
	// or it's equivalent CAST(expr AS type). Both are rewritten to the former.
	ConvertExpr struct {
		Expr Expr
		Type *ConvertType
	}

	// ConvertUsingExpr represents a call to CONVERT(expr USING charset).
	ConvertUsingExpr struct {
		Expr Expr
		Type string
	}

	// MatchExpr represents a call to the MATCH function
	MatchExpr struct {
		Columns SelectExprs
		Expr    Expr
		Option  MatchExprOption
	}

	// MatchExprOption is an enum for MatchExpr.Option
	MatchExprOption int8

	// CaseExpr represents a CASE expression.
	CaseExpr struct {
		Expr  Expr
		Whens []*When
		Else  Expr
	}

	// Default represents a DEFAULT expression.
	Default struct {
		ColName string
	}

	// When represents a WHEN sub-expression.
	When struct {
		Cond Expr
		Val  Expr
	}

	// CurTimeFuncExpr represents the function and arguments for CURRENT DATE/TIME functions
	// supported functions are documented in the grammar
	CurTimeFuncExpr struct {
		Name ColIdent
		Fsp  Expr // fractional seconds precision, integer from 0 to 6
	}
)

// iExpr ensures that only expressions nodes can be assigned to a Expr
func (*AndExpr) iExpr()           {}
func (*OrExpr) iExpr()            {}
func (*XorExpr) iExpr()           {}
func (*NotExpr) iExpr()           {}
func (*ComparisonExpr) iExpr()    {}
func (*RangeCond) iExpr()         {}
func (*IsExpr) iExpr()            {}
func (*ExistsExpr) iExpr()        {}
func (*Literal) iExpr()           {}
func (Argument) iExpr()           {}
func (*NullVal) iExpr()           {}
func (BoolVal) iExpr()            {}
func (*ColName) iExpr()           {}
func (ValTuple) iExpr()           {}
func (*Subquery) iExpr()          {}
func (ListArg) iExpr()            {}
func (*BinaryExpr) iExpr()        {}
func (*UnaryExpr) iExpr()         {}
func (*IntervalExpr) iExpr()      {}
func (*CollateExpr) iExpr()       {}
func (*FuncExpr) iExpr()          {}
func (*TimestampFuncExpr) iExpr() {}
func (*CurTimeFuncExpr) iExpr()   {}
func (*CaseExpr) iExpr()          {}
func (*ValuesFuncExpr) iExpr()    {}
func (*ConvertExpr) iExpr()       {}
func (*SubstrExpr) iExpr()        {}
func (*ConvertUsingExpr) iExpr()  {}
func (*MatchExpr) iExpr()         {}
func (*GroupConcatExpr) iExpr()   {}
func (*Default) iExpr()           {}

// Exprs represents a list of value expressions.
// It's not a valid expression because it's not parenthesized.
type Exprs []Expr

func (ValTuple) iColTuple()  {}
func (*Subquery) iColTuple() {}
func (ListArg) iColTuple()   {}

// ConvertType represents the type in call to CONVERT(expr, type)
type ConvertType struct {
	Type     string
	Length   *Literal
	Scale    *Literal
	Operator ConvertTypeOperator
	Charset  string
}

// ConvertTypeOperator is an enum for ConvertType.Operator
type ConvertTypeOperator int8

// GroupBy represents a GROUP BY clause.
type GroupBy []Expr

// OrderBy represents an ORDER By clause.
type OrderBy []*Order

// Order represents an ordering expression.
type Order struct {
	Expr      Expr
	Direction OrderDirection
}

// OrderDirection is an enum for the direction in which to order - asc or desc.
type OrderDirection int8

// Limit represents a LIMIT clause.
type Limit struct {
	Offset, Rowcount Expr
}

// Values represents a VALUES clause.
type Values []ValTuple

// UpdateExprs represents a list of update expressions.
type UpdateExprs []*UpdateExpr

// UpdateExpr represents an update expression.
type UpdateExpr struct {
	Name *ColName
	Expr Expr
}

// SetExprs represents a list of set expressions.
type SetExprs []*SetExpr

// SetExpr represents a set expression.
type SetExpr struct {
	Scope Scope
	Name  ColIdent
	Expr  Expr
}

// OnDup represents an ON DUPLICATE KEY clause.
type OnDup UpdateExprs

// ColIdent is a case insensitive SQL identifier. It will be escaped with
// backquotes if necessary.
type ColIdent struct {
	// This artifact prevents this struct from being compared
	// with itself. It consumes no space as long as it's not the
	// last field in the struct.
	_            [0]struct{ _ []byte }
	val, lowered string
	at           AtCount
}

// TableIdent is a case sensitive SQL identifier. It will be escaped with
// backquotes if necessary.
type TableIdent struct {
	v string
}

// Here follow all the Format implementations for AST nodes

// Format formats the node.
func (node *Select) Format(buf *TrackedBuffer) {
	var options string
	addIf := func(b bool, s string) {
		if b {
			options += s
		}
	}
	addIf(node.Distinct, DistinctStr)
	if node.Cache != nil {
		if *node.Cache {
			options += SQLCacheStr
		} else {
			options += SQLNoCacheStr
		}
	}
	addIf(node.StraightJoinHint, StraightJoinHint)
	addIf(node.SQLCalcFoundRows, SQLCalcFoundRowsStr)

	buf.astPrintf(node, "select %v%s%v from %v%v%v%v%v%v%s%v",
		node.Comments, options, node.SelectExprs,
		node.From, node.Where,
		node.GroupBy, node.Having, node.OrderBy,
		node.Limit, node.Lock.ToString(), node.Into)
}

// Format formats the node.
func (node *ParenSelect) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "(%v)", node.Select)
}

// Format formats the node.
func (node *Union) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "%v", node.FirstStatement)
	for _, us := range node.UnionSelects {
		buf.astPrintf(node, "%v", us)
	}
	buf.astPrintf(node, "%v%v%s", node.OrderBy, node.Limit, node.Lock.ToString())
}

// Format formats the node.
func (node *UnionSelect) Format(buf *TrackedBuffer) {
	if node.Distinct {
		buf.astPrintf(node, " %s %v", UnionStr, node.Statement)
	} else {
		buf.astPrintf(node, " %s %v", UnionAllStr, node.Statement)
	}
}

// Format formats the node.
func (node *VStream) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "vstream %v%v from %v",
		node.Comments, node.SelectExpr, node.Table)
}

// Format formats the node.
func (node *Stream) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "stream %v%v from %v",
		node.Comments, node.SelectExpr, node.Table)
}

// Format formats the node.
func (node *Insert) Format(buf *TrackedBuffer) {
	switch node.Action {
	case InsertAct:
		buf.astPrintf(node, "%s %v%sinto %v%v%v %v%v",
			InsertStr,
			node.Comments, node.Ignore.ToString(),
			node.Table, node.Partitions, node.Columns, node.Rows, node.OnDup)
	case ReplaceAct:
		buf.astPrintf(node, "%s %v%sinto %v%v%v %v%v",
			ReplaceStr,
			node.Comments, node.Ignore.ToString(),
			node.Table, node.Partitions, node.Columns, node.Rows, node.OnDup)
	default:
		buf.astPrintf(node, "%s %v%sinto %v%v%v %v%v",
			"Unkown Insert Action",
			node.Comments, node.Ignore.ToString(),
			node.Table, node.Partitions, node.Columns, node.Rows, node.OnDup)
	}

}

// Format formats the node.
func (node *Update) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "update %v%s%v set %v%v%v%v",
		node.Comments, node.Ignore.ToString(), node.TableExprs,
		node.Exprs, node.Where, node.OrderBy, node.Limit)
}

// Format formats the node.
func (node *Delete) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "delete %v", node.Comments)
	if node.Ignore {
		buf.WriteString("ignore ")
	}
	if node.Targets != nil {
		buf.astPrintf(node, "%v ", node.Targets)
	}
	buf.astPrintf(node, "from %v%v%v%v%v", node.TableExprs, node.Partitions, node.Where, node.OrderBy, node.Limit)
}

// Format formats the node.
func (node *Set) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "set %v%v", node.Comments, node.Exprs)
}

// Format formats the node.
func (node *SetTransaction) Format(buf *TrackedBuffer) {
	if node.Scope == ImplicitScope {
		buf.astPrintf(node, "set %vtransaction ", node.Comments)
	} else {
		buf.astPrintf(node, "set %v%s transaction ", node.Comments, node.Scope.ToString())
	}

	for i, char := range node.Characteristics {
		if i > 0 {
			buf.WriteString(", ")
		}
		buf.astPrintf(node, "%v", char)
	}
}

// Format formats the node.
func (node *DropDatabase) Format(buf *TrackedBuffer) {
	exists := ""
	if node.IfExists {
		exists = " if exists"
	}
	buf.WriteString(fmt.Sprintf("%s database%s %v", DropStr, exists, node.DBName))
}

// Format formats the node.
func (node *Flush) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "%s", FlushStr)
	if node.IsLocal {
		buf.WriteString(" local")
	}
	if len(node.FlushOptions) != 0 {
		prefix := " "
		for _, option := range node.FlushOptions {
			buf.astPrintf(node, "%s%s", prefix, option)
			prefix = ", "
		}
	} else {
		buf.WriteString(" tables")
		if len(node.TableNames) != 0 {
			buf.astPrintf(node, " %v", node.TableNames)
		}
		if node.ForExport {
			buf.WriteString(" for export")
		}
		if node.WithLock {
			buf.WriteString(" with read lock")
		}
	}
}

// Format formats the node.
func (node *AlterVschema) Format(buf *TrackedBuffer) {
	switch node.Action {
	case CreateVindexDDLAction:
		buf.astPrintf(node, "alter vschema create vindex %v %v", node.Table, node.VindexSpec)
	case DropVindexDDLAction:
		buf.astPrintf(node, "alter vschema drop vindex %v", node.Table)
	case AddVschemaTableDDLAction:
		buf.astPrintf(node, "alter vschema add table %v", node.Table)
	case DropVschemaTableDDLAction:
		buf.astPrintf(node, "alter vschema drop table %v", node.Table)
	case AddColVindexDDLAction:
		buf.astPrintf(node, "alter vschema on %v add vindex %v (", node.Table, node.VindexSpec.Name)
		for i, col := range node.VindexCols {
			if i != 0 {
				buf.astPrintf(node, ", %v", col)
			} else {
				buf.astPrintf(node, "%v", col)
			}
		}
		buf.astPrintf(node, ")")
		if node.VindexSpec.Type.String() != "" {
			buf.astPrintf(node, " %v", node.VindexSpec)
		}
	case DropColVindexDDLAction:
		buf.astPrintf(node, "alter vschema on %v drop vindex %v", node.Table, node.VindexSpec.Name)
	case AddSequenceDDLAction:
		buf.astPrintf(node, "alter vschema add sequence %v", node.Table)
	case AddAutoIncDDLAction:
		buf.astPrintf(node, "alter vschema on %v add auto_increment %v", node.Table, node.AutoIncSpec)
	default:
		buf.astPrintf(node, "%s table %v", node.Action.ToString(), node.Table)
	}
}

// Format formats the node.
func (node *OptLike) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "like %v", node.LikeTable)
}

// Format formats the node.
func (node *PartitionSpec) Format(buf *TrackedBuffer) {
	switch node.Action {
	case ReorganizeAction:
		buf.astPrintf(node, "%s ", ReorganizeStr)
		prefix := ""
		for _, n := range node.Names {
			buf.astPrintf(node, "%s%v", prefix, n)
			prefix = ", "
		}
		buf.WriteString(" into (")
		prefix = ""
		for _, pd := range node.Definitions {
			buf.astPrintf(node, "%s%v", prefix, pd)
			prefix = ", "
		}
		buf.astPrintf(node, ")")
	case AddAction:
		buf.astPrintf(node, "%s (%v)", AddStr, node.Definitions[0])
	case DropAction:
		buf.astPrintf(node, "%s ", DropPartitionStr)
		prefix := ""
		for _, n := range node.Names {
			buf.astPrintf(node, "%s%v", prefix, n)
			prefix = ", "
		}
	case DiscardAction:
		buf.astPrintf(node, "%s ", DiscardStr)
		if node.IsAll {
			buf.WriteString("all")
		} else {
			prefix := ""
			for _, n := range node.Names {
				buf.astPrintf(node, "%s%v", prefix, n)
				prefix = ", "
			}
		}
		buf.WriteString(" tablespace")
	case ImportAction:
		buf.astPrintf(node, "%s ", ImportStr)
		if node.IsAll {
			buf.WriteString("all")
		} else {
			prefix := ""
			for _, n := range node.Names {
				buf.astPrintf(node, "%s%v", prefix, n)
				prefix = ", "
			}
		}
		buf.WriteString(" tablespace")
	case TruncateAction:
		buf.astPrintf(node, "%s ", TruncatePartitionStr)
		if node.IsAll {
			buf.WriteString("all")
		} else {
			prefix := ""
			for _, n := range node.Names {
				buf.astPrintf(node, "%s%v", prefix, n)
				prefix = ", "
			}
		}
	case CoalesceAction:
		buf.astPrintf(node, "%s %v", CoalesceStr, node.Number)
	case ExchangeAction:
		buf.astPrintf(node, "%s %v with table %v", ExchangeStr, node.Names[0], node.TableName)
		if node.WithoutValidation {
			buf.WriteString(" without validation")
		}
	case AnalyzeAction:
		buf.astPrintf(node, "%s ", AnalyzePartitionStr)
		if node.IsAll {
			buf.WriteString("all")
		} else {
			prefix := ""
			for _, n := range node.Names {
				buf.astPrintf(node, "%s%v", prefix, n)
				prefix = ", "
			}
		}
	case CheckAction:
		buf.astPrintf(node, "%s ", CheckStr)
		if node.IsAll {
			buf.WriteString("all")
		} else {
			prefix := ""
			for _, n := range node.Names {
				buf.astPrintf(node, "%s%v", prefix, n)
				prefix = ", "
			}
		}
	case OptimizeAction:
		buf.astPrintf(node, "%s ", OptimizeStr)
		if node.IsAll {
			buf.WriteString("all")
		} else {
			prefix := ""
			for _, n := range node.Names {
				buf.astPrintf(node, "%s%v", prefix, n)
				prefix = ", "
			}
		}
	case RebuildAction:
		buf.astPrintf(node, "%s ", RebuildStr)
		if node.IsAll {
			buf.WriteString("all")
		} else {
			prefix := ""
			for _, n := range node.Names {
				buf.astPrintf(node, "%s%v", prefix, n)
				prefix = ", "
			}
		}
	case RepairAction:
		buf.astPrintf(node, "%s ", RepairStr)
		if node.IsAll {
			buf.WriteString("all")
		} else {
			prefix := ""
			for _, n := range node.Names {
				buf.astPrintf(node, "%s%v", prefix, n)
				prefix = ", "
			}
		}
	case RemoveAction:
		buf.WriteString(RemoveStr)
	case UpgradeAction:
		buf.WriteString(UpgradeStr)
	default:
		panic("unimplemented")
	}
}

// Format formats the node
func (node *PartitionDefinition) Format(buf *TrackedBuffer) {
	if !node.Maxvalue {
		buf.astPrintf(node, "partition %v values less than (%v)", node.Name, node.Limit)
	} else {
		buf.astPrintf(node, "partition %v values less than (maxvalue)", node.Name)
	}
}

// Format formats the node.
func (ts *TableSpec) Format(buf *TrackedBuffer) {
	buf.astPrintf(ts, "(\n")
	for i, col := range ts.Columns {
		if i == 0 {
			buf.astPrintf(ts, "\t%v", col)
		} else {
			buf.astPrintf(ts, ",\n\t%v", col)
		}
	}
	for _, idx := range ts.Indexes {
		buf.astPrintf(ts, ",\n\t%v", idx)
	}
	for _, c := range ts.Constraints {
		buf.astPrintf(ts, ",\n\t%v", c)
	}

	buf.astPrintf(ts, "\n)")
	for i, opt := range ts.Options {
		if i != 0 {
			buf.WriteString(",\n ")
		}
		buf.astPrintf(ts, " %s", opt.Name)
		if opt.String != "" {
			buf.astPrintf(ts, " %s", opt.String)
		} else if opt.Value != nil {
			buf.astPrintf(ts, " %v", opt.Value)
		} else {
			buf.astPrintf(ts, " (%v)", opt.Tables)
		}
	}
}

// Format formats the node.
func (col *ColumnDefinition) Format(buf *TrackedBuffer) {
	buf.astPrintf(col, "%v %v", col.Name, &col.Type)
}

// Format returns a canonical string representation of the type and all relevant options
func (ct *ColumnType) Format(buf *TrackedBuffer) {
	buf.astPrintf(ct, "%s", ct.Type)

	if ct.Length != nil && ct.Scale != nil {
		buf.astPrintf(ct, "(%v,%v)", ct.Length, ct.Scale)

	} else if ct.Length != nil {
		buf.astPrintf(ct, "(%v)", ct.Length)
	}

	if ct.EnumValues != nil {
		buf.astPrintf(ct, "(%s)", strings.Join(ct.EnumValues, ", "))
	}

	opts := make([]string, 0, 16)
	if ct.Unsigned {
		opts = append(opts, keywordStrings[UNSIGNED])
	}
	if ct.Zerofill {
		opts = append(opts, keywordStrings[ZEROFILL])
	}
	if ct.Charset != "" {
		opts = append(opts, keywordStrings[CHARACTER], keywordStrings[SET], ct.Charset)
	}
	if ct.Collate != "" {
		opts = append(opts, keywordStrings[COLLATE], ct.Collate)
	}
	if ct.NotNull {
		opts = append(opts, keywordStrings[NOT], keywordStrings[NULL])
	}
	if ct.Default != nil {
		opts = append(opts, keywordStrings[DEFAULT], String(ct.Default))
	}
	if ct.OnUpdate != nil {
		opts = append(opts, keywordStrings[ON], keywordStrings[UPDATE], String(ct.OnUpdate))
	}
	if ct.Autoincrement {
		opts = append(opts, keywordStrings[AUTO_INCREMENT])
	}
	if ct.Comment != nil {
		opts = append(opts, keywordStrings[COMMENT_KEYWORD], String(ct.Comment))
	}
	if ct.KeyOpt == colKeyPrimary {
		opts = append(opts, keywordStrings[PRIMARY], keywordStrings[KEY])
	}
	if ct.KeyOpt == colKeyUnique {
		opts = append(opts, keywordStrings[UNIQUE])
	}
	if ct.KeyOpt == colKeyUniqueKey {
		opts = append(opts, keywordStrings[UNIQUE], keywordStrings[KEY])
	}
	if ct.KeyOpt == colKeySpatialKey {
		opts = append(opts, keywordStrings[SPATIAL], keywordStrings[KEY])
	}
	if ct.KeyOpt == colKeyFulltextKey {
		opts = append(opts, keywordStrings[FULLTEXT], keywordStrings[KEY])
	}
	if ct.KeyOpt == colKey {
		opts = append(opts, keywordStrings[KEY])
	}

	if len(opts) != 0 {
		buf.astPrintf(ct, " %s", strings.Join(opts, " "))
	}
}

// Format formats the node.
func (idx *IndexDefinition) Format(buf *TrackedBuffer) {
	buf.astPrintf(idx, "%v (", idx.Info)
	for i, col := range idx.Columns {
		if i != 0 {
			buf.astPrintf(idx, ", %v", col.Column)
		} else {
			buf.astPrintf(idx, "%v", col.Column)
		}
		if col.Length != nil {
			buf.astPrintf(idx, "(%v)", col.Length)
		}
		if col.Direction == DescOrder {
			buf.astPrintf(idx, " desc")
		}
	}
	buf.astPrintf(idx, ")")

	for _, opt := range idx.Options {
		buf.astPrintf(idx, " %s", opt.Name)
		if opt.String != "" {
			buf.astPrintf(idx, " %s", opt.String)
		} else {
			buf.astPrintf(idx, " %v", opt.Value)
		}
	}
}

// Format formats the node.
func (ii *IndexInfo) Format(buf *TrackedBuffer) {
	if !ii.ConstraintName.IsEmpty() {
		buf.astPrintf(ii, "constraint %v ", ii.ConstraintName)
	}
	if ii.Primary {
		buf.astPrintf(ii, "%s", ii.Type)
	} else {
		buf.astPrintf(ii, "%s", ii.Type)
		if !ii.Name.IsEmpty() {
			buf.astPrintf(ii, " %v", ii.Name)
		}
	}
}

// Format formats the node.
func (node *AutoIncSpec) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "%v ", node.Column)
	buf.astPrintf(node, "using %v", node.Sequence)
}

// Format formats the node. The "CREATE VINDEX" preamble was formatted in
// the containing DDL node Format, so this just prints the type, any
// parameters, and optionally the owner
func (node *VindexSpec) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "using %v", node.Type)

	numParams := len(node.Params)
	if numParams != 0 {
		buf.astPrintf(node, " with ")
		for i, p := range node.Params {
			if i != 0 {
				buf.astPrintf(node, ", ")
			}
			buf.astPrintf(node, "%v", p)
		}
	}
}

// Format formats the node.
func (node VindexParam) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "%s=%s", node.Key.String(), node.Val)
}

// Format formats the node.
func (c *ConstraintDefinition) Format(buf *TrackedBuffer) {
	if c.Name != "" {
		buf.astPrintf(c, "constraint %s ", c.Name)
	}
	c.Details.Format(buf)
}

// Format formats the node.
func (a ReferenceAction) Format(buf *TrackedBuffer) {
	switch a {
	case Restrict:
		buf.WriteString("restrict")
	case Cascade:
		buf.WriteString("cascade")
	case NoAction:
		buf.WriteString("no action")
	case SetNull:
		buf.WriteString("set null")
	case SetDefault:
		buf.WriteString("set default")
	}
}

// Format formats the node.
func (f *ForeignKeyDefinition) Format(buf *TrackedBuffer) {
	buf.astPrintf(f, "foreign key %v references %v %v", f.Source, f.ReferencedTable, f.ReferencedColumns)
	if f.OnDelete != DefaultAction {
		buf.astPrintf(f, " on delete %v", f.OnDelete)
	}
	if f.OnUpdate != DefaultAction {
		buf.astPrintf(f, " on update %v", f.OnUpdate)
	}
}

// Format formats the node.
func (c *CheckConstraintDefinition) Format(buf *TrackedBuffer) {
	buf.astPrintf(c, "check (%v)", c.Expr)
	if c.Enforced {
		buf.astPrintf(c, " enforced")
	} else {
		buf.astPrintf(c, " not enforced")
	}
}

// Format formats the node.
func (node *Show) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "%v", node.Internal)
}

// Format formats the node.
func (node *ShowColumns) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "show %s", node.Full)
	buf.astPrintf(node, "columns from %v", node.Table)

	buf.printIf(node.DbName != "", " from "+node.DbName)
	if node.Filter != nil {
		buf.astPrintf(node, "%v", node.Filter)
	}
}

// Format formats the node.
func (node *ShowLegacy) Format(buf *TrackedBuffer) {
	nodeType := strings.ToLower(node.Type)
	if (nodeType == "tables" || nodeType == "columns" || nodeType == "fields" || nodeType == "index" || nodeType == "keys" || nodeType == "indexes" ||
		nodeType == "databases" || nodeType == "schemas" || nodeType == "keyspaces" || nodeType == "vitess_keyspaces" || nodeType == "vitess_shards" || nodeType == "vitess_tablets") && node.ShowTablesOpt != nil {
		opt := node.ShowTablesOpt
		if node.Extended != "" {
			buf.astPrintf(node, "show %s%s", node.Extended, nodeType)
		} else {
			buf.astPrintf(node, "show %s%s", opt.Full, nodeType)
		}
		if (nodeType == "columns" || nodeType == "fields") && node.HasOnTable() {
			buf.astPrintf(node, " from %v", node.OnTable)
		}
		if (nodeType == "index" || nodeType == "keys" || nodeType == "indexes") && node.HasOnTable() {
			buf.astPrintf(node, " from %v", node.OnTable)
		}
		if opt.DbName != "" {
			buf.astPrintf(node, " from %s", opt.DbName)
		}
		buf.astPrintf(node, "%v", opt.Filter)
		return
	}
	if node.Scope == ImplicitScope {
		buf.astPrintf(node, "show %s", nodeType)
	} else {
		buf.astPrintf(node, "show %s %s", node.Scope.ToString(), nodeType)
	}
	if node.HasOnTable() {
		buf.astPrintf(node, " on %v", node.OnTable)
	}
	if nodeType == "collation" && node.ShowCollationFilterOpt != nil {
		buf.astPrintf(node, " where %v", node.ShowCollationFilterOpt)
	}
	if nodeType == "charset" && node.ShowTablesOpt != nil {
		buf.astPrintf(node, "%v", node.ShowTablesOpt.Filter)
	}
	if node.HasTable() {
		buf.astPrintf(node, " %v", node.Table)
	}
}

// Format formats the node.
func (node *ShowFilter) Format(buf *TrackedBuffer) {
	if node == nil {
		return
	}
	if node.Like != "" {
		buf.astPrintf(node, " like '%s'", node.Like)
	} else {
		buf.astPrintf(node, " where %v", node.Filter)
	}
}

// Format formats the node.
func (node *Use) Format(buf *TrackedBuffer) {
	if node.DBName.v != "" {
		buf.astPrintf(node, "use %v", node.DBName)
	} else {
		buf.astPrintf(node, "use")
	}
}

// Format formats the node.
func (node *Commit) Format(buf *TrackedBuffer) {
	buf.WriteString("commit")
}

// Format formats the node.
func (node *Begin) Format(buf *TrackedBuffer) {
	buf.WriteString("begin")
}

// Format formats the node.
func (node *Rollback) Format(buf *TrackedBuffer) {
	buf.WriteString("rollback")
}

// Format formats the node.
func (node *SRollback) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "rollback to %v", node.Name)
}

// Format formats the node.
func (node *Savepoint) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "savepoint %v", node.Name)
}

// Format formats the node.
func (node *Release) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "release savepoint %v", node.Name)
}

// Format formats the node.
func (node *Explain) Format(buf *TrackedBuffer) {
	format := ""
	switch node.Type {
	case EmptyType: // do nothing
	case AnalyzeType:
		format = AnalyzeStr + " "
	default:
		format = "format = " + node.Type.ToString() + " "
	}
	buf.astPrintf(node, "explain %s%v", format, node.Statement)
}

// Format formats the node.
func (node *OtherRead) Format(buf *TrackedBuffer) {
	buf.WriteString("otherread")
}

// Format formats the node.
func (node *OtherAdmin) Format(buf *TrackedBuffer) {
	buf.WriteString("otheradmin")
}

// Format formats the node.
func (node Comments) Format(buf *TrackedBuffer) {
	for _, c := range node {
		buf.astPrintf(node, "%s ", c)
	}
}

// Format formats the node.
func (node SelectExprs) Format(buf *TrackedBuffer) {
	var prefix string
	for _, n := range node {
		buf.astPrintf(node, "%s%v", prefix, n)
		prefix = ", "
	}
}

// Format formats the node.
func (node *StarExpr) Format(buf *TrackedBuffer) {
	if !node.TableName.IsEmpty() {
		buf.astPrintf(node, "%v.", node.TableName)
	}
	buf.astPrintf(node, "*")
}

// Format formats the node.
func (node *AliasedExpr) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "%v", node.Expr)
	if !node.As.IsEmpty() {
		buf.astPrintf(node, " as %v", node.As)
	}
}

// Format formats the node.
func (node Nextval) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "next %v values", node.Expr)
}

// Format formats the node.
func (node Columns) Format(buf *TrackedBuffer) {
	if node == nil {
		return
	}
	prefix := "("
	for _, n := range node {
		buf.astPrintf(node, "%s%v", prefix, n)
		prefix = ", "
	}
	buf.WriteString(")")
}

// Format formats the node
func (node Partitions) Format(buf *TrackedBuffer) {
	if node == nil {
		return
	}
	prefix := " partition ("
	for _, n := range node {
		buf.astPrintf(node, "%s%v", prefix, n)
		prefix = ", "
	}
	buf.WriteString(")")
}

// Format formats the node.
func (node TableExprs) Format(buf *TrackedBuffer) {
	var prefix string
	for _, n := range node {
		buf.astPrintf(node, "%s%v", prefix, n)
		prefix = ", "
	}
}

// Format formats the node.
func (node *AliasedTableExpr) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "%v%v", node.Expr, node.Partitions)
	if !node.As.IsEmpty() {
		buf.astPrintf(node, " as %v", node.As)
	}
	if node.Hints != nil {
		// Hint node provides the space padding.
		buf.astPrintf(node, "%v", node.Hints)
	}
}

// Format formats the node.
func (node TableNames) Format(buf *TrackedBuffer) {
	var prefix string
	for _, n := range node {
		buf.astPrintf(node, "%s%v", prefix, n)
		prefix = ", "
	}
}

// Format formats the node.
func (node TableName) Format(buf *TrackedBuffer) {
	if node.IsEmpty() {
		return
	}
	if !node.Qualifier.IsEmpty() {
		buf.astPrintf(node, "%v.", node.Qualifier)
	}
	buf.astPrintf(node, "%v", node.Name)
}

// Format formats the node.
func (node *ParenTableExpr) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "(%v)", node.Exprs)
}

// Format formats the node.
func (node JoinCondition) Format(buf *TrackedBuffer) {
	if node.On != nil {
		buf.astPrintf(node, " on %v", node.On)
	}
	if node.Using != nil {
		buf.astPrintf(node, " using %v", node.Using)
	}
}

// Format formats the node.
func (node *JoinTableExpr) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "%v %s %v%v", node.LeftExpr, node.Join.ToString(), node.RightExpr, node.Condition)
}

// Format formats the node.
func (node *IndexHints) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, " %sindex ", node.Type.ToString())
	if len(node.Indexes) == 0 {
		buf.astPrintf(node, "()")
	} else {
		prefix := "("
		for _, n := range node.Indexes {
			buf.astPrintf(node, "%s%v", prefix, n)
			prefix = ", "
		}
		buf.astPrintf(node, ")")
	}
}

// Format formats the node.
func (node *Where) Format(buf *TrackedBuffer) {
	if node == nil || node.Expr == nil {
		return
	}
	buf.astPrintf(node, " %s %v", node.Type.ToString(), node.Expr)
}

// Format formats the node.
func (node Exprs) Format(buf *TrackedBuffer) {
	var prefix string
	for _, n := range node {
		buf.astPrintf(node, "%s%v", prefix, n)
		prefix = ", "
	}
}

// Format formats the node.
func (node *AndExpr) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "%l and %r", node.Left, node.Right)
}

// Format formats the node.
func (node *OrExpr) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "%l or %r", node.Left, node.Right)
}

// Format formats the node.
func (node *XorExpr) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "%l xor %r", node.Left, node.Right)
}

// Format formats the node.
func (node *NotExpr) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "not %v", node.Expr)
}

// Format formats the node.
func (node *ComparisonExpr) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "%l %s %r", node.Left, node.Operator.ToString(), node.Right)
	if node.Escape != nil {
		buf.astPrintf(node, " escape %v", node.Escape)
	}
}

// Format formats the node.
func (node *RangeCond) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "%v %s %l and %r", node.Left, node.Operator.ToString(), node.From, node.To)
}

// Format formats the node.
func (node *IsExpr) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "%v %s", node.Expr, node.Operator.ToString())
}

// Format formats the node.
func (node *ExistsExpr) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "exists %v", node.Subquery)
}

// Format formats the node.
func (node *Literal) Format(buf *TrackedBuffer) {
	switch node.Type {
	case StrVal:
		sqltypes.MakeTrusted(sqltypes.VarBinary, node.Val).EncodeSQL(buf)
	case IntVal, FloatVal, HexNum:
		buf.astPrintf(node, "%s", node.Val)
	case HexVal:
		buf.astPrintf(node, "X'%s'", node.Val)
	case BitVal:
		buf.astPrintf(node, "B'%s'", node.Val)
	default:
		panic("unexpected")
	}
}

// Format formats the node.
func (node Argument) Format(buf *TrackedBuffer) {
	buf.WriteArg(string(node))
}

// Format formats the node.
func (node *NullVal) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "null")
}

// Format formats the node.
func (node BoolVal) Format(buf *TrackedBuffer) {
	if node {
		buf.astPrintf(node, "true")
	} else {
		buf.astPrintf(node, "false")
	}
}

// Format formats the node.
func (node *ColName) Format(buf *TrackedBuffer) {
	if !node.Qualifier.IsEmpty() {
		buf.astPrintf(node, "%v.", node.Qualifier)
	}
	buf.astPrintf(node, "%v", node.Name)
}

// Format formats the node.
func (node ValTuple) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "(%v)", Exprs(node))
}

// Format formats the node.
func (node *Subquery) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "(%v)", node.Select)
}

// Format formats the node.
func (node *DerivedTable) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "(%v)", node.Select)
}

// Format formats the node.
func (node ListArg) Format(buf *TrackedBuffer) {
	buf.WriteArg(string(node))
}

// Format formats the node.
func (node *BinaryExpr) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "%l %s %r", node.Left, node.Operator.ToString(), node.Right)
}

// Format formats the node.
func (node *UnaryExpr) Format(buf *TrackedBuffer) {
	if _, unary := node.Expr.(*UnaryExpr); unary {
		// They have same precedence so parenthesis is not required.
		buf.astPrintf(node, "%s %v", node.Operator.ToString(), node.Expr)
		return
	}
	buf.astPrintf(node, "%s%v", node.Operator.ToString(), node.Expr)
}

// Format formats the node.
func (node *IntervalExpr) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "interval %v %s", node.Expr, node.Unit)
}

// Format formats the node.
func (node *TimestampFuncExpr) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "%s(%s, %v, %v)", node.Name, node.Unit, node.Expr1, node.Expr2)
}

// Format formats the node.
func (node *CurTimeFuncExpr) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "%s(%v)", node.Name.String(), node.Fsp)
}

// Format formats the node.
func (node *CollateExpr) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "%v collate %s", node.Expr, node.Charset)
}

// Format formats the node.
func (node *FuncExpr) Format(buf *TrackedBuffer) {
	var distinct string
	if node.Distinct {
		distinct = "distinct "
	}
	if !node.Qualifier.IsEmpty() {
		buf.astPrintf(node, "%v.", node.Qualifier)
	}
	// Function names should not be back-quoted even
	// if they match a reserved word, only if they contain illegal characters
	funcName := node.Name.String()

	if containEscapableChars(funcName, NoAt) {
		writeEscapedString(buf, funcName)
	} else {
		buf.WriteString(funcName)
	}
	buf.astPrintf(node, "(%s%v)", distinct, node.Exprs)
}

// Format formats the node
func (node *GroupConcatExpr) Format(buf *TrackedBuffer) {
	if node.Distinct {
		buf.astPrintf(node, "group_concat(%s%v%v%s%v)", DistinctStr, node.Exprs, node.OrderBy, node.Separator, node.Limit)
	} else {
		buf.astPrintf(node, "group_concat(%v%v%s%v)", node.Exprs, node.OrderBy, node.Separator, node.Limit)
	}
}

// Format formats the node.
func (node *ValuesFuncExpr) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "values(%v)", node.Name)
}

// Format formats the node.
func (node *SubstrExpr) Format(buf *TrackedBuffer) {
	var val interface{}
	if node.Name != nil {
		val = node.Name
	} else {
		val = node.StrVal
	}

	if node.To == nil {
		buf.astPrintf(node, "substr(%v, %v)", val, node.From)
	} else {
		buf.astPrintf(node, "substr(%v, %v, %v)", val, node.From, node.To)
	}
}

// Format formats the node.
func (node *ConvertExpr) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "convert(%v, %v)", node.Expr, node.Type)
}

// Format formats the node.
func (node *ConvertUsingExpr) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "convert(%v using %s)", node.Expr, node.Type)
}

// Format formats the node.
func (node *ConvertType) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "%s", node.Type)
	if node.Length != nil {
		buf.astPrintf(node, "(%v", node.Length)
		if node.Scale != nil {
			buf.astPrintf(node, ", %v", node.Scale)
		}
		buf.astPrintf(node, ")")
	}
	if node.Charset != "" {
		buf.astPrintf(node, "%s %s", node.Operator.ToString(), node.Charset)
	}
}

// Format formats the node
func (node *MatchExpr) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "match(%v) against (%v%s)", node.Columns, node.Expr, node.Option.ToString())
}

// Format formats the node.
func (node *CaseExpr) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "case ")
	if node.Expr != nil {
		buf.astPrintf(node, "%v ", node.Expr)
	}
	for _, when := range node.Whens {
		buf.astPrintf(node, "%v ", when)
	}
	if node.Else != nil {
		buf.astPrintf(node, "else %v ", node.Else)
	}
	buf.astPrintf(node, "end")
}

// Format formats the node.
func (node *Default) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "default")
	if node.ColName != "" {
		buf.WriteString("(")
		formatID(buf, node.ColName, strings.ToLower(node.ColName), NoAt)
		buf.WriteString(")")
	}
}

// Format formats the node.
func (node *When) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "when %v then %v", node.Cond, node.Val)
}

// Format formats the node.
func (node GroupBy) Format(buf *TrackedBuffer) {
	prefix := " group by "
	for _, n := range node {
		buf.astPrintf(node, "%s%v", prefix, n)
		prefix = ", "
	}
}

// Format formats the node.
func (node OrderBy) Format(buf *TrackedBuffer) {
	prefix := " order by "
	for _, n := range node {
		buf.astPrintf(node, "%s%v", prefix, n)
		prefix = ", "
	}
}

// Format formats the node.
func (node *Order) Format(buf *TrackedBuffer) {
	if node, ok := node.Expr.(*NullVal); ok {
		buf.astPrintf(node, "%v", node)
		return
	}
	if node, ok := node.Expr.(*FuncExpr); ok {
		if node.Name.Lowered() == "rand" {
			buf.astPrintf(node, "%v", node)
			return
		}
	}

	buf.astPrintf(node, "%v %s", node.Expr, node.Direction.ToString())
}

// Format formats the node.
func (node *Limit) Format(buf *TrackedBuffer) {
	if node == nil {
		return
	}
	buf.astPrintf(node, " limit ")
	if node.Offset != nil {
		buf.astPrintf(node, "%v, ", node.Offset)
	}
	buf.astPrintf(node, "%v", node.Rowcount)
}

// Format formats the node.
func (node Values) Format(buf *TrackedBuffer) {
	prefix := "values "
	for _, n := range node {
		buf.astPrintf(node, "%s%v", prefix, n)
		prefix = ", "
	}
}

// Format formats the node.
func (node UpdateExprs) Format(buf *TrackedBuffer) {
	var prefix string
	for _, n := range node {
		buf.astPrintf(node, "%s%v", prefix, n)
		prefix = ", "
	}
}

// Format formats the node.
func (node *UpdateExpr) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "%v = %v", node.Name, node.Expr)
}

// Format formats the node.
func (node SetExprs) Format(buf *TrackedBuffer) {
	var prefix string
	for _, n := range node {
		buf.astPrintf(node, "%s%v", prefix, n)
		prefix = ", "
	}
}

// Format formats the node.
func (node *SetExpr) Format(buf *TrackedBuffer) {
	if node.Scope != ImplicitScope {
		buf.WriteString(node.Scope.ToString())
		buf.WriteString(" ")
	}
	// We don't have to backtick set variable names.
	switch {
	case node.Name.EqualString("charset") || node.Name.EqualString("names"):
		buf.astPrintf(node, "%s %v", node.Name.String(), node.Expr)
	case node.Name.EqualString(TransactionStr):
		literal := node.Expr.(*Literal)
		buf.astPrintf(node, "%s %s", node.Name.String(), strings.ToLower(string(literal.Val)))
	default:
		buf.astPrintf(node, "%v = %v", node.Name, node.Expr)
	}
}

// Format formats the node.
func (node OnDup) Format(buf *TrackedBuffer) {
	if node == nil {
		return
	}
	buf.astPrintf(node, " on duplicate key update %v", UpdateExprs(node))
}

// Format formats the node.
func (node ColIdent) Format(buf *TrackedBuffer) {
	for i := NoAt; i < node.at; i++ {
		buf.WriteByte('@')
	}
	formatID(buf, node.val, node.Lowered(), node.at)
}

// Format formats the node.
func (node TableIdent) Format(buf *TrackedBuffer) {
	formatID(buf, node.v, strings.ToLower(node.v), NoAt)
}

// AtCount return the '@' count present in ColIdent Name
func (node ColIdent) AtCount() AtCount {
	return node.at
}

func (IsolationLevel) iChar() {}
func (AccessMode) iChar()     {}

// Format formats the node.
func (node IsolationLevel) Format(buf *TrackedBuffer) {
	buf.WriteString("isolation level ")
	switch node {
	case ReadUncommitted:
		buf.WriteString(ReadUncommittedStr)
	case ReadCommitted:
		buf.WriteString(ReadCommittedStr)
	case RepeatableRead:
		buf.WriteString(RepeatableReadStr)
	case Serializable:
		buf.WriteString(SerializableStr)
	default:
		buf.WriteString("Unknown Isolation level value")
	}
}

// Format formats the node.
func (node AccessMode) Format(buf *TrackedBuffer) {
	if node == ReadOnly {
		buf.WriteString(TxReadOnly)
	} else {
		buf.WriteString(TxReadWrite)
	}
}

// Format formats the node.
func (node *Load) Format(buf *TrackedBuffer) {
	buf.WriteString("AST node missing for Load type")
}

// Format formats the node.
func (node *ShowTableStatus) Format(buf *TrackedBuffer) {
	buf.WriteString("show table status")
	if node.DatabaseName != "" {
		buf.WriteString(" from ")
		buf.WriteString(node.DatabaseName)
	}
	buf.astPrintf(node, "%v", node.Filter)
}

// Format formats the node.
func (node *ShowBasic) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "show%s%v", node.Command.ToString(), node.Filter)
}

// Format formats the node.
func (node *SelectInto) Format(buf *TrackedBuffer) {
	if node == nil {
		return
	}
	buf.astPrintf(node, "%s'%s'", node.Type.ToString(), node.FileName)
	if node.Charset != "" {
		buf.astPrintf(node, " character set %s", node.Charset)
	}
	buf.astPrintf(node, "%s%s%s%s", node.FormatOption, node.ExportOption, node.Manifest, node.Overwrite)
}

// Format formats the node.
func (node *CreateDatabase) Format(buf *TrackedBuffer) {
	buf.WriteString("create database")
	if node.IfNotExists {
		buf.WriteString(" if not exists")
	}
	buf.astPrintf(node, " %s", node.DBName)
	if node.CreateOptions != nil {
		for _, createOption := range node.CreateOptions {
			if createOption.IsDefault {
				buf.WriteString(" default")
			}
			buf.WriteString(createOption.Type.ToString())
			buf.WriteString(" " + createOption.Value)
		}
	}
}

// Format formats the node.
func (node *AlterDatabase) Format(buf *TrackedBuffer) {
	buf.WriteString("alter database")
	if node.DBName != "" {
		buf.astPrintf(node, " %s", node.DBName)
	}
	if node.UpdateDataDirectory {
		buf.WriteString(" upgrade data directory name")
	}
	if node.AlterOptions != nil {
		for _, createOption := range node.AlterOptions {
			if createOption.IsDefault {
				buf.WriteString(" default")
			}
			buf.WriteString(createOption.Type.ToString())
			buf.WriteString(" " + createOption.Value)
		}
	}
}

// Format formats the node.
func (node *CreateTable) Format(buf *TrackedBuffer) {
	if node.IfNotExists {
		buf.astPrintf(node, "create table if not exists %v", node.Table)
	} else {
		buf.astPrintf(node, "create table %v", node.Table)
	}
	if node.OptLike != nil {
		buf.astPrintf(node, " %v", node.OptLike)
	}
	if node.TableSpec != nil {
		buf.astPrintf(node, " %v", node.TableSpec)
	}
}

// Format formats the node.
func (node *CreateView) Format(buf *TrackedBuffer) {
	buf.WriteString("create")
	if node.IsReplace {
		buf.WriteString(" or replace")
	}
	if node.Algorithm != "" {
		buf.astPrintf(node, " algorithm = %s", node.Algorithm)
	}
	if node.Definer != "" {
		buf.astPrintf(node, " definer = %s", node.Definer)
	}
	if node.Security != "" {
		buf.astPrintf(node, " sql security %s", node.Security)
	}
	buf.astPrintf(node, " view %v", node.ViewName)
	buf.astPrintf(node, "%v as %v", node.Columns, node.Select)
	if node.CheckOption != "" {
		buf.astPrintf(node, " with %s check option", node.CheckOption)
	}
}

// Format formats the LockTables node.
func (node *LockTables) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "lock tables %v %s", node.Tables[0].Table, node.Tables[0].Lock.ToString())
	for i := 1; i < len(node.Tables); i++ {
		buf.astPrintf(node, ", %v %s", node.Tables[i].Table, node.Tables[i].Lock.ToString())
	}
}

// Format formats the UnlockTables node.
func (node *UnlockTables) Format(buf *TrackedBuffer) {
	buf.WriteString("unlock tables")
}

// Format formats the node.
func (node *AlterView) Format(buf *TrackedBuffer) {
	buf.WriteString("alter")
	if node.Algorithm != "" {
		buf.astPrintf(node, " algorithm = %s", node.Algorithm)
	}
	if node.Definer != "" {
		buf.astPrintf(node, " definer = %s", node.Definer)
	}
	if node.Security != "" {
		buf.astPrintf(node, " sql security %s", node.Security)
	}
	buf.astPrintf(node, " view %v", node.ViewName)
	buf.astPrintf(node, "%v as %v", node.Columns, node.Select)
	if node.CheckOption != "" {
		buf.astPrintf(node, " with %s check option", node.CheckOption)
	}
}

// Format formats the node.
func (node *DropTable) Format(buf *TrackedBuffer) {
	exists := ""
	if node.IfExists {
		exists = " if exists"
	}
	buf.astPrintf(node, "drop table%s %v", exists, node.FromTables)
}

// Format formats the node.
func (node *DropView) Format(buf *TrackedBuffer) {
	exists := ""
	if node.IfExists {
		exists = " if exists"
	}
	buf.astPrintf(node, "drop view%s %v", exists, node.FromTables)
}

// Format formats the AlterTable node.
func (node *AlterTable) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "alter table %v", node.Table)
	prefix := ""
	for i, option := range node.AlterOptions {
		if i != 0 {
			buf.WriteString(",")
		}
		buf.astPrintf(node, " %v", option)
		if node.PartitionSpec != nil && node.PartitionSpec.Action != RemoveAction {
			prefix = ","
		}
	}
	if node.PartitionSpec != nil {
		buf.astPrintf(node, "%s %v", prefix, node.PartitionSpec)
	}
}

// Format formats the node.
func (node *AddConstraintDefinition) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "add %v", node.ConstraintDefinition)
}

// Format formats the node.
func (node *AddIndexDefinition) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "add %v", node.IndexDefinition)
}

// Format formats the node.
func (node *AddColumns) Format(buf *TrackedBuffer) {

	if len(node.Columns) == 1 {
		buf.astPrintf(node, "add column %v", node.Columns[0])
		if node.First != nil {
			buf.astPrintf(node, " first %v", node.First)
		}
		if node.After != nil {
			buf.astPrintf(node, " after %v", node.After)
		}
	} else {
		for i, col := range node.Columns {
			if i == 0 {
				buf.astPrintf(node, "add column (%v", col)
			} else {
				buf.astPrintf(node, ", %v", col)
			}
		}
		buf.WriteString(")")
	}
}

// Format formats the node.
func (node AlgorithmValue) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "algorithm = %s", string(node))
}

// Format formats the node
func (node *AlterColumn) Format(buf *TrackedBuffer) {
	if node.DropDefault {
		buf.astPrintf(node, "alter column %v drop default", node.Column)
	} else {
		buf.astPrintf(node, "alter column %v set default", node.Column)
		buf.astPrintf(node, " %v", node.DefaultVal)
	}
}

// Format formats the node
func (node *ChangeColumn) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "change column %v %v", node.OldColumn, node.NewColDefinition)
	if node.First != nil {
		buf.astPrintf(node, " first %v", node.First)
	}
	if node.After != nil {
		buf.astPrintf(node, " after %v", node.After)
	}
}

// Format formats the node
func (node *ModifyColumn) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "modify column %v", node.NewColDefinition)
	if node.First != nil {
		buf.astPrintf(node, " first %v", node.First)
	}
	if node.After != nil {
		buf.astPrintf(node, " after %v", node.After)
	}
}

// Format formats the node
func (node *AlterCharset) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "convert to character set %s", node.CharacterSet)
	if node.Collate != "" {
		buf.astPrintf(node, " collate %s", node.Collate)
	}
}

// Format formats the node
func (node *KeyState) Format(buf *TrackedBuffer) {
	if node.Enable {
		buf.WriteString("enable keys")
	} else {
		buf.WriteString("disable keys")
	}

}

// Format formats the node
func (node *TablespaceOperation) Format(buf *TrackedBuffer) {
	if node.Import {
		buf.WriteString("import tablespace")
	} else {
		buf.WriteString("discard tablespace")
	}
}

// Format formats the node
func (node *DropColumn) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "drop column %v", node.Name)
}

// Format formats the node
func (node *DropKey) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "drop %s", node.Type.ToString())
	if node.Name != "" {
		buf.astPrintf(node, " %s", node.Name)
	}
}

// Format formats the node
func (node *Force) Format(buf *TrackedBuffer) {
	buf.WriteString("force")
}

// Format formats the node
func (node *LockOption) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "lock %s", node.Type.ToString())
}

// Format formats the node
func (node *OrderByOption) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "order by ")
	prefix := ""
	for _, n := range node.Cols {
		buf.astPrintf(node, "%s%v", prefix, n)
		prefix = ", "
	}
}

// Format formats the node
func (node *RenameTableName) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "rename %v", node.Table)
}

// Format formats the node
func (node *RenameIndex) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "rename index %s to %s", node.OldName, node.NewName)
}

// Format formats the node
func (node *Validation) Format(buf *TrackedBuffer) {
	if node.With {
		buf.WriteString("with validation")
	} else {
		buf.WriteString("without validation")
	}
}

// Format formats the node
func (node TableOptions) Format(buf *TrackedBuffer) {
	for i, option := range node {
		if i != 0 {
			buf.WriteString(" ")
		}
		buf.astPrintf(node, "%s", option.Name)
		if option.String != "" {
			buf.astPrintf(node, " %s", option.String)
		} else if option.Value != nil {
			buf.astPrintf(node, " %v", option.Value)
		} else {
			buf.astPrintf(node, " (%v)", option.Tables)
		}
	}
}

// Format formats the node
func (node *TruncateTable) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "truncate table %v", node.Table)
}

// Format formats the node.
func (node *RenameTable) Format(buf *TrackedBuffer) {
	buf.astPrintf(node, "rename table")
	prefix := " "
	for _, pair := range node.TablePairs {
		buf.astPrintf(node, "%s%v to %v", prefix, pair.FromTable, pair.ToTable)
		prefix = ", "
	}
}
