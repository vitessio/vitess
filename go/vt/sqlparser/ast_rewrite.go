/*
Copyright 2025 The Vitess Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
// Code generated by ASTHelperGen. DO NOT EDIT.

package sqlparser

// Function Generation Source: InterfaceMethod
func (a *application) rewriteSQLNode(parent SQLNode, node SQLNode, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	switch node := node.(type) {
	case *AddColumns:
		return a.rewriteRefOfAddColumns(parent, node, replacer)
	case *AddConstraintDefinition:
		return a.rewriteRefOfAddConstraintDefinition(parent, node, replacer)
	case *AddIndexDefinition:
		return a.rewriteRefOfAddIndexDefinition(parent, node, replacer)
	case AlgorithmValue:
		return a.rewriteAlgorithmValue(parent, node, replacer)
	case *AliasedExpr:
		return a.rewriteRefOfAliasedExpr(parent, node, replacer)
	case *AliasedTableExpr:
		return a.rewriteRefOfAliasedTableExpr(parent, node, replacer)
	case *AlterCharset:
		return a.rewriteRefOfAlterCharset(parent, node, replacer)
	case *AlterCheck:
		return a.rewriteRefOfAlterCheck(parent, node, replacer)
	case *AlterColumn:
		return a.rewriteRefOfAlterColumn(parent, node, replacer)
	case *AlterDatabase:
		return a.rewriteRefOfAlterDatabase(parent, node, replacer)
	case *AlterIndex:
		return a.rewriteRefOfAlterIndex(parent, node, replacer)
	case *AlterMigration:
		return a.rewriteRefOfAlterMigration(parent, node, replacer)
	case *AlterTable:
		return a.rewriteRefOfAlterTable(parent, node, replacer)
	case *AlterView:
		return a.rewriteRefOfAlterView(parent, node, replacer)
	case *AlterVschema:
		return a.rewriteRefOfAlterVschema(parent, node, replacer)
	case *Analyze:
		return a.rewriteRefOfAnalyze(parent, node, replacer)
	case *AndExpr:
		return a.rewriteRefOfAndExpr(parent, node, replacer)
	case *AnyValue:
		return a.rewriteRefOfAnyValue(parent, node, replacer)
	case *Argument:
		return a.rewriteRefOfArgument(parent, node, replacer)
	case *ArgumentLessWindowExpr:
		return a.rewriteRefOfArgumentLessWindowExpr(parent, node, replacer)
	case *AssignmentExpr:
		return a.rewriteRefOfAssignmentExpr(parent, node, replacer)
	case *AutoIncSpec:
		return a.rewriteRefOfAutoIncSpec(parent, node, replacer)
	case *Avg:
		return a.rewriteRefOfAvg(parent, node, replacer)
	case *Begin:
		return a.rewriteRefOfBegin(parent, node, replacer)
	case *BetweenExpr:
		return a.rewriteRefOfBetweenExpr(parent, node, replacer)
	case *BinaryExpr:
		return a.rewriteRefOfBinaryExpr(parent, node, replacer)
	case *BitAnd:
		return a.rewriteRefOfBitAnd(parent, node, replacer)
	case *BitOr:
		return a.rewriteRefOfBitOr(parent, node, replacer)
	case *BitXor:
		return a.rewriteRefOfBitXor(parent, node, replacer)
	case BoolVal:
		return a.rewriteBoolVal(parent, node, replacer)
	case *CallProc:
		return a.rewriteRefOfCallProc(parent, node, replacer)
	case *CaseExpr:
		return a.rewriteRefOfCaseExpr(parent, node, replacer)
	case *CastExpr:
		return a.rewriteRefOfCastExpr(parent, node, replacer)
	case *ChangeColumn:
		return a.rewriteRefOfChangeColumn(parent, node, replacer)
	case *CharExpr:
		return a.rewriteRefOfCharExpr(parent, node, replacer)
	case *CheckConstraintDefinition:
		return a.rewriteRefOfCheckConstraintDefinition(parent, node, replacer)
	case *ColName:
		return a.rewriteRefOfColName(parent, node, replacer)
	case *CollateExpr:
		return a.rewriteRefOfCollateExpr(parent, node, replacer)
	case *ColumnDefinition:
		return a.rewriteRefOfColumnDefinition(parent, node, replacer)
	case *ColumnType:
		return a.rewriteRefOfColumnType(parent, node, replacer)
	case Columns:
		return a.rewriteColumns(parent, node, replacer)
	case *CommentOnly:
		return a.rewriteRefOfCommentOnly(parent, node, replacer)
	case *Commit:
		return a.rewriteRefOfCommit(parent, node, replacer)
	case *CommonTableExpr:
		return a.rewriteRefOfCommonTableExpr(parent, node, replacer)
	case *ComparisonExpr:
		return a.rewriteRefOfComparisonExpr(parent, node, replacer)
	case *ConstraintDefinition:
		return a.rewriteRefOfConstraintDefinition(parent, node, replacer)
	case *ConvertExpr:
		return a.rewriteRefOfConvertExpr(parent, node, replacer)
	case *ConvertType:
		return a.rewriteRefOfConvertType(parent, node, replacer)
	case *ConvertUsingExpr:
		return a.rewriteRefOfConvertUsingExpr(parent, node, replacer)
	case *Count:
		return a.rewriteRefOfCount(parent, node, replacer)
	case *CountStar:
		return a.rewriteRefOfCountStar(parent, node, replacer)
	case *CreateDatabase:
		return a.rewriteRefOfCreateDatabase(parent, node, replacer)
	case *CreateTable:
		return a.rewriteRefOfCreateTable(parent, node, replacer)
	case *CreateView:
		return a.rewriteRefOfCreateView(parent, node, replacer)
	case *CurTimeFuncExpr:
		return a.rewriteRefOfCurTimeFuncExpr(parent, node, replacer)
	case *DeallocateStmt:
		return a.rewriteRefOfDeallocateStmt(parent, node, replacer)
	case *Default:
		return a.rewriteRefOfDefault(parent, node, replacer)
	case *Definer:
		return a.rewriteRefOfDefiner(parent, node, replacer)
	case *Delete:
		return a.rewriteRefOfDelete(parent, node, replacer)
	case *DerivedTable:
		return a.rewriteRefOfDerivedTable(parent, node, replacer)
	case *DropColumn:
		return a.rewriteRefOfDropColumn(parent, node, replacer)
	case *DropDatabase:
		return a.rewriteRefOfDropDatabase(parent, node, replacer)
	case *DropKey:
		return a.rewriteRefOfDropKey(parent, node, replacer)
	case *DropTable:
		return a.rewriteRefOfDropTable(parent, node, replacer)
	case *DropView:
		return a.rewriteRefOfDropView(parent, node, replacer)
	case *ExecuteStmt:
		return a.rewriteRefOfExecuteStmt(parent, node, replacer)
	case *ExistsExpr:
		return a.rewriteRefOfExistsExpr(parent, node, replacer)
	case *ExplainStmt:
		return a.rewriteRefOfExplainStmt(parent, node, replacer)
	case *ExplainTab:
		return a.rewriteRefOfExplainTab(parent, node, replacer)
	case *Exprs:
		return a.rewriteRefOfExprs(parent, node, replacer)
	case *ExtractFuncExpr:
		return a.rewriteRefOfExtractFuncExpr(parent, node, replacer)
	case *ExtractValueExpr:
		return a.rewriteRefOfExtractValueExpr(parent, node, replacer)
	case *FirstOrLastValueExpr:
		return a.rewriteRefOfFirstOrLastValueExpr(parent, node, replacer)
	case *Flush:
		return a.rewriteRefOfFlush(parent, node, replacer)
	case *Force:
		return a.rewriteRefOfForce(parent, node, replacer)
	case *ForeignKeyDefinition:
		return a.rewriteRefOfForeignKeyDefinition(parent, node, replacer)
	case *FrameClause:
		return a.rewriteRefOfFrameClause(parent, node, replacer)
	case *FramePoint:
		return a.rewriteRefOfFramePoint(parent, node, replacer)
	case *FromFirstLastClause:
		return a.rewriteRefOfFromFirstLastClause(parent, node, replacer)
	case *FuncExpr:
		return a.rewriteRefOfFuncExpr(parent, node, replacer)
	case *GTIDFuncExpr:
		return a.rewriteRefOfGTIDFuncExpr(parent, node, replacer)
	case *GeoHashFromLatLongExpr:
		return a.rewriteRefOfGeoHashFromLatLongExpr(parent, node, replacer)
	case *GeoHashFromPointExpr:
		return a.rewriteRefOfGeoHashFromPointExpr(parent, node, replacer)
	case *GeoJSONFromGeomExpr:
		return a.rewriteRefOfGeoJSONFromGeomExpr(parent, node, replacer)
	case *GeomCollPropertyFuncExpr:
		return a.rewriteRefOfGeomCollPropertyFuncExpr(parent, node, replacer)
	case *GeomFormatExpr:
		return a.rewriteRefOfGeomFormatExpr(parent, node, replacer)
	case *GeomFromGeoHashExpr:
		return a.rewriteRefOfGeomFromGeoHashExpr(parent, node, replacer)
	case *GeomFromGeoJSONExpr:
		return a.rewriteRefOfGeomFromGeoJSONExpr(parent, node, replacer)
	case *GeomFromTextExpr:
		return a.rewriteRefOfGeomFromTextExpr(parent, node, replacer)
	case *GeomFromWKBExpr:
		return a.rewriteRefOfGeomFromWKBExpr(parent, node, replacer)
	case *GeomPropertyFuncExpr:
		return a.rewriteRefOfGeomPropertyFuncExpr(parent, node, replacer)
	case *GroupBy:
		return a.rewriteRefOfGroupBy(parent, node, replacer)
	case *GroupConcatExpr:
		return a.rewriteRefOfGroupConcatExpr(parent, node, replacer)
	case IdentifierCI:
		return a.rewriteIdentifierCI(parent, node, replacer)
	case IdentifierCS:
		return a.rewriteIdentifierCS(parent, node, replacer)
	case *IndexDefinition:
		return a.rewriteRefOfIndexDefinition(parent, node, replacer)
	case *IndexHint:
		return a.rewriteRefOfIndexHint(parent, node, replacer)
	case IndexHints:
		return a.rewriteIndexHints(parent, node, replacer)
	case *IndexInfo:
		return a.rewriteRefOfIndexInfo(parent, node, replacer)
	case *Insert:
		return a.rewriteRefOfInsert(parent, node, replacer)
	case *InsertExpr:
		return a.rewriteRefOfInsertExpr(parent, node, replacer)
	case *IntervalDateExpr:
		return a.rewriteRefOfIntervalDateExpr(parent, node, replacer)
	case *IntervalFuncExpr:
		return a.rewriteRefOfIntervalFuncExpr(parent, node, replacer)
	case *IntroducerExpr:
		return a.rewriteRefOfIntroducerExpr(parent, node, replacer)
	case *IsExpr:
		return a.rewriteRefOfIsExpr(parent, node, replacer)
	case *JSONArrayAgg:
		return a.rewriteRefOfJSONArrayAgg(parent, node, replacer)
	case *JSONArrayExpr:
		return a.rewriteRefOfJSONArrayExpr(parent, node, replacer)
	case *JSONAttributesExpr:
		return a.rewriteRefOfJSONAttributesExpr(parent, node, replacer)
	case *JSONContainsExpr:
		return a.rewriteRefOfJSONContainsExpr(parent, node, replacer)
	case *JSONContainsPathExpr:
		return a.rewriteRefOfJSONContainsPathExpr(parent, node, replacer)
	case *JSONExtractExpr:
		return a.rewriteRefOfJSONExtractExpr(parent, node, replacer)
	case *JSONKeysExpr:
		return a.rewriteRefOfJSONKeysExpr(parent, node, replacer)
	case *JSONObjectAgg:
		return a.rewriteRefOfJSONObjectAgg(parent, node, replacer)
	case *JSONObjectExpr:
		return a.rewriteRefOfJSONObjectExpr(parent, node, replacer)
	case *JSONObjectParam:
		return a.rewriteRefOfJSONObjectParam(parent, node, replacer)
	case *JSONOverlapsExpr:
		return a.rewriteRefOfJSONOverlapsExpr(parent, node, replacer)
	case *JSONPrettyExpr:
		return a.rewriteRefOfJSONPrettyExpr(parent, node, replacer)
	case *JSONQuoteExpr:
		return a.rewriteRefOfJSONQuoteExpr(parent, node, replacer)
	case *JSONRemoveExpr:
		return a.rewriteRefOfJSONRemoveExpr(parent, node, replacer)
	case *JSONSchemaValidFuncExpr:
		return a.rewriteRefOfJSONSchemaValidFuncExpr(parent, node, replacer)
	case *JSONSchemaValidationReportFuncExpr:
		return a.rewriteRefOfJSONSchemaValidationReportFuncExpr(parent, node, replacer)
	case *JSONSearchExpr:
		return a.rewriteRefOfJSONSearchExpr(parent, node, replacer)
	case *JSONStorageFreeExpr:
		return a.rewriteRefOfJSONStorageFreeExpr(parent, node, replacer)
	case *JSONStorageSizeExpr:
		return a.rewriteRefOfJSONStorageSizeExpr(parent, node, replacer)
	case *JSONTableExpr:
		return a.rewriteRefOfJSONTableExpr(parent, node, replacer)
	case *JSONUnquoteExpr:
		return a.rewriteRefOfJSONUnquoteExpr(parent, node, replacer)
	case *JSONValueExpr:
		return a.rewriteRefOfJSONValueExpr(parent, node, replacer)
	case *JSONValueMergeExpr:
		return a.rewriteRefOfJSONValueMergeExpr(parent, node, replacer)
	case *JSONValueModifierExpr:
		return a.rewriteRefOfJSONValueModifierExpr(parent, node, replacer)
	case *JoinCondition:
		return a.rewriteRefOfJoinCondition(parent, node, replacer)
	case *JoinTableExpr:
		return a.rewriteRefOfJoinTableExpr(parent, node, replacer)
	case *JtColumnDefinition:
		return a.rewriteRefOfJtColumnDefinition(parent, node, replacer)
	case *JtOnResponse:
		return a.rewriteRefOfJtOnResponse(parent, node, replacer)
	case *KeyState:
		return a.rewriteRefOfKeyState(parent, node, replacer)
	case *Kill:
		return a.rewriteRefOfKill(parent, node, replacer)
	case *LagLeadExpr:
		return a.rewriteRefOfLagLeadExpr(parent, node, replacer)
	case *Limit:
		return a.rewriteRefOfLimit(parent, node, replacer)
	case *LineStringExpr:
		return a.rewriteRefOfLineStringExpr(parent, node, replacer)
	case *LinestrPropertyFuncExpr:
		return a.rewriteRefOfLinestrPropertyFuncExpr(parent, node, replacer)
	case ListArg:
		return a.rewriteListArg(parent, node, replacer)
	case *Literal:
		return a.rewriteRefOfLiteral(parent, node, replacer)
	case *Load:
		return a.rewriteRefOfLoad(parent, node, replacer)
	case *LocateExpr:
		return a.rewriteRefOfLocateExpr(parent, node, replacer)
	case *LockOption:
		return a.rewriteRefOfLockOption(parent, node, replacer)
	case *LockTables:
		return a.rewriteRefOfLockTables(parent, node, replacer)
	case *LockingFunc:
		return a.rewriteRefOfLockingFunc(parent, node, replacer)
	case MatchAction:
		return a.rewriteMatchAction(parent, node, replacer)
	case *MatchExpr:
		return a.rewriteRefOfMatchExpr(parent, node, replacer)
	case *Max:
		return a.rewriteRefOfMax(parent, node, replacer)
	case *MemberOfExpr:
		return a.rewriteRefOfMemberOfExpr(parent, node, replacer)
	case *Min:
		return a.rewriteRefOfMin(parent, node, replacer)
	case *ModifyColumn:
		return a.rewriteRefOfModifyColumn(parent, node, replacer)
	case *MultiLinestringExpr:
		return a.rewriteRefOfMultiLinestringExpr(parent, node, replacer)
	case *MultiPointExpr:
		return a.rewriteRefOfMultiPointExpr(parent, node, replacer)
	case *MultiPolygonExpr:
		return a.rewriteRefOfMultiPolygonExpr(parent, node, replacer)
	case *NTHValueExpr:
		return a.rewriteRefOfNTHValueExpr(parent, node, replacer)
	case *NamedWindow:
		return a.rewriteRefOfNamedWindow(parent, node, replacer)
	case NamedWindows:
		return a.rewriteNamedWindows(parent, node, replacer)
	case *Nextval:
		return a.rewriteRefOfNextval(parent, node, replacer)
	case *NotExpr:
		return a.rewriteRefOfNotExpr(parent, node, replacer)
	case *NtileExpr:
		return a.rewriteRefOfNtileExpr(parent, node, replacer)
	case *NullTreatmentClause:
		return a.rewriteRefOfNullTreatmentClause(parent, node, replacer)
	case *NullVal:
		return a.rewriteRefOfNullVal(parent, node, replacer)
	case *Offset:
		return a.rewriteRefOfOffset(parent, node, replacer)
	case OnDup:
		return a.rewriteOnDup(parent, node, replacer)
	case *OptLike:
		return a.rewriteRefOfOptLike(parent, node, replacer)
	case *OrExpr:
		return a.rewriteRefOfOrExpr(parent, node, replacer)
	case *Order:
		return a.rewriteRefOfOrder(parent, node, replacer)
	case OrderBy:
		return a.rewriteOrderBy(parent, node, replacer)
	case *OrderByOption:
		return a.rewriteRefOfOrderByOption(parent, node, replacer)
	case *OtherAdmin:
		return a.rewriteRefOfOtherAdmin(parent, node, replacer)
	case *OverClause:
		return a.rewriteRefOfOverClause(parent, node, replacer)
	case *ParenTableExpr:
		return a.rewriteRefOfParenTableExpr(parent, node, replacer)
	case *ParsedComments:
		return a.rewriteRefOfParsedComments(parent, node, replacer)
	case *PartitionDefinition:
		return a.rewriteRefOfPartitionDefinition(parent, node, replacer)
	case *PartitionDefinitionOptions:
		return a.rewriteRefOfPartitionDefinitionOptions(parent, node, replacer)
	case *PartitionEngine:
		return a.rewriteRefOfPartitionEngine(parent, node, replacer)
	case *PartitionOption:
		return a.rewriteRefOfPartitionOption(parent, node, replacer)
	case *PartitionSpec:
		return a.rewriteRefOfPartitionSpec(parent, node, replacer)
	case *PartitionValueRange:
		return a.rewriteRefOfPartitionValueRange(parent, node, replacer)
	case Partitions:
		return a.rewritePartitions(parent, node, replacer)
	case *PerformanceSchemaFuncExpr:
		return a.rewriteRefOfPerformanceSchemaFuncExpr(parent, node, replacer)
	case *PointExpr:
		return a.rewriteRefOfPointExpr(parent, node, replacer)
	case *PointPropertyFuncExpr:
		return a.rewriteRefOfPointPropertyFuncExpr(parent, node, replacer)
	case *PolygonExpr:
		return a.rewriteRefOfPolygonExpr(parent, node, replacer)
	case *PolygonPropertyFuncExpr:
		return a.rewriteRefOfPolygonPropertyFuncExpr(parent, node, replacer)
	case *PrepareStmt:
		return a.rewriteRefOfPrepareStmt(parent, node, replacer)
	case *PurgeBinaryLogs:
		return a.rewriteRefOfPurgeBinaryLogs(parent, node, replacer)
	case ReferenceAction:
		return a.rewriteReferenceAction(parent, node, replacer)
	case *ReferenceDefinition:
		return a.rewriteRefOfReferenceDefinition(parent, node, replacer)
	case *RegexpInstrExpr:
		return a.rewriteRefOfRegexpInstrExpr(parent, node, replacer)
	case *RegexpLikeExpr:
		return a.rewriteRefOfRegexpLikeExpr(parent, node, replacer)
	case *RegexpReplaceExpr:
		return a.rewriteRefOfRegexpReplaceExpr(parent, node, replacer)
	case *RegexpSubstrExpr:
		return a.rewriteRefOfRegexpSubstrExpr(parent, node, replacer)
	case *Release:
		return a.rewriteRefOfRelease(parent, node, replacer)
	case *RenameColumn:
		return a.rewriteRefOfRenameColumn(parent, node, replacer)
	case *RenameIndex:
		return a.rewriteRefOfRenameIndex(parent, node, replacer)
	case *RenameTable:
		return a.rewriteRefOfRenameTable(parent, node, replacer)
	case *RenameTableName:
		return a.rewriteRefOfRenameTableName(parent, node, replacer)
	case *RevertMigration:
		return a.rewriteRefOfRevertMigration(parent, node, replacer)
	case *Rollback:
		return a.rewriteRefOfRollback(parent, node, replacer)
	case RootNode:
		return a.rewriteRootNode(parent, node, replacer)
	case *RowAlias:
		return a.rewriteRefOfRowAlias(parent, node, replacer)
	case *SRollback:
		return a.rewriteRefOfSRollback(parent, node, replacer)
	case *Savepoint:
		return a.rewriteRefOfSavepoint(parent, node, replacer)
	case *Select:
		return a.rewriteRefOfSelect(parent, node, replacer)
	case *SelectExprs:
		return a.rewriteRefOfSelectExprs(parent, node, replacer)
	case *SelectInto:
		return a.rewriteRefOfSelectInto(parent, node, replacer)
	case *Set:
		return a.rewriteRefOfSet(parent, node, replacer)
	case *SetExpr:
		return a.rewriteRefOfSetExpr(parent, node, replacer)
	case SetExprs:
		return a.rewriteSetExprs(parent, node, replacer)
	case *Show:
		return a.rewriteRefOfShow(parent, node, replacer)
	case *ShowBasic:
		return a.rewriteRefOfShowBasic(parent, node, replacer)
	case *ShowCreate:
		return a.rewriteRefOfShowCreate(parent, node, replacer)
	case *ShowFilter:
		return a.rewriteRefOfShowFilter(parent, node, replacer)
	case *ShowMigrationLogs:
		return a.rewriteRefOfShowMigrationLogs(parent, node, replacer)
	case *ShowOther:
		return a.rewriteRefOfShowOther(parent, node, replacer)
	case *ShowThrottledApps:
		return a.rewriteRefOfShowThrottledApps(parent, node, replacer)
	case *ShowThrottlerStatus:
		return a.rewriteRefOfShowThrottlerStatus(parent, node, replacer)
	case *ShowTransactionStatus:
		return a.rewriteRefOfShowTransactionStatus(parent, node, replacer)
	case *StarExpr:
		return a.rewriteRefOfStarExpr(parent, node, replacer)
	case *Std:
		return a.rewriteRefOfStd(parent, node, replacer)
	case *StdDev:
		return a.rewriteRefOfStdDev(parent, node, replacer)
	case *StdPop:
		return a.rewriteRefOfStdPop(parent, node, replacer)
	case *StdSamp:
		return a.rewriteRefOfStdSamp(parent, node, replacer)
	case *Stream:
		return a.rewriteRefOfStream(parent, node, replacer)
	case *SubPartition:
		return a.rewriteRefOfSubPartition(parent, node, replacer)
	case *SubPartitionDefinition:
		return a.rewriteRefOfSubPartitionDefinition(parent, node, replacer)
	case *SubPartitionDefinitionOptions:
		return a.rewriteRefOfSubPartitionDefinitionOptions(parent, node, replacer)
	case SubPartitionDefinitions:
		return a.rewriteSubPartitionDefinitions(parent, node, replacer)
	case *Subquery:
		return a.rewriteRefOfSubquery(parent, node, replacer)
	case *SubstrExpr:
		return a.rewriteRefOfSubstrExpr(parent, node, replacer)
	case *Sum:
		return a.rewriteRefOfSum(parent, node, replacer)
	case TableExprs:
		return a.rewriteTableExprs(parent, node, replacer)
	case TableName:
		return a.rewriteTableName(parent, node, replacer)
	case TableNames:
		return a.rewriteTableNames(parent, node, replacer)
	case TableOptions:
		return a.rewriteTableOptions(parent, node, replacer)
	case *TableSpec:
		return a.rewriteRefOfTableSpec(parent, node, replacer)
	case *TablespaceOperation:
		return a.rewriteRefOfTablespaceOperation(parent, node, replacer)
	case *TimestampDiffExpr:
		return a.rewriteRefOfTimestampDiffExpr(parent, node, replacer)
	case *TrimFuncExpr:
		return a.rewriteRefOfTrimFuncExpr(parent, node, replacer)
	case *TruncateTable:
		return a.rewriteRefOfTruncateTable(parent, node, replacer)
	case *UnaryExpr:
		return a.rewriteRefOfUnaryExpr(parent, node, replacer)
	case *Union:
		return a.rewriteRefOfUnion(parent, node, replacer)
	case *UnlockTables:
		return a.rewriteRefOfUnlockTables(parent, node, replacer)
	case *Update:
		return a.rewriteRefOfUpdate(parent, node, replacer)
	case *UpdateExpr:
		return a.rewriteRefOfUpdateExpr(parent, node, replacer)
	case UpdateExprs:
		return a.rewriteUpdateExprs(parent, node, replacer)
	case *UpdateXMLExpr:
		return a.rewriteRefOfUpdateXMLExpr(parent, node, replacer)
	case *Use:
		return a.rewriteRefOfUse(parent, node, replacer)
	case *VExplainStmt:
		return a.rewriteRefOfVExplainStmt(parent, node, replacer)
	case *VStream:
		return a.rewriteRefOfVStream(parent, node, replacer)
	case ValTuple:
		return a.rewriteValTuple(parent, node, replacer)
	case *Validation:
		return a.rewriteRefOfValidation(parent, node, replacer)
	case Values:
		return a.rewriteValues(parent, node, replacer)
	case *ValuesFuncExpr:
		return a.rewriteRefOfValuesFuncExpr(parent, node, replacer)
	case *ValuesStatement:
		return a.rewriteRefOfValuesStatement(parent, node, replacer)
	case *VarPop:
		return a.rewriteRefOfVarPop(parent, node, replacer)
	case *VarSamp:
		return a.rewriteRefOfVarSamp(parent, node, replacer)
	case *Variable:
		return a.rewriteRefOfVariable(parent, node, replacer)
	case *Variance:
		return a.rewriteRefOfVariance(parent, node, replacer)
	case VindexParam:
		return a.rewriteVindexParam(parent, node, replacer)
	case *VindexSpec:
		return a.rewriteRefOfVindexSpec(parent, node, replacer)
	case *WeightStringFuncExpr:
		return a.rewriteRefOfWeightStringFuncExpr(parent, node, replacer)
	case *When:
		return a.rewriteRefOfWhen(parent, node, replacer)
	case *Where:
		return a.rewriteRefOfWhere(parent, node, replacer)
	case *WindowDefinition:
		return a.rewriteRefOfWindowDefinition(parent, node, replacer)
	case WindowDefinitions:
		return a.rewriteWindowDefinitions(parent, node, replacer)
	case *WindowSpecification:
		return a.rewriteRefOfWindowSpecification(parent, node, replacer)
	case *With:
		return a.rewriteRefOfWith(parent, node, replacer)
	case *XorExpr:
		return a.rewriteRefOfXorExpr(parent, node, replacer)
	default:
		// this should never happen
		return true
	}
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAddColumns(parent SQLNode, node *AddColumns, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	for x, el := range node.Columns {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(RefOfAddColumnsColumnsOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteRefOfColumnDefinition(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(*AddColumns).Columns[idx] = newNode.(*ColumnDefinition)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths && len(node.Columns) > 0 {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfAddColumnsAfter))
	}
	if !a.rewriteRefOfColName(node, node.After, func(newNode, parent SQLNode) {
		parent.(*AddColumns).After = newNode.(*ColName)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAddConstraintDefinition(parent SQLNode, node *AddConstraintDefinition, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfAddConstraintDefinitionConstraintDefinition))
	}
	if !a.rewriteRefOfConstraintDefinition(node, node.ConstraintDefinition, func(newNode, parent SQLNode) {
		parent.(*AddConstraintDefinition).ConstraintDefinition = newNode.(*ConstraintDefinition)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAddIndexDefinition(parent SQLNode, node *AddIndexDefinition, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfAddIndexDefinitionIndexDefinition))
	}
	if !a.rewriteRefOfIndexDefinition(node, node.IndexDefinition, func(newNode, parent SQLNode) {
		parent.(*AddIndexDefinition).IndexDefinition = newNode.(*IndexDefinition)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAliasedExpr(parent SQLNode, node *AliasedExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfAliasedExprExpr))
	}
	if !a.rewriteExpr(node, node.Expr, func(newNode, parent SQLNode) {
		parent.(*AliasedExpr).Expr = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfAliasedExprAs))
	}
	if !a.rewriteIdentifierCI(node, node.As, func(newNode, parent SQLNode) {
		parent.(*AliasedExpr).As = newNode.(IdentifierCI)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAliasedTableExpr(parent SQLNode, node *AliasedTableExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfAliasedTableExprExpr))
	}
	if !a.rewriteSimpleTableExpr(node, node.Expr, func(newNode, parent SQLNode) {
		parent.(*AliasedTableExpr).Expr = newNode.(SimpleTableExpr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfAliasedTableExprPartitions))
	}
	if !a.rewritePartitions(node, node.Partitions, func(newNode, parent SQLNode) {
		parent.(*AliasedTableExpr).Partitions = newNode.(Partitions)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfAliasedTableExprAs))
	}
	if !a.rewriteIdentifierCS(node, node.As, func(newNode, parent SQLNode) {
		parent.(*AliasedTableExpr).As = newNode.(IdentifierCS)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfAliasedTableExprHints))
	}
	if !a.rewriteIndexHints(node, node.Hints, func(newNode, parent SQLNode) {
		parent.(*AliasedTableExpr).Hints = newNode.(IndexHints)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfAliasedTableExprColumns))
	}
	if !a.rewriteColumns(node, node.Columns, func(newNode, parent SQLNode) {
		parent.(*AliasedTableExpr).Columns = newNode.(Columns)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterCharset(parent SQLNode, node *AlterCharset, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterCheck(parent SQLNode, node *AlterCheck, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfAlterCheckName))
	}
	if !a.rewriteIdentifierCI(node, node.Name, func(newNode, parent SQLNode) {
		parent.(*AlterCheck).Name = newNode.(IdentifierCI)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterColumn(parent SQLNode, node *AlterColumn, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfAlterColumnColumn))
	}
	if !a.rewriteRefOfColName(node, node.Column, func(newNode, parent SQLNode) {
		parent.(*AlterColumn).Column = newNode.(*ColName)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfAlterColumnDefaultVal))
	}
	if !a.rewriteExpr(node, node.DefaultVal, func(newNode, parent SQLNode) {
		parent.(*AlterColumn).DefaultVal = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterDatabase(parent SQLNode, node *AlterDatabase, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfAlterDatabaseComments))
	}
	if !a.rewriteRefOfParsedComments(node, node.Comments, func(newNode, parent SQLNode) {
		parent.(*AlterDatabase).Comments = newNode.(*ParsedComments)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfAlterDatabaseDBName))
	}
	if !a.rewriteIdentifierCS(node, node.DBName, func(newNode, parent SQLNode) {
		parent.(*AlterDatabase).DBName = newNode.(IdentifierCS)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterIndex(parent SQLNode, node *AlterIndex, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfAlterIndexName))
	}
	if !a.rewriteIdentifierCI(node, node.Name, func(newNode, parent SQLNode) {
		parent.(*AlterIndex).Name = newNode.(IdentifierCI)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterMigration(parent SQLNode, node *AlterMigration, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfAlterMigrationRatio))
	}
	if !a.rewriteRefOfLiteral(node, node.Ratio, func(newNode, parent SQLNode) {
		parent.(*AlterMigration).Ratio = newNode.(*Literal)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterTable(parent SQLNode, node *AlterTable, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfAlterTableTable))
	}
	if !a.rewriteTableName(node, node.Table, func(newNode, parent SQLNode) {
		parent.(*AlterTable).Table = newNode.(TableName)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	for x, el := range node.AlterOptions {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(RefOfAlterTableAlterOptionsOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteAlterOption(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(*AlterTable).AlterOptions[idx] = newNode.(AlterOption)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths && len(node.AlterOptions) > 0 {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfAlterTablePartitionSpec))
	}
	if !a.rewriteRefOfPartitionSpec(node, node.PartitionSpec, func(newNode, parent SQLNode) {
		parent.(*AlterTable).PartitionSpec = newNode.(*PartitionSpec)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfAlterTablePartitionOption))
	}
	if !a.rewriteRefOfPartitionOption(node, node.PartitionOption, func(newNode, parent SQLNode) {
		parent.(*AlterTable).PartitionOption = newNode.(*PartitionOption)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfAlterTableComments))
	}
	if !a.rewriteRefOfParsedComments(node, node.Comments, func(newNode, parent SQLNode) {
		parent.(*AlterTable).Comments = newNode.(*ParsedComments)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterView(parent SQLNode, node *AlterView, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfAlterViewViewName))
	}
	if !a.rewriteTableName(node, node.ViewName, func(newNode, parent SQLNode) {
		parent.(*AlterView).ViewName = newNode.(TableName)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfAlterViewDefiner))
	}
	if !a.rewriteRefOfDefiner(node, node.Definer, func(newNode, parent SQLNode) {
		parent.(*AlterView).Definer = newNode.(*Definer)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfAlterViewColumns))
	}
	if !a.rewriteColumns(node, node.Columns, func(newNode, parent SQLNode) {
		parent.(*AlterView).Columns = newNode.(Columns)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfAlterViewSelect))
	}
	if !a.rewriteTableStatement(node, node.Select, func(newNode, parent SQLNode) {
		parent.(*AlterView).Select = newNode.(TableStatement)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfAlterViewComments))
	}
	if !a.rewriteRefOfParsedComments(node, node.Comments, func(newNode, parent SQLNode) {
		parent.(*AlterView).Comments = newNode.(*ParsedComments)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterVschema(parent SQLNode, node *AlterVschema, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfAlterVschemaTable))
	}
	if !a.rewriteTableName(node, node.Table, func(newNode, parent SQLNode) {
		parent.(*AlterVschema).Table = newNode.(TableName)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfAlterVschemaVindexSpec))
	}
	if !a.rewriteRefOfVindexSpec(node, node.VindexSpec, func(newNode, parent SQLNode) {
		parent.(*AlterVschema).VindexSpec = newNode.(*VindexSpec)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	for x, el := range node.VindexCols {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(RefOfAlterVschemaVindexColsOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteIdentifierCI(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(*AlterVschema).VindexCols[idx] = newNode.(IdentifierCI)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths && len(node.VindexCols) > 0 {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfAlterVschemaAutoIncSpec))
	}
	if !a.rewriteRefOfAutoIncSpec(node, node.AutoIncSpec, func(newNode, parent SQLNode) {
		parent.(*AlterVschema).AutoIncSpec = newNode.(*AutoIncSpec)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAnalyze(parent SQLNode, node *Analyze, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfAnalyzeTable))
	}
	if !a.rewriteTableName(node, node.Table, func(newNode, parent SQLNode) {
		parent.(*Analyze).Table = newNode.(TableName)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAndExpr(parent SQLNode, node *AndExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfAndExprLeft))
	}
	if !a.rewriteExpr(node, node.Left, func(newNode, parent SQLNode) {
		parent.(*AndExpr).Left = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfAndExprRight))
	}
	if !a.rewriteExpr(node, node.Right, func(newNode, parent SQLNode) {
		parent.(*AndExpr).Right = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAnyValue(parent SQLNode, node *AnyValue, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfAnyValueArg))
	}
	if !a.rewriteExpr(node, node.Arg, func(newNode, parent SQLNode) {
		parent.(*AnyValue).Arg = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfArgument(parent SQLNode, node *Argument, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfArgumentLessWindowExpr(parent SQLNode, node *ArgumentLessWindowExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfArgumentLessWindowExprOverClause))
	}
	if !a.rewriteRefOfOverClause(node, node.OverClause, func(newNode, parent SQLNode) {
		parent.(*ArgumentLessWindowExpr).OverClause = newNode.(*OverClause)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAssignmentExpr(parent SQLNode, node *AssignmentExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfAssignmentExprLeft))
	}
	if !a.rewriteExpr(node, node.Left, func(newNode, parent SQLNode) {
		parent.(*AssignmentExpr).Left = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfAssignmentExprRight))
	}
	if !a.rewriteExpr(node, node.Right, func(newNode, parent SQLNode) {
		parent.(*AssignmentExpr).Right = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAutoIncSpec(parent SQLNode, node *AutoIncSpec, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfAutoIncSpecColumn))
	}
	if !a.rewriteIdentifierCI(node, node.Column, func(newNode, parent SQLNode) {
		parent.(*AutoIncSpec).Column = newNode.(IdentifierCI)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfAutoIncSpecSequence))
	}
	if !a.rewriteTableName(node, node.Sequence, func(newNode, parent SQLNode) {
		parent.(*AutoIncSpec).Sequence = newNode.(TableName)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAvg(parent SQLNode, node *Avg, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfAvgArg))
	}
	if !a.rewriteExpr(node, node.Arg, func(newNode, parent SQLNode) {
		parent.(*Avg).Arg = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfAvgOverClause))
	}
	if !a.rewriteRefOfOverClause(node, node.OverClause, func(newNode, parent SQLNode) {
		parent.(*Avg).OverClause = newNode.(*OverClause)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfBegin(parent SQLNode, node *Begin, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfBetweenExpr(parent SQLNode, node *BetweenExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfBetweenExprLeft))
	}
	if !a.rewriteExpr(node, node.Left, func(newNode, parent SQLNode) {
		parent.(*BetweenExpr).Left = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfBetweenExprFrom))
	}
	if !a.rewriteExpr(node, node.From, func(newNode, parent SQLNode) {
		parent.(*BetweenExpr).From = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfBetweenExprTo))
	}
	if !a.rewriteExpr(node, node.To, func(newNode, parent SQLNode) {
		parent.(*BetweenExpr).To = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfBinaryExpr(parent SQLNode, node *BinaryExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfBinaryExprLeft))
	}
	if !a.rewriteExpr(node, node.Left, func(newNode, parent SQLNode) {
		parent.(*BinaryExpr).Left = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfBinaryExprRight))
	}
	if !a.rewriteExpr(node, node.Right, func(newNode, parent SQLNode) {
		parent.(*BinaryExpr).Right = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfBitAnd(parent SQLNode, node *BitAnd, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfBitAndArg))
	}
	if !a.rewriteExpr(node, node.Arg, func(newNode, parent SQLNode) {
		parent.(*BitAnd).Arg = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfBitAndOverClause))
	}
	if !a.rewriteRefOfOverClause(node, node.OverClause, func(newNode, parent SQLNode) {
		parent.(*BitAnd).OverClause = newNode.(*OverClause)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfBitOr(parent SQLNode, node *BitOr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfBitOrArg))
	}
	if !a.rewriteExpr(node, node.Arg, func(newNode, parent SQLNode) {
		parent.(*BitOr).Arg = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfBitOrOverClause))
	}
	if !a.rewriteRefOfOverClause(node, node.OverClause, func(newNode, parent SQLNode) {
		parent.(*BitOr).OverClause = newNode.(*OverClause)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfBitXor(parent SQLNode, node *BitXor, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfBitXorArg))
	}
	if !a.rewriteExpr(node, node.Arg, func(newNode, parent SQLNode) {
		parent.(*BitXor).Arg = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfBitXorOverClause))
	}
	if !a.rewriteRefOfOverClause(node, node.OverClause, func(newNode, parent SQLNode) {
		parent.(*BitXor).OverClause = newNode.(*OverClause)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCallProc(parent SQLNode, node *CallProc, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfCallProcName))
	}
	if !a.rewriteTableName(node, node.Name, func(newNode, parent SQLNode) {
		parent.(*CallProc).Name = newNode.(TableName)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	for x, el := range node.Params {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(RefOfCallProcParamsOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteExpr(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(*CallProc).Params[idx] = newNode.(Expr)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCaseExpr(parent SQLNode, node *CaseExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfCaseExprExpr))
	}
	if !a.rewriteExpr(node, node.Expr, func(newNode, parent SQLNode) {
		parent.(*CaseExpr).Expr = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	for x, el := range node.Whens {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(RefOfCaseExprWhensOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteRefOfWhen(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(*CaseExpr).Whens[idx] = newNode.(*When)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths && len(node.Whens) > 0 {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfCaseExprElse))
	}
	if !a.rewriteExpr(node, node.Else, func(newNode, parent SQLNode) {
		parent.(*CaseExpr).Else = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCastExpr(parent SQLNode, node *CastExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfCastExprExpr))
	}
	if !a.rewriteExpr(node, node.Expr, func(newNode, parent SQLNode) {
		parent.(*CastExpr).Expr = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfCastExprType))
	}
	if !a.rewriteRefOfConvertType(node, node.Type, func(newNode, parent SQLNode) {
		parent.(*CastExpr).Type = newNode.(*ConvertType)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfChangeColumn(parent SQLNode, node *ChangeColumn, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfChangeColumnOldColumn))
	}
	if !a.rewriteRefOfColName(node, node.OldColumn, func(newNode, parent SQLNode) {
		parent.(*ChangeColumn).OldColumn = newNode.(*ColName)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfChangeColumnNewColDefinition))
	}
	if !a.rewriteRefOfColumnDefinition(node, node.NewColDefinition, func(newNode, parent SQLNode) {
		parent.(*ChangeColumn).NewColDefinition = newNode.(*ColumnDefinition)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfChangeColumnAfter))
	}
	if !a.rewriteRefOfColName(node, node.After, func(newNode, parent SQLNode) {
		parent.(*ChangeColumn).After = newNode.(*ColName)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCharExpr(parent SQLNode, node *CharExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	for x, el := range node.Exprs {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(RefOfCharExprExprsOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteExpr(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(*CharExpr).Exprs[idx] = newNode.(Expr)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCheckConstraintDefinition(parent SQLNode, node *CheckConstraintDefinition, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfCheckConstraintDefinitionExpr))
	}
	if !a.rewriteExpr(node, node.Expr, func(newNode, parent SQLNode) {
		parent.(*CheckConstraintDefinition).Expr = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfColName(parent SQLNode, node *ColName, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfColNameName))
	}
	if !a.rewriteIdentifierCI(node, node.Name, func(newNode, parent SQLNode) {
		parent.(*ColName).Name = newNode.(IdentifierCI)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfColNameQualifier))
	}
	if !a.rewriteTableName(node, node.Qualifier, func(newNode, parent SQLNode) {
		parent.(*ColName).Qualifier = newNode.(TableName)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCollateExpr(parent SQLNode, node *CollateExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfCollateExprExpr))
	}
	if !a.rewriteExpr(node, node.Expr, func(newNode, parent SQLNode) {
		parent.(*CollateExpr).Expr = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfColumnDefinition(parent SQLNode, node *ColumnDefinition, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfColumnDefinitionName))
	}
	if !a.rewriteIdentifierCI(node, node.Name, func(newNode, parent SQLNode) {
		parent.(*ColumnDefinition).Name = newNode.(IdentifierCI)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfColumnDefinitionType))
	}
	if !a.rewriteRefOfColumnType(node, node.Type, func(newNode, parent SQLNode) {
		parent.(*ColumnDefinition).Type = newNode.(*ColumnType)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfColumnType(parent SQLNode, node *ColumnType, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: SliceMethod
func (a *application) rewriteColumns(parent SQLNode, node Columns, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	for x, el := range node {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(ColumnsOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteIdentifierCI(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(Columns)[idx] = newNode.(IdentifierCI)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths && len(node) > 0 {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCommentOnly(parent SQLNode, node *CommentOnly, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCommit(parent SQLNode, node *Commit, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCommonTableExpr(parent SQLNode, node *CommonTableExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfCommonTableExprID))
	}
	if !a.rewriteIdentifierCS(node, node.ID, func(newNode, parent SQLNode) {
		parent.(*CommonTableExpr).ID = newNode.(IdentifierCS)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfCommonTableExprColumns))
	}
	if !a.rewriteColumns(node, node.Columns, func(newNode, parent SQLNode) {
		parent.(*CommonTableExpr).Columns = newNode.(Columns)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfCommonTableExprSubquery))
	}
	if !a.rewriteTableStatement(node, node.Subquery, func(newNode, parent SQLNode) {
		parent.(*CommonTableExpr).Subquery = newNode.(TableStatement)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfComparisonExpr(parent SQLNode, node *ComparisonExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfComparisonExprLeft))
	}
	if !a.rewriteExpr(node, node.Left, func(newNode, parent SQLNode) {
		parent.(*ComparisonExpr).Left = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfComparisonExprRight))
	}
	if !a.rewriteExpr(node, node.Right, func(newNode, parent SQLNode) {
		parent.(*ComparisonExpr).Right = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfComparisonExprEscape))
	}
	if !a.rewriteExpr(node, node.Escape, func(newNode, parent SQLNode) {
		parent.(*ComparisonExpr).Escape = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfConstraintDefinition(parent SQLNode, node *ConstraintDefinition, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfConstraintDefinitionName))
	}
	if !a.rewriteIdentifierCI(node, node.Name, func(newNode, parent SQLNode) {
		parent.(*ConstraintDefinition).Name = newNode.(IdentifierCI)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfConstraintDefinitionDetails))
	}
	if !a.rewriteConstraintInfo(node, node.Details, func(newNode, parent SQLNode) {
		parent.(*ConstraintDefinition).Details = newNode.(ConstraintInfo)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfConvertExpr(parent SQLNode, node *ConvertExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfConvertExprExpr))
	}
	if !a.rewriteExpr(node, node.Expr, func(newNode, parent SQLNode) {
		parent.(*ConvertExpr).Expr = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfConvertExprType))
	}
	if !a.rewriteRefOfConvertType(node, node.Type, func(newNode, parent SQLNode) {
		parent.(*ConvertExpr).Type = newNode.(*ConvertType)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfConvertType(parent SQLNode, node *ConvertType, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfConvertUsingExpr(parent SQLNode, node *ConvertUsingExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfConvertUsingExprExpr))
	}
	if !a.rewriteExpr(node, node.Expr, func(newNode, parent SQLNode) {
		parent.(*ConvertUsingExpr).Expr = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCount(parent SQLNode, node *Count, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	for x, el := range node.Args {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(RefOfCountArgsOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteExpr(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(*Count).Args[idx] = newNode.(Expr)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths && len(node.Args) > 0 {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfCountOverClause))
	}
	if !a.rewriteRefOfOverClause(node, node.OverClause, func(newNode, parent SQLNode) {
		parent.(*Count).OverClause = newNode.(*OverClause)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCountStar(parent SQLNode, node *CountStar, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfCountStarOverClause))
	}
	if !a.rewriteRefOfOverClause(node, node.OverClause, func(newNode, parent SQLNode) {
		parent.(*CountStar).OverClause = newNode.(*OverClause)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCreateDatabase(parent SQLNode, node *CreateDatabase, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfCreateDatabaseComments))
	}
	if !a.rewriteRefOfParsedComments(node, node.Comments, func(newNode, parent SQLNode) {
		parent.(*CreateDatabase).Comments = newNode.(*ParsedComments)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfCreateDatabaseDBName))
	}
	if !a.rewriteIdentifierCS(node, node.DBName, func(newNode, parent SQLNode) {
		parent.(*CreateDatabase).DBName = newNode.(IdentifierCS)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCreateTable(parent SQLNode, node *CreateTable, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfCreateTableTable))
	}
	if !a.rewriteTableName(node, node.Table, func(newNode, parent SQLNode) {
		parent.(*CreateTable).Table = newNode.(TableName)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfCreateTableTableSpec))
	}
	if !a.rewriteRefOfTableSpec(node, node.TableSpec, func(newNode, parent SQLNode) {
		parent.(*CreateTable).TableSpec = newNode.(*TableSpec)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfCreateTableOptLike))
	}
	if !a.rewriteRefOfOptLike(node, node.OptLike, func(newNode, parent SQLNode) {
		parent.(*CreateTable).OptLike = newNode.(*OptLike)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfCreateTableComments))
	}
	if !a.rewriteRefOfParsedComments(node, node.Comments, func(newNode, parent SQLNode) {
		parent.(*CreateTable).Comments = newNode.(*ParsedComments)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCreateView(parent SQLNode, node *CreateView, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfCreateViewViewName))
	}
	if !a.rewriteTableName(node, node.ViewName, func(newNode, parent SQLNode) {
		parent.(*CreateView).ViewName = newNode.(TableName)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfCreateViewDefiner))
	}
	if !a.rewriteRefOfDefiner(node, node.Definer, func(newNode, parent SQLNode) {
		parent.(*CreateView).Definer = newNode.(*Definer)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfCreateViewColumns))
	}
	if !a.rewriteColumns(node, node.Columns, func(newNode, parent SQLNode) {
		parent.(*CreateView).Columns = newNode.(Columns)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfCreateViewSelect))
	}
	if !a.rewriteTableStatement(node, node.Select, func(newNode, parent SQLNode) {
		parent.(*CreateView).Select = newNode.(TableStatement)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfCreateViewComments))
	}
	if !a.rewriteRefOfParsedComments(node, node.Comments, func(newNode, parent SQLNode) {
		parent.(*CreateView).Comments = newNode.(*ParsedComments)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCurTimeFuncExpr(parent SQLNode, node *CurTimeFuncExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfCurTimeFuncExprName))
	}
	if !a.rewriteIdentifierCI(node, node.Name, func(newNode, parent SQLNode) {
		parent.(*CurTimeFuncExpr).Name = newNode.(IdentifierCI)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfDeallocateStmt(parent SQLNode, node *DeallocateStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfDeallocateStmtComments))
	}
	if !a.rewriteRefOfParsedComments(node, node.Comments, func(newNode, parent SQLNode) {
		parent.(*DeallocateStmt).Comments = newNode.(*ParsedComments)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfDeallocateStmtName))
	}
	if !a.rewriteIdentifierCI(node, node.Name, func(newNode, parent SQLNode) {
		parent.(*DeallocateStmt).Name = newNode.(IdentifierCI)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfDefault(parent SQLNode, node *Default, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfDefiner(parent SQLNode, node *Definer, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfDelete(parent SQLNode, node *Delete, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfDeleteWith))
	}
	if !a.rewriteRefOfWith(node, node.With, func(newNode, parent SQLNode) {
		parent.(*Delete).With = newNode.(*With)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfDeleteComments))
	}
	if !a.rewriteRefOfParsedComments(node, node.Comments, func(newNode, parent SQLNode) {
		parent.(*Delete).Comments = newNode.(*ParsedComments)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	for x, el := range node.TableExprs {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(RefOfDeleteTableExprsOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteTableExpr(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(*Delete).TableExprs[idx] = newNode.(TableExpr)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths && len(node.TableExprs) > 0 {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfDeleteTargets))
	}
	if !a.rewriteTableNames(node, node.Targets, func(newNode, parent SQLNode) {
		parent.(*Delete).Targets = newNode.(TableNames)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfDeletePartitions))
	}
	if !a.rewritePartitions(node, node.Partitions, func(newNode, parent SQLNode) {
		parent.(*Delete).Partitions = newNode.(Partitions)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfDeleteWhere))
	}
	if !a.rewriteRefOfWhere(node, node.Where, func(newNode, parent SQLNode) {
		parent.(*Delete).Where = newNode.(*Where)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfDeleteOrderBy))
	}
	if !a.rewriteOrderBy(node, node.OrderBy, func(newNode, parent SQLNode) {
		parent.(*Delete).OrderBy = newNode.(OrderBy)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfDeleteLimit))
	}
	if !a.rewriteRefOfLimit(node, node.Limit, func(newNode, parent SQLNode) {
		parent.(*Delete).Limit = newNode.(*Limit)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfDerivedTable(parent SQLNode, node *DerivedTable, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfDerivedTableSelect))
	}
	if !a.rewriteTableStatement(node, node.Select, func(newNode, parent SQLNode) {
		parent.(*DerivedTable).Select = newNode.(TableStatement)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfDropColumn(parent SQLNode, node *DropColumn, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfDropColumnName))
	}
	if !a.rewriteRefOfColName(node, node.Name, func(newNode, parent SQLNode) {
		parent.(*DropColumn).Name = newNode.(*ColName)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfDropDatabase(parent SQLNode, node *DropDatabase, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfDropDatabaseComments))
	}
	if !a.rewriteRefOfParsedComments(node, node.Comments, func(newNode, parent SQLNode) {
		parent.(*DropDatabase).Comments = newNode.(*ParsedComments)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfDropDatabaseDBName))
	}
	if !a.rewriteIdentifierCS(node, node.DBName, func(newNode, parent SQLNode) {
		parent.(*DropDatabase).DBName = newNode.(IdentifierCS)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfDropKey(parent SQLNode, node *DropKey, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfDropKeyName))
	}
	if !a.rewriteIdentifierCI(node, node.Name, func(newNode, parent SQLNode) {
		parent.(*DropKey).Name = newNode.(IdentifierCI)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfDropTable(parent SQLNode, node *DropTable, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfDropTableFromTables))
	}
	if !a.rewriteTableNames(node, node.FromTables, func(newNode, parent SQLNode) {
		parent.(*DropTable).FromTables = newNode.(TableNames)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfDropTableComments))
	}
	if !a.rewriteRefOfParsedComments(node, node.Comments, func(newNode, parent SQLNode) {
		parent.(*DropTable).Comments = newNode.(*ParsedComments)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfDropView(parent SQLNode, node *DropView, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfDropViewFromTables))
	}
	if !a.rewriteTableNames(node, node.FromTables, func(newNode, parent SQLNode) {
		parent.(*DropView).FromTables = newNode.(TableNames)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfDropViewComments))
	}
	if !a.rewriteRefOfParsedComments(node, node.Comments, func(newNode, parent SQLNode) {
		parent.(*DropView).Comments = newNode.(*ParsedComments)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfExecuteStmt(parent SQLNode, node *ExecuteStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfExecuteStmtName))
	}
	if !a.rewriteIdentifierCI(node, node.Name, func(newNode, parent SQLNode) {
		parent.(*ExecuteStmt).Name = newNode.(IdentifierCI)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfExecuteStmtComments))
	}
	if !a.rewriteRefOfParsedComments(node, node.Comments, func(newNode, parent SQLNode) {
		parent.(*ExecuteStmt).Comments = newNode.(*ParsedComments)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	for x, el := range node.Arguments {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(RefOfExecuteStmtArgumentsOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteRefOfVariable(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(*ExecuteStmt).Arguments[idx] = newNode.(*Variable)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfExistsExpr(parent SQLNode, node *ExistsExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfExistsExprSubquery))
	}
	if !a.rewriteRefOfSubquery(node, node.Subquery, func(newNode, parent SQLNode) {
		parent.(*ExistsExpr).Subquery = newNode.(*Subquery)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfExplainStmt(parent SQLNode, node *ExplainStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfExplainStmtStatement))
	}
	if !a.rewriteStatement(node, node.Statement, func(newNode, parent SQLNode) {
		parent.(*ExplainStmt).Statement = newNode.(Statement)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfExplainStmtComments))
	}
	if !a.rewriteRefOfParsedComments(node, node.Comments, func(newNode, parent SQLNode) {
		parent.(*ExplainStmt).Comments = newNode.(*ParsedComments)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfExplainTab(parent SQLNode, node *ExplainTab, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfExplainTabTable))
	}
	if !a.rewriteTableName(node, node.Table, func(newNode, parent SQLNode) {
		parent.(*ExplainTab).Table = newNode.(TableName)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfExprs(parent SQLNode, node *Exprs, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	for x, el := range node.Exprs {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(RefOfExprsExprsOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteExpr(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(*Exprs).Exprs[idx] = newNode.(Expr)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfExtractFuncExpr(parent SQLNode, node *ExtractFuncExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfExtractFuncExprExpr))
	}
	if !a.rewriteExpr(node, node.Expr, func(newNode, parent SQLNode) {
		parent.(*ExtractFuncExpr).Expr = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfExtractValueExpr(parent SQLNode, node *ExtractValueExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfExtractValueExprFragment))
	}
	if !a.rewriteExpr(node, node.Fragment, func(newNode, parent SQLNode) {
		parent.(*ExtractValueExpr).Fragment = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfExtractValueExprXPathExpr))
	}
	if !a.rewriteExpr(node, node.XPathExpr, func(newNode, parent SQLNode) {
		parent.(*ExtractValueExpr).XPathExpr = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfFirstOrLastValueExpr(parent SQLNode, node *FirstOrLastValueExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfFirstOrLastValueExprExpr))
	}
	if !a.rewriteExpr(node, node.Expr, func(newNode, parent SQLNode) {
		parent.(*FirstOrLastValueExpr).Expr = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfFirstOrLastValueExprNullTreatmentClause))
	}
	if !a.rewriteRefOfNullTreatmentClause(node, node.NullTreatmentClause, func(newNode, parent SQLNode) {
		parent.(*FirstOrLastValueExpr).NullTreatmentClause = newNode.(*NullTreatmentClause)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfFirstOrLastValueExprOverClause))
	}
	if !a.rewriteRefOfOverClause(node, node.OverClause, func(newNode, parent SQLNode) {
		parent.(*FirstOrLastValueExpr).OverClause = newNode.(*OverClause)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfFlush(parent SQLNode, node *Flush, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfFlushTableNames))
	}
	if !a.rewriteTableNames(node, node.TableNames, func(newNode, parent SQLNode) {
		parent.(*Flush).TableNames = newNode.(TableNames)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfForce(parent SQLNode, node *Force, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfForeignKeyDefinition(parent SQLNode, node *ForeignKeyDefinition, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfForeignKeyDefinitionSource))
	}
	if !a.rewriteColumns(node, node.Source, func(newNode, parent SQLNode) {
		parent.(*ForeignKeyDefinition).Source = newNode.(Columns)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfForeignKeyDefinitionIndexName))
	}
	if !a.rewriteIdentifierCI(node, node.IndexName, func(newNode, parent SQLNode) {
		parent.(*ForeignKeyDefinition).IndexName = newNode.(IdentifierCI)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfForeignKeyDefinitionReferenceDefinition))
	}
	if !a.rewriteRefOfReferenceDefinition(node, node.ReferenceDefinition, func(newNode, parent SQLNode) {
		parent.(*ForeignKeyDefinition).ReferenceDefinition = newNode.(*ReferenceDefinition)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfFrameClause(parent SQLNode, node *FrameClause, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfFrameClauseStart))
	}
	if !a.rewriteRefOfFramePoint(node, node.Start, func(newNode, parent SQLNode) {
		parent.(*FrameClause).Start = newNode.(*FramePoint)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfFrameClauseEnd))
	}
	if !a.rewriteRefOfFramePoint(node, node.End, func(newNode, parent SQLNode) {
		parent.(*FrameClause).End = newNode.(*FramePoint)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfFramePoint(parent SQLNode, node *FramePoint, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfFramePointExpr))
	}
	if !a.rewriteExpr(node, node.Expr, func(newNode, parent SQLNode) {
		parent.(*FramePoint).Expr = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfFromFirstLastClause(parent SQLNode, node *FromFirstLastClause, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfFuncExpr(parent SQLNode, node *FuncExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfFuncExprQualifier))
	}
	if !a.rewriteIdentifierCS(node, node.Qualifier, func(newNode, parent SQLNode) {
		parent.(*FuncExpr).Qualifier = newNode.(IdentifierCS)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfFuncExprName))
	}
	if !a.rewriteIdentifierCI(node, node.Name, func(newNode, parent SQLNode) {
		parent.(*FuncExpr).Name = newNode.(IdentifierCI)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	for x, el := range node.Exprs {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(RefOfFuncExprExprsOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteExpr(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(*FuncExpr).Exprs[idx] = newNode.(Expr)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfGTIDFuncExpr(parent SQLNode, node *GTIDFuncExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfGTIDFuncExprSet1))
	}
	if !a.rewriteExpr(node, node.Set1, func(newNode, parent SQLNode) {
		parent.(*GTIDFuncExpr).Set1 = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfGTIDFuncExprSet2))
	}
	if !a.rewriteExpr(node, node.Set2, func(newNode, parent SQLNode) {
		parent.(*GTIDFuncExpr).Set2 = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfGTIDFuncExprTimeout))
	}
	if !a.rewriteExpr(node, node.Timeout, func(newNode, parent SQLNode) {
		parent.(*GTIDFuncExpr).Timeout = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfGTIDFuncExprChannel))
	}
	if !a.rewriteExpr(node, node.Channel, func(newNode, parent SQLNode) {
		parent.(*GTIDFuncExpr).Channel = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfGeoHashFromLatLongExpr(parent SQLNode, node *GeoHashFromLatLongExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfGeoHashFromLatLongExprLatitude))
	}
	if !a.rewriteExpr(node, node.Latitude, func(newNode, parent SQLNode) {
		parent.(*GeoHashFromLatLongExpr).Latitude = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfGeoHashFromLatLongExprLongitude))
	}
	if !a.rewriteExpr(node, node.Longitude, func(newNode, parent SQLNode) {
		parent.(*GeoHashFromLatLongExpr).Longitude = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfGeoHashFromLatLongExprMaxLength))
	}
	if !a.rewriteExpr(node, node.MaxLength, func(newNode, parent SQLNode) {
		parent.(*GeoHashFromLatLongExpr).MaxLength = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfGeoHashFromPointExpr(parent SQLNode, node *GeoHashFromPointExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfGeoHashFromPointExprPoint))
	}
	if !a.rewriteExpr(node, node.Point, func(newNode, parent SQLNode) {
		parent.(*GeoHashFromPointExpr).Point = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfGeoHashFromPointExprMaxLength))
	}
	if !a.rewriteExpr(node, node.MaxLength, func(newNode, parent SQLNode) {
		parent.(*GeoHashFromPointExpr).MaxLength = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfGeoJSONFromGeomExpr(parent SQLNode, node *GeoJSONFromGeomExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfGeoJSONFromGeomExprGeom))
	}
	if !a.rewriteExpr(node, node.Geom, func(newNode, parent SQLNode) {
		parent.(*GeoJSONFromGeomExpr).Geom = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfGeoJSONFromGeomExprMaxDecimalDigits))
	}
	if !a.rewriteExpr(node, node.MaxDecimalDigits, func(newNode, parent SQLNode) {
		parent.(*GeoJSONFromGeomExpr).MaxDecimalDigits = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfGeoJSONFromGeomExprBitmask))
	}
	if !a.rewriteExpr(node, node.Bitmask, func(newNode, parent SQLNode) {
		parent.(*GeoJSONFromGeomExpr).Bitmask = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfGeomCollPropertyFuncExpr(parent SQLNode, node *GeomCollPropertyFuncExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfGeomCollPropertyFuncExprGeomColl))
	}
	if !a.rewriteExpr(node, node.GeomColl, func(newNode, parent SQLNode) {
		parent.(*GeomCollPropertyFuncExpr).GeomColl = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfGeomCollPropertyFuncExprPropertyDefArg))
	}
	if !a.rewriteExpr(node, node.PropertyDefArg, func(newNode, parent SQLNode) {
		parent.(*GeomCollPropertyFuncExpr).PropertyDefArg = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfGeomFormatExpr(parent SQLNode, node *GeomFormatExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfGeomFormatExprGeom))
	}
	if !a.rewriteExpr(node, node.Geom, func(newNode, parent SQLNode) {
		parent.(*GeomFormatExpr).Geom = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfGeomFormatExprAxisOrderOpt))
	}
	if !a.rewriteExpr(node, node.AxisOrderOpt, func(newNode, parent SQLNode) {
		parent.(*GeomFormatExpr).AxisOrderOpt = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfGeomFromGeoHashExpr(parent SQLNode, node *GeomFromGeoHashExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfGeomFromGeoHashExprGeoHash))
	}
	if !a.rewriteExpr(node, node.GeoHash, func(newNode, parent SQLNode) {
		parent.(*GeomFromGeoHashExpr).GeoHash = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfGeomFromGeoHashExprSridOpt))
	}
	if !a.rewriteExpr(node, node.SridOpt, func(newNode, parent SQLNode) {
		parent.(*GeomFromGeoHashExpr).SridOpt = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfGeomFromGeoJSONExpr(parent SQLNode, node *GeomFromGeoJSONExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfGeomFromGeoJSONExprGeoJSON))
	}
	if !a.rewriteExpr(node, node.GeoJSON, func(newNode, parent SQLNode) {
		parent.(*GeomFromGeoJSONExpr).GeoJSON = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfGeomFromGeoJSONExprHigherDimHandlerOpt))
	}
	if !a.rewriteExpr(node, node.HigherDimHandlerOpt, func(newNode, parent SQLNode) {
		parent.(*GeomFromGeoJSONExpr).HigherDimHandlerOpt = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfGeomFromGeoJSONExprSrid))
	}
	if !a.rewriteExpr(node, node.Srid, func(newNode, parent SQLNode) {
		parent.(*GeomFromGeoJSONExpr).Srid = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfGeomFromTextExpr(parent SQLNode, node *GeomFromTextExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfGeomFromTextExprWktText))
	}
	if !a.rewriteExpr(node, node.WktText, func(newNode, parent SQLNode) {
		parent.(*GeomFromTextExpr).WktText = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfGeomFromTextExprSrid))
	}
	if !a.rewriteExpr(node, node.Srid, func(newNode, parent SQLNode) {
		parent.(*GeomFromTextExpr).Srid = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfGeomFromTextExprAxisOrderOpt))
	}
	if !a.rewriteExpr(node, node.AxisOrderOpt, func(newNode, parent SQLNode) {
		parent.(*GeomFromTextExpr).AxisOrderOpt = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfGeomFromWKBExpr(parent SQLNode, node *GeomFromWKBExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfGeomFromWKBExprWkbBlob))
	}
	if !a.rewriteExpr(node, node.WkbBlob, func(newNode, parent SQLNode) {
		parent.(*GeomFromWKBExpr).WkbBlob = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfGeomFromWKBExprSrid))
	}
	if !a.rewriteExpr(node, node.Srid, func(newNode, parent SQLNode) {
		parent.(*GeomFromWKBExpr).Srid = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfGeomFromWKBExprAxisOrderOpt))
	}
	if !a.rewriteExpr(node, node.AxisOrderOpt, func(newNode, parent SQLNode) {
		parent.(*GeomFromWKBExpr).AxisOrderOpt = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfGeomPropertyFuncExpr(parent SQLNode, node *GeomPropertyFuncExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfGeomPropertyFuncExprGeom))
	}
	if !a.rewriteExpr(node, node.Geom, func(newNode, parent SQLNode) {
		parent.(*GeomPropertyFuncExpr).Geom = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfGroupBy(parent SQLNode, node *GroupBy, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	for x, el := range node.Exprs {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(RefOfGroupByExprsOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteExpr(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(*GroupBy).Exprs[idx] = newNode.(Expr)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfGroupConcatExpr(parent SQLNode, node *GroupConcatExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	for x, el := range node.Exprs {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(RefOfGroupConcatExprExprsOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteExpr(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(*GroupConcatExpr).Exprs[idx] = newNode.(Expr)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths && len(node.Exprs) > 0 {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfGroupConcatExprOrderBy))
	}
	if !a.rewriteOrderBy(node, node.OrderBy, func(newNode, parent SQLNode) {
		parent.(*GroupConcatExpr).OrderBy = newNode.(OrderBy)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfGroupConcatExprLimit))
	}
	if !a.rewriteRefOfLimit(node, node.Limit, func(newNode, parent SQLNode) {
		parent.(*GroupConcatExpr).Limit = newNode.(*Limit)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: StructMethod
func (a *application) rewriteIdentifierCI(parent SQLNode, node IdentifierCI, replacer replacerFunc) bool {
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: StructMethod
func (a *application) rewriteIdentifierCS(parent SQLNode, node IdentifierCS, replacer replacerFunc) bool {
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfIndexDefinition(parent SQLNode, node *IndexDefinition, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfIndexDefinitionInfo))
	}
	if !a.rewriteRefOfIndexInfo(node, node.Info, func(newNode, parent SQLNode) {
		parent.(*IndexDefinition).Info = newNode.(*IndexInfo)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfIndexHint(parent SQLNode, node *IndexHint, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	for x, el := range node.Indexes {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(RefOfIndexHintIndexesOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteIdentifierCI(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(*IndexHint).Indexes[idx] = newNode.(IdentifierCI)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: SliceMethod
func (a *application) rewriteIndexHints(parent SQLNode, node IndexHints, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	for x, el := range node {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(IndexHintsOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteRefOfIndexHint(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(IndexHints)[idx] = newNode.(*IndexHint)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths && len(node) > 0 {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfIndexInfo(parent SQLNode, node *IndexInfo, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfIndexInfoName))
	}
	if !a.rewriteIdentifierCI(node, node.Name, func(newNode, parent SQLNode) {
		parent.(*IndexInfo).Name = newNode.(IdentifierCI)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfIndexInfoConstraintName))
	}
	if !a.rewriteIdentifierCI(node, node.ConstraintName, func(newNode, parent SQLNode) {
		parent.(*IndexInfo).ConstraintName = newNode.(IdentifierCI)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfInsert(parent SQLNode, node *Insert, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfInsertComments))
	}
	if !a.rewriteRefOfParsedComments(node, node.Comments, func(newNode, parent SQLNode) {
		parent.(*Insert).Comments = newNode.(*ParsedComments)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfInsertTable))
	}
	if !a.rewriteRefOfAliasedTableExpr(node, node.Table, func(newNode, parent SQLNode) {
		parent.(*Insert).Table = newNode.(*AliasedTableExpr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfInsertPartitions))
	}
	if !a.rewritePartitions(node, node.Partitions, func(newNode, parent SQLNode) {
		parent.(*Insert).Partitions = newNode.(Partitions)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfInsertColumns))
	}
	if !a.rewriteColumns(node, node.Columns, func(newNode, parent SQLNode) {
		parent.(*Insert).Columns = newNode.(Columns)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfInsertRows))
	}
	if !a.rewriteInsertRows(node, node.Rows, func(newNode, parent SQLNode) {
		parent.(*Insert).Rows = newNode.(InsertRows)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfInsertRowAlias))
	}
	if !a.rewriteRefOfRowAlias(node, node.RowAlias, func(newNode, parent SQLNode) {
		parent.(*Insert).RowAlias = newNode.(*RowAlias)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfInsertOnDup))
	}
	if !a.rewriteOnDup(node, node.OnDup, func(newNode, parent SQLNode) {
		parent.(*Insert).OnDup = newNode.(OnDup)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfInsertExpr(parent SQLNode, node *InsertExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfInsertExprStr))
	}
	if !a.rewriteExpr(node, node.Str, func(newNode, parent SQLNode) {
		parent.(*InsertExpr).Str = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfInsertExprPos))
	}
	if !a.rewriteExpr(node, node.Pos, func(newNode, parent SQLNode) {
		parent.(*InsertExpr).Pos = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfInsertExprLen))
	}
	if !a.rewriteExpr(node, node.Len, func(newNode, parent SQLNode) {
		parent.(*InsertExpr).Len = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfInsertExprNewStr))
	}
	if !a.rewriteExpr(node, node.NewStr, func(newNode, parent SQLNode) {
		parent.(*InsertExpr).NewStr = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfIntervalDateExpr(parent SQLNode, node *IntervalDateExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfIntervalDateExprDate))
	}
	if !a.rewriteExpr(node, node.Date, func(newNode, parent SQLNode) {
		parent.(*IntervalDateExpr).Date = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfIntervalDateExprInterval))
	}
	if !a.rewriteExpr(node, node.Interval, func(newNode, parent SQLNode) {
		parent.(*IntervalDateExpr).Interval = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfIntervalFuncExpr(parent SQLNode, node *IntervalFuncExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfIntervalFuncExprExpr))
	}
	if !a.rewriteExpr(node, node.Expr, func(newNode, parent SQLNode) {
		parent.(*IntervalFuncExpr).Expr = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	for x, el := range node.Exprs {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(RefOfIntervalFuncExprExprsOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteExpr(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(*IntervalFuncExpr).Exprs[idx] = newNode.(Expr)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfIntroducerExpr(parent SQLNode, node *IntroducerExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfIntroducerExprExpr))
	}
	if !a.rewriteExpr(node, node.Expr, func(newNode, parent SQLNode) {
		parent.(*IntroducerExpr).Expr = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfIsExpr(parent SQLNode, node *IsExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfIsExprLeft))
	}
	if !a.rewriteExpr(node, node.Left, func(newNode, parent SQLNode) {
		parent.(*IsExpr).Left = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJSONArrayAgg(parent SQLNode, node *JSONArrayAgg, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfJSONArrayAggExpr))
	}
	if !a.rewriteExpr(node, node.Expr, func(newNode, parent SQLNode) {
		parent.(*JSONArrayAgg).Expr = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfJSONArrayAggOverClause))
	}
	if !a.rewriteRefOfOverClause(node, node.OverClause, func(newNode, parent SQLNode) {
		parent.(*JSONArrayAgg).OverClause = newNode.(*OverClause)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJSONArrayExpr(parent SQLNode, node *JSONArrayExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	for x, el := range node.Params {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(RefOfJSONArrayExprParamsOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteExpr(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(*JSONArrayExpr).Params[idx] = newNode.(Expr)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJSONAttributesExpr(parent SQLNode, node *JSONAttributesExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfJSONAttributesExprJSONDoc))
	}
	if !a.rewriteExpr(node, node.JSONDoc, func(newNode, parent SQLNode) {
		parent.(*JSONAttributesExpr).JSONDoc = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfJSONAttributesExprPath))
	}
	if !a.rewriteExpr(node, node.Path, func(newNode, parent SQLNode) {
		parent.(*JSONAttributesExpr).Path = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJSONContainsExpr(parent SQLNode, node *JSONContainsExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfJSONContainsExprTarget))
	}
	if !a.rewriteExpr(node, node.Target, func(newNode, parent SQLNode) {
		parent.(*JSONContainsExpr).Target = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfJSONContainsExprCandidate))
	}
	if !a.rewriteExpr(node, node.Candidate, func(newNode, parent SQLNode) {
		parent.(*JSONContainsExpr).Candidate = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	for x, el := range node.PathList {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(RefOfJSONContainsExprPathListOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteExpr(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(*JSONContainsExpr).PathList[idx] = newNode.(Expr)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJSONContainsPathExpr(parent SQLNode, node *JSONContainsPathExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfJSONContainsPathExprJSONDoc))
	}
	if !a.rewriteExpr(node, node.JSONDoc, func(newNode, parent SQLNode) {
		parent.(*JSONContainsPathExpr).JSONDoc = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfJSONContainsPathExprOneOrAll))
	}
	if !a.rewriteExpr(node, node.OneOrAll, func(newNode, parent SQLNode) {
		parent.(*JSONContainsPathExpr).OneOrAll = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	for x, el := range node.PathList {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(RefOfJSONContainsPathExprPathListOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteExpr(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(*JSONContainsPathExpr).PathList[idx] = newNode.(Expr)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJSONExtractExpr(parent SQLNode, node *JSONExtractExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfJSONExtractExprJSONDoc))
	}
	if !a.rewriteExpr(node, node.JSONDoc, func(newNode, parent SQLNode) {
		parent.(*JSONExtractExpr).JSONDoc = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	for x, el := range node.PathList {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(RefOfJSONExtractExprPathListOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteExpr(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(*JSONExtractExpr).PathList[idx] = newNode.(Expr)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJSONKeysExpr(parent SQLNode, node *JSONKeysExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfJSONKeysExprJSONDoc))
	}
	if !a.rewriteExpr(node, node.JSONDoc, func(newNode, parent SQLNode) {
		parent.(*JSONKeysExpr).JSONDoc = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfJSONKeysExprPath))
	}
	if !a.rewriteExpr(node, node.Path, func(newNode, parent SQLNode) {
		parent.(*JSONKeysExpr).Path = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJSONObjectAgg(parent SQLNode, node *JSONObjectAgg, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfJSONObjectAggKey))
	}
	if !a.rewriteExpr(node, node.Key, func(newNode, parent SQLNode) {
		parent.(*JSONObjectAgg).Key = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfJSONObjectAggValue))
	}
	if !a.rewriteExpr(node, node.Value, func(newNode, parent SQLNode) {
		parent.(*JSONObjectAgg).Value = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfJSONObjectAggOverClause))
	}
	if !a.rewriteRefOfOverClause(node, node.OverClause, func(newNode, parent SQLNode) {
		parent.(*JSONObjectAgg).OverClause = newNode.(*OverClause)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJSONObjectExpr(parent SQLNode, node *JSONObjectExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	for x, el := range node.Params {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(RefOfJSONObjectExprParamsOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteRefOfJSONObjectParam(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(*JSONObjectExpr).Params[idx] = newNode.(*JSONObjectParam)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJSONObjectParam(parent SQLNode, node *JSONObjectParam, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfJSONObjectParamKey))
	}
	if !a.rewriteExpr(node, node.Key, func(newNode, parent SQLNode) {
		parent.(*JSONObjectParam).Key = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfJSONObjectParamValue))
	}
	if !a.rewriteExpr(node, node.Value, func(newNode, parent SQLNode) {
		parent.(*JSONObjectParam).Value = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJSONOverlapsExpr(parent SQLNode, node *JSONOverlapsExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfJSONOverlapsExprJSONDoc1))
	}
	if !a.rewriteExpr(node, node.JSONDoc1, func(newNode, parent SQLNode) {
		parent.(*JSONOverlapsExpr).JSONDoc1 = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfJSONOverlapsExprJSONDoc2))
	}
	if !a.rewriteExpr(node, node.JSONDoc2, func(newNode, parent SQLNode) {
		parent.(*JSONOverlapsExpr).JSONDoc2 = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJSONPrettyExpr(parent SQLNode, node *JSONPrettyExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfJSONPrettyExprJSONVal))
	}
	if !a.rewriteExpr(node, node.JSONVal, func(newNode, parent SQLNode) {
		parent.(*JSONPrettyExpr).JSONVal = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJSONQuoteExpr(parent SQLNode, node *JSONQuoteExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfJSONQuoteExprStringArg))
	}
	if !a.rewriteExpr(node, node.StringArg, func(newNode, parent SQLNode) {
		parent.(*JSONQuoteExpr).StringArg = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJSONRemoveExpr(parent SQLNode, node *JSONRemoveExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfJSONRemoveExprJSONDoc))
	}
	if !a.rewriteExpr(node, node.JSONDoc, func(newNode, parent SQLNode) {
		parent.(*JSONRemoveExpr).JSONDoc = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	for x, el := range node.PathList {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(RefOfJSONRemoveExprPathListOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteExpr(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(*JSONRemoveExpr).PathList[idx] = newNode.(Expr)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJSONSchemaValidFuncExpr(parent SQLNode, node *JSONSchemaValidFuncExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfJSONSchemaValidFuncExprSchema))
	}
	if !a.rewriteExpr(node, node.Schema, func(newNode, parent SQLNode) {
		parent.(*JSONSchemaValidFuncExpr).Schema = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfJSONSchemaValidFuncExprDocument))
	}
	if !a.rewriteExpr(node, node.Document, func(newNode, parent SQLNode) {
		parent.(*JSONSchemaValidFuncExpr).Document = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJSONSchemaValidationReportFuncExpr(parent SQLNode, node *JSONSchemaValidationReportFuncExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfJSONSchemaValidationReportFuncExprSchema))
	}
	if !a.rewriteExpr(node, node.Schema, func(newNode, parent SQLNode) {
		parent.(*JSONSchemaValidationReportFuncExpr).Schema = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfJSONSchemaValidationReportFuncExprDocument))
	}
	if !a.rewriteExpr(node, node.Document, func(newNode, parent SQLNode) {
		parent.(*JSONSchemaValidationReportFuncExpr).Document = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJSONSearchExpr(parent SQLNode, node *JSONSearchExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfJSONSearchExprJSONDoc))
	}
	if !a.rewriteExpr(node, node.JSONDoc, func(newNode, parent SQLNode) {
		parent.(*JSONSearchExpr).JSONDoc = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfJSONSearchExprOneOrAll))
	}
	if !a.rewriteExpr(node, node.OneOrAll, func(newNode, parent SQLNode) {
		parent.(*JSONSearchExpr).OneOrAll = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfJSONSearchExprSearchStr))
	}
	if !a.rewriteExpr(node, node.SearchStr, func(newNode, parent SQLNode) {
		parent.(*JSONSearchExpr).SearchStr = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfJSONSearchExprEscapeChar))
	}
	if !a.rewriteExpr(node, node.EscapeChar, func(newNode, parent SQLNode) {
		parent.(*JSONSearchExpr).EscapeChar = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	for x, el := range node.PathList {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(RefOfJSONSearchExprPathListOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteExpr(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(*JSONSearchExpr).PathList[idx] = newNode.(Expr)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJSONStorageFreeExpr(parent SQLNode, node *JSONStorageFreeExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfJSONStorageFreeExprJSONVal))
	}
	if !a.rewriteExpr(node, node.JSONVal, func(newNode, parent SQLNode) {
		parent.(*JSONStorageFreeExpr).JSONVal = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJSONStorageSizeExpr(parent SQLNode, node *JSONStorageSizeExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfJSONStorageSizeExprJSONVal))
	}
	if !a.rewriteExpr(node, node.JSONVal, func(newNode, parent SQLNode) {
		parent.(*JSONStorageSizeExpr).JSONVal = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJSONTableExpr(parent SQLNode, node *JSONTableExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfJSONTableExprExpr))
	}
	if !a.rewriteExpr(node, node.Expr, func(newNode, parent SQLNode) {
		parent.(*JSONTableExpr).Expr = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfJSONTableExprAlias))
	}
	if !a.rewriteIdentifierCS(node, node.Alias, func(newNode, parent SQLNode) {
		parent.(*JSONTableExpr).Alias = newNode.(IdentifierCS)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfJSONTableExprFilter))
	}
	if !a.rewriteExpr(node, node.Filter, func(newNode, parent SQLNode) {
		parent.(*JSONTableExpr).Filter = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	for x, el := range node.Columns {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(RefOfJSONTableExprColumnsOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteRefOfJtColumnDefinition(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(*JSONTableExpr).Columns[idx] = newNode.(*JtColumnDefinition)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJSONUnquoteExpr(parent SQLNode, node *JSONUnquoteExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfJSONUnquoteExprJSONValue))
	}
	if !a.rewriteExpr(node, node.JSONValue, func(newNode, parent SQLNode) {
		parent.(*JSONUnquoteExpr).JSONValue = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJSONValueExpr(parent SQLNode, node *JSONValueExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfJSONValueExprJSONDoc))
	}
	if !a.rewriteExpr(node, node.JSONDoc, func(newNode, parent SQLNode) {
		parent.(*JSONValueExpr).JSONDoc = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfJSONValueExprPath))
	}
	if !a.rewriteExpr(node, node.Path, func(newNode, parent SQLNode) {
		parent.(*JSONValueExpr).Path = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfJSONValueExprReturningType))
	}
	if !a.rewriteRefOfConvertType(node, node.ReturningType, func(newNode, parent SQLNode) {
		parent.(*JSONValueExpr).ReturningType = newNode.(*ConvertType)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfJSONValueExprEmptyOnResponse))
	}
	if !a.rewriteRefOfJtOnResponse(node, node.EmptyOnResponse, func(newNode, parent SQLNode) {
		parent.(*JSONValueExpr).EmptyOnResponse = newNode.(*JtOnResponse)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfJSONValueExprErrorOnResponse))
	}
	if !a.rewriteRefOfJtOnResponse(node, node.ErrorOnResponse, func(newNode, parent SQLNode) {
		parent.(*JSONValueExpr).ErrorOnResponse = newNode.(*JtOnResponse)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJSONValueMergeExpr(parent SQLNode, node *JSONValueMergeExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfJSONValueMergeExprJSONDoc))
	}
	if !a.rewriteExpr(node, node.JSONDoc, func(newNode, parent SQLNode) {
		parent.(*JSONValueMergeExpr).JSONDoc = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	for x, el := range node.JSONDocList {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(RefOfJSONValueMergeExprJSONDocListOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteExpr(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(*JSONValueMergeExpr).JSONDocList[idx] = newNode.(Expr)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJSONValueModifierExpr(parent SQLNode, node *JSONValueModifierExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfJSONValueModifierExprJSONDoc))
	}
	if !a.rewriteExpr(node, node.JSONDoc, func(newNode, parent SQLNode) {
		parent.(*JSONValueModifierExpr).JSONDoc = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	for x, el := range node.Params {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(RefOfJSONValueModifierExprParamsOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteRefOfJSONObjectParam(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(*JSONValueModifierExpr).Params[idx] = newNode.(*JSONObjectParam)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJoinCondition(parent SQLNode, node *JoinCondition, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfJoinConditionOn))
	}
	if !a.rewriteExpr(node, node.On, func(newNode, parent SQLNode) {
		parent.(*JoinCondition).On = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfJoinConditionUsing))
	}
	if !a.rewriteColumns(node, node.Using, func(newNode, parent SQLNode) {
		parent.(*JoinCondition).Using = newNode.(Columns)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJoinTableExpr(parent SQLNode, node *JoinTableExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfJoinTableExprLeftExpr))
	}
	if !a.rewriteTableExpr(node, node.LeftExpr, func(newNode, parent SQLNode) {
		parent.(*JoinTableExpr).LeftExpr = newNode.(TableExpr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfJoinTableExprRightExpr))
	}
	if !a.rewriteTableExpr(node, node.RightExpr, func(newNode, parent SQLNode) {
		parent.(*JoinTableExpr).RightExpr = newNode.(TableExpr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfJoinTableExprCondition))
	}
	if !a.rewriteRefOfJoinCondition(node, node.Condition, func(newNode, parent SQLNode) {
		parent.(*JoinTableExpr).Condition = newNode.(*JoinCondition)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJtColumnDefinition(parent SQLNode, node *JtColumnDefinition, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJtOnResponse(parent SQLNode, node *JtOnResponse, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfJtOnResponseExpr))
	}
	if !a.rewriteExpr(node, node.Expr, func(newNode, parent SQLNode) {
		parent.(*JtOnResponse).Expr = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfKeyState(parent SQLNode, node *KeyState, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfKill(parent SQLNode, node *Kill, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfLagLeadExpr(parent SQLNode, node *LagLeadExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfLagLeadExprExpr))
	}
	if !a.rewriteExpr(node, node.Expr, func(newNode, parent SQLNode) {
		parent.(*LagLeadExpr).Expr = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfLagLeadExprN))
	}
	if !a.rewriteExpr(node, node.N, func(newNode, parent SQLNode) {
		parent.(*LagLeadExpr).N = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfLagLeadExprDefault))
	}
	if !a.rewriteExpr(node, node.Default, func(newNode, parent SQLNode) {
		parent.(*LagLeadExpr).Default = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfLagLeadExprOverClause))
	}
	if !a.rewriteRefOfOverClause(node, node.OverClause, func(newNode, parent SQLNode) {
		parent.(*LagLeadExpr).OverClause = newNode.(*OverClause)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfLagLeadExprNullTreatmentClause))
	}
	if !a.rewriteRefOfNullTreatmentClause(node, node.NullTreatmentClause, func(newNode, parent SQLNode) {
		parent.(*LagLeadExpr).NullTreatmentClause = newNode.(*NullTreatmentClause)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfLimit(parent SQLNode, node *Limit, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfLimitOffset))
	}
	if !a.rewriteExpr(node, node.Offset, func(newNode, parent SQLNode) {
		parent.(*Limit).Offset = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfLimitRowcount))
	}
	if !a.rewriteExpr(node, node.Rowcount, func(newNode, parent SQLNode) {
		parent.(*Limit).Rowcount = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfLineStringExpr(parent SQLNode, node *LineStringExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	for x, el := range node.PointParams {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(RefOfLineStringExprPointParamsOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteExpr(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(*LineStringExpr).PointParams[idx] = newNode.(Expr)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfLinestrPropertyFuncExpr(parent SQLNode, node *LinestrPropertyFuncExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfLinestrPropertyFuncExprLinestring))
	}
	if !a.rewriteExpr(node, node.Linestring, func(newNode, parent SQLNode) {
		parent.(*LinestrPropertyFuncExpr).Linestring = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfLinestrPropertyFuncExprPropertyDefArg))
	}
	if !a.rewriteExpr(node, node.PropertyDefArg, func(newNode, parent SQLNode) {
		parent.(*LinestrPropertyFuncExpr).PropertyDefArg = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfLiteral(parent SQLNode, node *Literal, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfLoad(parent SQLNode, node *Load, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfLocateExpr(parent SQLNode, node *LocateExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfLocateExprSubStr))
	}
	if !a.rewriteExpr(node, node.SubStr, func(newNode, parent SQLNode) {
		parent.(*LocateExpr).SubStr = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfLocateExprStr))
	}
	if !a.rewriteExpr(node, node.Str, func(newNode, parent SQLNode) {
		parent.(*LocateExpr).Str = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfLocateExprPos))
	}
	if !a.rewriteExpr(node, node.Pos, func(newNode, parent SQLNode) {
		parent.(*LocateExpr).Pos = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfLockOption(parent SQLNode, node *LockOption, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfLockTables(parent SQLNode, node *LockTables, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfLockingFunc(parent SQLNode, node *LockingFunc, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfLockingFuncName))
	}
	if !a.rewriteExpr(node, node.Name, func(newNode, parent SQLNode) {
		parent.(*LockingFunc).Name = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfLockingFuncTimeout))
	}
	if !a.rewriteExpr(node, node.Timeout, func(newNode, parent SQLNode) {
		parent.(*LockingFunc).Timeout = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfMatchExpr(parent SQLNode, node *MatchExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	for x, el := range node.Columns {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(RefOfMatchExprColumnsOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteRefOfColName(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(*MatchExpr).Columns[idx] = newNode.(*ColName)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths && len(node.Columns) > 0 {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfMatchExprExpr))
	}
	if !a.rewriteExpr(node, node.Expr, func(newNode, parent SQLNode) {
		parent.(*MatchExpr).Expr = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfMax(parent SQLNode, node *Max, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfMaxArg))
	}
	if !a.rewriteExpr(node, node.Arg, func(newNode, parent SQLNode) {
		parent.(*Max).Arg = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfMaxOverClause))
	}
	if !a.rewriteRefOfOverClause(node, node.OverClause, func(newNode, parent SQLNode) {
		parent.(*Max).OverClause = newNode.(*OverClause)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfMemberOfExpr(parent SQLNode, node *MemberOfExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfMemberOfExprValue))
	}
	if !a.rewriteExpr(node, node.Value, func(newNode, parent SQLNode) {
		parent.(*MemberOfExpr).Value = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfMemberOfExprJSONArr))
	}
	if !a.rewriteExpr(node, node.JSONArr, func(newNode, parent SQLNode) {
		parent.(*MemberOfExpr).JSONArr = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfMin(parent SQLNode, node *Min, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfMinArg))
	}
	if !a.rewriteExpr(node, node.Arg, func(newNode, parent SQLNode) {
		parent.(*Min).Arg = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfMinOverClause))
	}
	if !a.rewriteRefOfOverClause(node, node.OverClause, func(newNode, parent SQLNode) {
		parent.(*Min).OverClause = newNode.(*OverClause)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfModifyColumn(parent SQLNode, node *ModifyColumn, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfModifyColumnNewColDefinition))
	}
	if !a.rewriteRefOfColumnDefinition(node, node.NewColDefinition, func(newNode, parent SQLNode) {
		parent.(*ModifyColumn).NewColDefinition = newNode.(*ColumnDefinition)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfModifyColumnAfter))
	}
	if !a.rewriteRefOfColName(node, node.After, func(newNode, parent SQLNode) {
		parent.(*ModifyColumn).After = newNode.(*ColName)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfMultiLinestringExpr(parent SQLNode, node *MultiLinestringExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	for x, el := range node.LinestringParams {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(RefOfMultiLinestringExprLinestringParamsOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteExpr(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(*MultiLinestringExpr).LinestringParams[idx] = newNode.(Expr)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfMultiPointExpr(parent SQLNode, node *MultiPointExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	for x, el := range node.PointParams {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(RefOfMultiPointExprPointParamsOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteExpr(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(*MultiPointExpr).PointParams[idx] = newNode.(Expr)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfMultiPolygonExpr(parent SQLNode, node *MultiPolygonExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	for x, el := range node.PolygonParams {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(RefOfMultiPolygonExprPolygonParamsOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteExpr(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(*MultiPolygonExpr).PolygonParams[idx] = newNode.(Expr)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfNTHValueExpr(parent SQLNode, node *NTHValueExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfNTHValueExprExpr))
	}
	if !a.rewriteExpr(node, node.Expr, func(newNode, parent SQLNode) {
		parent.(*NTHValueExpr).Expr = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfNTHValueExprN))
	}
	if !a.rewriteExpr(node, node.N, func(newNode, parent SQLNode) {
		parent.(*NTHValueExpr).N = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfNTHValueExprOverClause))
	}
	if !a.rewriteRefOfOverClause(node, node.OverClause, func(newNode, parent SQLNode) {
		parent.(*NTHValueExpr).OverClause = newNode.(*OverClause)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfNTHValueExprFromFirstLastClause))
	}
	if !a.rewriteRefOfFromFirstLastClause(node, node.FromFirstLastClause, func(newNode, parent SQLNode) {
		parent.(*NTHValueExpr).FromFirstLastClause = newNode.(*FromFirstLastClause)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfNTHValueExprNullTreatmentClause))
	}
	if !a.rewriteRefOfNullTreatmentClause(node, node.NullTreatmentClause, func(newNode, parent SQLNode) {
		parent.(*NTHValueExpr).NullTreatmentClause = newNode.(*NullTreatmentClause)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfNamedWindow(parent SQLNode, node *NamedWindow, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfNamedWindowWindows))
	}
	if !a.rewriteWindowDefinitions(node, node.Windows, func(newNode, parent SQLNode) {
		parent.(*NamedWindow).Windows = newNode.(WindowDefinitions)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: SliceMethod
func (a *application) rewriteNamedWindows(parent SQLNode, node NamedWindows, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	for x, el := range node {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(NamedWindowsOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteRefOfNamedWindow(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(NamedWindows)[idx] = newNode.(*NamedWindow)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths && len(node) > 0 {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfNextval(parent SQLNode, node *Nextval, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfNextvalExpr))
	}
	if !a.rewriteExpr(node, node.Expr, func(newNode, parent SQLNode) {
		parent.(*Nextval).Expr = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfNotExpr(parent SQLNode, node *NotExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfNotExprExpr))
	}
	if !a.rewriteExpr(node, node.Expr, func(newNode, parent SQLNode) {
		parent.(*NotExpr).Expr = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfNtileExpr(parent SQLNode, node *NtileExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfNtileExprN))
	}
	if !a.rewriteExpr(node, node.N, func(newNode, parent SQLNode) {
		parent.(*NtileExpr).N = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfNtileExprOverClause))
	}
	if !a.rewriteRefOfOverClause(node, node.OverClause, func(newNode, parent SQLNode) {
		parent.(*NtileExpr).OverClause = newNode.(*OverClause)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfNullTreatmentClause(parent SQLNode, node *NullTreatmentClause, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfNullVal(parent SQLNode, node *NullVal, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfOffset(parent SQLNode, node *Offset, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfOffsetOriginal))
	}
	if !a.rewriteExpr(node, node.Original, func(newNode, parent SQLNode) {
		parent.(*Offset).Original = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: SliceMethod
func (a *application) rewriteOnDup(parent SQLNode, node OnDup, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	for x, el := range node {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(OnDupOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteRefOfUpdateExpr(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(OnDup)[idx] = newNode.(*UpdateExpr)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths && len(node) > 0 {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfOptLike(parent SQLNode, node *OptLike, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfOptLikeLikeTable))
	}
	if !a.rewriteTableName(node, node.LikeTable, func(newNode, parent SQLNode) {
		parent.(*OptLike).LikeTable = newNode.(TableName)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfOrExpr(parent SQLNode, node *OrExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfOrExprLeft))
	}
	if !a.rewriteExpr(node, node.Left, func(newNode, parent SQLNode) {
		parent.(*OrExpr).Left = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfOrExprRight))
	}
	if !a.rewriteExpr(node, node.Right, func(newNode, parent SQLNode) {
		parent.(*OrExpr).Right = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfOrder(parent SQLNode, node *Order, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfOrderExpr))
	}
	if !a.rewriteExpr(node, node.Expr, func(newNode, parent SQLNode) {
		parent.(*Order).Expr = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: SliceMethod
func (a *application) rewriteOrderBy(parent SQLNode, node OrderBy, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	for x, el := range node {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(OrderByOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteRefOfOrder(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(OrderBy)[idx] = newNode.(*Order)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths && len(node) > 0 {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfOrderByOption(parent SQLNode, node *OrderByOption, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfOrderByOptionCols))
	}
	if !a.rewriteColumns(node, node.Cols, func(newNode, parent SQLNode) {
		parent.(*OrderByOption).Cols = newNode.(Columns)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfOtherAdmin(parent SQLNode, node *OtherAdmin, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfOverClause(parent SQLNode, node *OverClause, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfOverClauseWindowName))
	}
	if !a.rewriteIdentifierCI(node, node.WindowName, func(newNode, parent SQLNode) {
		parent.(*OverClause).WindowName = newNode.(IdentifierCI)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfOverClauseWindowSpec))
	}
	if !a.rewriteRefOfWindowSpecification(node, node.WindowSpec, func(newNode, parent SQLNode) {
		parent.(*OverClause).WindowSpec = newNode.(*WindowSpecification)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfParenTableExpr(parent SQLNode, node *ParenTableExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfParenTableExprExprs))
	}
	if !a.rewriteTableExprs(node, node.Exprs, func(newNode, parent SQLNode) {
		parent.(*ParenTableExpr).Exprs = newNode.(TableExprs)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfParsedComments(parent SQLNode, node *ParsedComments, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfPartitionDefinition(parent SQLNode, node *PartitionDefinition, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfPartitionDefinitionName))
	}
	if !a.rewriteIdentifierCI(node, node.Name, func(newNode, parent SQLNode) {
		parent.(*PartitionDefinition).Name = newNode.(IdentifierCI)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfPartitionDefinitionOptions))
	}
	if !a.rewriteRefOfPartitionDefinitionOptions(node, node.Options, func(newNode, parent SQLNode) {
		parent.(*PartitionDefinition).Options = newNode.(*PartitionDefinitionOptions)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfPartitionDefinitionOptions(parent SQLNode, node *PartitionDefinitionOptions, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfPartitionDefinitionOptionsValueRange))
	}
	if !a.rewriteRefOfPartitionValueRange(node, node.ValueRange, func(newNode, parent SQLNode) {
		parent.(*PartitionDefinitionOptions).ValueRange = newNode.(*PartitionValueRange)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfPartitionDefinitionOptionsComment))
	}
	if !a.rewriteRefOfLiteral(node, node.Comment, func(newNode, parent SQLNode) {
		parent.(*PartitionDefinitionOptions).Comment = newNode.(*Literal)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfPartitionDefinitionOptionsEngine))
	}
	if !a.rewriteRefOfPartitionEngine(node, node.Engine, func(newNode, parent SQLNode) {
		parent.(*PartitionDefinitionOptions).Engine = newNode.(*PartitionEngine)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfPartitionDefinitionOptionsDataDirectory))
	}
	if !a.rewriteRefOfLiteral(node, node.DataDirectory, func(newNode, parent SQLNode) {
		parent.(*PartitionDefinitionOptions).DataDirectory = newNode.(*Literal)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfPartitionDefinitionOptionsIndexDirectory))
	}
	if !a.rewriteRefOfLiteral(node, node.IndexDirectory, func(newNode, parent SQLNode) {
		parent.(*PartitionDefinitionOptions).IndexDirectory = newNode.(*Literal)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfPartitionDefinitionOptionsSubPartitionDefinitions))
	}
	if !a.rewriteSubPartitionDefinitions(node, node.SubPartitionDefinitions, func(newNode, parent SQLNode) {
		parent.(*PartitionDefinitionOptions).SubPartitionDefinitions = newNode.(SubPartitionDefinitions)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfPartitionEngine(parent SQLNode, node *PartitionEngine, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfPartitionOption(parent SQLNode, node *PartitionOption, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfPartitionOptionColList))
	}
	if !a.rewriteColumns(node, node.ColList, func(newNode, parent SQLNode) {
		parent.(*PartitionOption).ColList = newNode.(Columns)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfPartitionOptionExpr))
	}
	if !a.rewriteExpr(node, node.Expr, func(newNode, parent SQLNode) {
		parent.(*PartitionOption).Expr = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfPartitionOptionSubPartition))
	}
	if !a.rewriteRefOfSubPartition(node, node.SubPartition, func(newNode, parent SQLNode) {
		parent.(*PartitionOption).SubPartition = newNode.(*SubPartition)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	for x, el := range node.Definitions {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(RefOfPartitionOptionDefinitionsOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteRefOfPartitionDefinition(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(*PartitionOption).Definitions[idx] = newNode.(*PartitionDefinition)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfPartitionSpec(parent SQLNode, node *PartitionSpec, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfPartitionSpecNames))
	}
	if !a.rewritePartitions(node, node.Names, func(newNode, parent SQLNode) {
		parent.(*PartitionSpec).Names = newNode.(Partitions)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfPartitionSpecNumber))
	}
	if !a.rewriteRefOfLiteral(node, node.Number, func(newNode, parent SQLNode) {
		parent.(*PartitionSpec).Number = newNode.(*Literal)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfPartitionSpecTableName))
	}
	if !a.rewriteTableName(node, node.TableName, func(newNode, parent SQLNode) {
		parent.(*PartitionSpec).TableName = newNode.(TableName)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	for x, el := range node.Definitions {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(RefOfPartitionSpecDefinitionsOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteRefOfPartitionDefinition(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(*PartitionSpec).Definitions[idx] = newNode.(*PartitionDefinition)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfPartitionValueRange(parent SQLNode, node *PartitionValueRange, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfPartitionValueRangeRange))
	}
	if !a.rewriteValTuple(node, node.Range, func(newNode, parent SQLNode) {
		parent.(*PartitionValueRange).Range = newNode.(ValTuple)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: SliceMethod
func (a *application) rewritePartitions(parent SQLNode, node Partitions, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	for x, el := range node {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(PartitionsOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteIdentifierCI(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(Partitions)[idx] = newNode.(IdentifierCI)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths && len(node) > 0 {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfPerformanceSchemaFuncExpr(parent SQLNode, node *PerformanceSchemaFuncExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfPerformanceSchemaFuncExprArgument))
	}
	if !a.rewriteExpr(node, node.Argument, func(newNode, parent SQLNode) {
		parent.(*PerformanceSchemaFuncExpr).Argument = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfPointExpr(parent SQLNode, node *PointExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfPointExprXCordinate))
	}
	if !a.rewriteExpr(node, node.XCordinate, func(newNode, parent SQLNode) {
		parent.(*PointExpr).XCordinate = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfPointExprYCordinate))
	}
	if !a.rewriteExpr(node, node.YCordinate, func(newNode, parent SQLNode) {
		parent.(*PointExpr).YCordinate = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfPointPropertyFuncExpr(parent SQLNode, node *PointPropertyFuncExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfPointPropertyFuncExprPoint))
	}
	if !a.rewriteExpr(node, node.Point, func(newNode, parent SQLNode) {
		parent.(*PointPropertyFuncExpr).Point = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfPointPropertyFuncExprValueToSet))
	}
	if !a.rewriteExpr(node, node.ValueToSet, func(newNode, parent SQLNode) {
		parent.(*PointPropertyFuncExpr).ValueToSet = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfPolygonExpr(parent SQLNode, node *PolygonExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	for x, el := range node.LinestringParams {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(RefOfPolygonExprLinestringParamsOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteExpr(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(*PolygonExpr).LinestringParams[idx] = newNode.(Expr)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfPolygonPropertyFuncExpr(parent SQLNode, node *PolygonPropertyFuncExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfPolygonPropertyFuncExprPolygon))
	}
	if !a.rewriteExpr(node, node.Polygon, func(newNode, parent SQLNode) {
		parent.(*PolygonPropertyFuncExpr).Polygon = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfPolygonPropertyFuncExprPropertyDefArg))
	}
	if !a.rewriteExpr(node, node.PropertyDefArg, func(newNode, parent SQLNode) {
		parent.(*PolygonPropertyFuncExpr).PropertyDefArg = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfPrepareStmt(parent SQLNode, node *PrepareStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfPrepareStmtName))
	}
	if !a.rewriteIdentifierCI(node, node.Name, func(newNode, parent SQLNode) {
		parent.(*PrepareStmt).Name = newNode.(IdentifierCI)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfPrepareStmtStatement))
	}
	if !a.rewriteExpr(node, node.Statement, func(newNode, parent SQLNode) {
		parent.(*PrepareStmt).Statement = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfPrepareStmtComments))
	}
	if !a.rewriteRefOfParsedComments(node, node.Comments, func(newNode, parent SQLNode) {
		parent.(*PrepareStmt).Comments = newNode.(*ParsedComments)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfPurgeBinaryLogs(parent SQLNode, node *PurgeBinaryLogs, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfReferenceDefinition(parent SQLNode, node *ReferenceDefinition, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfReferenceDefinitionReferencedTable))
	}
	if !a.rewriteTableName(node, node.ReferencedTable, func(newNode, parent SQLNode) {
		parent.(*ReferenceDefinition).ReferencedTable = newNode.(TableName)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfReferenceDefinitionReferencedColumns))
	}
	if !a.rewriteColumns(node, node.ReferencedColumns, func(newNode, parent SQLNode) {
		parent.(*ReferenceDefinition).ReferencedColumns = newNode.(Columns)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfReferenceDefinitionMatch))
	}
	if !a.rewriteMatchAction(node, node.Match, func(newNode, parent SQLNode) {
		parent.(*ReferenceDefinition).Match = newNode.(MatchAction)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfReferenceDefinitionOnDelete))
	}
	if !a.rewriteReferenceAction(node, node.OnDelete, func(newNode, parent SQLNode) {
		parent.(*ReferenceDefinition).OnDelete = newNode.(ReferenceAction)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfReferenceDefinitionOnUpdate))
	}
	if !a.rewriteReferenceAction(node, node.OnUpdate, func(newNode, parent SQLNode) {
		parent.(*ReferenceDefinition).OnUpdate = newNode.(ReferenceAction)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfRegexpInstrExpr(parent SQLNode, node *RegexpInstrExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfRegexpInstrExprExpr))
	}
	if !a.rewriteExpr(node, node.Expr, func(newNode, parent SQLNode) {
		parent.(*RegexpInstrExpr).Expr = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfRegexpInstrExprPattern))
	}
	if !a.rewriteExpr(node, node.Pattern, func(newNode, parent SQLNode) {
		parent.(*RegexpInstrExpr).Pattern = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfRegexpInstrExprPosition))
	}
	if !a.rewriteExpr(node, node.Position, func(newNode, parent SQLNode) {
		parent.(*RegexpInstrExpr).Position = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfRegexpInstrExprOccurrence))
	}
	if !a.rewriteExpr(node, node.Occurrence, func(newNode, parent SQLNode) {
		parent.(*RegexpInstrExpr).Occurrence = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfRegexpInstrExprReturnOption))
	}
	if !a.rewriteExpr(node, node.ReturnOption, func(newNode, parent SQLNode) {
		parent.(*RegexpInstrExpr).ReturnOption = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfRegexpInstrExprMatchType))
	}
	if !a.rewriteExpr(node, node.MatchType, func(newNode, parent SQLNode) {
		parent.(*RegexpInstrExpr).MatchType = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfRegexpLikeExpr(parent SQLNode, node *RegexpLikeExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfRegexpLikeExprExpr))
	}
	if !a.rewriteExpr(node, node.Expr, func(newNode, parent SQLNode) {
		parent.(*RegexpLikeExpr).Expr = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfRegexpLikeExprPattern))
	}
	if !a.rewriteExpr(node, node.Pattern, func(newNode, parent SQLNode) {
		parent.(*RegexpLikeExpr).Pattern = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfRegexpLikeExprMatchType))
	}
	if !a.rewriteExpr(node, node.MatchType, func(newNode, parent SQLNode) {
		parent.(*RegexpLikeExpr).MatchType = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfRegexpReplaceExpr(parent SQLNode, node *RegexpReplaceExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfRegexpReplaceExprExpr))
	}
	if !a.rewriteExpr(node, node.Expr, func(newNode, parent SQLNode) {
		parent.(*RegexpReplaceExpr).Expr = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfRegexpReplaceExprPattern))
	}
	if !a.rewriteExpr(node, node.Pattern, func(newNode, parent SQLNode) {
		parent.(*RegexpReplaceExpr).Pattern = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfRegexpReplaceExprRepl))
	}
	if !a.rewriteExpr(node, node.Repl, func(newNode, parent SQLNode) {
		parent.(*RegexpReplaceExpr).Repl = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfRegexpReplaceExprOccurrence))
	}
	if !a.rewriteExpr(node, node.Occurrence, func(newNode, parent SQLNode) {
		parent.(*RegexpReplaceExpr).Occurrence = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfRegexpReplaceExprPosition))
	}
	if !a.rewriteExpr(node, node.Position, func(newNode, parent SQLNode) {
		parent.(*RegexpReplaceExpr).Position = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfRegexpReplaceExprMatchType))
	}
	if !a.rewriteExpr(node, node.MatchType, func(newNode, parent SQLNode) {
		parent.(*RegexpReplaceExpr).MatchType = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfRegexpSubstrExpr(parent SQLNode, node *RegexpSubstrExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfRegexpSubstrExprExpr))
	}
	if !a.rewriteExpr(node, node.Expr, func(newNode, parent SQLNode) {
		parent.(*RegexpSubstrExpr).Expr = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfRegexpSubstrExprPattern))
	}
	if !a.rewriteExpr(node, node.Pattern, func(newNode, parent SQLNode) {
		parent.(*RegexpSubstrExpr).Pattern = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfRegexpSubstrExprOccurrence))
	}
	if !a.rewriteExpr(node, node.Occurrence, func(newNode, parent SQLNode) {
		parent.(*RegexpSubstrExpr).Occurrence = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfRegexpSubstrExprPosition))
	}
	if !a.rewriteExpr(node, node.Position, func(newNode, parent SQLNode) {
		parent.(*RegexpSubstrExpr).Position = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfRegexpSubstrExprMatchType))
	}
	if !a.rewriteExpr(node, node.MatchType, func(newNode, parent SQLNode) {
		parent.(*RegexpSubstrExpr).MatchType = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfRelease(parent SQLNode, node *Release, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfReleaseName))
	}
	if !a.rewriteIdentifierCI(node, node.Name, func(newNode, parent SQLNode) {
		parent.(*Release).Name = newNode.(IdentifierCI)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfRenameColumn(parent SQLNode, node *RenameColumn, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfRenameColumnOldName))
	}
	if !a.rewriteRefOfColName(node, node.OldName, func(newNode, parent SQLNode) {
		parent.(*RenameColumn).OldName = newNode.(*ColName)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfRenameColumnNewName))
	}
	if !a.rewriteRefOfColName(node, node.NewName, func(newNode, parent SQLNode) {
		parent.(*RenameColumn).NewName = newNode.(*ColName)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfRenameIndex(parent SQLNode, node *RenameIndex, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfRenameIndexOldName))
	}
	if !a.rewriteIdentifierCI(node, node.OldName, func(newNode, parent SQLNode) {
		parent.(*RenameIndex).OldName = newNode.(IdentifierCI)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfRenameIndexNewName))
	}
	if !a.rewriteIdentifierCI(node, node.NewName, func(newNode, parent SQLNode) {
		parent.(*RenameIndex).NewName = newNode.(IdentifierCI)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfRenameTable(parent SQLNode, node *RenameTable, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfRenameTableName(parent SQLNode, node *RenameTableName, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfRenameTableNameTable))
	}
	if !a.rewriteTableName(node, node.Table, func(newNode, parent SQLNode) {
		parent.(*RenameTableName).Table = newNode.(TableName)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfRevertMigration(parent SQLNode, node *RevertMigration, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfRevertMigrationComments))
	}
	if !a.rewriteRefOfParsedComments(node, node.Comments, func(newNode, parent SQLNode) {
		parent.(*RevertMigration).Comments = newNode.(*ParsedComments)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfRollback(parent SQLNode, node *Rollback, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: StructMethod
func (a *application) rewriteRootNode(parent SQLNode, node RootNode, replacer replacerFunc) bool {
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RootNodeSQLNode))
	}
	if !a.rewriteSQLNode(node, node.SQLNode, func(newNode, parent SQLNode) {
		panic("[BUG] tried to replace 'SQLNode' on 'RootNode'")
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfRowAlias(parent SQLNode, node *RowAlias, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfRowAliasTableName))
	}
	if !a.rewriteIdentifierCS(node, node.TableName, func(newNode, parent SQLNode) {
		parent.(*RowAlias).TableName = newNode.(IdentifierCS)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfRowAliasColumns))
	}
	if !a.rewriteColumns(node, node.Columns, func(newNode, parent SQLNode) {
		parent.(*RowAlias).Columns = newNode.(Columns)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfSRollback(parent SQLNode, node *SRollback, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfSRollbackName))
	}
	if !a.rewriteIdentifierCI(node, node.Name, func(newNode, parent SQLNode) {
		parent.(*SRollback).Name = newNode.(IdentifierCI)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfSavepoint(parent SQLNode, node *Savepoint, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfSavepointName))
	}
	if !a.rewriteIdentifierCI(node, node.Name, func(newNode, parent SQLNode) {
		parent.(*Savepoint).Name = newNode.(IdentifierCI)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfSelect(parent SQLNode, node *Select, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfSelectWith))
	}
	if !a.rewriteRefOfWith(node, node.With, func(newNode, parent SQLNode) {
		parent.(*Select).With = newNode.(*With)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	for x, el := range node.From {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(RefOfSelectFromOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteTableExpr(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(*Select).From[idx] = newNode.(TableExpr)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths && len(node.From) > 0 {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfSelectComments))
	}
	if !a.rewriteRefOfParsedComments(node, node.Comments, func(newNode, parent SQLNode) {
		parent.(*Select).Comments = newNode.(*ParsedComments)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfSelectSelectExprs))
	}
	if !a.rewriteRefOfSelectExprs(node, node.SelectExprs, func(newNode, parent SQLNode) {
		parent.(*Select).SelectExprs = newNode.(*SelectExprs)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfSelectWhere))
	}
	if !a.rewriteRefOfWhere(node, node.Where, func(newNode, parent SQLNode) {
		parent.(*Select).Where = newNode.(*Where)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfSelectGroupBy))
	}
	if !a.rewriteRefOfGroupBy(node, node.GroupBy, func(newNode, parent SQLNode) {
		parent.(*Select).GroupBy = newNode.(*GroupBy)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfSelectHaving))
	}
	if !a.rewriteRefOfWhere(node, node.Having, func(newNode, parent SQLNode) {
		parent.(*Select).Having = newNode.(*Where)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfSelectWindows))
	}
	if !a.rewriteNamedWindows(node, node.Windows, func(newNode, parent SQLNode) {
		parent.(*Select).Windows = newNode.(NamedWindows)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfSelectOrderBy))
	}
	if !a.rewriteOrderBy(node, node.OrderBy, func(newNode, parent SQLNode) {
		parent.(*Select).OrderBy = newNode.(OrderBy)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfSelectLimit))
	}
	if !a.rewriteRefOfLimit(node, node.Limit, func(newNode, parent SQLNode) {
		parent.(*Select).Limit = newNode.(*Limit)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfSelectInto))
	}
	if !a.rewriteRefOfSelectInto(node, node.Into, func(newNode, parent SQLNode) {
		parent.(*Select).Into = newNode.(*SelectInto)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfSelectExprs(parent SQLNode, node *SelectExprs, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	for x, el := range node.Exprs {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(RefOfSelectExprsExprsOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteSelectExpr(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(*SelectExprs).Exprs[idx] = newNode.(SelectExpr)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfSelectInto(parent SQLNode, node *SelectInto, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfSet(parent SQLNode, node *Set, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfSetComments))
	}
	if !a.rewriteRefOfParsedComments(node, node.Comments, func(newNode, parent SQLNode) {
		parent.(*Set).Comments = newNode.(*ParsedComments)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfSetExprs))
	}
	if !a.rewriteSetExprs(node, node.Exprs, func(newNode, parent SQLNode) {
		parent.(*Set).Exprs = newNode.(SetExprs)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfSetExpr(parent SQLNode, node *SetExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfSetExprVar))
	}
	if !a.rewriteRefOfVariable(node, node.Var, func(newNode, parent SQLNode) {
		parent.(*SetExpr).Var = newNode.(*Variable)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfSetExprExpr))
	}
	if !a.rewriteExpr(node, node.Expr, func(newNode, parent SQLNode) {
		parent.(*SetExpr).Expr = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: SliceMethod
func (a *application) rewriteSetExprs(parent SQLNode, node SetExprs, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	for x, el := range node {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(SetExprsOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteRefOfSetExpr(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(SetExprs)[idx] = newNode.(*SetExpr)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths && len(node) > 0 {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfShow(parent SQLNode, node *Show, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfShowInternal))
	}
	if !a.rewriteShowInternal(node, node.Internal, func(newNode, parent SQLNode) {
		parent.(*Show).Internal = newNode.(ShowInternal)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfShowBasic(parent SQLNode, node *ShowBasic, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfShowBasicTbl))
	}
	if !a.rewriteTableName(node, node.Tbl, func(newNode, parent SQLNode) {
		parent.(*ShowBasic).Tbl = newNode.(TableName)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfShowBasicDbName))
	}
	if !a.rewriteIdentifierCS(node, node.DbName, func(newNode, parent SQLNode) {
		parent.(*ShowBasic).DbName = newNode.(IdentifierCS)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfShowBasicFilter))
	}
	if !a.rewriteRefOfShowFilter(node, node.Filter, func(newNode, parent SQLNode) {
		parent.(*ShowBasic).Filter = newNode.(*ShowFilter)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfShowCreate(parent SQLNode, node *ShowCreate, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfShowCreateOp))
	}
	if !a.rewriteTableName(node, node.Op, func(newNode, parent SQLNode) {
		parent.(*ShowCreate).Op = newNode.(TableName)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfShowFilter(parent SQLNode, node *ShowFilter, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfShowFilterFilter))
	}
	if !a.rewriteExpr(node, node.Filter, func(newNode, parent SQLNode) {
		parent.(*ShowFilter).Filter = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfShowMigrationLogs(parent SQLNode, node *ShowMigrationLogs, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfShowMigrationLogsComments))
	}
	if !a.rewriteRefOfParsedComments(node, node.Comments, func(newNode, parent SQLNode) {
		parent.(*ShowMigrationLogs).Comments = newNode.(*ParsedComments)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfShowOther(parent SQLNode, node *ShowOther, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfShowThrottledApps(parent SQLNode, node *ShowThrottledApps, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfShowThrottlerStatus(parent SQLNode, node *ShowThrottlerStatus, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfShowTransactionStatus(parent SQLNode, node *ShowTransactionStatus, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfStarExpr(parent SQLNode, node *StarExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfStarExprTableName))
	}
	if !a.rewriteTableName(node, node.TableName, func(newNode, parent SQLNode) {
		parent.(*StarExpr).TableName = newNode.(TableName)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfStd(parent SQLNode, node *Std, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfStdArg))
	}
	if !a.rewriteExpr(node, node.Arg, func(newNode, parent SQLNode) {
		parent.(*Std).Arg = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfStdOverClause))
	}
	if !a.rewriteRefOfOverClause(node, node.OverClause, func(newNode, parent SQLNode) {
		parent.(*Std).OverClause = newNode.(*OverClause)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfStdDev(parent SQLNode, node *StdDev, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfStdDevArg))
	}
	if !a.rewriteExpr(node, node.Arg, func(newNode, parent SQLNode) {
		parent.(*StdDev).Arg = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfStdDevOverClause))
	}
	if !a.rewriteRefOfOverClause(node, node.OverClause, func(newNode, parent SQLNode) {
		parent.(*StdDev).OverClause = newNode.(*OverClause)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfStdPop(parent SQLNode, node *StdPop, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfStdPopArg))
	}
	if !a.rewriteExpr(node, node.Arg, func(newNode, parent SQLNode) {
		parent.(*StdPop).Arg = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfStdPopOverClause))
	}
	if !a.rewriteRefOfOverClause(node, node.OverClause, func(newNode, parent SQLNode) {
		parent.(*StdPop).OverClause = newNode.(*OverClause)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfStdSamp(parent SQLNode, node *StdSamp, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfStdSampArg))
	}
	if !a.rewriteExpr(node, node.Arg, func(newNode, parent SQLNode) {
		parent.(*StdSamp).Arg = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfStdSampOverClause))
	}
	if !a.rewriteRefOfOverClause(node, node.OverClause, func(newNode, parent SQLNode) {
		parent.(*StdSamp).OverClause = newNode.(*OverClause)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfStream(parent SQLNode, node *Stream, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfStreamComments))
	}
	if !a.rewriteRefOfParsedComments(node, node.Comments, func(newNode, parent SQLNode) {
		parent.(*Stream).Comments = newNode.(*ParsedComments)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfStreamSelectExpr))
	}
	if !a.rewriteSelectExpr(node, node.SelectExpr, func(newNode, parent SQLNode) {
		parent.(*Stream).SelectExpr = newNode.(SelectExpr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfStreamTable))
	}
	if !a.rewriteTableName(node, node.Table, func(newNode, parent SQLNode) {
		parent.(*Stream).Table = newNode.(TableName)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfSubPartition(parent SQLNode, node *SubPartition, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfSubPartitionColList))
	}
	if !a.rewriteColumns(node, node.ColList, func(newNode, parent SQLNode) {
		parent.(*SubPartition).ColList = newNode.(Columns)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfSubPartitionExpr))
	}
	if !a.rewriteExpr(node, node.Expr, func(newNode, parent SQLNode) {
		parent.(*SubPartition).Expr = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfSubPartitionDefinition(parent SQLNode, node *SubPartitionDefinition, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfSubPartitionDefinitionName))
	}
	if !a.rewriteIdentifierCI(node, node.Name, func(newNode, parent SQLNode) {
		parent.(*SubPartitionDefinition).Name = newNode.(IdentifierCI)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfSubPartitionDefinitionOptions))
	}
	if !a.rewriteRefOfSubPartitionDefinitionOptions(node, node.Options, func(newNode, parent SQLNode) {
		parent.(*SubPartitionDefinition).Options = newNode.(*SubPartitionDefinitionOptions)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfSubPartitionDefinitionOptions(parent SQLNode, node *SubPartitionDefinitionOptions, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfSubPartitionDefinitionOptionsComment))
	}
	if !a.rewriteRefOfLiteral(node, node.Comment, func(newNode, parent SQLNode) {
		parent.(*SubPartitionDefinitionOptions).Comment = newNode.(*Literal)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfSubPartitionDefinitionOptionsEngine))
	}
	if !a.rewriteRefOfPartitionEngine(node, node.Engine, func(newNode, parent SQLNode) {
		parent.(*SubPartitionDefinitionOptions).Engine = newNode.(*PartitionEngine)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfSubPartitionDefinitionOptionsDataDirectory))
	}
	if !a.rewriteRefOfLiteral(node, node.DataDirectory, func(newNode, parent SQLNode) {
		parent.(*SubPartitionDefinitionOptions).DataDirectory = newNode.(*Literal)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfSubPartitionDefinitionOptionsIndexDirectory))
	}
	if !a.rewriteRefOfLiteral(node, node.IndexDirectory, func(newNode, parent SQLNode) {
		parent.(*SubPartitionDefinitionOptions).IndexDirectory = newNode.(*Literal)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: SliceMethod
func (a *application) rewriteSubPartitionDefinitions(parent SQLNode, node SubPartitionDefinitions, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	for x, el := range node {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(SubPartitionDefinitionsOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteRefOfSubPartitionDefinition(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(SubPartitionDefinitions)[idx] = newNode.(*SubPartitionDefinition)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths && len(node) > 0 {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfSubquery(parent SQLNode, node *Subquery, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfSubquerySelect))
	}
	if !a.rewriteTableStatement(node, node.Select, func(newNode, parent SQLNode) {
		parent.(*Subquery).Select = newNode.(TableStatement)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfSubstrExpr(parent SQLNode, node *SubstrExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfSubstrExprName))
	}
	if !a.rewriteExpr(node, node.Name, func(newNode, parent SQLNode) {
		parent.(*SubstrExpr).Name = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfSubstrExprFrom))
	}
	if !a.rewriteExpr(node, node.From, func(newNode, parent SQLNode) {
		parent.(*SubstrExpr).From = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfSubstrExprTo))
	}
	if !a.rewriteExpr(node, node.To, func(newNode, parent SQLNode) {
		parent.(*SubstrExpr).To = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfSum(parent SQLNode, node *Sum, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfSumArg))
	}
	if !a.rewriteExpr(node, node.Arg, func(newNode, parent SQLNode) {
		parent.(*Sum).Arg = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfSumOverClause))
	}
	if !a.rewriteRefOfOverClause(node, node.OverClause, func(newNode, parent SQLNode) {
		parent.(*Sum).OverClause = newNode.(*OverClause)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: SliceMethod
func (a *application) rewriteTableExprs(parent SQLNode, node TableExprs, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	for x, el := range node {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(TableExprsOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteTableExpr(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(TableExprs)[idx] = newNode.(TableExpr)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths && len(node) > 0 {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: StructMethod
func (a *application) rewriteTableName(parent SQLNode, node TableName, replacer replacerFunc) bool {
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(TableNameName))
	}
	if !a.rewriteIdentifierCS(node, node.Name, func(newNode, parent SQLNode) {
		panic("[BUG] tried to replace 'Name' on 'TableName'")
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(TableNameQualifier))
	}
	if !a.rewriteIdentifierCS(node, node.Qualifier, func(newNode, parent SQLNode) {
		panic("[BUG] tried to replace 'Qualifier' on 'TableName'")
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: SliceMethod
func (a *application) rewriteTableNames(parent SQLNode, node TableNames, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	for x, el := range node {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(TableNamesOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteTableName(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(TableNames)[idx] = newNode.(TableName)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths && len(node) > 0 {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: SliceMethod
func (a *application) rewriteTableOptions(parent SQLNode, node TableOptions, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfTableSpec(parent SQLNode, node *TableSpec, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	for x, el := range node.Columns {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(RefOfTableSpecColumnsOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteRefOfColumnDefinition(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(*TableSpec).Columns[idx] = newNode.(*ColumnDefinition)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths && len(node.Columns) > 0 {
		a.cur.current.Pop()
	}
	for x, el := range node.Indexes {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(RefOfTableSpecIndexesOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteRefOfIndexDefinition(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(*TableSpec).Indexes[idx] = newNode.(*IndexDefinition)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths && len(node.Indexes) > 0 {
		a.cur.current.Pop()
	}
	for x, el := range node.Constraints {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(RefOfTableSpecConstraintsOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteRefOfConstraintDefinition(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(*TableSpec).Constraints[idx] = newNode.(*ConstraintDefinition)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths && len(node.Constraints) > 0 {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfTableSpecOptions))
	}
	if !a.rewriteTableOptions(node, node.Options, func(newNode, parent SQLNode) {
		parent.(*TableSpec).Options = newNode.(TableOptions)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfTableSpecPartitionOption))
	}
	if !a.rewriteRefOfPartitionOption(node, node.PartitionOption, func(newNode, parent SQLNode) {
		parent.(*TableSpec).PartitionOption = newNode.(*PartitionOption)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfTablespaceOperation(parent SQLNode, node *TablespaceOperation, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfTimestampDiffExpr(parent SQLNode, node *TimestampDiffExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfTimestampDiffExprExpr1))
	}
	if !a.rewriteExpr(node, node.Expr1, func(newNode, parent SQLNode) {
		parent.(*TimestampDiffExpr).Expr1 = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfTimestampDiffExprExpr2))
	}
	if !a.rewriteExpr(node, node.Expr2, func(newNode, parent SQLNode) {
		parent.(*TimestampDiffExpr).Expr2 = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfTrimFuncExpr(parent SQLNode, node *TrimFuncExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfTrimFuncExprTrimArg))
	}
	if !a.rewriteExpr(node, node.TrimArg, func(newNode, parent SQLNode) {
		parent.(*TrimFuncExpr).TrimArg = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfTrimFuncExprStringArg))
	}
	if !a.rewriteExpr(node, node.StringArg, func(newNode, parent SQLNode) {
		parent.(*TrimFuncExpr).StringArg = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfTruncateTable(parent SQLNode, node *TruncateTable, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfTruncateTableTable))
	}
	if !a.rewriteTableName(node, node.Table, func(newNode, parent SQLNode) {
		parent.(*TruncateTable).Table = newNode.(TableName)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfUnaryExpr(parent SQLNode, node *UnaryExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfUnaryExprExpr))
	}
	if !a.rewriteExpr(node, node.Expr, func(newNode, parent SQLNode) {
		parent.(*UnaryExpr).Expr = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfUnion(parent SQLNode, node *Union, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfUnionWith))
	}
	if !a.rewriteRefOfWith(node, node.With, func(newNode, parent SQLNode) {
		parent.(*Union).With = newNode.(*With)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfUnionLeft))
	}
	if !a.rewriteTableStatement(node, node.Left, func(newNode, parent SQLNode) {
		parent.(*Union).Left = newNode.(TableStatement)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfUnionRight))
	}
	if !a.rewriteTableStatement(node, node.Right, func(newNode, parent SQLNode) {
		parent.(*Union).Right = newNode.(TableStatement)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfUnionOrderBy))
	}
	if !a.rewriteOrderBy(node, node.OrderBy, func(newNode, parent SQLNode) {
		parent.(*Union).OrderBy = newNode.(OrderBy)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfUnionLimit))
	}
	if !a.rewriteRefOfLimit(node, node.Limit, func(newNode, parent SQLNode) {
		parent.(*Union).Limit = newNode.(*Limit)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfUnionInto))
	}
	if !a.rewriteRefOfSelectInto(node, node.Into, func(newNode, parent SQLNode) {
		parent.(*Union).Into = newNode.(*SelectInto)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfUnlockTables(parent SQLNode, node *UnlockTables, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfUpdate(parent SQLNode, node *Update, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfUpdateWith))
	}
	if !a.rewriteRefOfWith(node, node.With, func(newNode, parent SQLNode) {
		parent.(*Update).With = newNode.(*With)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfUpdateComments))
	}
	if !a.rewriteRefOfParsedComments(node, node.Comments, func(newNode, parent SQLNode) {
		parent.(*Update).Comments = newNode.(*ParsedComments)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	for x, el := range node.TableExprs {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(RefOfUpdateTableExprsOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteTableExpr(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(*Update).TableExprs[idx] = newNode.(TableExpr)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths && len(node.TableExprs) > 0 {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfUpdateExprs))
	}
	if !a.rewriteUpdateExprs(node, node.Exprs, func(newNode, parent SQLNode) {
		parent.(*Update).Exprs = newNode.(UpdateExprs)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfUpdateWhere))
	}
	if !a.rewriteRefOfWhere(node, node.Where, func(newNode, parent SQLNode) {
		parent.(*Update).Where = newNode.(*Where)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfUpdateOrderBy))
	}
	if !a.rewriteOrderBy(node, node.OrderBy, func(newNode, parent SQLNode) {
		parent.(*Update).OrderBy = newNode.(OrderBy)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfUpdateLimit))
	}
	if !a.rewriteRefOfLimit(node, node.Limit, func(newNode, parent SQLNode) {
		parent.(*Update).Limit = newNode.(*Limit)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfUpdateExpr(parent SQLNode, node *UpdateExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfUpdateExprName))
	}
	if !a.rewriteRefOfColName(node, node.Name, func(newNode, parent SQLNode) {
		parent.(*UpdateExpr).Name = newNode.(*ColName)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfUpdateExprExpr))
	}
	if !a.rewriteExpr(node, node.Expr, func(newNode, parent SQLNode) {
		parent.(*UpdateExpr).Expr = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: SliceMethod
func (a *application) rewriteUpdateExprs(parent SQLNode, node UpdateExprs, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	for x, el := range node {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(UpdateExprsOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteRefOfUpdateExpr(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(UpdateExprs)[idx] = newNode.(*UpdateExpr)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths && len(node) > 0 {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfUpdateXMLExpr(parent SQLNode, node *UpdateXMLExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfUpdateXMLExprTarget))
	}
	if !a.rewriteExpr(node, node.Target, func(newNode, parent SQLNode) {
		parent.(*UpdateXMLExpr).Target = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfUpdateXMLExprXPathExpr))
	}
	if !a.rewriteExpr(node, node.XPathExpr, func(newNode, parent SQLNode) {
		parent.(*UpdateXMLExpr).XPathExpr = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfUpdateXMLExprNewXML))
	}
	if !a.rewriteExpr(node, node.NewXML, func(newNode, parent SQLNode) {
		parent.(*UpdateXMLExpr).NewXML = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfUse(parent SQLNode, node *Use, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfUseDBName))
	}
	if !a.rewriteIdentifierCS(node, node.DBName, func(newNode, parent SQLNode) {
		parent.(*Use).DBName = newNode.(IdentifierCS)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfVExplainStmt(parent SQLNode, node *VExplainStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfVExplainStmtStatement))
	}
	if !a.rewriteStatement(node, node.Statement, func(newNode, parent SQLNode) {
		parent.(*VExplainStmt).Statement = newNode.(Statement)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfVExplainStmtComments))
	}
	if !a.rewriteRefOfParsedComments(node, node.Comments, func(newNode, parent SQLNode) {
		parent.(*VExplainStmt).Comments = newNode.(*ParsedComments)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfVStream(parent SQLNode, node *VStream, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfVStreamComments))
	}
	if !a.rewriteRefOfParsedComments(node, node.Comments, func(newNode, parent SQLNode) {
		parent.(*VStream).Comments = newNode.(*ParsedComments)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfVStreamSelectExpr))
	}
	if !a.rewriteSelectExpr(node, node.SelectExpr, func(newNode, parent SQLNode) {
		parent.(*VStream).SelectExpr = newNode.(SelectExpr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfVStreamTable))
	}
	if !a.rewriteTableName(node, node.Table, func(newNode, parent SQLNode) {
		parent.(*VStream).Table = newNode.(TableName)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfVStreamWhere))
	}
	if !a.rewriteRefOfWhere(node, node.Where, func(newNode, parent SQLNode) {
		parent.(*VStream).Where = newNode.(*Where)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfVStreamLimit))
	}
	if !a.rewriteRefOfLimit(node, node.Limit, func(newNode, parent SQLNode) {
		parent.(*VStream).Limit = newNode.(*Limit)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: SliceMethod
func (a *application) rewriteValTuple(parent SQLNode, node ValTuple, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	for x, el := range node {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(ValTupleOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteExpr(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(ValTuple)[idx] = newNode.(Expr)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths && len(node) > 0 {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfValidation(parent SQLNode, node *Validation, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: SliceMethod
func (a *application) rewriteValues(parent SQLNode, node Values, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	for x, el := range node {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(ValuesOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteValTuple(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(Values)[idx] = newNode.(ValTuple)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths && len(node) > 0 {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfValuesFuncExpr(parent SQLNode, node *ValuesFuncExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfValuesFuncExprName))
	}
	if !a.rewriteRefOfColName(node, node.Name, func(newNode, parent SQLNode) {
		parent.(*ValuesFuncExpr).Name = newNode.(*ColName)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfValuesStatement(parent SQLNode, node *ValuesStatement, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfValuesStatementWith))
	}
	if !a.rewriteRefOfWith(node, node.With, func(newNode, parent SQLNode) {
		parent.(*ValuesStatement).With = newNode.(*With)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfValuesStatementRows))
	}
	if !a.rewriteValues(node, node.Rows, func(newNode, parent SQLNode) {
		parent.(*ValuesStatement).Rows = newNode.(Values)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfValuesStatementListArg))
	}
	if !a.rewriteListArg(node, node.ListArg, func(newNode, parent SQLNode) {
		parent.(*ValuesStatement).ListArg = newNode.(ListArg)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfValuesStatementComments))
	}
	if !a.rewriteRefOfParsedComments(node, node.Comments, func(newNode, parent SQLNode) {
		parent.(*ValuesStatement).Comments = newNode.(*ParsedComments)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfValuesStatementOrder))
	}
	if !a.rewriteOrderBy(node, node.Order, func(newNode, parent SQLNode) {
		parent.(*ValuesStatement).Order = newNode.(OrderBy)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfValuesStatementLimit))
	}
	if !a.rewriteRefOfLimit(node, node.Limit, func(newNode, parent SQLNode) {
		parent.(*ValuesStatement).Limit = newNode.(*Limit)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfVarPop(parent SQLNode, node *VarPop, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfVarPopArg))
	}
	if !a.rewriteExpr(node, node.Arg, func(newNode, parent SQLNode) {
		parent.(*VarPop).Arg = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfVarPopOverClause))
	}
	if !a.rewriteRefOfOverClause(node, node.OverClause, func(newNode, parent SQLNode) {
		parent.(*VarPop).OverClause = newNode.(*OverClause)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfVarSamp(parent SQLNode, node *VarSamp, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfVarSampArg))
	}
	if !a.rewriteExpr(node, node.Arg, func(newNode, parent SQLNode) {
		parent.(*VarSamp).Arg = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfVarSampOverClause))
	}
	if !a.rewriteRefOfOverClause(node, node.OverClause, func(newNode, parent SQLNode) {
		parent.(*VarSamp).OverClause = newNode.(*OverClause)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfVariable(parent SQLNode, node *Variable, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfVariableName))
	}
	if !a.rewriteIdentifierCI(node, node.Name, func(newNode, parent SQLNode) {
		parent.(*Variable).Name = newNode.(IdentifierCI)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfVariance(parent SQLNode, node *Variance, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfVarianceArg))
	}
	if !a.rewriteExpr(node, node.Arg, func(newNode, parent SQLNode) {
		parent.(*Variance).Arg = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfVarianceOverClause))
	}
	if !a.rewriteRefOfOverClause(node, node.OverClause, func(newNode, parent SQLNode) {
		parent.(*Variance).OverClause = newNode.(*OverClause)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: StructMethod
func (a *application) rewriteVindexParam(parent SQLNode, node VindexParam, replacer replacerFunc) bool {
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(VindexParamKey))
	}
	if !a.rewriteIdentifierCI(node, node.Key, func(newNode, parent SQLNode) {
		panic("[BUG] tried to replace 'Key' on 'VindexParam'")
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfVindexSpec(parent SQLNode, node *VindexSpec, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfVindexSpecName))
	}
	if !a.rewriteIdentifierCI(node, node.Name, func(newNode, parent SQLNode) {
		parent.(*VindexSpec).Name = newNode.(IdentifierCI)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfVindexSpecType))
	}
	if !a.rewriteIdentifierCI(node, node.Type, func(newNode, parent SQLNode) {
		parent.(*VindexSpec).Type = newNode.(IdentifierCI)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	for x, el := range node.Params {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(RefOfVindexSpecParamsOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteVindexParam(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(*VindexSpec).Params[idx] = newNode.(VindexParam)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfWeightStringFuncExpr(parent SQLNode, node *WeightStringFuncExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfWeightStringFuncExprExpr))
	}
	if !a.rewriteExpr(node, node.Expr, func(newNode, parent SQLNode) {
		parent.(*WeightStringFuncExpr).Expr = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfWeightStringFuncExprAs))
	}
	if !a.rewriteRefOfConvertType(node, node.As, func(newNode, parent SQLNode) {
		parent.(*WeightStringFuncExpr).As = newNode.(*ConvertType)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfWhen(parent SQLNode, node *When, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfWhenCond))
	}
	if !a.rewriteExpr(node, node.Cond, func(newNode, parent SQLNode) {
		parent.(*When).Cond = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfWhenVal))
	}
	if !a.rewriteExpr(node, node.Val, func(newNode, parent SQLNode) {
		parent.(*When).Val = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfWhere(parent SQLNode, node *Where, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfWhereExpr))
	}
	if !a.rewriteExpr(node, node.Expr, func(newNode, parent SQLNode) {
		parent.(*Where).Expr = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfWindowDefinition(parent SQLNode, node *WindowDefinition, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfWindowDefinitionName))
	}
	if !a.rewriteIdentifierCI(node, node.Name, func(newNode, parent SQLNode) {
		parent.(*WindowDefinition).Name = newNode.(IdentifierCI)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfWindowDefinitionWindowSpec))
	}
	if !a.rewriteRefOfWindowSpecification(node, node.WindowSpec, func(newNode, parent SQLNode) {
		parent.(*WindowDefinition).WindowSpec = newNode.(*WindowSpecification)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: SliceMethod
func (a *application) rewriteWindowDefinitions(parent SQLNode, node WindowDefinitions, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	for x, el := range node {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(WindowDefinitionsOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteRefOfWindowDefinition(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(WindowDefinitions)[idx] = newNode.(*WindowDefinition)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths && len(node) > 0 {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfWindowSpecification(parent SQLNode, node *WindowSpecification, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfWindowSpecificationName))
	}
	if !a.rewriteIdentifierCI(node, node.Name, func(newNode, parent SQLNode) {
		parent.(*WindowSpecification).Name = newNode.(IdentifierCI)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	for x, el := range node.PartitionClause {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(RefOfWindowSpecificationPartitionClauseOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteExpr(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(*WindowSpecification).PartitionClause[idx] = newNode.(Expr)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths && len(node.PartitionClause) > 0 {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfWindowSpecificationOrderClause))
	}
	if !a.rewriteOrderBy(node, node.OrderClause, func(newNode, parent SQLNode) {
		parent.(*WindowSpecification).OrderClause = newNode.(OrderBy)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfWindowSpecificationFrameClause))
	}
	if !a.rewriteRefOfFrameClause(node, node.FrameClause, func(newNode, parent SQLNode) {
		parent.(*WindowSpecification).FrameClause = newNode.(*FrameClause)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfWith(parent SQLNode, node *With, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	for x, el := range node.CTEs {
		if a.collectPaths {
			if x == 0 {
				a.cur.current.AddStepWithOffset(uint16(RefOfWithCTEsOffset))
			} else {
				a.cur.current.ChangeOffset(x)
			}
		}
		if !a.rewriteRefOfCommonTableExpr(node, el, func(idx int) replacerFunc {
			return func(newNode, parent SQLNode) {
				parent.(*With).CTEs[idx] = newNode.(*CommonTableExpr)
			}
		}(x)) {
			return false
		}
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfXorExpr(parent SQLNode, node *XorExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfXorExprLeft))
	}
	if !a.rewriteExpr(node, node.Left, func(newNode, parent SQLNode) {
		parent.(*XorExpr).Left = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfXorExprRight))
	}
	if !a.rewriteExpr(node, node.Right, func(newNode, parent SQLNode) {
		parent.(*XorExpr).Right = newNode.(Expr)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: InterfaceMethod
func (a *application) rewriteAggrFunc(parent SQLNode, node AggrFunc, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	switch node := node.(type) {
	case *AnyValue:
		return a.rewriteRefOfAnyValue(parent, node, replacer)
	case *Avg:
		return a.rewriteRefOfAvg(parent, node, replacer)
	case *BitAnd:
		return a.rewriteRefOfBitAnd(parent, node, replacer)
	case *BitOr:
		return a.rewriteRefOfBitOr(parent, node, replacer)
	case *BitXor:
		return a.rewriteRefOfBitXor(parent, node, replacer)
	case *Count:
		return a.rewriteRefOfCount(parent, node, replacer)
	case *CountStar:
		return a.rewriteRefOfCountStar(parent, node, replacer)
	case *GroupConcatExpr:
		return a.rewriteRefOfGroupConcatExpr(parent, node, replacer)
	case *JSONArrayAgg:
		return a.rewriteRefOfJSONArrayAgg(parent, node, replacer)
	case *JSONObjectAgg:
		return a.rewriteRefOfJSONObjectAgg(parent, node, replacer)
	case *Max:
		return a.rewriteRefOfMax(parent, node, replacer)
	case *Min:
		return a.rewriteRefOfMin(parent, node, replacer)
	case *Std:
		return a.rewriteRefOfStd(parent, node, replacer)
	case *StdDev:
		return a.rewriteRefOfStdDev(parent, node, replacer)
	case *StdPop:
		return a.rewriteRefOfStdPop(parent, node, replacer)
	case *StdSamp:
		return a.rewriteRefOfStdSamp(parent, node, replacer)
	case *Sum:
		return a.rewriteRefOfSum(parent, node, replacer)
	case *VarPop:
		return a.rewriteRefOfVarPop(parent, node, replacer)
	case *VarSamp:
		return a.rewriteRefOfVarSamp(parent, node, replacer)
	case *Variance:
		return a.rewriteRefOfVariance(parent, node, replacer)
	default:
		// this should never happen
		return true
	}
}

// Function Generation Source: InterfaceMethod
func (a *application) rewriteAlterOption(parent SQLNode, node AlterOption, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	switch node := node.(type) {
	case *AddColumns:
		return a.rewriteRefOfAddColumns(parent, node, replacer)
	case *AddConstraintDefinition:
		return a.rewriteRefOfAddConstraintDefinition(parent, node, replacer)
	case *AddIndexDefinition:
		return a.rewriteRefOfAddIndexDefinition(parent, node, replacer)
	case AlgorithmValue:
		return a.rewriteAlgorithmValue(parent, node, replacer)
	case *AlterCharset:
		return a.rewriteRefOfAlterCharset(parent, node, replacer)
	case *AlterCheck:
		return a.rewriteRefOfAlterCheck(parent, node, replacer)
	case *AlterColumn:
		return a.rewriteRefOfAlterColumn(parent, node, replacer)
	case *AlterIndex:
		return a.rewriteRefOfAlterIndex(parent, node, replacer)
	case *ChangeColumn:
		return a.rewriteRefOfChangeColumn(parent, node, replacer)
	case *DropColumn:
		return a.rewriteRefOfDropColumn(parent, node, replacer)
	case *DropKey:
		return a.rewriteRefOfDropKey(parent, node, replacer)
	case *Force:
		return a.rewriteRefOfForce(parent, node, replacer)
	case *KeyState:
		return a.rewriteRefOfKeyState(parent, node, replacer)
	case *LockOption:
		return a.rewriteRefOfLockOption(parent, node, replacer)
	case *ModifyColumn:
		return a.rewriteRefOfModifyColumn(parent, node, replacer)
	case *OrderByOption:
		return a.rewriteRefOfOrderByOption(parent, node, replacer)
	case *RenameColumn:
		return a.rewriteRefOfRenameColumn(parent, node, replacer)
	case *RenameIndex:
		return a.rewriteRefOfRenameIndex(parent, node, replacer)
	case *RenameTableName:
		return a.rewriteRefOfRenameTableName(parent, node, replacer)
	case TableOptions:
		return a.rewriteTableOptions(parent, node, replacer)
	case *TablespaceOperation:
		return a.rewriteRefOfTablespaceOperation(parent, node, replacer)
	case *Validation:
		return a.rewriteRefOfValidation(parent, node, replacer)
	default:
		// this should never happen
		return true
	}
}

// Function Generation Source: InterfaceMethod
func (a *application) rewriteCallable(parent SQLNode, node Callable, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	switch node := node.(type) {
	case *AnyValue:
		return a.rewriteRefOfAnyValue(parent, node, replacer)
	case *ArgumentLessWindowExpr:
		return a.rewriteRefOfArgumentLessWindowExpr(parent, node, replacer)
	case *Avg:
		return a.rewriteRefOfAvg(parent, node, replacer)
	case *CharExpr:
		return a.rewriteRefOfCharExpr(parent, node, replacer)
	case *ConvertExpr:
		return a.rewriteRefOfConvertExpr(parent, node, replacer)
	case *ConvertUsingExpr:
		return a.rewriteRefOfConvertUsingExpr(parent, node, replacer)
	case *Count:
		return a.rewriteRefOfCount(parent, node, replacer)
	case *CountStar:
		return a.rewriteRefOfCountStar(parent, node, replacer)
	case *CurTimeFuncExpr:
		return a.rewriteRefOfCurTimeFuncExpr(parent, node, replacer)
	case *ExtractFuncExpr:
		return a.rewriteRefOfExtractFuncExpr(parent, node, replacer)
	case *ExtractValueExpr:
		return a.rewriteRefOfExtractValueExpr(parent, node, replacer)
	case *FirstOrLastValueExpr:
		return a.rewriteRefOfFirstOrLastValueExpr(parent, node, replacer)
	case *FuncExpr:
		return a.rewriteRefOfFuncExpr(parent, node, replacer)
	case *GTIDFuncExpr:
		return a.rewriteRefOfGTIDFuncExpr(parent, node, replacer)
	case *GeoHashFromLatLongExpr:
		return a.rewriteRefOfGeoHashFromLatLongExpr(parent, node, replacer)
	case *GeoHashFromPointExpr:
		return a.rewriteRefOfGeoHashFromPointExpr(parent, node, replacer)
	case *GeoJSONFromGeomExpr:
		return a.rewriteRefOfGeoJSONFromGeomExpr(parent, node, replacer)
	case *GeomCollPropertyFuncExpr:
		return a.rewriteRefOfGeomCollPropertyFuncExpr(parent, node, replacer)
	case *GeomFormatExpr:
		return a.rewriteRefOfGeomFormatExpr(parent, node, replacer)
	case *GeomFromGeoHashExpr:
		return a.rewriteRefOfGeomFromGeoHashExpr(parent, node, replacer)
	case *GeomFromGeoJSONExpr:
		return a.rewriteRefOfGeomFromGeoJSONExpr(parent, node, replacer)
	case *GeomFromTextExpr:
		return a.rewriteRefOfGeomFromTextExpr(parent, node, replacer)
	case *GeomFromWKBExpr:
		return a.rewriteRefOfGeomFromWKBExpr(parent, node, replacer)
	case *GeomPropertyFuncExpr:
		return a.rewriteRefOfGeomPropertyFuncExpr(parent, node, replacer)
	case *GroupConcatExpr:
		return a.rewriteRefOfGroupConcatExpr(parent, node, replacer)
	case *InsertExpr:
		return a.rewriteRefOfInsertExpr(parent, node, replacer)
	case *IntervalDateExpr:
		return a.rewriteRefOfIntervalDateExpr(parent, node, replacer)
	case *IntervalFuncExpr:
		return a.rewriteRefOfIntervalFuncExpr(parent, node, replacer)
	case *JSONArrayExpr:
		return a.rewriteRefOfJSONArrayExpr(parent, node, replacer)
	case *JSONAttributesExpr:
		return a.rewriteRefOfJSONAttributesExpr(parent, node, replacer)
	case *JSONContainsExpr:
		return a.rewriteRefOfJSONContainsExpr(parent, node, replacer)
	case *JSONContainsPathExpr:
		return a.rewriteRefOfJSONContainsPathExpr(parent, node, replacer)
	case *JSONExtractExpr:
		return a.rewriteRefOfJSONExtractExpr(parent, node, replacer)
	case *JSONKeysExpr:
		return a.rewriteRefOfJSONKeysExpr(parent, node, replacer)
	case *JSONObjectExpr:
		return a.rewriteRefOfJSONObjectExpr(parent, node, replacer)
	case *JSONOverlapsExpr:
		return a.rewriteRefOfJSONOverlapsExpr(parent, node, replacer)
	case *JSONPrettyExpr:
		return a.rewriteRefOfJSONPrettyExpr(parent, node, replacer)
	case *JSONQuoteExpr:
		return a.rewriteRefOfJSONQuoteExpr(parent, node, replacer)
	case *JSONRemoveExpr:
		return a.rewriteRefOfJSONRemoveExpr(parent, node, replacer)
	case *JSONSchemaValidFuncExpr:
		return a.rewriteRefOfJSONSchemaValidFuncExpr(parent, node, replacer)
	case *JSONSchemaValidationReportFuncExpr:
		return a.rewriteRefOfJSONSchemaValidationReportFuncExpr(parent, node, replacer)
	case *JSONSearchExpr:
		return a.rewriteRefOfJSONSearchExpr(parent, node, replacer)
	case *JSONStorageFreeExpr:
		return a.rewriteRefOfJSONStorageFreeExpr(parent, node, replacer)
	case *JSONStorageSizeExpr:
		return a.rewriteRefOfJSONStorageSizeExpr(parent, node, replacer)
	case *JSONUnquoteExpr:
		return a.rewriteRefOfJSONUnquoteExpr(parent, node, replacer)
	case *JSONValueExpr:
		return a.rewriteRefOfJSONValueExpr(parent, node, replacer)
	case *JSONValueMergeExpr:
		return a.rewriteRefOfJSONValueMergeExpr(parent, node, replacer)
	case *JSONValueModifierExpr:
		return a.rewriteRefOfJSONValueModifierExpr(parent, node, replacer)
	case *LagLeadExpr:
		return a.rewriteRefOfLagLeadExpr(parent, node, replacer)
	case *LineStringExpr:
		return a.rewriteRefOfLineStringExpr(parent, node, replacer)
	case *LinestrPropertyFuncExpr:
		return a.rewriteRefOfLinestrPropertyFuncExpr(parent, node, replacer)
	case *LocateExpr:
		return a.rewriteRefOfLocateExpr(parent, node, replacer)
	case *MatchExpr:
		return a.rewriteRefOfMatchExpr(parent, node, replacer)
	case *Max:
		return a.rewriteRefOfMax(parent, node, replacer)
	case *MemberOfExpr:
		return a.rewriteRefOfMemberOfExpr(parent, node, replacer)
	case *Min:
		return a.rewriteRefOfMin(parent, node, replacer)
	case *MultiLinestringExpr:
		return a.rewriteRefOfMultiLinestringExpr(parent, node, replacer)
	case *MultiPointExpr:
		return a.rewriteRefOfMultiPointExpr(parent, node, replacer)
	case *MultiPolygonExpr:
		return a.rewriteRefOfMultiPolygonExpr(parent, node, replacer)
	case *NTHValueExpr:
		return a.rewriteRefOfNTHValueExpr(parent, node, replacer)
	case *NamedWindow:
		return a.rewriteRefOfNamedWindow(parent, node, replacer)
	case *NtileExpr:
		return a.rewriteRefOfNtileExpr(parent, node, replacer)
	case *PerformanceSchemaFuncExpr:
		return a.rewriteRefOfPerformanceSchemaFuncExpr(parent, node, replacer)
	case *PointExpr:
		return a.rewriteRefOfPointExpr(parent, node, replacer)
	case *PointPropertyFuncExpr:
		return a.rewriteRefOfPointPropertyFuncExpr(parent, node, replacer)
	case *PolygonExpr:
		return a.rewriteRefOfPolygonExpr(parent, node, replacer)
	case *PolygonPropertyFuncExpr:
		return a.rewriteRefOfPolygonPropertyFuncExpr(parent, node, replacer)
	case *RegexpInstrExpr:
		return a.rewriteRefOfRegexpInstrExpr(parent, node, replacer)
	case *RegexpLikeExpr:
		return a.rewriteRefOfRegexpLikeExpr(parent, node, replacer)
	case *RegexpReplaceExpr:
		return a.rewriteRefOfRegexpReplaceExpr(parent, node, replacer)
	case *RegexpSubstrExpr:
		return a.rewriteRefOfRegexpSubstrExpr(parent, node, replacer)
	case *SubstrExpr:
		return a.rewriteRefOfSubstrExpr(parent, node, replacer)
	case *Sum:
		return a.rewriteRefOfSum(parent, node, replacer)
	case *TimestampDiffExpr:
		return a.rewriteRefOfTimestampDiffExpr(parent, node, replacer)
	case *TrimFuncExpr:
		return a.rewriteRefOfTrimFuncExpr(parent, node, replacer)
	case *UpdateXMLExpr:
		return a.rewriteRefOfUpdateXMLExpr(parent, node, replacer)
	case *ValuesFuncExpr:
		return a.rewriteRefOfValuesFuncExpr(parent, node, replacer)
	case *WeightStringFuncExpr:
		return a.rewriteRefOfWeightStringFuncExpr(parent, node, replacer)
	default:
		// this should never happen
		return true
	}
}

// Function Generation Source: InterfaceMethod
func (a *application) rewriteColTuple(parent SQLNode, node ColTuple, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	switch node := node.(type) {
	case ListArg:
		return a.rewriteListArg(parent, node, replacer)
	case *Subquery:
		return a.rewriteRefOfSubquery(parent, node, replacer)
	case ValTuple:
		return a.rewriteValTuple(parent, node, replacer)
	default:
		// this should never happen
		return true
	}
}

// Function Generation Source: InterfaceMethod
func (a *application) rewriteConstraintInfo(parent SQLNode, node ConstraintInfo, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	switch node := node.(type) {
	case *CheckConstraintDefinition:
		return a.rewriteRefOfCheckConstraintDefinition(parent, node, replacer)
	case *ForeignKeyDefinition:
		return a.rewriteRefOfForeignKeyDefinition(parent, node, replacer)
	default:
		// this should never happen
		return true
	}
}

// Function Generation Source: InterfaceMethod
func (a *application) rewriteDBDDLStatement(parent SQLNode, node DBDDLStatement, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	switch node := node.(type) {
	case *AlterDatabase:
		return a.rewriteRefOfAlterDatabase(parent, node, replacer)
	case *CreateDatabase:
		return a.rewriteRefOfCreateDatabase(parent, node, replacer)
	case *DropDatabase:
		return a.rewriteRefOfDropDatabase(parent, node, replacer)
	default:
		// this should never happen
		return true
	}
}

// Function Generation Source: InterfaceMethod
func (a *application) rewriteDDLStatement(parent SQLNode, node DDLStatement, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	switch node := node.(type) {
	case *AlterTable:
		return a.rewriteRefOfAlterTable(parent, node, replacer)
	case *AlterView:
		return a.rewriteRefOfAlterView(parent, node, replacer)
	case *CreateTable:
		return a.rewriteRefOfCreateTable(parent, node, replacer)
	case *CreateView:
		return a.rewriteRefOfCreateView(parent, node, replacer)
	case *DropTable:
		return a.rewriteRefOfDropTable(parent, node, replacer)
	case *DropView:
		return a.rewriteRefOfDropView(parent, node, replacer)
	case *RenameTable:
		return a.rewriteRefOfRenameTable(parent, node, replacer)
	case *TruncateTable:
		return a.rewriteRefOfTruncateTable(parent, node, replacer)
	default:
		// this should never happen
		return true
	}
}

// Function Generation Source: InterfaceMethod
func (a *application) rewriteExplain(parent SQLNode, node Explain, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	switch node := node.(type) {
	case *ExplainStmt:
		return a.rewriteRefOfExplainStmt(parent, node, replacer)
	case *ExplainTab:
		return a.rewriteRefOfExplainTab(parent, node, replacer)
	default:
		// this should never happen
		return true
	}
}

// Function Generation Source: InterfaceMethod
func (a *application) rewriteExpr(parent SQLNode, node Expr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	switch node := node.(type) {
	case *AndExpr:
		return a.rewriteRefOfAndExpr(parent, node, replacer)
	case *AnyValue:
		return a.rewriteRefOfAnyValue(parent, node, replacer)
	case *Argument:
		return a.rewriteRefOfArgument(parent, node, replacer)
	case *ArgumentLessWindowExpr:
		return a.rewriteRefOfArgumentLessWindowExpr(parent, node, replacer)
	case *AssignmentExpr:
		return a.rewriteRefOfAssignmentExpr(parent, node, replacer)
	case *Avg:
		return a.rewriteRefOfAvg(parent, node, replacer)
	case *BetweenExpr:
		return a.rewriteRefOfBetweenExpr(parent, node, replacer)
	case *BinaryExpr:
		return a.rewriteRefOfBinaryExpr(parent, node, replacer)
	case *BitAnd:
		return a.rewriteRefOfBitAnd(parent, node, replacer)
	case *BitOr:
		return a.rewriteRefOfBitOr(parent, node, replacer)
	case *BitXor:
		return a.rewriteRefOfBitXor(parent, node, replacer)
	case BoolVal:
		return a.rewriteBoolVal(parent, node, replacer)
	case *CaseExpr:
		return a.rewriteRefOfCaseExpr(parent, node, replacer)
	case *CastExpr:
		return a.rewriteRefOfCastExpr(parent, node, replacer)
	case *CharExpr:
		return a.rewriteRefOfCharExpr(parent, node, replacer)
	case *ColName:
		return a.rewriteRefOfColName(parent, node, replacer)
	case *CollateExpr:
		return a.rewriteRefOfCollateExpr(parent, node, replacer)
	case *ComparisonExpr:
		return a.rewriteRefOfComparisonExpr(parent, node, replacer)
	case *ConvertExpr:
		return a.rewriteRefOfConvertExpr(parent, node, replacer)
	case *ConvertUsingExpr:
		return a.rewriteRefOfConvertUsingExpr(parent, node, replacer)
	case *Count:
		return a.rewriteRefOfCount(parent, node, replacer)
	case *CountStar:
		return a.rewriteRefOfCountStar(parent, node, replacer)
	case *CurTimeFuncExpr:
		return a.rewriteRefOfCurTimeFuncExpr(parent, node, replacer)
	case *Default:
		return a.rewriteRefOfDefault(parent, node, replacer)
	case *ExistsExpr:
		return a.rewriteRefOfExistsExpr(parent, node, replacer)
	case *ExtractFuncExpr:
		return a.rewriteRefOfExtractFuncExpr(parent, node, replacer)
	case *ExtractValueExpr:
		return a.rewriteRefOfExtractValueExpr(parent, node, replacer)
	case *FirstOrLastValueExpr:
		return a.rewriteRefOfFirstOrLastValueExpr(parent, node, replacer)
	case *FuncExpr:
		return a.rewriteRefOfFuncExpr(parent, node, replacer)
	case *GTIDFuncExpr:
		return a.rewriteRefOfGTIDFuncExpr(parent, node, replacer)
	case *GeoHashFromLatLongExpr:
		return a.rewriteRefOfGeoHashFromLatLongExpr(parent, node, replacer)
	case *GeoHashFromPointExpr:
		return a.rewriteRefOfGeoHashFromPointExpr(parent, node, replacer)
	case *GeoJSONFromGeomExpr:
		return a.rewriteRefOfGeoJSONFromGeomExpr(parent, node, replacer)
	case *GeomCollPropertyFuncExpr:
		return a.rewriteRefOfGeomCollPropertyFuncExpr(parent, node, replacer)
	case *GeomFormatExpr:
		return a.rewriteRefOfGeomFormatExpr(parent, node, replacer)
	case *GeomFromGeoHashExpr:
		return a.rewriteRefOfGeomFromGeoHashExpr(parent, node, replacer)
	case *GeomFromGeoJSONExpr:
		return a.rewriteRefOfGeomFromGeoJSONExpr(parent, node, replacer)
	case *GeomFromTextExpr:
		return a.rewriteRefOfGeomFromTextExpr(parent, node, replacer)
	case *GeomFromWKBExpr:
		return a.rewriteRefOfGeomFromWKBExpr(parent, node, replacer)
	case *GeomPropertyFuncExpr:
		return a.rewriteRefOfGeomPropertyFuncExpr(parent, node, replacer)
	case *GroupConcatExpr:
		return a.rewriteRefOfGroupConcatExpr(parent, node, replacer)
	case *InsertExpr:
		return a.rewriteRefOfInsertExpr(parent, node, replacer)
	case *IntervalDateExpr:
		return a.rewriteRefOfIntervalDateExpr(parent, node, replacer)
	case *IntervalFuncExpr:
		return a.rewriteRefOfIntervalFuncExpr(parent, node, replacer)
	case *IntroducerExpr:
		return a.rewriteRefOfIntroducerExpr(parent, node, replacer)
	case *IsExpr:
		return a.rewriteRefOfIsExpr(parent, node, replacer)
	case *JSONArrayAgg:
		return a.rewriteRefOfJSONArrayAgg(parent, node, replacer)
	case *JSONArrayExpr:
		return a.rewriteRefOfJSONArrayExpr(parent, node, replacer)
	case *JSONAttributesExpr:
		return a.rewriteRefOfJSONAttributesExpr(parent, node, replacer)
	case *JSONContainsExpr:
		return a.rewriteRefOfJSONContainsExpr(parent, node, replacer)
	case *JSONContainsPathExpr:
		return a.rewriteRefOfJSONContainsPathExpr(parent, node, replacer)
	case *JSONExtractExpr:
		return a.rewriteRefOfJSONExtractExpr(parent, node, replacer)
	case *JSONKeysExpr:
		return a.rewriteRefOfJSONKeysExpr(parent, node, replacer)
	case *JSONObjectAgg:
		return a.rewriteRefOfJSONObjectAgg(parent, node, replacer)
	case *JSONObjectExpr:
		return a.rewriteRefOfJSONObjectExpr(parent, node, replacer)
	case *JSONOverlapsExpr:
		return a.rewriteRefOfJSONOverlapsExpr(parent, node, replacer)
	case *JSONPrettyExpr:
		return a.rewriteRefOfJSONPrettyExpr(parent, node, replacer)
	case *JSONQuoteExpr:
		return a.rewriteRefOfJSONQuoteExpr(parent, node, replacer)
	case *JSONRemoveExpr:
		return a.rewriteRefOfJSONRemoveExpr(parent, node, replacer)
	case *JSONSchemaValidFuncExpr:
		return a.rewriteRefOfJSONSchemaValidFuncExpr(parent, node, replacer)
	case *JSONSchemaValidationReportFuncExpr:
		return a.rewriteRefOfJSONSchemaValidationReportFuncExpr(parent, node, replacer)
	case *JSONSearchExpr:
		return a.rewriteRefOfJSONSearchExpr(parent, node, replacer)
	case *JSONStorageFreeExpr:
		return a.rewriteRefOfJSONStorageFreeExpr(parent, node, replacer)
	case *JSONStorageSizeExpr:
		return a.rewriteRefOfJSONStorageSizeExpr(parent, node, replacer)
	case *JSONUnquoteExpr:
		return a.rewriteRefOfJSONUnquoteExpr(parent, node, replacer)
	case *JSONValueExpr:
		return a.rewriteRefOfJSONValueExpr(parent, node, replacer)
	case *JSONValueMergeExpr:
		return a.rewriteRefOfJSONValueMergeExpr(parent, node, replacer)
	case *JSONValueModifierExpr:
		return a.rewriteRefOfJSONValueModifierExpr(parent, node, replacer)
	case *LagLeadExpr:
		return a.rewriteRefOfLagLeadExpr(parent, node, replacer)
	case *LineStringExpr:
		return a.rewriteRefOfLineStringExpr(parent, node, replacer)
	case *LinestrPropertyFuncExpr:
		return a.rewriteRefOfLinestrPropertyFuncExpr(parent, node, replacer)
	case ListArg:
		return a.rewriteListArg(parent, node, replacer)
	case *Literal:
		return a.rewriteRefOfLiteral(parent, node, replacer)
	case *LocateExpr:
		return a.rewriteRefOfLocateExpr(parent, node, replacer)
	case *LockingFunc:
		return a.rewriteRefOfLockingFunc(parent, node, replacer)
	case *MatchExpr:
		return a.rewriteRefOfMatchExpr(parent, node, replacer)
	case *Max:
		return a.rewriteRefOfMax(parent, node, replacer)
	case *MemberOfExpr:
		return a.rewriteRefOfMemberOfExpr(parent, node, replacer)
	case *Min:
		return a.rewriteRefOfMin(parent, node, replacer)
	case *MultiLinestringExpr:
		return a.rewriteRefOfMultiLinestringExpr(parent, node, replacer)
	case *MultiPointExpr:
		return a.rewriteRefOfMultiPointExpr(parent, node, replacer)
	case *MultiPolygonExpr:
		return a.rewriteRefOfMultiPolygonExpr(parent, node, replacer)
	case *NTHValueExpr:
		return a.rewriteRefOfNTHValueExpr(parent, node, replacer)
	case *NamedWindow:
		return a.rewriteRefOfNamedWindow(parent, node, replacer)
	case *NotExpr:
		return a.rewriteRefOfNotExpr(parent, node, replacer)
	case *NtileExpr:
		return a.rewriteRefOfNtileExpr(parent, node, replacer)
	case *NullVal:
		return a.rewriteRefOfNullVal(parent, node, replacer)
	case *Offset:
		return a.rewriteRefOfOffset(parent, node, replacer)
	case *OrExpr:
		return a.rewriteRefOfOrExpr(parent, node, replacer)
	case *PerformanceSchemaFuncExpr:
		return a.rewriteRefOfPerformanceSchemaFuncExpr(parent, node, replacer)
	case *PointExpr:
		return a.rewriteRefOfPointExpr(parent, node, replacer)
	case *PointPropertyFuncExpr:
		return a.rewriteRefOfPointPropertyFuncExpr(parent, node, replacer)
	case *PolygonExpr:
		return a.rewriteRefOfPolygonExpr(parent, node, replacer)
	case *PolygonPropertyFuncExpr:
		return a.rewriteRefOfPolygonPropertyFuncExpr(parent, node, replacer)
	case *RegexpInstrExpr:
		return a.rewriteRefOfRegexpInstrExpr(parent, node, replacer)
	case *RegexpLikeExpr:
		return a.rewriteRefOfRegexpLikeExpr(parent, node, replacer)
	case *RegexpReplaceExpr:
		return a.rewriteRefOfRegexpReplaceExpr(parent, node, replacer)
	case *RegexpSubstrExpr:
		return a.rewriteRefOfRegexpSubstrExpr(parent, node, replacer)
	case *Std:
		return a.rewriteRefOfStd(parent, node, replacer)
	case *StdDev:
		return a.rewriteRefOfStdDev(parent, node, replacer)
	case *StdPop:
		return a.rewriteRefOfStdPop(parent, node, replacer)
	case *StdSamp:
		return a.rewriteRefOfStdSamp(parent, node, replacer)
	case *Subquery:
		return a.rewriteRefOfSubquery(parent, node, replacer)
	case *SubstrExpr:
		return a.rewriteRefOfSubstrExpr(parent, node, replacer)
	case *Sum:
		return a.rewriteRefOfSum(parent, node, replacer)
	case *TimestampDiffExpr:
		return a.rewriteRefOfTimestampDiffExpr(parent, node, replacer)
	case *TrimFuncExpr:
		return a.rewriteRefOfTrimFuncExpr(parent, node, replacer)
	case *UnaryExpr:
		return a.rewriteRefOfUnaryExpr(parent, node, replacer)
	case *UpdateXMLExpr:
		return a.rewriteRefOfUpdateXMLExpr(parent, node, replacer)
	case ValTuple:
		return a.rewriteValTuple(parent, node, replacer)
	case *ValuesFuncExpr:
		return a.rewriteRefOfValuesFuncExpr(parent, node, replacer)
	case *VarPop:
		return a.rewriteRefOfVarPop(parent, node, replacer)
	case *VarSamp:
		return a.rewriteRefOfVarSamp(parent, node, replacer)
	case *Variable:
		return a.rewriteRefOfVariable(parent, node, replacer)
	case *Variance:
		return a.rewriteRefOfVariance(parent, node, replacer)
	case *WeightStringFuncExpr:
		return a.rewriteRefOfWeightStringFuncExpr(parent, node, replacer)
	case *XorExpr:
		return a.rewriteRefOfXorExpr(parent, node, replacer)
	default:
		// this should never happen
		return true
	}
}

// Function Generation Source: InterfaceMethod
func (a *application) rewriteInsertRows(parent SQLNode, node InsertRows, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	switch node := node.(type) {
	case *Select:
		return a.rewriteRefOfSelect(parent, node, replacer)
	case *Union:
		return a.rewriteRefOfUnion(parent, node, replacer)
	case Values:
		return a.rewriteValues(parent, node, replacer)
	case *ValuesStatement:
		return a.rewriteRefOfValuesStatement(parent, node, replacer)
	default:
		// this should never happen
		return true
	}
}

// Function Generation Source: InterfaceMethod
func (a *application) rewriteSelectExpr(parent SQLNode, node SelectExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	switch node := node.(type) {
	case *AliasedExpr:
		return a.rewriteRefOfAliasedExpr(parent, node, replacer)
	case *Nextval:
		return a.rewriteRefOfNextval(parent, node, replacer)
	case *StarExpr:
		return a.rewriteRefOfStarExpr(parent, node, replacer)
	default:
		// this should never happen
		return true
	}
}

// Function Generation Source: InterfaceMethod
func (a *application) rewriteSelectStatement(parent SQLNode, node SelectStatement, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	switch node := node.(type) {
	case *Select:
		return a.rewriteRefOfSelect(parent, node, replacer)
	case *Union:
		return a.rewriteRefOfUnion(parent, node, replacer)
	default:
		// this should never happen
		return true
	}
}

// Function Generation Source: InterfaceMethod
func (a *application) rewriteShowInternal(parent SQLNode, node ShowInternal, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	switch node := node.(type) {
	case *ShowBasic:
		return a.rewriteRefOfShowBasic(parent, node, replacer)
	case *ShowCreate:
		return a.rewriteRefOfShowCreate(parent, node, replacer)
	case *ShowOther:
		return a.rewriteRefOfShowOther(parent, node, replacer)
	case *ShowTransactionStatus:
		return a.rewriteRefOfShowTransactionStatus(parent, node, replacer)
	default:
		// this should never happen
		return true
	}
}

// Function Generation Source: InterfaceMethod
func (a *application) rewriteSimpleTableExpr(parent SQLNode, node SimpleTableExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	switch node := node.(type) {
	case *DerivedTable:
		return a.rewriteRefOfDerivedTable(parent, node, replacer)
	case TableName:
		return a.rewriteTableName(parent, node, replacer)
	default:
		// this should never happen
		return true
	}
}

// Function Generation Source: InterfaceMethod
func (a *application) rewriteStatement(parent SQLNode, node Statement, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	switch node := node.(type) {
	case *AlterDatabase:
		return a.rewriteRefOfAlterDatabase(parent, node, replacer)
	case *AlterMigration:
		return a.rewriteRefOfAlterMigration(parent, node, replacer)
	case *AlterTable:
		return a.rewriteRefOfAlterTable(parent, node, replacer)
	case *AlterView:
		return a.rewriteRefOfAlterView(parent, node, replacer)
	case *AlterVschema:
		return a.rewriteRefOfAlterVschema(parent, node, replacer)
	case *Analyze:
		return a.rewriteRefOfAnalyze(parent, node, replacer)
	case *Begin:
		return a.rewriteRefOfBegin(parent, node, replacer)
	case *CallProc:
		return a.rewriteRefOfCallProc(parent, node, replacer)
	case *CommentOnly:
		return a.rewriteRefOfCommentOnly(parent, node, replacer)
	case *Commit:
		return a.rewriteRefOfCommit(parent, node, replacer)
	case *CreateDatabase:
		return a.rewriteRefOfCreateDatabase(parent, node, replacer)
	case *CreateTable:
		return a.rewriteRefOfCreateTable(parent, node, replacer)
	case *CreateView:
		return a.rewriteRefOfCreateView(parent, node, replacer)
	case *DeallocateStmt:
		return a.rewriteRefOfDeallocateStmt(parent, node, replacer)
	case *Delete:
		return a.rewriteRefOfDelete(parent, node, replacer)
	case *DropDatabase:
		return a.rewriteRefOfDropDatabase(parent, node, replacer)
	case *DropTable:
		return a.rewriteRefOfDropTable(parent, node, replacer)
	case *DropView:
		return a.rewriteRefOfDropView(parent, node, replacer)
	case *ExecuteStmt:
		return a.rewriteRefOfExecuteStmt(parent, node, replacer)
	case *ExplainStmt:
		return a.rewriteRefOfExplainStmt(parent, node, replacer)
	case *ExplainTab:
		return a.rewriteRefOfExplainTab(parent, node, replacer)
	case *Flush:
		return a.rewriteRefOfFlush(parent, node, replacer)
	case *Insert:
		return a.rewriteRefOfInsert(parent, node, replacer)
	case *Kill:
		return a.rewriteRefOfKill(parent, node, replacer)
	case *Load:
		return a.rewriteRefOfLoad(parent, node, replacer)
	case *LockTables:
		return a.rewriteRefOfLockTables(parent, node, replacer)
	case *OtherAdmin:
		return a.rewriteRefOfOtherAdmin(parent, node, replacer)
	case *PrepareStmt:
		return a.rewriteRefOfPrepareStmt(parent, node, replacer)
	case *PurgeBinaryLogs:
		return a.rewriteRefOfPurgeBinaryLogs(parent, node, replacer)
	case *Release:
		return a.rewriteRefOfRelease(parent, node, replacer)
	case *RenameTable:
		return a.rewriteRefOfRenameTable(parent, node, replacer)
	case *RevertMigration:
		return a.rewriteRefOfRevertMigration(parent, node, replacer)
	case *Rollback:
		return a.rewriteRefOfRollback(parent, node, replacer)
	case *SRollback:
		return a.rewriteRefOfSRollback(parent, node, replacer)
	case *Savepoint:
		return a.rewriteRefOfSavepoint(parent, node, replacer)
	case *Select:
		return a.rewriteRefOfSelect(parent, node, replacer)
	case *Set:
		return a.rewriteRefOfSet(parent, node, replacer)
	case *Show:
		return a.rewriteRefOfShow(parent, node, replacer)
	case *ShowMigrationLogs:
		return a.rewriteRefOfShowMigrationLogs(parent, node, replacer)
	case *ShowThrottledApps:
		return a.rewriteRefOfShowThrottledApps(parent, node, replacer)
	case *ShowThrottlerStatus:
		return a.rewriteRefOfShowThrottlerStatus(parent, node, replacer)
	case *Stream:
		return a.rewriteRefOfStream(parent, node, replacer)
	case *TruncateTable:
		return a.rewriteRefOfTruncateTable(parent, node, replacer)
	case *Union:
		return a.rewriteRefOfUnion(parent, node, replacer)
	case *UnlockTables:
		return a.rewriteRefOfUnlockTables(parent, node, replacer)
	case *Update:
		return a.rewriteRefOfUpdate(parent, node, replacer)
	case *Use:
		return a.rewriteRefOfUse(parent, node, replacer)
	case *VExplainStmt:
		return a.rewriteRefOfVExplainStmt(parent, node, replacer)
	case *VStream:
		return a.rewriteRefOfVStream(parent, node, replacer)
	case *ValuesStatement:
		return a.rewriteRefOfValuesStatement(parent, node, replacer)
	default:
		// this should never happen
		return true
	}
}

// Function Generation Source: InterfaceMethod
func (a *application) rewriteTableExpr(parent SQLNode, node TableExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	switch node := node.(type) {
	case *AliasedTableExpr:
		return a.rewriteRefOfAliasedTableExpr(parent, node, replacer)
	case *JSONTableExpr:
		return a.rewriteRefOfJSONTableExpr(parent, node, replacer)
	case *JoinTableExpr:
		return a.rewriteRefOfJoinTableExpr(parent, node, replacer)
	case *ParenTableExpr:
		return a.rewriteRefOfParenTableExpr(parent, node, replacer)
	default:
		// this should never happen
		return true
	}
}

// Function Generation Source: InterfaceMethod
func (a *application) rewriteTableStatement(parent SQLNode, node TableStatement, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	switch node := node.(type) {
	case *Select:
		return a.rewriteRefOfSelect(parent, node, replacer)
	case *Union:
		return a.rewriteRefOfUnion(parent, node, replacer)
	case *ValuesStatement:
		return a.rewriteRefOfValuesStatement(parent, node, replacer)
	default:
		// this should never happen
		return true
	}
}

// Function Generation Source: BasicMethod
func (a *application) rewriteAlgorithmValue(parent SQLNode, node AlgorithmValue, replacer replacerFunc) bool {
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: BasicMethod
func (a *application) rewriteBoolVal(parent SQLNode, node BoolVal, replacer replacerFunc) bool {
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: BasicMethod
func (a *application) rewriteListArg(parent SQLNode, node ListArg, replacer replacerFunc) bool {
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: BasicMethod
func (a *application) rewriteMatchAction(parent SQLNode, node MatchAction, replacer replacerFunc) bool {
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: BasicMethod
func (a *application) rewriteReferenceAction(parent SQLNode, node ReferenceAction, replacer replacerFunc) bool {
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfIdentifierCI(parent SQLNode, node *IdentifierCI, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfIdentifierCS(parent SQLNode, node *IdentifierCS, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfRootNode(parent SQLNode, node *RootNode, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfRootNodeSQLNode))
	}
	if !a.rewriteSQLNode(node, node.SQLNode, func(newNode, parent SQLNode) {
		parent.(*RootNode).SQLNode = newNode.(SQLNode)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfTableName(parent SQLNode, node *TableName, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfTableNameName))
	}
	if !a.rewriteIdentifierCS(node, node.Name, func(newNode, parent SQLNode) {
		parent.(*TableName).Name = newNode.(IdentifierCS)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
		a.cur.current.AddStep(uint16(RefOfTableNameQualifier))
	}
	if !a.rewriteIdentifierCS(node, node.Qualifier, func(newNode, parent SQLNode) {
		parent.(*TableName).Qualifier = newNode.(IdentifierCS)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfVindexParam(parent SQLNode, node *VindexParam, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteSQLNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.collectPaths {
		a.cur.current.AddStep(uint16(RefOfVindexParamKey))
	}
	if !a.rewriteIdentifierCI(node, node.Key, func(newNode, parent SQLNode) {
		parent.(*VindexParam).Key = newNode.(IdentifierCI)
	}) {
		return false
	}
	if a.collectPaths {
		a.cur.current.Pop()
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}
