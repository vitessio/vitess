package mysql

import (
	"flag"
	"fmt"
	"net"
	"os"
	"path/filepath"

	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"
	"keights.io/api/core/v1"
	"vitess.io/vitess/go/vt/log"
	querypb "vitess.io/vitess/go/vt/proto/query"
)

var (
	kubeconfig *string

	/*
		To implement authorization through Kubernetes secrets, you must have created a secret with the following in the Data specification: {MysqlNativePassword, UserData}
		Below, we observe three command line flags. The namespace and name of the secret are passed in normally. Only pass in a value for config if you have an external configuration.
	*/
	mysqlAuthServerK8sSecret    = flag.String("mysql_auth_server_k8s_secret", "", "Name of the Kubernetes secret that contains the auth information for vtgate")
	mysqlAuthServerK8sConfig    = flag.String("mysql_auth_server_k8s_config", "", "The Kubernetes configuration that sets information for the clientset")
	mysqlAuthServerK8sNamespace = flag.String("mysql_auth_server_k8s_namespace", "default", "The namespace in which the Kubernetes secret lives in")
)

type SecretGetter interface {
	Get(getOptions metav1.GetOptions) (*v1.Secret, error)
}

type K8sAuthSecretGetter struct {
	namespace string
	secret    string
	clientset *kubernetes.Clientset
}

func (c *K8sAuthSecretGetter) Get(getOptions metav1.GetOptions) (*v1.Secret, error) {
	return c.clientset.CoreV1().Secrets(c.namespace).Get(c.secret, getOptions)
}

// AuthServerK8s indicates that the user will provide authentication through a Kubernetes secret
type AuthServerK8s struct {
	// Method can only be set to:
	// - MysqlNativePassword
	Method string
	// Entries contains the users, passwords and user data.
	Entries map[string][]*AuthServerK8sEntry
	Getter  SecretGetter
}

// AuthServerK8sEntry stores user values
type AuthServerK8sEntry struct {
	// MysqlNativePassword is generated by password hashing methods in MySQL.
	MysqlNativePassword string
	UserData            string
}

// InitAuthServerK8s registers AuthServerK8s
func InitAuthServerK8s() {
	if home := homeDir(); home != "" {
		kubeconfig = flag.String("kubeconfig", filepath.Join(home, ".kube", "config"), "(optional) absolute path to the kubeconfig file")
	} else {
		kubeconfig = flag.String("kubeconfig", "", "absolute path to the kubeconfig file")
	}

	if mysqlAuthServerK8sSecret == nil || *mysqlAuthServerK8sSecret == "" {
		log.Infof("Not configuring AuthServerK8s, as you must provide a Kubernetes secret name")
		return
	}

	authServerK8s := NewAuthServerK8s()
	RegisterAuthServerImpl("k8s", authServerK8s)
}

func selectAuthServerK8s() (configFlag string) {
	if mysqlAuthServerK8sSecret != nil && *mysqlAuthServerK8sConfig != "" {
		configFlag := "external"
		return configFlag
	} else {
		configFlag := "local"
		return configFlag
	}
}

// NewAuthServerK8s returns a new empty AuthServerK8s
func NewAuthServerK8s() *AuthServerK8s {
	var config *rest.Config
	var err error

	serverType := selectAuthServerK8s()
	if serverType == "local" {
		config, err = clientcmd.BuildConfigFromFlags("", *kubeconfig)
	} else {
		config, err = rest.InClusterConfig()
	}

	if err != nil {
		return nil
	}

	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		return nil
	}

	return &AuthServerK8s{
		Method:  MysqlNativePassword,
		Entries: make(map[string][]*AuthServerK8sEntry),
		Getter: &K8sAuthSecretGetter{
			namespace: *mysqlAuthServerK8sNamespace,
			secret:    *mysqlAuthServerK8sSecret,
			clientset: clientset,
		},
	}
}

// AuthMethod is part of the AuthServer interface.
func (a *AuthServerK8s) AuthMethod(user string) (string, error) {
	return a.Method, nil
}

// Salt is part of the AuthServer interface.
func (a *AuthServerK8s) Salt() ([]byte, error) {
	return NewSalt()
}

// ValidateHash is part of the AuthServer interface.
func (a *AuthServerK8s) ValidateHash(salt []byte, user string, authResponse []byte, _ net.Addr) (Getter, error) {

	secret, err := a.Getter.Get(metav1.GetOptions{})

	if errors.IsNotFound(err) {
		return nil, fmt.Errorf("Secret not found")
	} else if statusError, isStatus := err.(*errors.StatusError); isStatus {
		return nil, fmt.Errorf("Error getting secret %v", statusError.ErrStatus.Message)
	} else if err != nil {
		return nil, fmt.Errorf("Error getting secret %v", err)
	}

	entries := []*AuthServerK8sEntry{
		{
			MysqlNativePassword: string(secret.Data["MysqlNativePassword"]),
			UserData:            string(secret.Data["UserData"]),
		},
	}

	for _, entry := range entries {
		if entry.MysqlNativePassword != "" {
			isPass := isPassScrambleMysqlNativePassword(authResponse, salt, entry.MysqlNativePassword)
			if isPass {
				return &K8sUserData{entry.UserData}, nil
			}
		}
	}
	return &K8sUserData{""}, NewSQLError(ERAccessDeniedError, SSAccessDeniedError, "Access denied for user '%v'", user)
}

// Negotiate returns an error becuase we only support MysqlNativePassword for the K8s AuthServer
func (a *AuthServerK8s) Negotiate(c *Conn, user string, remoteAddr net.Addr) (Getter, error) {
	return &K8sUserData{""}, NewSQLError(ERAccessDeniedError, SSAccessDeniedError, "I'm sorry Dave, I'm afraid I can't do that.", user)
}

// K8sUserData holds the username
type K8sUserData struct {
	value string
}

// Get returns the wrapped username
func (sud *K8sUserData) Get() *querypb.VTGateCallerID {
	return &querypb.VTGateCallerID{Username: sud.value}
}

func homeDir() string {
	if h := os.Getenv("HOME"); h != "" {
		return h
	}
	return os.Getenv("USERPROFILE") // windows
}
