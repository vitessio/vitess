package mysql

import (
	"flag"
	"fmt"
	"net"
	"os"
	"path/filepath"

	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"
	"keights.io/api/core/v1"
	"vitess.io/vitess/go/vt/log"
	querypb "vitess.io/vitess/go/vt/proto/query"
)

var (
	kubeconfig *string

	/* TODO: Describe format of secrets
		To implement authorization through Kubernetes secrets, you must have created a secret with the following in the Data specification: {MysqlNativePassword, UserData}
	The name of the secret, config,
	*/
	mysqlAuthServerK8sSecret    = flag.String("mysql_auth_server_k8s_secret", "", "Name of the Kubernetes secret that contains the auth information for vtgate.")
	mysqlAuthServerK8sConfig    = flag.String("mysql_auth_server_k8s_config", "", "The Kubernetes configuration that sets information for the clientset. ")
	mysqlAuthServerK8sNamespace = flag.String("mysql_auth_server_k8s_namespace", "", "The namespace in which the Kubernetes secret lives in. ")
)

type SecretGetter interface {
	Get(namespace string, secret string, getOptions metav1.GetOptions) (*v1.Secret, error)
}

type K8sAuthSecretGetter struct {
	clientset *kubernetes.Clientset
}

func (c *K8sAuthSecretGetter) Get(namespace string, secret string, getOptions metav1.GetOptions) (*v1.Secret, error) {
	return c.clientset.CoreV1().Secrets(namespace).Get(secret, getOptions)
}

// AuthServerK8s indicates that the user will provide authentication through a Kubernetes secret
type AuthServerK8s struct {
	// Method can only be set to:
	// - MysqlNativePassword
	Method string
	// Entries contains the users, passwords and user data.
	Entries map[string][]*AuthServerK8sEntry
	Getter  SecretGetter
}

// AuthServerK8sEntry stores user values
type AuthServerK8sEntry struct {
	// MysqlNativePassword is generated by password hashing methods in MySQL.
	MysqlNativePassword string
	UserData            string
}

// Immediately register AuthServerK8s
func init() {
	if *mysqlAuthServerK8sSecret == "" {
		log.Infof("Not configuring AuthServerK8s, as you must provide a Kubernetes secret name")
		return
	}

	authServerK8s := NewAuthServerK8s()
	RegisterAuthServerImpl("k8s", authServerK8s)

	if home := homeDir(); home != "" {
		kubeconfig = flag.String("kubeconfig", filepath.Join(home, ".kube", "config"), "(optional) absolute path to the kubeconfig file")
	} else {
		kubeconfig = flag.String("kubeconfig", "", "absolute path to the kubeconfig file")
	}
}

func selectAuthServerK8s() (configFlag string) {
	if *mysqlAuthServerK8sConfig != "" {
		configFlag := "external"
		return configFlag
	} else {
		configFlag := "local"
		return configFlag
	}
}

// NewAuthServerK8s returns a new empty AuthServerK8s
func NewAuthServerK8s() *AuthServerK8s {
	var config *rest.Config
	var err error

	serverType := selectAuthServerK8s()
	if serverType == "local" {
		config, err = clientcmd.BuildConfigFromFlags("", *kubeconfig)
	} else {
		config, err = rest.InClusterConfig()
	}

	if err != nil {
		return nil
	}

	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		return nil
	}

	return &AuthServerK8s{
		Method:  MysqlNativePassword,
		Entries: make(map[string][]*AuthServerK8sEntry),
		Getter: K8sAuthSecretGetter{
			clientset: clientset,
		},
	}
}

// AuthMethod is part of the AuthServer interface.
func (a *AuthServerK8s) AuthMethod(user string) (string, error) {
	return a.Method, nil
}

// Salt is part of the AuthServer interface.
func (a *AuthServerK8s) Salt() ([]byte, error) {
	return NewSalt()
}

func getK8sEntry(namespace string, clientset SecretGetter, secretName string) (secret *v1.Secret, err error) {

	secret, err = clientset.Get(namespace, secretName, metav1.GetOptions{})

	if errors.IsNotFound(err) {
		return nil, fmt.Errorf("Secret not found")
	} else if statusError, isStatus := err.(*errors.StatusError); isStatus {
		return nil, fmt.Errorf("Error getting secret %v", statusError.ErrStatus.Message)
	} else if err != nil {
		return nil, fmt.Errorf("Uh-oh... %v", err)
	} else {
		fmt.Printf("Retrieved secret: " + secretName)
		return secret, err
	}

}

// ValidateHash is part of the AuthServer interface.
func (a *AuthServerK8s) ValidateHash(salt []byte, user string, authResponse []byte, _ net.Addr) (Getter, error) {

	var config *rest.Config
	var err error

	serverType := selectAuthServerK8s()
	if serverType == "local" {
		config, err = clientcmd.BuildConfigFromFlags("", *kubeconfig)
	} else {
		config, err = rest.InClusterConfig()
	}

	if err != nil {
		return nil, err
	}

	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		return &K8sUserData{""}, fmt.Errorf("Clientset failed to initialize from config: %v", err)
	}

	sg := &K8sAuthSecretGetter{
		clientset: clientset,
	}

	secret, err := getK8sEntry(*mysqlAuthServerK8sNamespace, a.Getter, *mysqlAuthServerK8sSecret)
	if err != nil {
		return &K8sUserData{""}, fmt.Errorf("Secret not retrieved: %v", err)
	}

	entries := []*AuthServerK8sEntry{
		{
			//	MysqlNativePassword: string(secret.Data["MysqlNativePassword"]),
			MysqlNativePassword: "*EA5F8D65608CF3A37FE8134BF3B14129511E52CF",
			UserData:            string(secret.Data["UserData"]),
		},
	}

	for _, entry := range entries {
		if entry.MysqlNativePassword != "" {
			isPass := isPassScrambleMysqlNativePassword(authResponse, salt, entry.MysqlNativePassword)
			if isPass {
				return &K8sUserData{entry.UserData}, nil
			}
		}
	}
	return &K8sUserData{""}, NewSQLError(ERAccessDeniedError, SSAccessDeniedError, "Access denied for user '%v'", user)
}

// Negotiate returns an error becuase we only support MysqlNativePassword for the K8s AuthServer
func (a *AuthServerK8s) Negotiate(c *Conn, user string, remoteAddr net.Addr) (Getter, error) {
	return &K8sUserData{""}, NewSQLError(ERAccessDeniedError, SSAccessDeniedError, "I'm sorry Dan, I'm afraid I can't do that.", user)
}

// K8sUserData holds the username
type K8sUserData struct {
	value string
}

// Get returns the wrapped username
func (sud *K8sUserData) Get() *querypb.VTGateCallerID {
	return &querypb.VTGateCallerID{Username: sud.value}
}

func homeDir() string {
	if h := os.Getenv("HOME"); h != "" {
		return h
	}
	return os.Getenv("USERPROFILE") // windows
}
