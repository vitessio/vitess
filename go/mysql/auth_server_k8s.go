package mysql

import (
	"flag"
	"fmt"
	"io/ioutil"
	"net"

	"github.com/ghodss/yaml"
	"vitess.io/vitess/go/mysql/k8s"
	"vitess.io/vitess/go/vt/log"
	querypb "vitess.io/vitess/go/vt/proto/query"
)

var (
	kubeconfig *string

	/*
		To implement authorization through Kubernetes secrets, you must have created a secret with the following in the Data specification: {MysqlNativePassword, UserData}
		Below, we observe three command line flags. The namespace and name of the secret are passed in normally. Only pass in a value for config if you have an external configuration.
	*/
	mysqlAuthServerK8sSecret    = flag.String("mysql_auth_server_k8s_secret", "", "Name of the Kubernetes secret that contains the auth information for vtgate")
	mysqlAuthServerK8sConfig    = flag.String("mysql_auth_server_k8s_config", "", "The Kubernetes configuration that sets information for the clientset")
	mysqlAuthServerK8sNamespace = flag.String("mysql_auth_server_k8s_namespace", "default", "The namespace in which the Kubernetes secret lives in")
)

type SecretGetter interface {
	Get() (map[string][]byte, error)
}

type K8sAuthSecretGetter struct {
	namespace string
	secret    string
	config    *string
}

func (c *K8sAuthSecretGetter) Get() (map[string][]byte, error) {
	var client *k8s.Client
	if c.config != nil {
		data, err := ioutil.ReadFile(*c.config)
		if err != nil {
			log.Errorf("Error creating client: %v", err)
			return nil, err
		}
		var config k8s.Config
		if err := yaml.Unmarshal(data, &config); err != nil {
			log.Errorf("Error reading config: %v", err)
			return nil, err
		}
		client, err = k8s.NewClient(&config)
	} else {
		var err error
		client, err = k8s.NewInClusterClient()
		if err != nil {
			log.Errorf("Error creating in cluster client: %v", err)
			return nil, err
		}
	}
	secret, err := client.Get(c.namespace, "/secrets/"+c.secret)
	if err != nil {
		log.Errorf("Error fetching secret: %v", err)
		return nil, err
	}
	return secret["Data"].(map[string][]byte), nil

}

// AuthServerK8s indicates that the user will provide authentication through a Kubernetes secret
type AuthServerK8s struct {
	// Method can only be set to:
	// - MysqlNativePassword
	Method string
	// Entries contains the users, passwords and user data.
	Entries map[string][]*AuthServerK8sEntry
	Getter  SecretGetter
}

// AuthServerK8sEntry stores user values
type AuthServerK8sEntry struct {
	// MysqlNativePassword is generated by password hashing methods in MySQL.
	MysqlNativePassword string
	UserData            string
}

// InitAuthServerK8s registers AuthServerK8s
func InitAuthServerK8s() {
	if mysqlAuthServerK8sSecret == nil || *mysqlAuthServerK8sSecret == "" {
		log.Infof("Not configuring AuthServerK8s, as you must provide a Kubernetes secret name")
		return
	}

	authServerK8s := NewAuthServerK8s()
	if authServerK8s != nil {
		log.Errorf("Successfully created AuthServerK8s")
	}
	RegisterAuthServerImpl("k8s", authServerK8s)
}

// NewAuthServerK8s returns a new empty AuthServerK8s
func NewAuthServerK8s() *AuthServerK8s {
	return &AuthServerK8s{
		Method:  MysqlNativePassword,
		Entries: make(map[string][]*AuthServerK8sEntry),
		Getter: &K8sAuthSecretGetter{
			namespace: *mysqlAuthServerK8sNamespace,
			secret:    *mysqlAuthServerK8sSecret,
		},
	}
}

// AuthMethod is part of the AuthServer interface.
func (a *AuthServerK8s) AuthMethod(user string) (string, error) {
	log.Errorf("The method is: %v", a.Method)
	return a.Method, nil
}

// Salt is part of the AuthServer interface.
func (a *AuthServerK8s) Salt() ([]byte, error) {
	return NewSalt()
}

// ValidateHash is part of the AuthServer interface.
func (a *AuthServerK8s) ValidateHash(salt []byte, user string, authResponse []byte, _ net.Addr) (Getter, error) {

	secret, err := a.Getter.Get()

	if err != nil {
		return nil, fmt.Errorf("Error getting secret %v", err)
	}

	entries := []*AuthServerK8sEntry{
		{
			MysqlNativePassword: string(secret["MysqlNativePassword"]),
			UserData:            string(secret["UserData"]),
		},
	}

	for _, entry := range entries {
		if entry.MysqlNativePassword != "" {
			isPass := isPassScrambleMysqlNativePassword(authResponse, salt, entry.MysqlNativePassword)
			if isPass {
				return &K8sUserData{entry.UserData}, nil
			}
		}
	}
	return &K8sUserData{""}, NewSQLError(ERAccessDeniedError, SSAccessDeniedError, "Access denied for user '%v'", user)
}

// Negotiate returns an error becuase we only support MysqlNativePassword for the K8s AuthServer
func (a *AuthServerK8s) Negotiate(c *Conn, user string, remoteAddr net.Addr) (Getter, error) {
	return &K8sUserData{""}, NewSQLError(ERAccessDeniedError, SSAccessDeniedError, "I'm sorry Dave, I'm afraid I can't do that.", user)
}

// K8sUserData holds the username
type K8sUserData struct {
	value string
}

// Get returns the wrapped username
func (sud *K8sUserData) Get() *querypb.VTGateCallerID {
	return &querypb.VTGateCallerID{Username: sud.value}
}
