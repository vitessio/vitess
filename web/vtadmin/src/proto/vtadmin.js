/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.vtadmin = (function() {

    /**
     * Namespace vtadmin.
     * @exports vtadmin
     * @namespace
     */
    var vtadmin = {};

    vtadmin.VTAdmin = (function() {

        /**
         * Constructs a new VTAdmin service.
         * @memberof vtadmin
         * @classdesc Represents a VTAdmin
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function VTAdmin(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (VTAdmin.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = VTAdmin;

        /**
         * Creates new VTAdmin service using the specified rpc implementation.
         * @function create
         * @memberof vtadmin.VTAdmin
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {VTAdmin} RPC service. Useful where requests and/or responses are streamed.
         */
        VTAdmin.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link vtadmin.VTAdmin#findSchema}.
         * @memberof vtadmin.VTAdmin
         * @typedef FindSchemaCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {vtadmin.Schema} [response] Schema
         */

        /**
         * Calls FindSchema.
         * @function findSchema
         * @memberof vtadmin.VTAdmin
         * @instance
         * @param {vtadmin.IFindSchemaRequest} request FindSchemaRequest message or plain object
         * @param {vtadmin.VTAdmin.FindSchemaCallback} callback Node-style callback called with the error, if any, and Schema
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(VTAdmin.prototype.findSchema = function findSchema(request, callback) {
            return this.rpcCall(findSchema, $root.vtadmin.FindSchemaRequest, $root.vtadmin.Schema, request, callback);
        }, "name", { value: "FindSchema" });

        /**
         * Calls FindSchema.
         * @function findSchema
         * @memberof vtadmin.VTAdmin
         * @instance
         * @param {vtadmin.IFindSchemaRequest} request FindSchemaRequest message or plain object
         * @returns {Promise<vtadmin.Schema>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link vtadmin.VTAdmin#getClusters}.
         * @memberof vtadmin.VTAdmin
         * @typedef GetClustersCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {vtadmin.GetClustersResponse} [response] GetClustersResponse
         */

        /**
         * Calls GetClusters.
         * @function getClusters
         * @memberof vtadmin.VTAdmin
         * @instance
         * @param {vtadmin.IGetClustersRequest} request GetClustersRequest message or plain object
         * @param {vtadmin.VTAdmin.GetClustersCallback} callback Node-style callback called with the error, if any, and GetClustersResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(VTAdmin.prototype.getClusters = function getClusters(request, callback) {
            return this.rpcCall(getClusters, $root.vtadmin.GetClustersRequest, $root.vtadmin.GetClustersResponse, request, callback);
        }, "name", { value: "GetClusters" });

        /**
         * Calls GetClusters.
         * @function getClusters
         * @memberof vtadmin.VTAdmin
         * @instance
         * @param {vtadmin.IGetClustersRequest} request GetClustersRequest message or plain object
         * @returns {Promise<vtadmin.GetClustersResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link vtadmin.VTAdmin#getGates}.
         * @memberof vtadmin.VTAdmin
         * @typedef GetGatesCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {vtadmin.GetGatesResponse} [response] GetGatesResponse
         */

        /**
         * Calls GetGates.
         * @function getGates
         * @memberof vtadmin.VTAdmin
         * @instance
         * @param {vtadmin.IGetGatesRequest} request GetGatesRequest message or plain object
         * @param {vtadmin.VTAdmin.GetGatesCallback} callback Node-style callback called with the error, if any, and GetGatesResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(VTAdmin.prototype.getGates = function getGates(request, callback) {
            return this.rpcCall(getGates, $root.vtadmin.GetGatesRequest, $root.vtadmin.GetGatesResponse, request, callback);
        }, "name", { value: "GetGates" });

        /**
         * Calls GetGates.
         * @function getGates
         * @memberof vtadmin.VTAdmin
         * @instance
         * @param {vtadmin.IGetGatesRequest} request GetGatesRequest message or plain object
         * @returns {Promise<vtadmin.GetGatesResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link vtadmin.VTAdmin#getKeyspaces}.
         * @memberof vtadmin.VTAdmin
         * @typedef GetKeyspacesCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {vtadmin.GetKeyspacesResponse} [response] GetKeyspacesResponse
         */

        /**
         * Calls GetKeyspaces.
         * @function getKeyspaces
         * @memberof vtadmin.VTAdmin
         * @instance
         * @param {vtadmin.IGetKeyspacesRequest} request GetKeyspacesRequest message or plain object
         * @param {vtadmin.VTAdmin.GetKeyspacesCallback} callback Node-style callback called with the error, if any, and GetKeyspacesResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(VTAdmin.prototype.getKeyspaces = function getKeyspaces(request, callback) {
            return this.rpcCall(getKeyspaces, $root.vtadmin.GetKeyspacesRequest, $root.vtadmin.GetKeyspacesResponse, request, callback);
        }, "name", { value: "GetKeyspaces" });

        /**
         * Calls GetKeyspaces.
         * @function getKeyspaces
         * @memberof vtadmin.VTAdmin
         * @instance
         * @param {vtadmin.IGetKeyspacesRequest} request GetKeyspacesRequest message or plain object
         * @returns {Promise<vtadmin.GetKeyspacesResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link vtadmin.VTAdmin#getSchema}.
         * @memberof vtadmin.VTAdmin
         * @typedef GetSchemaCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {vtadmin.Schema} [response] Schema
         */

        /**
         * Calls GetSchema.
         * @function getSchema
         * @memberof vtadmin.VTAdmin
         * @instance
         * @param {vtadmin.IGetSchemaRequest} request GetSchemaRequest message or plain object
         * @param {vtadmin.VTAdmin.GetSchemaCallback} callback Node-style callback called with the error, if any, and Schema
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(VTAdmin.prototype.getSchema = function getSchema(request, callback) {
            return this.rpcCall(getSchema, $root.vtadmin.GetSchemaRequest, $root.vtadmin.Schema, request, callback);
        }, "name", { value: "GetSchema" });

        /**
         * Calls GetSchema.
         * @function getSchema
         * @memberof vtadmin.VTAdmin
         * @instance
         * @param {vtadmin.IGetSchemaRequest} request GetSchemaRequest message or plain object
         * @returns {Promise<vtadmin.Schema>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link vtadmin.VTAdmin#getSchemas}.
         * @memberof vtadmin.VTAdmin
         * @typedef GetSchemasCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {vtadmin.GetSchemasResponse} [response] GetSchemasResponse
         */

        /**
         * Calls GetSchemas.
         * @function getSchemas
         * @memberof vtadmin.VTAdmin
         * @instance
         * @param {vtadmin.IGetSchemasRequest} request GetSchemasRequest message or plain object
         * @param {vtadmin.VTAdmin.GetSchemasCallback} callback Node-style callback called with the error, if any, and GetSchemasResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(VTAdmin.prototype.getSchemas = function getSchemas(request, callback) {
            return this.rpcCall(getSchemas, $root.vtadmin.GetSchemasRequest, $root.vtadmin.GetSchemasResponse, request, callback);
        }, "name", { value: "GetSchemas" });

        /**
         * Calls GetSchemas.
         * @function getSchemas
         * @memberof vtadmin.VTAdmin
         * @instance
         * @param {vtadmin.IGetSchemasRequest} request GetSchemasRequest message or plain object
         * @returns {Promise<vtadmin.GetSchemasResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link vtadmin.VTAdmin#getTablet}.
         * @memberof vtadmin.VTAdmin
         * @typedef GetTabletCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {vtadmin.Tablet} [response] Tablet
         */

        /**
         * Calls GetTablet.
         * @function getTablet
         * @memberof vtadmin.VTAdmin
         * @instance
         * @param {vtadmin.IGetTabletRequest} request GetTabletRequest message or plain object
         * @param {vtadmin.VTAdmin.GetTabletCallback} callback Node-style callback called with the error, if any, and Tablet
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(VTAdmin.prototype.getTablet = function getTablet(request, callback) {
            return this.rpcCall(getTablet, $root.vtadmin.GetTabletRequest, $root.vtadmin.Tablet, request, callback);
        }, "name", { value: "GetTablet" });

        /**
         * Calls GetTablet.
         * @function getTablet
         * @memberof vtadmin.VTAdmin
         * @instance
         * @param {vtadmin.IGetTabletRequest} request GetTabletRequest message or plain object
         * @returns {Promise<vtadmin.Tablet>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link vtadmin.VTAdmin#getTablets}.
         * @memberof vtadmin.VTAdmin
         * @typedef GetTabletsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {vtadmin.GetTabletsResponse} [response] GetTabletsResponse
         */

        /**
         * Calls GetTablets.
         * @function getTablets
         * @memberof vtadmin.VTAdmin
         * @instance
         * @param {vtadmin.IGetTabletsRequest} request GetTabletsRequest message or plain object
         * @param {vtadmin.VTAdmin.GetTabletsCallback} callback Node-style callback called with the error, if any, and GetTabletsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(VTAdmin.prototype.getTablets = function getTablets(request, callback) {
            return this.rpcCall(getTablets, $root.vtadmin.GetTabletsRequest, $root.vtadmin.GetTabletsResponse, request, callback);
        }, "name", { value: "GetTablets" });

        /**
         * Calls GetTablets.
         * @function getTablets
         * @memberof vtadmin.VTAdmin
         * @instance
         * @param {vtadmin.IGetTabletsRequest} request GetTabletsRequest message or plain object
         * @returns {Promise<vtadmin.GetTabletsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link vtadmin.VTAdmin#getVSchema}.
         * @memberof vtadmin.VTAdmin
         * @typedef GetVSchemaCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {vtadmin.VSchema} [response] VSchema
         */

        /**
         * Calls GetVSchema.
         * @function getVSchema
         * @memberof vtadmin.VTAdmin
         * @instance
         * @param {vtadmin.IGetVSchemaRequest} request GetVSchemaRequest message or plain object
         * @param {vtadmin.VTAdmin.GetVSchemaCallback} callback Node-style callback called with the error, if any, and VSchema
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(VTAdmin.prototype.getVSchema = function getVSchema(request, callback) {
            return this.rpcCall(getVSchema, $root.vtadmin.GetVSchemaRequest, $root.vtadmin.VSchema, request, callback);
        }, "name", { value: "GetVSchema" });

        /**
         * Calls GetVSchema.
         * @function getVSchema
         * @memberof vtadmin.VTAdmin
         * @instance
         * @param {vtadmin.IGetVSchemaRequest} request GetVSchemaRequest message or plain object
         * @returns {Promise<vtadmin.VSchema>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link vtadmin.VTAdmin#getVSchemas}.
         * @memberof vtadmin.VTAdmin
         * @typedef GetVSchemasCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {vtadmin.GetVSchemasResponse} [response] GetVSchemasResponse
         */

        /**
         * Calls GetVSchemas.
         * @function getVSchemas
         * @memberof vtadmin.VTAdmin
         * @instance
         * @param {vtadmin.IGetVSchemasRequest} request GetVSchemasRequest message or plain object
         * @param {vtadmin.VTAdmin.GetVSchemasCallback} callback Node-style callback called with the error, if any, and GetVSchemasResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(VTAdmin.prototype.getVSchemas = function getVSchemas(request, callback) {
            return this.rpcCall(getVSchemas, $root.vtadmin.GetVSchemasRequest, $root.vtadmin.GetVSchemasResponse, request, callback);
        }, "name", { value: "GetVSchemas" });

        /**
         * Calls GetVSchemas.
         * @function getVSchemas
         * @memberof vtadmin.VTAdmin
         * @instance
         * @param {vtadmin.IGetVSchemasRequest} request GetVSchemasRequest message or plain object
         * @returns {Promise<vtadmin.GetVSchemasResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link vtadmin.VTAdmin#getWorkflow}.
         * @memberof vtadmin.VTAdmin
         * @typedef GetWorkflowCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {vtadmin.Workflow} [response] Workflow
         */

        /**
         * Calls GetWorkflow.
         * @function getWorkflow
         * @memberof vtadmin.VTAdmin
         * @instance
         * @param {vtadmin.IGetWorkflowRequest} request GetWorkflowRequest message or plain object
         * @param {vtadmin.VTAdmin.GetWorkflowCallback} callback Node-style callback called with the error, if any, and Workflow
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(VTAdmin.prototype.getWorkflow = function getWorkflow(request, callback) {
            return this.rpcCall(getWorkflow, $root.vtadmin.GetWorkflowRequest, $root.vtadmin.Workflow, request, callback);
        }, "name", { value: "GetWorkflow" });

        /**
         * Calls GetWorkflow.
         * @function getWorkflow
         * @memberof vtadmin.VTAdmin
         * @instance
         * @param {vtadmin.IGetWorkflowRequest} request GetWorkflowRequest message or plain object
         * @returns {Promise<vtadmin.Workflow>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link vtadmin.VTAdmin#getWorkflows}.
         * @memberof vtadmin.VTAdmin
         * @typedef GetWorkflowsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {vtadmin.GetWorkflowsResponse} [response] GetWorkflowsResponse
         */

        /**
         * Calls GetWorkflows.
         * @function getWorkflows
         * @memberof vtadmin.VTAdmin
         * @instance
         * @param {vtadmin.IGetWorkflowsRequest} request GetWorkflowsRequest message or plain object
         * @param {vtadmin.VTAdmin.GetWorkflowsCallback} callback Node-style callback called with the error, if any, and GetWorkflowsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(VTAdmin.prototype.getWorkflows = function getWorkflows(request, callback) {
            return this.rpcCall(getWorkflows, $root.vtadmin.GetWorkflowsRequest, $root.vtadmin.GetWorkflowsResponse, request, callback);
        }, "name", { value: "GetWorkflows" });

        /**
         * Calls GetWorkflows.
         * @function getWorkflows
         * @memberof vtadmin.VTAdmin
         * @instance
         * @param {vtadmin.IGetWorkflowsRequest} request GetWorkflowsRequest message or plain object
         * @returns {Promise<vtadmin.GetWorkflowsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link vtadmin.VTAdmin#vTExplain}.
         * @memberof vtadmin.VTAdmin
         * @typedef VTExplainCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {vtadmin.VTExplainResponse} [response] VTExplainResponse
         */

        /**
         * Calls VTExplain.
         * @function vTExplain
         * @memberof vtadmin.VTAdmin
         * @instance
         * @param {vtadmin.IVTExplainRequest} request VTExplainRequest message or plain object
         * @param {vtadmin.VTAdmin.VTExplainCallback} callback Node-style callback called with the error, if any, and VTExplainResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(VTAdmin.prototype.vTExplain = function vTExplain(request, callback) {
            return this.rpcCall(vTExplain, $root.vtadmin.VTExplainRequest, $root.vtadmin.VTExplainResponse, request, callback);
        }, "name", { value: "VTExplain" });

        /**
         * Calls VTExplain.
         * @function vTExplain
         * @memberof vtadmin.VTAdmin
         * @instance
         * @param {vtadmin.IVTExplainRequest} request VTExplainRequest message or plain object
         * @returns {Promise<vtadmin.VTExplainResponse>} Promise
         * @variation 2
         */

        return VTAdmin;
    })();

    vtadmin.Cluster = (function() {

        /**
         * Properties of a Cluster.
         * @memberof vtadmin
         * @interface ICluster
         * @property {string|null} [id] Cluster id
         * @property {string|null} [name] Cluster name
         */

        /**
         * Constructs a new Cluster.
         * @memberof vtadmin
         * @classdesc Represents a Cluster.
         * @implements ICluster
         * @constructor
         * @param {vtadmin.ICluster=} [properties] Properties to set
         */
        function Cluster(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Cluster id.
         * @member {string} id
         * @memberof vtadmin.Cluster
         * @instance
         */
        Cluster.prototype.id = "";

        /**
         * Cluster name.
         * @member {string} name
         * @memberof vtadmin.Cluster
         * @instance
         */
        Cluster.prototype.name = "";

        /**
         * Creates a new Cluster instance using the specified properties.
         * @function create
         * @memberof vtadmin.Cluster
         * @static
         * @param {vtadmin.ICluster=} [properties] Properties to set
         * @returns {vtadmin.Cluster} Cluster instance
         */
        Cluster.create = function create(properties) {
            return new Cluster(properties);
        };

        /**
         * Encodes the specified Cluster message. Does not implicitly {@link vtadmin.Cluster.verify|verify} messages.
         * @function encode
         * @memberof vtadmin.Cluster
         * @static
         * @param {vtadmin.ICluster} message Cluster message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Cluster.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified Cluster message, length delimited. Does not implicitly {@link vtadmin.Cluster.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtadmin.Cluster
         * @static
         * @param {vtadmin.ICluster} message Cluster message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Cluster.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Cluster message from the specified reader or buffer.
         * @function decode
         * @memberof vtadmin.Cluster
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtadmin.Cluster} Cluster
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Cluster.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtadmin.Cluster();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Cluster message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtadmin.Cluster
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtadmin.Cluster} Cluster
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Cluster.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Cluster message.
         * @function verify
         * @memberof vtadmin.Cluster
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Cluster.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates a Cluster message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtadmin.Cluster
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtadmin.Cluster} Cluster
         */
        Cluster.fromObject = function fromObject(object) {
            if (object instanceof $root.vtadmin.Cluster)
                return object;
            var message = new $root.vtadmin.Cluster();
            if (object.id != null)
                message.id = String(object.id);
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a Cluster message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtadmin.Cluster
         * @static
         * @param {vtadmin.Cluster} message Cluster
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Cluster.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.name = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this Cluster to JSON.
         * @function toJSON
         * @memberof vtadmin.Cluster
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Cluster.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Cluster;
    })();

    vtadmin.ClusterWorkflows = (function() {

        /**
         * Properties of a ClusterWorkflows.
         * @memberof vtadmin
         * @interface IClusterWorkflows
         * @property {Array.<vtadmin.IWorkflow>|null} [workflows] ClusterWorkflows workflows
         * @property {Array.<string>|null} [warnings] ClusterWorkflows warnings
         */

        /**
         * Constructs a new ClusterWorkflows.
         * @memberof vtadmin
         * @classdesc Represents a ClusterWorkflows.
         * @implements IClusterWorkflows
         * @constructor
         * @param {vtadmin.IClusterWorkflows=} [properties] Properties to set
         */
        function ClusterWorkflows(properties) {
            this.workflows = [];
            this.warnings = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClusterWorkflows workflows.
         * @member {Array.<vtadmin.IWorkflow>} workflows
         * @memberof vtadmin.ClusterWorkflows
         * @instance
         */
        ClusterWorkflows.prototype.workflows = $util.emptyArray;

        /**
         * ClusterWorkflows warnings.
         * @member {Array.<string>} warnings
         * @memberof vtadmin.ClusterWorkflows
         * @instance
         */
        ClusterWorkflows.prototype.warnings = $util.emptyArray;

        /**
         * Creates a new ClusterWorkflows instance using the specified properties.
         * @function create
         * @memberof vtadmin.ClusterWorkflows
         * @static
         * @param {vtadmin.IClusterWorkflows=} [properties] Properties to set
         * @returns {vtadmin.ClusterWorkflows} ClusterWorkflows instance
         */
        ClusterWorkflows.create = function create(properties) {
            return new ClusterWorkflows(properties);
        };

        /**
         * Encodes the specified ClusterWorkflows message. Does not implicitly {@link vtadmin.ClusterWorkflows.verify|verify} messages.
         * @function encode
         * @memberof vtadmin.ClusterWorkflows
         * @static
         * @param {vtadmin.IClusterWorkflows} message ClusterWorkflows message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClusterWorkflows.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.workflows != null && message.workflows.length)
                for (var i = 0; i < message.workflows.length; ++i)
                    $root.vtadmin.Workflow.encode(message.workflows[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.warnings != null && message.warnings.length)
                for (var i = 0; i < message.warnings.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.warnings[i]);
            return writer;
        };

        /**
         * Encodes the specified ClusterWorkflows message, length delimited. Does not implicitly {@link vtadmin.ClusterWorkflows.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtadmin.ClusterWorkflows
         * @static
         * @param {vtadmin.IClusterWorkflows} message ClusterWorkflows message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClusterWorkflows.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClusterWorkflows message from the specified reader or buffer.
         * @function decode
         * @memberof vtadmin.ClusterWorkflows
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtadmin.ClusterWorkflows} ClusterWorkflows
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClusterWorkflows.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtadmin.ClusterWorkflows();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.workflows && message.workflows.length))
                        message.workflows = [];
                    message.workflows.push($root.vtadmin.Workflow.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.warnings && message.warnings.length))
                        message.warnings = [];
                    message.warnings.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClusterWorkflows message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtadmin.ClusterWorkflows
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtadmin.ClusterWorkflows} ClusterWorkflows
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClusterWorkflows.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClusterWorkflows message.
         * @function verify
         * @memberof vtadmin.ClusterWorkflows
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClusterWorkflows.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.workflows != null && message.hasOwnProperty("workflows")) {
                if (!Array.isArray(message.workflows))
                    return "workflows: array expected";
                for (var i = 0; i < message.workflows.length; ++i) {
                    var error = $root.vtadmin.Workflow.verify(message.workflows[i]);
                    if (error)
                        return "workflows." + error;
                }
            }
            if (message.warnings != null && message.hasOwnProperty("warnings")) {
                if (!Array.isArray(message.warnings))
                    return "warnings: array expected";
                for (var i = 0; i < message.warnings.length; ++i)
                    if (!$util.isString(message.warnings[i]))
                        return "warnings: string[] expected";
            }
            return null;
        };

        /**
         * Creates a ClusterWorkflows message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtadmin.ClusterWorkflows
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtadmin.ClusterWorkflows} ClusterWorkflows
         */
        ClusterWorkflows.fromObject = function fromObject(object) {
            if (object instanceof $root.vtadmin.ClusterWorkflows)
                return object;
            var message = new $root.vtadmin.ClusterWorkflows();
            if (object.workflows) {
                if (!Array.isArray(object.workflows))
                    throw TypeError(".vtadmin.ClusterWorkflows.workflows: array expected");
                message.workflows = [];
                for (var i = 0; i < object.workflows.length; ++i) {
                    if (typeof object.workflows[i] !== "object")
                        throw TypeError(".vtadmin.ClusterWorkflows.workflows: object expected");
                    message.workflows[i] = $root.vtadmin.Workflow.fromObject(object.workflows[i]);
                }
            }
            if (object.warnings) {
                if (!Array.isArray(object.warnings))
                    throw TypeError(".vtadmin.ClusterWorkflows.warnings: array expected");
                message.warnings = [];
                for (var i = 0; i < object.warnings.length; ++i)
                    message.warnings[i] = String(object.warnings[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a ClusterWorkflows message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtadmin.ClusterWorkflows
         * @static
         * @param {vtadmin.ClusterWorkflows} message ClusterWorkflows
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClusterWorkflows.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.workflows = [];
                object.warnings = [];
            }
            if (message.workflows && message.workflows.length) {
                object.workflows = [];
                for (var j = 0; j < message.workflows.length; ++j)
                    object.workflows[j] = $root.vtadmin.Workflow.toObject(message.workflows[j], options);
            }
            if (message.warnings && message.warnings.length) {
                object.warnings = [];
                for (var j = 0; j < message.warnings.length; ++j)
                    object.warnings[j] = message.warnings[j];
            }
            return object;
        };

        /**
         * Converts this ClusterWorkflows to JSON.
         * @function toJSON
         * @memberof vtadmin.ClusterWorkflows
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClusterWorkflows.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ClusterWorkflows;
    })();

    vtadmin.Keyspace = (function() {

        /**
         * Properties of a Keyspace.
         * @memberof vtadmin
         * @interface IKeyspace
         * @property {vtadmin.ICluster|null} [cluster] Keyspace cluster
         * @property {vtctldata.IKeyspace|null} [keyspace] Keyspace keyspace
         * @property {Object.<string,vtctldata.IShard>|null} [shards] Keyspace shards
         */

        /**
         * Constructs a new Keyspace.
         * @memberof vtadmin
         * @classdesc Represents a Keyspace.
         * @implements IKeyspace
         * @constructor
         * @param {vtadmin.IKeyspace=} [properties] Properties to set
         */
        function Keyspace(properties) {
            this.shards = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Keyspace cluster.
         * @member {vtadmin.ICluster|null|undefined} cluster
         * @memberof vtadmin.Keyspace
         * @instance
         */
        Keyspace.prototype.cluster = null;

        /**
         * Keyspace keyspace.
         * @member {vtctldata.IKeyspace|null|undefined} keyspace
         * @memberof vtadmin.Keyspace
         * @instance
         */
        Keyspace.prototype.keyspace = null;

        /**
         * Keyspace shards.
         * @member {Object.<string,vtctldata.IShard>} shards
         * @memberof vtadmin.Keyspace
         * @instance
         */
        Keyspace.prototype.shards = $util.emptyObject;

        /**
         * Creates a new Keyspace instance using the specified properties.
         * @function create
         * @memberof vtadmin.Keyspace
         * @static
         * @param {vtadmin.IKeyspace=} [properties] Properties to set
         * @returns {vtadmin.Keyspace} Keyspace instance
         */
        Keyspace.create = function create(properties) {
            return new Keyspace(properties);
        };

        /**
         * Encodes the specified Keyspace message. Does not implicitly {@link vtadmin.Keyspace.verify|verify} messages.
         * @function encode
         * @memberof vtadmin.Keyspace
         * @static
         * @param {vtadmin.IKeyspace} message Keyspace message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Keyspace.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cluster != null && Object.hasOwnProperty.call(message, "cluster"))
                $root.vtadmin.Cluster.encode(message.cluster, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.keyspace != null && Object.hasOwnProperty.call(message, "keyspace"))
                $root.vtctldata.Keyspace.encode(message.keyspace, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.shards != null && Object.hasOwnProperty.call(message, "shards"))
                for (var keys = Object.keys(message.shards), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.vtctldata.Shard.encode(message.shards[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            return writer;
        };

        /**
         * Encodes the specified Keyspace message, length delimited. Does not implicitly {@link vtadmin.Keyspace.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtadmin.Keyspace
         * @static
         * @param {vtadmin.IKeyspace} message Keyspace message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Keyspace.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Keyspace message from the specified reader or buffer.
         * @function decode
         * @memberof vtadmin.Keyspace
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtadmin.Keyspace} Keyspace
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Keyspace.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtadmin.Keyspace(), key, value;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.cluster = $root.vtadmin.Cluster.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.keyspace = $root.vtctldata.Keyspace.decode(reader, reader.uint32());
                    break;
                case 3:
                    if (message.shards === $util.emptyObject)
                        message.shards = {};
                    var end2 = reader.uint32() + reader.pos;
                    key = "";
                    value = null;
                    while (reader.pos < end2) {
                        var tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.string();
                            break;
                        case 2:
                            value = $root.vtctldata.Shard.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.shards[key] = value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Keyspace message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtadmin.Keyspace
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtadmin.Keyspace} Keyspace
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Keyspace.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Keyspace message.
         * @function verify
         * @memberof vtadmin.Keyspace
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Keyspace.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cluster != null && message.hasOwnProperty("cluster")) {
                var error = $root.vtadmin.Cluster.verify(message.cluster);
                if (error)
                    return "cluster." + error;
            }
            if (message.keyspace != null && message.hasOwnProperty("keyspace")) {
                var error = $root.vtctldata.Keyspace.verify(message.keyspace);
                if (error)
                    return "keyspace." + error;
            }
            if (message.shards != null && message.hasOwnProperty("shards")) {
                if (!$util.isObject(message.shards))
                    return "shards: object expected";
                var key = Object.keys(message.shards);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.vtctldata.Shard.verify(message.shards[key[i]]);
                    if (error)
                        return "shards." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Keyspace message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtadmin.Keyspace
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtadmin.Keyspace} Keyspace
         */
        Keyspace.fromObject = function fromObject(object) {
            if (object instanceof $root.vtadmin.Keyspace)
                return object;
            var message = new $root.vtadmin.Keyspace();
            if (object.cluster != null) {
                if (typeof object.cluster !== "object")
                    throw TypeError(".vtadmin.Keyspace.cluster: object expected");
                message.cluster = $root.vtadmin.Cluster.fromObject(object.cluster);
            }
            if (object.keyspace != null) {
                if (typeof object.keyspace !== "object")
                    throw TypeError(".vtadmin.Keyspace.keyspace: object expected");
                message.keyspace = $root.vtctldata.Keyspace.fromObject(object.keyspace);
            }
            if (object.shards) {
                if (typeof object.shards !== "object")
                    throw TypeError(".vtadmin.Keyspace.shards: object expected");
                message.shards = {};
                for (var keys = Object.keys(object.shards), i = 0; i < keys.length; ++i) {
                    if (typeof object.shards[keys[i]] !== "object")
                        throw TypeError(".vtadmin.Keyspace.shards: object expected");
                    message.shards[keys[i]] = $root.vtctldata.Shard.fromObject(object.shards[keys[i]]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Keyspace message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtadmin.Keyspace
         * @static
         * @param {vtadmin.Keyspace} message Keyspace
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Keyspace.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults)
                object.shards = {};
            if (options.defaults) {
                object.cluster = null;
                object.keyspace = null;
            }
            if (message.cluster != null && message.hasOwnProperty("cluster"))
                object.cluster = $root.vtadmin.Cluster.toObject(message.cluster, options);
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                object.keyspace = $root.vtctldata.Keyspace.toObject(message.keyspace, options);
            var keys2;
            if (message.shards && (keys2 = Object.keys(message.shards)).length) {
                object.shards = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.shards[keys2[j]] = $root.vtctldata.Shard.toObject(message.shards[keys2[j]], options);
            }
            return object;
        };

        /**
         * Converts this Keyspace to JSON.
         * @function toJSON
         * @memberof vtadmin.Keyspace
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Keyspace.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Keyspace;
    })();

    vtadmin.Schema = (function() {

        /**
         * Properties of a Schema.
         * @memberof vtadmin
         * @interface ISchema
         * @property {vtadmin.ICluster|null} [cluster] Schema cluster
         * @property {string|null} [keyspace] Schema keyspace
         * @property {Array.<tabletmanagerdata.ITableDefinition>|null} [table_definitions] Schema table_definitions
         * @property {Object.<string,vtadmin.Schema.ITableSize>|null} [table_sizes] Schema table_sizes
         */

        /**
         * Constructs a new Schema.
         * @memberof vtadmin
         * @classdesc Represents a Schema.
         * @implements ISchema
         * @constructor
         * @param {vtadmin.ISchema=} [properties] Properties to set
         */
        function Schema(properties) {
            this.table_definitions = [];
            this.table_sizes = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Schema cluster.
         * @member {vtadmin.ICluster|null|undefined} cluster
         * @memberof vtadmin.Schema
         * @instance
         */
        Schema.prototype.cluster = null;

        /**
         * Schema keyspace.
         * @member {string} keyspace
         * @memberof vtadmin.Schema
         * @instance
         */
        Schema.prototype.keyspace = "";

        /**
         * Schema table_definitions.
         * @member {Array.<tabletmanagerdata.ITableDefinition>} table_definitions
         * @memberof vtadmin.Schema
         * @instance
         */
        Schema.prototype.table_definitions = $util.emptyArray;

        /**
         * Schema table_sizes.
         * @member {Object.<string,vtadmin.Schema.ITableSize>} table_sizes
         * @memberof vtadmin.Schema
         * @instance
         */
        Schema.prototype.table_sizes = $util.emptyObject;

        /**
         * Creates a new Schema instance using the specified properties.
         * @function create
         * @memberof vtadmin.Schema
         * @static
         * @param {vtadmin.ISchema=} [properties] Properties to set
         * @returns {vtadmin.Schema} Schema instance
         */
        Schema.create = function create(properties) {
            return new Schema(properties);
        };

        /**
         * Encodes the specified Schema message. Does not implicitly {@link vtadmin.Schema.verify|verify} messages.
         * @function encode
         * @memberof vtadmin.Schema
         * @static
         * @param {vtadmin.ISchema} message Schema message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Schema.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cluster != null && Object.hasOwnProperty.call(message, "cluster"))
                $root.vtadmin.Cluster.encode(message.cluster, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.keyspace != null && Object.hasOwnProperty.call(message, "keyspace"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.keyspace);
            if (message.table_definitions != null && message.table_definitions.length)
                for (var i = 0; i < message.table_definitions.length; ++i)
                    $root.tabletmanagerdata.TableDefinition.encode(message.table_definitions[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.table_sizes != null && Object.hasOwnProperty.call(message, "table_sizes"))
                for (var keys = Object.keys(message.table_sizes), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.vtadmin.Schema.TableSize.encode(message.table_sizes[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            return writer;
        };

        /**
         * Encodes the specified Schema message, length delimited. Does not implicitly {@link vtadmin.Schema.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtadmin.Schema
         * @static
         * @param {vtadmin.ISchema} message Schema message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Schema.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Schema message from the specified reader or buffer.
         * @function decode
         * @memberof vtadmin.Schema
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtadmin.Schema} Schema
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Schema.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtadmin.Schema(), key, value;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.cluster = $root.vtadmin.Cluster.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.keyspace = reader.string();
                    break;
                case 3:
                    if (!(message.table_definitions && message.table_definitions.length))
                        message.table_definitions = [];
                    message.table_definitions.push($root.tabletmanagerdata.TableDefinition.decode(reader, reader.uint32()));
                    break;
                case 4:
                    if (message.table_sizes === $util.emptyObject)
                        message.table_sizes = {};
                    var end2 = reader.uint32() + reader.pos;
                    key = "";
                    value = null;
                    while (reader.pos < end2) {
                        var tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.string();
                            break;
                        case 2:
                            value = $root.vtadmin.Schema.TableSize.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.table_sizes[key] = value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Schema message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtadmin.Schema
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtadmin.Schema} Schema
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Schema.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Schema message.
         * @function verify
         * @memberof vtadmin.Schema
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Schema.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cluster != null && message.hasOwnProperty("cluster")) {
                var error = $root.vtadmin.Cluster.verify(message.cluster);
                if (error)
                    return "cluster." + error;
            }
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                if (!$util.isString(message.keyspace))
                    return "keyspace: string expected";
            if (message.table_definitions != null && message.hasOwnProperty("table_definitions")) {
                if (!Array.isArray(message.table_definitions))
                    return "table_definitions: array expected";
                for (var i = 0; i < message.table_definitions.length; ++i) {
                    var error = $root.tabletmanagerdata.TableDefinition.verify(message.table_definitions[i]);
                    if (error)
                        return "table_definitions." + error;
                }
            }
            if (message.table_sizes != null && message.hasOwnProperty("table_sizes")) {
                if (!$util.isObject(message.table_sizes))
                    return "table_sizes: object expected";
                var key = Object.keys(message.table_sizes);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.vtadmin.Schema.TableSize.verify(message.table_sizes[key[i]]);
                    if (error)
                        return "table_sizes." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Schema message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtadmin.Schema
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtadmin.Schema} Schema
         */
        Schema.fromObject = function fromObject(object) {
            if (object instanceof $root.vtadmin.Schema)
                return object;
            var message = new $root.vtadmin.Schema();
            if (object.cluster != null) {
                if (typeof object.cluster !== "object")
                    throw TypeError(".vtadmin.Schema.cluster: object expected");
                message.cluster = $root.vtadmin.Cluster.fromObject(object.cluster);
            }
            if (object.keyspace != null)
                message.keyspace = String(object.keyspace);
            if (object.table_definitions) {
                if (!Array.isArray(object.table_definitions))
                    throw TypeError(".vtadmin.Schema.table_definitions: array expected");
                message.table_definitions = [];
                for (var i = 0; i < object.table_definitions.length; ++i) {
                    if (typeof object.table_definitions[i] !== "object")
                        throw TypeError(".vtadmin.Schema.table_definitions: object expected");
                    message.table_definitions[i] = $root.tabletmanagerdata.TableDefinition.fromObject(object.table_definitions[i]);
                }
            }
            if (object.table_sizes) {
                if (typeof object.table_sizes !== "object")
                    throw TypeError(".vtadmin.Schema.table_sizes: object expected");
                message.table_sizes = {};
                for (var keys = Object.keys(object.table_sizes), i = 0; i < keys.length; ++i) {
                    if (typeof object.table_sizes[keys[i]] !== "object")
                        throw TypeError(".vtadmin.Schema.table_sizes: object expected");
                    message.table_sizes[keys[i]] = $root.vtadmin.Schema.TableSize.fromObject(object.table_sizes[keys[i]]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Schema message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtadmin.Schema
         * @static
         * @param {vtadmin.Schema} message Schema
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Schema.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.table_definitions = [];
            if (options.objects || options.defaults)
                object.table_sizes = {};
            if (options.defaults) {
                object.cluster = null;
                object.keyspace = "";
            }
            if (message.cluster != null && message.hasOwnProperty("cluster"))
                object.cluster = $root.vtadmin.Cluster.toObject(message.cluster, options);
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                object.keyspace = message.keyspace;
            if (message.table_definitions && message.table_definitions.length) {
                object.table_definitions = [];
                for (var j = 0; j < message.table_definitions.length; ++j)
                    object.table_definitions[j] = $root.tabletmanagerdata.TableDefinition.toObject(message.table_definitions[j], options);
            }
            var keys2;
            if (message.table_sizes && (keys2 = Object.keys(message.table_sizes)).length) {
                object.table_sizes = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.table_sizes[keys2[j]] = $root.vtadmin.Schema.TableSize.toObject(message.table_sizes[keys2[j]], options);
            }
            return object;
        };

        /**
         * Converts this Schema to JSON.
         * @function toJSON
         * @memberof vtadmin.Schema
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Schema.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        Schema.ShardTableSize = (function() {

            /**
             * Properties of a ShardTableSize.
             * @memberof vtadmin.Schema
             * @interface IShardTableSize
             * @property {number|Long|null} [row_count] ShardTableSize row_count
             * @property {number|Long|null} [data_length] ShardTableSize data_length
             */

            /**
             * Constructs a new ShardTableSize.
             * @memberof vtadmin.Schema
             * @classdesc Represents a ShardTableSize.
             * @implements IShardTableSize
             * @constructor
             * @param {vtadmin.Schema.IShardTableSize=} [properties] Properties to set
             */
            function ShardTableSize(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ShardTableSize row_count.
             * @member {number|Long} row_count
             * @memberof vtadmin.Schema.ShardTableSize
             * @instance
             */
            ShardTableSize.prototype.row_count = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ShardTableSize data_length.
             * @member {number|Long} data_length
             * @memberof vtadmin.Schema.ShardTableSize
             * @instance
             */
            ShardTableSize.prototype.data_length = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new ShardTableSize instance using the specified properties.
             * @function create
             * @memberof vtadmin.Schema.ShardTableSize
             * @static
             * @param {vtadmin.Schema.IShardTableSize=} [properties] Properties to set
             * @returns {vtadmin.Schema.ShardTableSize} ShardTableSize instance
             */
            ShardTableSize.create = function create(properties) {
                return new ShardTableSize(properties);
            };

            /**
             * Encodes the specified ShardTableSize message. Does not implicitly {@link vtadmin.Schema.ShardTableSize.verify|verify} messages.
             * @function encode
             * @memberof vtadmin.Schema.ShardTableSize
             * @static
             * @param {vtadmin.Schema.IShardTableSize} message ShardTableSize message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ShardTableSize.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.row_count != null && Object.hasOwnProperty.call(message, "row_count"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.row_count);
                if (message.data_length != null && Object.hasOwnProperty.call(message, "data_length"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.data_length);
                return writer;
            };

            /**
             * Encodes the specified ShardTableSize message, length delimited. Does not implicitly {@link vtadmin.Schema.ShardTableSize.verify|verify} messages.
             * @function encodeDelimited
             * @memberof vtadmin.Schema.ShardTableSize
             * @static
             * @param {vtadmin.Schema.IShardTableSize} message ShardTableSize message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ShardTableSize.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ShardTableSize message from the specified reader or buffer.
             * @function decode
             * @memberof vtadmin.Schema.ShardTableSize
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {vtadmin.Schema.ShardTableSize} ShardTableSize
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ShardTableSize.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtadmin.Schema.ShardTableSize();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.row_count = reader.uint64();
                        break;
                    case 2:
                        message.data_length = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ShardTableSize message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof vtadmin.Schema.ShardTableSize
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {vtadmin.Schema.ShardTableSize} ShardTableSize
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ShardTableSize.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ShardTableSize message.
             * @function verify
             * @memberof vtadmin.Schema.ShardTableSize
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ShardTableSize.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.row_count != null && message.hasOwnProperty("row_count"))
                    if (!$util.isInteger(message.row_count) && !(message.row_count && $util.isInteger(message.row_count.low) && $util.isInteger(message.row_count.high)))
                        return "row_count: integer|Long expected";
                if (message.data_length != null && message.hasOwnProperty("data_length"))
                    if (!$util.isInteger(message.data_length) && !(message.data_length && $util.isInteger(message.data_length.low) && $util.isInteger(message.data_length.high)))
                        return "data_length: integer|Long expected";
                return null;
            };

            /**
             * Creates a ShardTableSize message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof vtadmin.Schema.ShardTableSize
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {vtadmin.Schema.ShardTableSize} ShardTableSize
             */
            ShardTableSize.fromObject = function fromObject(object) {
                if (object instanceof $root.vtadmin.Schema.ShardTableSize)
                    return object;
                var message = new $root.vtadmin.Schema.ShardTableSize();
                if (object.row_count != null)
                    if ($util.Long)
                        (message.row_count = $util.Long.fromValue(object.row_count)).unsigned = true;
                    else if (typeof object.row_count === "string")
                        message.row_count = parseInt(object.row_count, 10);
                    else if (typeof object.row_count === "number")
                        message.row_count = object.row_count;
                    else if (typeof object.row_count === "object")
                        message.row_count = new $util.LongBits(object.row_count.low >>> 0, object.row_count.high >>> 0).toNumber(true);
                if (object.data_length != null)
                    if ($util.Long)
                        (message.data_length = $util.Long.fromValue(object.data_length)).unsigned = true;
                    else if (typeof object.data_length === "string")
                        message.data_length = parseInt(object.data_length, 10);
                    else if (typeof object.data_length === "number")
                        message.data_length = object.data_length;
                    else if (typeof object.data_length === "object")
                        message.data_length = new $util.LongBits(object.data_length.low >>> 0, object.data_length.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a ShardTableSize message. Also converts values to other types if specified.
             * @function toObject
             * @memberof vtadmin.Schema.ShardTableSize
             * @static
             * @param {vtadmin.Schema.ShardTableSize} message ShardTableSize
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ShardTableSize.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.row_count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.row_count = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.data_length = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.data_length = options.longs === String ? "0" : 0;
                }
                if (message.row_count != null && message.hasOwnProperty("row_count"))
                    if (typeof message.row_count === "number")
                        object.row_count = options.longs === String ? String(message.row_count) : message.row_count;
                    else
                        object.row_count = options.longs === String ? $util.Long.prototype.toString.call(message.row_count) : options.longs === Number ? new $util.LongBits(message.row_count.low >>> 0, message.row_count.high >>> 0).toNumber(true) : message.row_count;
                if (message.data_length != null && message.hasOwnProperty("data_length"))
                    if (typeof message.data_length === "number")
                        object.data_length = options.longs === String ? String(message.data_length) : message.data_length;
                    else
                        object.data_length = options.longs === String ? $util.Long.prototype.toString.call(message.data_length) : options.longs === Number ? new $util.LongBits(message.data_length.low >>> 0, message.data_length.high >>> 0).toNumber(true) : message.data_length;
                return object;
            };

            /**
             * Converts this ShardTableSize to JSON.
             * @function toJSON
             * @memberof vtadmin.Schema.ShardTableSize
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ShardTableSize.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ShardTableSize;
        })();

        Schema.TableSize = (function() {

            /**
             * Properties of a TableSize.
             * @memberof vtadmin.Schema
             * @interface ITableSize
             * @property {number|Long|null} [row_count] TableSize row_count
             * @property {number|Long|null} [data_length] TableSize data_length
             * @property {Object.<string,vtadmin.Schema.IShardTableSize>|null} [by_shard] TableSize by_shard
             */

            /**
             * Constructs a new TableSize.
             * @memberof vtadmin.Schema
             * @classdesc Represents a TableSize.
             * @implements ITableSize
             * @constructor
             * @param {vtadmin.Schema.ITableSize=} [properties] Properties to set
             */
            function TableSize(properties) {
                this.by_shard = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TableSize row_count.
             * @member {number|Long} row_count
             * @memberof vtadmin.Schema.TableSize
             * @instance
             */
            TableSize.prototype.row_count = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * TableSize data_length.
             * @member {number|Long} data_length
             * @memberof vtadmin.Schema.TableSize
             * @instance
             */
            TableSize.prototype.data_length = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * TableSize by_shard.
             * @member {Object.<string,vtadmin.Schema.IShardTableSize>} by_shard
             * @memberof vtadmin.Schema.TableSize
             * @instance
             */
            TableSize.prototype.by_shard = $util.emptyObject;

            /**
             * Creates a new TableSize instance using the specified properties.
             * @function create
             * @memberof vtadmin.Schema.TableSize
             * @static
             * @param {vtadmin.Schema.ITableSize=} [properties] Properties to set
             * @returns {vtadmin.Schema.TableSize} TableSize instance
             */
            TableSize.create = function create(properties) {
                return new TableSize(properties);
            };

            /**
             * Encodes the specified TableSize message. Does not implicitly {@link vtadmin.Schema.TableSize.verify|verify} messages.
             * @function encode
             * @memberof vtadmin.Schema.TableSize
             * @static
             * @param {vtadmin.Schema.ITableSize} message TableSize message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TableSize.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.row_count != null && Object.hasOwnProperty.call(message, "row_count"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.row_count);
                if (message.data_length != null && Object.hasOwnProperty.call(message, "data_length"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.data_length);
                if (message.by_shard != null && Object.hasOwnProperty.call(message, "by_shard"))
                    for (var keys = Object.keys(message.by_shard), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.vtadmin.Schema.ShardTableSize.encode(message.by_shard[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Encodes the specified TableSize message, length delimited. Does not implicitly {@link vtadmin.Schema.TableSize.verify|verify} messages.
             * @function encodeDelimited
             * @memberof vtadmin.Schema.TableSize
             * @static
             * @param {vtadmin.Schema.ITableSize} message TableSize message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TableSize.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TableSize message from the specified reader or buffer.
             * @function decode
             * @memberof vtadmin.Schema.TableSize
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {vtadmin.Schema.TableSize} TableSize
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TableSize.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtadmin.Schema.TableSize(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.row_count = reader.uint64();
                        break;
                    case 2:
                        message.data_length = reader.uint64();
                        break;
                    case 3:
                        if (message.by_shard === $util.emptyObject)
                            message.by_shard = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = null;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = $root.vtadmin.Schema.ShardTableSize.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.by_shard[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TableSize message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof vtadmin.Schema.TableSize
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {vtadmin.Schema.TableSize} TableSize
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TableSize.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TableSize message.
             * @function verify
             * @memberof vtadmin.Schema.TableSize
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TableSize.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.row_count != null && message.hasOwnProperty("row_count"))
                    if (!$util.isInteger(message.row_count) && !(message.row_count && $util.isInteger(message.row_count.low) && $util.isInteger(message.row_count.high)))
                        return "row_count: integer|Long expected";
                if (message.data_length != null && message.hasOwnProperty("data_length"))
                    if (!$util.isInteger(message.data_length) && !(message.data_length && $util.isInteger(message.data_length.low) && $util.isInteger(message.data_length.high)))
                        return "data_length: integer|Long expected";
                if (message.by_shard != null && message.hasOwnProperty("by_shard")) {
                    if (!$util.isObject(message.by_shard))
                        return "by_shard: object expected";
                    var key = Object.keys(message.by_shard);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.vtadmin.Schema.ShardTableSize.verify(message.by_shard[key[i]]);
                        if (error)
                            return "by_shard." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a TableSize message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof vtadmin.Schema.TableSize
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {vtadmin.Schema.TableSize} TableSize
             */
            TableSize.fromObject = function fromObject(object) {
                if (object instanceof $root.vtadmin.Schema.TableSize)
                    return object;
                var message = new $root.vtadmin.Schema.TableSize();
                if (object.row_count != null)
                    if ($util.Long)
                        (message.row_count = $util.Long.fromValue(object.row_count)).unsigned = true;
                    else if (typeof object.row_count === "string")
                        message.row_count = parseInt(object.row_count, 10);
                    else if (typeof object.row_count === "number")
                        message.row_count = object.row_count;
                    else if (typeof object.row_count === "object")
                        message.row_count = new $util.LongBits(object.row_count.low >>> 0, object.row_count.high >>> 0).toNumber(true);
                if (object.data_length != null)
                    if ($util.Long)
                        (message.data_length = $util.Long.fromValue(object.data_length)).unsigned = true;
                    else if (typeof object.data_length === "string")
                        message.data_length = parseInt(object.data_length, 10);
                    else if (typeof object.data_length === "number")
                        message.data_length = object.data_length;
                    else if (typeof object.data_length === "object")
                        message.data_length = new $util.LongBits(object.data_length.low >>> 0, object.data_length.high >>> 0).toNumber(true);
                if (object.by_shard) {
                    if (typeof object.by_shard !== "object")
                        throw TypeError(".vtadmin.Schema.TableSize.by_shard: object expected");
                    message.by_shard = {};
                    for (var keys = Object.keys(object.by_shard), i = 0; i < keys.length; ++i) {
                        if (typeof object.by_shard[keys[i]] !== "object")
                            throw TypeError(".vtadmin.Schema.TableSize.by_shard: object expected");
                        message.by_shard[keys[i]] = $root.vtadmin.Schema.ShardTableSize.fromObject(object.by_shard[keys[i]]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a TableSize message. Also converts values to other types if specified.
             * @function toObject
             * @memberof vtadmin.Schema.TableSize
             * @static
             * @param {vtadmin.Schema.TableSize} message TableSize
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TableSize.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.by_shard = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.row_count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.row_count = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.data_length = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.data_length = options.longs === String ? "0" : 0;
                }
                if (message.row_count != null && message.hasOwnProperty("row_count"))
                    if (typeof message.row_count === "number")
                        object.row_count = options.longs === String ? String(message.row_count) : message.row_count;
                    else
                        object.row_count = options.longs === String ? $util.Long.prototype.toString.call(message.row_count) : options.longs === Number ? new $util.LongBits(message.row_count.low >>> 0, message.row_count.high >>> 0).toNumber(true) : message.row_count;
                if (message.data_length != null && message.hasOwnProperty("data_length"))
                    if (typeof message.data_length === "number")
                        object.data_length = options.longs === String ? String(message.data_length) : message.data_length;
                    else
                        object.data_length = options.longs === String ? $util.Long.prototype.toString.call(message.data_length) : options.longs === Number ? new $util.LongBits(message.data_length.low >>> 0, message.data_length.high >>> 0).toNumber(true) : message.data_length;
                var keys2;
                if (message.by_shard && (keys2 = Object.keys(message.by_shard)).length) {
                    object.by_shard = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.by_shard[keys2[j]] = $root.vtadmin.Schema.ShardTableSize.toObject(message.by_shard[keys2[j]], options);
                }
                return object;
            };

            /**
             * Converts this TableSize to JSON.
             * @function toJSON
             * @memberof vtadmin.Schema.TableSize
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TableSize.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TableSize;
        })();

        return Schema;
    })();

    vtadmin.Tablet = (function() {

        /**
         * Properties of a Tablet.
         * @memberof vtadmin
         * @interface ITablet
         * @property {vtadmin.ICluster|null} [cluster] Tablet cluster
         * @property {topodata.ITablet|null} [tablet] Tablet tablet
         * @property {vtadmin.Tablet.ServingState|null} [state] Tablet state
         */

        /**
         * Constructs a new Tablet.
         * @memberof vtadmin
         * @classdesc Represents a Tablet.
         * @implements ITablet
         * @constructor
         * @param {vtadmin.ITablet=} [properties] Properties to set
         */
        function Tablet(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Tablet cluster.
         * @member {vtadmin.ICluster|null|undefined} cluster
         * @memberof vtadmin.Tablet
         * @instance
         */
        Tablet.prototype.cluster = null;

        /**
         * Tablet tablet.
         * @member {topodata.ITablet|null|undefined} tablet
         * @memberof vtadmin.Tablet
         * @instance
         */
        Tablet.prototype.tablet = null;

        /**
         * Tablet state.
         * @member {vtadmin.Tablet.ServingState} state
         * @memberof vtadmin.Tablet
         * @instance
         */
        Tablet.prototype.state = 0;

        /**
         * Creates a new Tablet instance using the specified properties.
         * @function create
         * @memberof vtadmin.Tablet
         * @static
         * @param {vtadmin.ITablet=} [properties] Properties to set
         * @returns {vtadmin.Tablet} Tablet instance
         */
        Tablet.create = function create(properties) {
            return new Tablet(properties);
        };

        /**
         * Encodes the specified Tablet message. Does not implicitly {@link vtadmin.Tablet.verify|verify} messages.
         * @function encode
         * @memberof vtadmin.Tablet
         * @static
         * @param {vtadmin.ITablet} message Tablet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Tablet.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cluster != null && Object.hasOwnProperty.call(message, "cluster"))
                $root.vtadmin.Cluster.encode(message.cluster, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.tablet != null && Object.hasOwnProperty.call(message, "tablet"))
                $root.topodata.Tablet.encode(message.tablet, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.state);
            return writer;
        };

        /**
         * Encodes the specified Tablet message, length delimited. Does not implicitly {@link vtadmin.Tablet.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtadmin.Tablet
         * @static
         * @param {vtadmin.ITablet} message Tablet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Tablet.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Tablet message from the specified reader or buffer.
         * @function decode
         * @memberof vtadmin.Tablet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtadmin.Tablet} Tablet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Tablet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtadmin.Tablet();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.cluster = $root.vtadmin.Cluster.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.tablet = $root.topodata.Tablet.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.state = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Tablet message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtadmin.Tablet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtadmin.Tablet} Tablet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Tablet.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Tablet message.
         * @function verify
         * @memberof vtadmin.Tablet
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Tablet.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cluster != null && message.hasOwnProperty("cluster")) {
                var error = $root.vtadmin.Cluster.verify(message.cluster);
                if (error)
                    return "cluster." + error;
            }
            if (message.tablet != null && message.hasOwnProperty("tablet")) {
                var error = $root.topodata.Tablet.verify(message.tablet);
                if (error)
                    return "tablet." + error;
            }
            if (message.state != null && message.hasOwnProperty("state"))
                switch (message.state) {
                default:
                    return "state: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a Tablet message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtadmin.Tablet
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtadmin.Tablet} Tablet
         */
        Tablet.fromObject = function fromObject(object) {
            if (object instanceof $root.vtadmin.Tablet)
                return object;
            var message = new $root.vtadmin.Tablet();
            if (object.cluster != null) {
                if (typeof object.cluster !== "object")
                    throw TypeError(".vtadmin.Tablet.cluster: object expected");
                message.cluster = $root.vtadmin.Cluster.fromObject(object.cluster);
            }
            if (object.tablet != null) {
                if (typeof object.tablet !== "object")
                    throw TypeError(".vtadmin.Tablet.tablet: object expected");
                message.tablet = $root.topodata.Tablet.fromObject(object.tablet);
            }
            switch (object.state) {
            case "UNKNOWN":
            case 0:
                message.state = 0;
                break;
            case "SERVING":
            case 1:
                message.state = 1;
                break;
            case "NOT_SERVING":
            case 2:
                message.state = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a Tablet message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtadmin.Tablet
         * @static
         * @param {vtadmin.Tablet} message Tablet
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Tablet.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.cluster = null;
                object.tablet = null;
                object.state = options.enums === String ? "UNKNOWN" : 0;
            }
            if (message.cluster != null && message.hasOwnProperty("cluster"))
                object.cluster = $root.vtadmin.Cluster.toObject(message.cluster, options);
            if (message.tablet != null && message.hasOwnProperty("tablet"))
                object.tablet = $root.topodata.Tablet.toObject(message.tablet, options);
            if (message.state != null && message.hasOwnProperty("state"))
                object.state = options.enums === String ? $root.vtadmin.Tablet.ServingState[message.state] : message.state;
            return object;
        };

        /**
         * Converts this Tablet to JSON.
         * @function toJSON
         * @memberof vtadmin.Tablet
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Tablet.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * ServingState enum.
         * @name vtadmin.Tablet.ServingState
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} SERVING=1 SERVING value
         * @property {number} NOT_SERVING=2 NOT_SERVING value
         */
        Tablet.ServingState = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "SERVING"] = 1;
            values[valuesById[2] = "NOT_SERVING"] = 2;
            return values;
        })();

        return Tablet;
    })();

    vtadmin.VSchema = (function() {

        /**
         * Properties of a VSchema.
         * @memberof vtadmin
         * @interface IVSchema
         * @property {vtadmin.ICluster|null} [cluster] VSchema cluster
         * @property {string|null} [name] VSchema name
         * @property {vschema.IKeyspace|null} [v_schema] VSchema v_schema
         */

        /**
         * Constructs a new VSchema.
         * @memberof vtadmin
         * @classdesc Represents a VSchema.
         * @implements IVSchema
         * @constructor
         * @param {vtadmin.IVSchema=} [properties] Properties to set
         */
        function VSchema(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VSchema cluster.
         * @member {vtadmin.ICluster|null|undefined} cluster
         * @memberof vtadmin.VSchema
         * @instance
         */
        VSchema.prototype.cluster = null;

        /**
         * VSchema name.
         * @member {string} name
         * @memberof vtadmin.VSchema
         * @instance
         */
        VSchema.prototype.name = "";

        /**
         * VSchema v_schema.
         * @member {vschema.IKeyspace|null|undefined} v_schema
         * @memberof vtadmin.VSchema
         * @instance
         */
        VSchema.prototype.v_schema = null;

        /**
         * Creates a new VSchema instance using the specified properties.
         * @function create
         * @memberof vtadmin.VSchema
         * @static
         * @param {vtadmin.IVSchema=} [properties] Properties to set
         * @returns {vtadmin.VSchema} VSchema instance
         */
        VSchema.create = function create(properties) {
            return new VSchema(properties);
        };

        /**
         * Encodes the specified VSchema message. Does not implicitly {@link vtadmin.VSchema.verify|verify} messages.
         * @function encode
         * @memberof vtadmin.VSchema
         * @static
         * @param {vtadmin.IVSchema} message VSchema message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VSchema.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cluster != null && Object.hasOwnProperty.call(message, "cluster"))
                $root.vtadmin.Cluster.encode(message.cluster, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.v_schema != null && Object.hasOwnProperty.call(message, "v_schema"))
                $root.vschema.Keyspace.encode(message.v_schema, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified VSchema message, length delimited. Does not implicitly {@link vtadmin.VSchema.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtadmin.VSchema
         * @static
         * @param {vtadmin.IVSchema} message VSchema message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VSchema.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VSchema message from the specified reader or buffer.
         * @function decode
         * @memberof vtadmin.VSchema
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtadmin.VSchema} VSchema
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VSchema.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtadmin.VSchema();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.cluster = $root.vtadmin.Cluster.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.v_schema = $root.vschema.Keyspace.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VSchema message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtadmin.VSchema
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtadmin.VSchema} VSchema
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VSchema.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VSchema message.
         * @function verify
         * @memberof vtadmin.VSchema
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VSchema.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cluster != null && message.hasOwnProperty("cluster")) {
                var error = $root.vtadmin.Cluster.verify(message.cluster);
                if (error)
                    return "cluster." + error;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.v_schema != null && message.hasOwnProperty("v_schema")) {
                var error = $root.vschema.Keyspace.verify(message.v_schema);
                if (error)
                    return "v_schema." + error;
            }
            return null;
        };

        /**
         * Creates a VSchema message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtadmin.VSchema
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtadmin.VSchema} VSchema
         */
        VSchema.fromObject = function fromObject(object) {
            if (object instanceof $root.vtadmin.VSchema)
                return object;
            var message = new $root.vtadmin.VSchema();
            if (object.cluster != null) {
                if (typeof object.cluster !== "object")
                    throw TypeError(".vtadmin.VSchema.cluster: object expected");
                message.cluster = $root.vtadmin.Cluster.fromObject(object.cluster);
            }
            if (object.name != null)
                message.name = String(object.name);
            if (object.v_schema != null) {
                if (typeof object.v_schema !== "object")
                    throw TypeError(".vtadmin.VSchema.v_schema: object expected");
                message.v_schema = $root.vschema.Keyspace.fromObject(object.v_schema);
            }
            return message;
        };

        /**
         * Creates a plain object from a VSchema message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtadmin.VSchema
         * @static
         * @param {vtadmin.VSchema} message VSchema
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VSchema.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.cluster = null;
                object.name = "";
                object.v_schema = null;
            }
            if (message.cluster != null && message.hasOwnProperty("cluster"))
                object.cluster = $root.vtadmin.Cluster.toObject(message.cluster, options);
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.v_schema != null && message.hasOwnProperty("v_schema"))
                object.v_schema = $root.vschema.Keyspace.toObject(message.v_schema, options);
            return object;
        };

        /**
         * Converts this VSchema to JSON.
         * @function toJSON
         * @memberof vtadmin.VSchema
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VSchema.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VSchema;
    })();

    vtadmin.Vtctld = (function() {

        /**
         * Properties of a Vtctld.
         * @memberof vtadmin
         * @interface IVtctld
         * @property {string|null} [hostname] Vtctld hostname
         * @property {vtadmin.ICluster|null} [cluster] Vtctld cluster
         */

        /**
         * Constructs a new Vtctld.
         * @memberof vtadmin
         * @classdesc Represents a Vtctld.
         * @implements IVtctld
         * @constructor
         * @param {vtadmin.IVtctld=} [properties] Properties to set
         */
        function Vtctld(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Vtctld hostname.
         * @member {string} hostname
         * @memberof vtadmin.Vtctld
         * @instance
         */
        Vtctld.prototype.hostname = "";

        /**
         * Vtctld cluster.
         * @member {vtadmin.ICluster|null|undefined} cluster
         * @memberof vtadmin.Vtctld
         * @instance
         */
        Vtctld.prototype.cluster = null;

        /**
         * Creates a new Vtctld instance using the specified properties.
         * @function create
         * @memberof vtadmin.Vtctld
         * @static
         * @param {vtadmin.IVtctld=} [properties] Properties to set
         * @returns {vtadmin.Vtctld} Vtctld instance
         */
        Vtctld.create = function create(properties) {
            return new Vtctld(properties);
        };

        /**
         * Encodes the specified Vtctld message. Does not implicitly {@link vtadmin.Vtctld.verify|verify} messages.
         * @function encode
         * @memberof vtadmin.Vtctld
         * @static
         * @param {vtadmin.IVtctld} message Vtctld message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Vtctld.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hostname != null && Object.hasOwnProperty.call(message, "hostname"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.hostname);
            if (message.cluster != null && Object.hasOwnProperty.call(message, "cluster"))
                $root.vtadmin.Cluster.encode(message.cluster, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Vtctld message, length delimited. Does not implicitly {@link vtadmin.Vtctld.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtadmin.Vtctld
         * @static
         * @param {vtadmin.IVtctld} message Vtctld message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Vtctld.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Vtctld message from the specified reader or buffer.
         * @function decode
         * @memberof vtadmin.Vtctld
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtadmin.Vtctld} Vtctld
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Vtctld.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtadmin.Vtctld();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hostname = reader.string();
                    break;
                case 2:
                    message.cluster = $root.vtadmin.Cluster.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Vtctld message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtadmin.Vtctld
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtadmin.Vtctld} Vtctld
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Vtctld.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Vtctld message.
         * @function verify
         * @memberof vtadmin.Vtctld
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Vtctld.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hostname != null && message.hasOwnProperty("hostname"))
                if (!$util.isString(message.hostname))
                    return "hostname: string expected";
            if (message.cluster != null && message.hasOwnProperty("cluster")) {
                var error = $root.vtadmin.Cluster.verify(message.cluster);
                if (error)
                    return "cluster." + error;
            }
            return null;
        };

        /**
         * Creates a Vtctld message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtadmin.Vtctld
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtadmin.Vtctld} Vtctld
         */
        Vtctld.fromObject = function fromObject(object) {
            if (object instanceof $root.vtadmin.Vtctld)
                return object;
            var message = new $root.vtadmin.Vtctld();
            if (object.hostname != null)
                message.hostname = String(object.hostname);
            if (object.cluster != null) {
                if (typeof object.cluster !== "object")
                    throw TypeError(".vtadmin.Vtctld.cluster: object expected");
                message.cluster = $root.vtadmin.Cluster.fromObject(object.cluster);
            }
            return message;
        };

        /**
         * Creates a plain object from a Vtctld message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtadmin.Vtctld
         * @static
         * @param {vtadmin.Vtctld} message Vtctld
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Vtctld.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.hostname = "";
                object.cluster = null;
            }
            if (message.hostname != null && message.hasOwnProperty("hostname"))
                object.hostname = message.hostname;
            if (message.cluster != null && message.hasOwnProperty("cluster"))
                object.cluster = $root.vtadmin.Cluster.toObject(message.cluster, options);
            return object;
        };

        /**
         * Converts this Vtctld to JSON.
         * @function toJSON
         * @memberof vtadmin.Vtctld
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Vtctld.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Vtctld;
    })();

    vtadmin.VTGate = (function() {

        /**
         * Properties of a VTGate.
         * @memberof vtadmin
         * @interface IVTGate
         * @property {string|null} [hostname] VTGate hostname
         * @property {string|null} [pool] VTGate pool
         * @property {string|null} [cell] VTGate cell
         * @property {vtadmin.ICluster|null} [cluster] VTGate cluster
         * @property {Array.<string>|null} [keyspaces] VTGate keyspaces
         */

        /**
         * Constructs a new VTGate.
         * @memberof vtadmin
         * @classdesc Represents a VTGate.
         * @implements IVTGate
         * @constructor
         * @param {vtadmin.IVTGate=} [properties] Properties to set
         */
        function VTGate(properties) {
            this.keyspaces = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VTGate hostname.
         * @member {string} hostname
         * @memberof vtadmin.VTGate
         * @instance
         */
        VTGate.prototype.hostname = "";

        /**
         * VTGate pool.
         * @member {string} pool
         * @memberof vtadmin.VTGate
         * @instance
         */
        VTGate.prototype.pool = "";

        /**
         * VTGate cell.
         * @member {string} cell
         * @memberof vtadmin.VTGate
         * @instance
         */
        VTGate.prototype.cell = "";

        /**
         * VTGate cluster.
         * @member {vtadmin.ICluster|null|undefined} cluster
         * @memberof vtadmin.VTGate
         * @instance
         */
        VTGate.prototype.cluster = null;

        /**
         * VTGate keyspaces.
         * @member {Array.<string>} keyspaces
         * @memberof vtadmin.VTGate
         * @instance
         */
        VTGate.prototype.keyspaces = $util.emptyArray;

        /**
         * Creates a new VTGate instance using the specified properties.
         * @function create
         * @memberof vtadmin.VTGate
         * @static
         * @param {vtadmin.IVTGate=} [properties] Properties to set
         * @returns {vtadmin.VTGate} VTGate instance
         */
        VTGate.create = function create(properties) {
            return new VTGate(properties);
        };

        /**
         * Encodes the specified VTGate message. Does not implicitly {@link vtadmin.VTGate.verify|verify} messages.
         * @function encode
         * @memberof vtadmin.VTGate
         * @static
         * @param {vtadmin.IVTGate} message VTGate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VTGate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hostname != null && Object.hasOwnProperty.call(message, "hostname"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.hostname);
            if (message.pool != null && Object.hasOwnProperty.call(message, "pool"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.pool);
            if (message.cell != null && Object.hasOwnProperty.call(message, "cell"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.cell);
            if (message.cluster != null && Object.hasOwnProperty.call(message, "cluster"))
                $root.vtadmin.Cluster.encode(message.cluster, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.keyspaces != null && message.keyspaces.length)
                for (var i = 0; i < message.keyspaces.length; ++i)
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.keyspaces[i]);
            return writer;
        };

        /**
         * Encodes the specified VTGate message, length delimited. Does not implicitly {@link vtadmin.VTGate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtadmin.VTGate
         * @static
         * @param {vtadmin.IVTGate} message VTGate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VTGate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VTGate message from the specified reader or buffer.
         * @function decode
         * @memberof vtadmin.VTGate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtadmin.VTGate} VTGate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VTGate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtadmin.VTGate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hostname = reader.string();
                    break;
                case 2:
                    message.pool = reader.string();
                    break;
                case 3:
                    message.cell = reader.string();
                    break;
                case 4:
                    message.cluster = $root.vtadmin.Cluster.decode(reader, reader.uint32());
                    break;
                case 5:
                    if (!(message.keyspaces && message.keyspaces.length))
                        message.keyspaces = [];
                    message.keyspaces.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VTGate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtadmin.VTGate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtadmin.VTGate} VTGate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VTGate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VTGate message.
         * @function verify
         * @memberof vtadmin.VTGate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VTGate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hostname != null && message.hasOwnProperty("hostname"))
                if (!$util.isString(message.hostname))
                    return "hostname: string expected";
            if (message.pool != null && message.hasOwnProperty("pool"))
                if (!$util.isString(message.pool))
                    return "pool: string expected";
            if (message.cell != null && message.hasOwnProperty("cell"))
                if (!$util.isString(message.cell))
                    return "cell: string expected";
            if (message.cluster != null && message.hasOwnProperty("cluster")) {
                var error = $root.vtadmin.Cluster.verify(message.cluster);
                if (error)
                    return "cluster." + error;
            }
            if (message.keyspaces != null && message.hasOwnProperty("keyspaces")) {
                if (!Array.isArray(message.keyspaces))
                    return "keyspaces: array expected";
                for (var i = 0; i < message.keyspaces.length; ++i)
                    if (!$util.isString(message.keyspaces[i]))
                        return "keyspaces: string[] expected";
            }
            return null;
        };

        /**
         * Creates a VTGate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtadmin.VTGate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtadmin.VTGate} VTGate
         */
        VTGate.fromObject = function fromObject(object) {
            if (object instanceof $root.vtadmin.VTGate)
                return object;
            var message = new $root.vtadmin.VTGate();
            if (object.hostname != null)
                message.hostname = String(object.hostname);
            if (object.pool != null)
                message.pool = String(object.pool);
            if (object.cell != null)
                message.cell = String(object.cell);
            if (object.cluster != null) {
                if (typeof object.cluster !== "object")
                    throw TypeError(".vtadmin.VTGate.cluster: object expected");
                message.cluster = $root.vtadmin.Cluster.fromObject(object.cluster);
            }
            if (object.keyspaces) {
                if (!Array.isArray(object.keyspaces))
                    throw TypeError(".vtadmin.VTGate.keyspaces: array expected");
                message.keyspaces = [];
                for (var i = 0; i < object.keyspaces.length; ++i)
                    message.keyspaces[i] = String(object.keyspaces[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a VTGate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtadmin.VTGate
         * @static
         * @param {vtadmin.VTGate} message VTGate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VTGate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.keyspaces = [];
            if (options.defaults) {
                object.hostname = "";
                object.pool = "";
                object.cell = "";
                object.cluster = null;
            }
            if (message.hostname != null && message.hasOwnProperty("hostname"))
                object.hostname = message.hostname;
            if (message.pool != null && message.hasOwnProperty("pool"))
                object.pool = message.pool;
            if (message.cell != null && message.hasOwnProperty("cell"))
                object.cell = message.cell;
            if (message.cluster != null && message.hasOwnProperty("cluster"))
                object.cluster = $root.vtadmin.Cluster.toObject(message.cluster, options);
            if (message.keyspaces && message.keyspaces.length) {
                object.keyspaces = [];
                for (var j = 0; j < message.keyspaces.length; ++j)
                    object.keyspaces[j] = message.keyspaces[j];
            }
            return object;
        };

        /**
         * Converts this VTGate to JSON.
         * @function toJSON
         * @memberof vtadmin.VTGate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VTGate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VTGate;
    })();

    vtadmin.Workflow = (function() {

        /**
         * Properties of a Workflow.
         * @memberof vtadmin
         * @interface IWorkflow
         * @property {vtadmin.ICluster|null} [cluster] Workflow cluster
         * @property {string|null} [keyspace] Workflow keyspace
         * @property {vtctldata.IWorkflow|null} [workflow] Workflow workflow
         */

        /**
         * Constructs a new Workflow.
         * @memberof vtadmin
         * @classdesc Represents a Workflow.
         * @implements IWorkflow
         * @constructor
         * @param {vtadmin.IWorkflow=} [properties] Properties to set
         */
        function Workflow(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Workflow cluster.
         * @member {vtadmin.ICluster|null|undefined} cluster
         * @memberof vtadmin.Workflow
         * @instance
         */
        Workflow.prototype.cluster = null;

        /**
         * Workflow keyspace.
         * @member {string} keyspace
         * @memberof vtadmin.Workflow
         * @instance
         */
        Workflow.prototype.keyspace = "";

        /**
         * Workflow workflow.
         * @member {vtctldata.IWorkflow|null|undefined} workflow
         * @memberof vtadmin.Workflow
         * @instance
         */
        Workflow.prototype.workflow = null;

        /**
         * Creates a new Workflow instance using the specified properties.
         * @function create
         * @memberof vtadmin.Workflow
         * @static
         * @param {vtadmin.IWorkflow=} [properties] Properties to set
         * @returns {vtadmin.Workflow} Workflow instance
         */
        Workflow.create = function create(properties) {
            return new Workflow(properties);
        };

        /**
         * Encodes the specified Workflow message. Does not implicitly {@link vtadmin.Workflow.verify|verify} messages.
         * @function encode
         * @memberof vtadmin.Workflow
         * @static
         * @param {vtadmin.IWorkflow} message Workflow message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Workflow.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cluster != null && Object.hasOwnProperty.call(message, "cluster"))
                $root.vtadmin.Cluster.encode(message.cluster, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.keyspace != null && Object.hasOwnProperty.call(message, "keyspace"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.keyspace);
            if (message.workflow != null && Object.hasOwnProperty.call(message, "workflow"))
                $root.vtctldata.Workflow.encode(message.workflow, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Workflow message, length delimited. Does not implicitly {@link vtadmin.Workflow.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtadmin.Workflow
         * @static
         * @param {vtadmin.IWorkflow} message Workflow message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Workflow.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Workflow message from the specified reader or buffer.
         * @function decode
         * @memberof vtadmin.Workflow
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtadmin.Workflow} Workflow
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Workflow.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtadmin.Workflow();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.cluster = $root.vtadmin.Cluster.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.keyspace = reader.string();
                    break;
                case 3:
                    message.workflow = $root.vtctldata.Workflow.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Workflow message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtadmin.Workflow
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtadmin.Workflow} Workflow
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Workflow.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Workflow message.
         * @function verify
         * @memberof vtadmin.Workflow
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Workflow.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cluster != null && message.hasOwnProperty("cluster")) {
                var error = $root.vtadmin.Cluster.verify(message.cluster);
                if (error)
                    return "cluster." + error;
            }
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                if (!$util.isString(message.keyspace))
                    return "keyspace: string expected";
            if (message.workflow != null && message.hasOwnProperty("workflow")) {
                var error = $root.vtctldata.Workflow.verify(message.workflow);
                if (error)
                    return "workflow." + error;
            }
            return null;
        };

        /**
         * Creates a Workflow message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtadmin.Workflow
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtadmin.Workflow} Workflow
         */
        Workflow.fromObject = function fromObject(object) {
            if (object instanceof $root.vtadmin.Workflow)
                return object;
            var message = new $root.vtadmin.Workflow();
            if (object.cluster != null) {
                if (typeof object.cluster !== "object")
                    throw TypeError(".vtadmin.Workflow.cluster: object expected");
                message.cluster = $root.vtadmin.Cluster.fromObject(object.cluster);
            }
            if (object.keyspace != null)
                message.keyspace = String(object.keyspace);
            if (object.workflow != null) {
                if (typeof object.workflow !== "object")
                    throw TypeError(".vtadmin.Workflow.workflow: object expected");
                message.workflow = $root.vtctldata.Workflow.fromObject(object.workflow);
            }
            return message;
        };

        /**
         * Creates a plain object from a Workflow message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtadmin.Workflow
         * @static
         * @param {vtadmin.Workflow} message Workflow
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Workflow.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.cluster = null;
                object.keyspace = "";
                object.workflow = null;
            }
            if (message.cluster != null && message.hasOwnProperty("cluster"))
                object.cluster = $root.vtadmin.Cluster.toObject(message.cluster, options);
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                object.keyspace = message.keyspace;
            if (message.workflow != null && message.hasOwnProperty("workflow"))
                object.workflow = $root.vtctldata.Workflow.toObject(message.workflow, options);
            return object;
        };

        /**
         * Converts this Workflow to JSON.
         * @function toJSON
         * @memberof vtadmin.Workflow
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Workflow.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Workflow;
    })();

    vtadmin.FindSchemaRequest = (function() {

        /**
         * Properties of a FindSchemaRequest.
         * @memberof vtadmin
         * @interface IFindSchemaRequest
         * @property {string|null} [table] FindSchemaRequest table
         * @property {Array.<string>|null} [cluster_ids] FindSchemaRequest cluster_ids
         * @property {vtadmin.IGetSchemaTableSizeOptions|null} [table_size_options] FindSchemaRequest table_size_options
         */

        /**
         * Constructs a new FindSchemaRequest.
         * @memberof vtadmin
         * @classdesc Represents a FindSchemaRequest.
         * @implements IFindSchemaRequest
         * @constructor
         * @param {vtadmin.IFindSchemaRequest=} [properties] Properties to set
         */
        function FindSchemaRequest(properties) {
            this.cluster_ids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FindSchemaRequest table.
         * @member {string} table
         * @memberof vtadmin.FindSchemaRequest
         * @instance
         */
        FindSchemaRequest.prototype.table = "";

        /**
         * FindSchemaRequest cluster_ids.
         * @member {Array.<string>} cluster_ids
         * @memberof vtadmin.FindSchemaRequest
         * @instance
         */
        FindSchemaRequest.prototype.cluster_ids = $util.emptyArray;

        /**
         * FindSchemaRequest table_size_options.
         * @member {vtadmin.IGetSchemaTableSizeOptions|null|undefined} table_size_options
         * @memberof vtadmin.FindSchemaRequest
         * @instance
         */
        FindSchemaRequest.prototype.table_size_options = null;

        /**
         * Creates a new FindSchemaRequest instance using the specified properties.
         * @function create
         * @memberof vtadmin.FindSchemaRequest
         * @static
         * @param {vtadmin.IFindSchemaRequest=} [properties] Properties to set
         * @returns {vtadmin.FindSchemaRequest} FindSchemaRequest instance
         */
        FindSchemaRequest.create = function create(properties) {
            return new FindSchemaRequest(properties);
        };

        /**
         * Encodes the specified FindSchemaRequest message. Does not implicitly {@link vtadmin.FindSchemaRequest.verify|verify} messages.
         * @function encode
         * @memberof vtadmin.FindSchemaRequest
         * @static
         * @param {vtadmin.IFindSchemaRequest} message FindSchemaRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FindSchemaRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.table != null && Object.hasOwnProperty.call(message, "table"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.table);
            if (message.cluster_ids != null && message.cluster_ids.length)
                for (var i = 0; i < message.cluster_ids.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.cluster_ids[i]);
            if (message.table_size_options != null && Object.hasOwnProperty.call(message, "table_size_options"))
                $root.vtadmin.GetSchemaTableSizeOptions.encode(message.table_size_options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified FindSchemaRequest message, length delimited. Does not implicitly {@link vtadmin.FindSchemaRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtadmin.FindSchemaRequest
         * @static
         * @param {vtadmin.IFindSchemaRequest} message FindSchemaRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FindSchemaRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FindSchemaRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtadmin.FindSchemaRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtadmin.FindSchemaRequest} FindSchemaRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FindSchemaRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtadmin.FindSchemaRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.table = reader.string();
                    break;
                case 2:
                    if (!(message.cluster_ids && message.cluster_ids.length))
                        message.cluster_ids = [];
                    message.cluster_ids.push(reader.string());
                    break;
                case 3:
                    message.table_size_options = $root.vtadmin.GetSchemaTableSizeOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FindSchemaRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtadmin.FindSchemaRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtadmin.FindSchemaRequest} FindSchemaRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FindSchemaRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FindSchemaRequest message.
         * @function verify
         * @memberof vtadmin.FindSchemaRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FindSchemaRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.table != null && message.hasOwnProperty("table"))
                if (!$util.isString(message.table))
                    return "table: string expected";
            if (message.cluster_ids != null && message.hasOwnProperty("cluster_ids")) {
                if (!Array.isArray(message.cluster_ids))
                    return "cluster_ids: array expected";
                for (var i = 0; i < message.cluster_ids.length; ++i)
                    if (!$util.isString(message.cluster_ids[i]))
                        return "cluster_ids: string[] expected";
            }
            if (message.table_size_options != null && message.hasOwnProperty("table_size_options")) {
                var error = $root.vtadmin.GetSchemaTableSizeOptions.verify(message.table_size_options);
                if (error)
                    return "table_size_options." + error;
            }
            return null;
        };

        /**
         * Creates a FindSchemaRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtadmin.FindSchemaRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtadmin.FindSchemaRequest} FindSchemaRequest
         */
        FindSchemaRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtadmin.FindSchemaRequest)
                return object;
            var message = new $root.vtadmin.FindSchemaRequest();
            if (object.table != null)
                message.table = String(object.table);
            if (object.cluster_ids) {
                if (!Array.isArray(object.cluster_ids))
                    throw TypeError(".vtadmin.FindSchemaRequest.cluster_ids: array expected");
                message.cluster_ids = [];
                for (var i = 0; i < object.cluster_ids.length; ++i)
                    message.cluster_ids[i] = String(object.cluster_ids[i]);
            }
            if (object.table_size_options != null) {
                if (typeof object.table_size_options !== "object")
                    throw TypeError(".vtadmin.FindSchemaRequest.table_size_options: object expected");
                message.table_size_options = $root.vtadmin.GetSchemaTableSizeOptions.fromObject(object.table_size_options);
            }
            return message;
        };

        /**
         * Creates a plain object from a FindSchemaRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtadmin.FindSchemaRequest
         * @static
         * @param {vtadmin.FindSchemaRequest} message FindSchemaRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FindSchemaRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.cluster_ids = [];
            if (options.defaults) {
                object.table = "";
                object.table_size_options = null;
            }
            if (message.table != null && message.hasOwnProperty("table"))
                object.table = message.table;
            if (message.cluster_ids && message.cluster_ids.length) {
                object.cluster_ids = [];
                for (var j = 0; j < message.cluster_ids.length; ++j)
                    object.cluster_ids[j] = message.cluster_ids[j];
            }
            if (message.table_size_options != null && message.hasOwnProperty("table_size_options"))
                object.table_size_options = $root.vtadmin.GetSchemaTableSizeOptions.toObject(message.table_size_options, options);
            return object;
        };

        /**
         * Converts this FindSchemaRequest to JSON.
         * @function toJSON
         * @memberof vtadmin.FindSchemaRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FindSchemaRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FindSchemaRequest;
    })();

    vtadmin.GetClustersRequest = (function() {

        /**
         * Properties of a GetClustersRequest.
         * @memberof vtadmin
         * @interface IGetClustersRequest
         */

        /**
         * Constructs a new GetClustersRequest.
         * @memberof vtadmin
         * @classdesc Represents a GetClustersRequest.
         * @implements IGetClustersRequest
         * @constructor
         * @param {vtadmin.IGetClustersRequest=} [properties] Properties to set
         */
        function GetClustersRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new GetClustersRequest instance using the specified properties.
         * @function create
         * @memberof vtadmin.GetClustersRequest
         * @static
         * @param {vtadmin.IGetClustersRequest=} [properties] Properties to set
         * @returns {vtadmin.GetClustersRequest} GetClustersRequest instance
         */
        GetClustersRequest.create = function create(properties) {
            return new GetClustersRequest(properties);
        };

        /**
         * Encodes the specified GetClustersRequest message. Does not implicitly {@link vtadmin.GetClustersRequest.verify|verify} messages.
         * @function encode
         * @memberof vtadmin.GetClustersRequest
         * @static
         * @param {vtadmin.IGetClustersRequest} message GetClustersRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetClustersRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified GetClustersRequest message, length delimited. Does not implicitly {@link vtadmin.GetClustersRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtadmin.GetClustersRequest
         * @static
         * @param {vtadmin.IGetClustersRequest} message GetClustersRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetClustersRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetClustersRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtadmin.GetClustersRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtadmin.GetClustersRequest} GetClustersRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetClustersRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtadmin.GetClustersRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetClustersRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtadmin.GetClustersRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtadmin.GetClustersRequest} GetClustersRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetClustersRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetClustersRequest message.
         * @function verify
         * @memberof vtadmin.GetClustersRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetClustersRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a GetClustersRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtadmin.GetClustersRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtadmin.GetClustersRequest} GetClustersRequest
         */
        GetClustersRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtadmin.GetClustersRequest)
                return object;
            return new $root.vtadmin.GetClustersRequest();
        };

        /**
         * Creates a plain object from a GetClustersRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtadmin.GetClustersRequest
         * @static
         * @param {vtadmin.GetClustersRequest} message GetClustersRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetClustersRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this GetClustersRequest to JSON.
         * @function toJSON
         * @memberof vtadmin.GetClustersRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetClustersRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetClustersRequest;
    })();

    vtadmin.GetClustersResponse = (function() {

        /**
         * Properties of a GetClustersResponse.
         * @memberof vtadmin
         * @interface IGetClustersResponse
         * @property {Array.<vtadmin.ICluster>|null} [clusters] GetClustersResponse clusters
         */

        /**
         * Constructs a new GetClustersResponse.
         * @memberof vtadmin
         * @classdesc Represents a GetClustersResponse.
         * @implements IGetClustersResponse
         * @constructor
         * @param {vtadmin.IGetClustersResponse=} [properties] Properties to set
         */
        function GetClustersResponse(properties) {
            this.clusters = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetClustersResponse clusters.
         * @member {Array.<vtadmin.ICluster>} clusters
         * @memberof vtadmin.GetClustersResponse
         * @instance
         */
        GetClustersResponse.prototype.clusters = $util.emptyArray;

        /**
         * Creates a new GetClustersResponse instance using the specified properties.
         * @function create
         * @memberof vtadmin.GetClustersResponse
         * @static
         * @param {vtadmin.IGetClustersResponse=} [properties] Properties to set
         * @returns {vtadmin.GetClustersResponse} GetClustersResponse instance
         */
        GetClustersResponse.create = function create(properties) {
            return new GetClustersResponse(properties);
        };

        /**
         * Encodes the specified GetClustersResponse message. Does not implicitly {@link vtadmin.GetClustersResponse.verify|verify} messages.
         * @function encode
         * @memberof vtadmin.GetClustersResponse
         * @static
         * @param {vtadmin.IGetClustersResponse} message GetClustersResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetClustersResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.clusters != null && message.clusters.length)
                for (var i = 0; i < message.clusters.length; ++i)
                    $root.vtadmin.Cluster.encode(message.clusters[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetClustersResponse message, length delimited. Does not implicitly {@link vtadmin.GetClustersResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtadmin.GetClustersResponse
         * @static
         * @param {vtadmin.IGetClustersResponse} message GetClustersResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetClustersResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetClustersResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vtadmin.GetClustersResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtadmin.GetClustersResponse} GetClustersResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetClustersResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtadmin.GetClustersResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.clusters && message.clusters.length))
                        message.clusters = [];
                    message.clusters.push($root.vtadmin.Cluster.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetClustersResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtadmin.GetClustersResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtadmin.GetClustersResponse} GetClustersResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetClustersResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetClustersResponse message.
         * @function verify
         * @memberof vtadmin.GetClustersResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetClustersResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.clusters != null && message.hasOwnProperty("clusters")) {
                if (!Array.isArray(message.clusters))
                    return "clusters: array expected";
                for (var i = 0; i < message.clusters.length; ++i) {
                    var error = $root.vtadmin.Cluster.verify(message.clusters[i]);
                    if (error)
                        return "clusters." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetClustersResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtadmin.GetClustersResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtadmin.GetClustersResponse} GetClustersResponse
         */
        GetClustersResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vtadmin.GetClustersResponse)
                return object;
            var message = new $root.vtadmin.GetClustersResponse();
            if (object.clusters) {
                if (!Array.isArray(object.clusters))
                    throw TypeError(".vtadmin.GetClustersResponse.clusters: array expected");
                message.clusters = [];
                for (var i = 0; i < object.clusters.length; ++i) {
                    if (typeof object.clusters[i] !== "object")
                        throw TypeError(".vtadmin.GetClustersResponse.clusters: object expected");
                    message.clusters[i] = $root.vtadmin.Cluster.fromObject(object.clusters[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetClustersResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtadmin.GetClustersResponse
         * @static
         * @param {vtadmin.GetClustersResponse} message GetClustersResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetClustersResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.clusters = [];
            if (message.clusters && message.clusters.length) {
                object.clusters = [];
                for (var j = 0; j < message.clusters.length; ++j)
                    object.clusters[j] = $root.vtadmin.Cluster.toObject(message.clusters[j], options);
            }
            return object;
        };

        /**
         * Converts this GetClustersResponse to JSON.
         * @function toJSON
         * @memberof vtadmin.GetClustersResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetClustersResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetClustersResponse;
    })();

    vtadmin.GetGatesRequest = (function() {

        /**
         * Properties of a GetGatesRequest.
         * @memberof vtadmin
         * @interface IGetGatesRequest
         * @property {Array.<string>|null} [cluster_ids] GetGatesRequest cluster_ids
         */

        /**
         * Constructs a new GetGatesRequest.
         * @memberof vtadmin
         * @classdesc Represents a GetGatesRequest.
         * @implements IGetGatesRequest
         * @constructor
         * @param {vtadmin.IGetGatesRequest=} [properties] Properties to set
         */
        function GetGatesRequest(properties) {
            this.cluster_ids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetGatesRequest cluster_ids.
         * @member {Array.<string>} cluster_ids
         * @memberof vtadmin.GetGatesRequest
         * @instance
         */
        GetGatesRequest.prototype.cluster_ids = $util.emptyArray;

        /**
         * Creates a new GetGatesRequest instance using the specified properties.
         * @function create
         * @memberof vtadmin.GetGatesRequest
         * @static
         * @param {vtadmin.IGetGatesRequest=} [properties] Properties to set
         * @returns {vtadmin.GetGatesRequest} GetGatesRequest instance
         */
        GetGatesRequest.create = function create(properties) {
            return new GetGatesRequest(properties);
        };

        /**
         * Encodes the specified GetGatesRequest message. Does not implicitly {@link vtadmin.GetGatesRequest.verify|verify} messages.
         * @function encode
         * @memberof vtadmin.GetGatesRequest
         * @static
         * @param {vtadmin.IGetGatesRequest} message GetGatesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetGatesRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cluster_ids != null && message.cluster_ids.length)
                for (var i = 0; i < message.cluster_ids.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.cluster_ids[i]);
            return writer;
        };

        /**
         * Encodes the specified GetGatesRequest message, length delimited. Does not implicitly {@link vtadmin.GetGatesRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtadmin.GetGatesRequest
         * @static
         * @param {vtadmin.IGetGatesRequest} message GetGatesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetGatesRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetGatesRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtadmin.GetGatesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtadmin.GetGatesRequest} GetGatesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetGatesRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtadmin.GetGatesRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.cluster_ids && message.cluster_ids.length))
                        message.cluster_ids = [];
                    message.cluster_ids.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetGatesRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtadmin.GetGatesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtadmin.GetGatesRequest} GetGatesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetGatesRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetGatesRequest message.
         * @function verify
         * @memberof vtadmin.GetGatesRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetGatesRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cluster_ids != null && message.hasOwnProperty("cluster_ids")) {
                if (!Array.isArray(message.cluster_ids))
                    return "cluster_ids: array expected";
                for (var i = 0; i < message.cluster_ids.length; ++i)
                    if (!$util.isString(message.cluster_ids[i]))
                        return "cluster_ids: string[] expected";
            }
            return null;
        };

        /**
         * Creates a GetGatesRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtadmin.GetGatesRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtadmin.GetGatesRequest} GetGatesRequest
         */
        GetGatesRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtadmin.GetGatesRequest)
                return object;
            var message = new $root.vtadmin.GetGatesRequest();
            if (object.cluster_ids) {
                if (!Array.isArray(object.cluster_ids))
                    throw TypeError(".vtadmin.GetGatesRequest.cluster_ids: array expected");
                message.cluster_ids = [];
                for (var i = 0; i < object.cluster_ids.length; ++i)
                    message.cluster_ids[i] = String(object.cluster_ids[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetGatesRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtadmin.GetGatesRequest
         * @static
         * @param {vtadmin.GetGatesRequest} message GetGatesRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetGatesRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.cluster_ids = [];
            if (message.cluster_ids && message.cluster_ids.length) {
                object.cluster_ids = [];
                for (var j = 0; j < message.cluster_ids.length; ++j)
                    object.cluster_ids[j] = message.cluster_ids[j];
            }
            return object;
        };

        /**
         * Converts this GetGatesRequest to JSON.
         * @function toJSON
         * @memberof vtadmin.GetGatesRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetGatesRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetGatesRequest;
    })();

    vtadmin.GetGatesResponse = (function() {

        /**
         * Properties of a GetGatesResponse.
         * @memberof vtadmin
         * @interface IGetGatesResponse
         * @property {Array.<vtadmin.IVTGate>|null} [gates] GetGatesResponse gates
         */

        /**
         * Constructs a new GetGatesResponse.
         * @memberof vtadmin
         * @classdesc Represents a GetGatesResponse.
         * @implements IGetGatesResponse
         * @constructor
         * @param {vtadmin.IGetGatesResponse=} [properties] Properties to set
         */
        function GetGatesResponse(properties) {
            this.gates = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetGatesResponse gates.
         * @member {Array.<vtadmin.IVTGate>} gates
         * @memberof vtadmin.GetGatesResponse
         * @instance
         */
        GetGatesResponse.prototype.gates = $util.emptyArray;

        /**
         * Creates a new GetGatesResponse instance using the specified properties.
         * @function create
         * @memberof vtadmin.GetGatesResponse
         * @static
         * @param {vtadmin.IGetGatesResponse=} [properties] Properties to set
         * @returns {vtadmin.GetGatesResponse} GetGatesResponse instance
         */
        GetGatesResponse.create = function create(properties) {
            return new GetGatesResponse(properties);
        };

        /**
         * Encodes the specified GetGatesResponse message. Does not implicitly {@link vtadmin.GetGatesResponse.verify|verify} messages.
         * @function encode
         * @memberof vtadmin.GetGatesResponse
         * @static
         * @param {vtadmin.IGetGatesResponse} message GetGatesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetGatesResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gates != null && message.gates.length)
                for (var i = 0; i < message.gates.length; ++i)
                    $root.vtadmin.VTGate.encode(message.gates[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetGatesResponse message, length delimited. Does not implicitly {@link vtadmin.GetGatesResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtadmin.GetGatesResponse
         * @static
         * @param {vtadmin.IGetGatesResponse} message GetGatesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetGatesResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetGatesResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vtadmin.GetGatesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtadmin.GetGatesResponse} GetGatesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetGatesResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtadmin.GetGatesResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.gates && message.gates.length))
                        message.gates = [];
                    message.gates.push($root.vtadmin.VTGate.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetGatesResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtadmin.GetGatesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtadmin.GetGatesResponse} GetGatesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetGatesResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetGatesResponse message.
         * @function verify
         * @memberof vtadmin.GetGatesResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetGatesResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gates != null && message.hasOwnProperty("gates")) {
                if (!Array.isArray(message.gates))
                    return "gates: array expected";
                for (var i = 0; i < message.gates.length; ++i) {
                    var error = $root.vtadmin.VTGate.verify(message.gates[i]);
                    if (error)
                        return "gates." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetGatesResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtadmin.GetGatesResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtadmin.GetGatesResponse} GetGatesResponse
         */
        GetGatesResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vtadmin.GetGatesResponse)
                return object;
            var message = new $root.vtadmin.GetGatesResponse();
            if (object.gates) {
                if (!Array.isArray(object.gates))
                    throw TypeError(".vtadmin.GetGatesResponse.gates: array expected");
                message.gates = [];
                for (var i = 0; i < object.gates.length; ++i) {
                    if (typeof object.gates[i] !== "object")
                        throw TypeError(".vtadmin.GetGatesResponse.gates: object expected");
                    message.gates[i] = $root.vtadmin.VTGate.fromObject(object.gates[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetGatesResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtadmin.GetGatesResponse
         * @static
         * @param {vtadmin.GetGatesResponse} message GetGatesResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetGatesResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.gates = [];
            if (message.gates && message.gates.length) {
                object.gates = [];
                for (var j = 0; j < message.gates.length; ++j)
                    object.gates[j] = $root.vtadmin.VTGate.toObject(message.gates[j], options);
            }
            return object;
        };

        /**
         * Converts this GetGatesResponse to JSON.
         * @function toJSON
         * @memberof vtadmin.GetGatesResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetGatesResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetGatesResponse;
    })();

    vtadmin.GetKeyspacesRequest = (function() {

        /**
         * Properties of a GetKeyspacesRequest.
         * @memberof vtadmin
         * @interface IGetKeyspacesRequest
         * @property {Array.<string>|null} [cluster_ids] GetKeyspacesRequest cluster_ids
         */

        /**
         * Constructs a new GetKeyspacesRequest.
         * @memberof vtadmin
         * @classdesc Represents a GetKeyspacesRequest.
         * @implements IGetKeyspacesRequest
         * @constructor
         * @param {vtadmin.IGetKeyspacesRequest=} [properties] Properties to set
         */
        function GetKeyspacesRequest(properties) {
            this.cluster_ids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetKeyspacesRequest cluster_ids.
         * @member {Array.<string>} cluster_ids
         * @memberof vtadmin.GetKeyspacesRequest
         * @instance
         */
        GetKeyspacesRequest.prototype.cluster_ids = $util.emptyArray;

        /**
         * Creates a new GetKeyspacesRequest instance using the specified properties.
         * @function create
         * @memberof vtadmin.GetKeyspacesRequest
         * @static
         * @param {vtadmin.IGetKeyspacesRequest=} [properties] Properties to set
         * @returns {vtadmin.GetKeyspacesRequest} GetKeyspacesRequest instance
         */
        GetKeyspacesRequest.create = function create(properties) {
            return new GetKeyspacesRequest(properties);
        };

        /**
         * Encodes the specified GetKeyspacesRequest message. Does not implicitly {@link vtadmin.GetKeyspacesRequest.verify|verify} messages.
         * @function encode
         * @memberof vtadmin.GetKeyspacesRequest
         * @static
         * @param {vtadmin.IGetKeyspacesRequest} message GetKeyspacesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetKeyspacesRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cluster_ids != null && message.cluster_ids.length)
                for (var i = 0; i < message.cluster_ids.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.cluster_ids[i]);
            return writer;
        };

        /**
         * Encodes the specified GetKeyspacesRequest message, length delimited. Does not implicitly {@link vtadmin.GetKeyspacesRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtadmin.GetKeyspacesRequest
         * @static
         * @param {vtadmin.IGetKeyspacesRequest} message GetKeyspacesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetKeyspacesRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetKeyspacesRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtadmin.GetKeyspacesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtadmin.GetKeyspacesRequest} GetKeyspacesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetKeyspacesRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtadmin.GetKeyspacesRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.cluster_ids && message.cluster_ids.length))
                        message.cluster_ids = [];
                    message.cluster_ids.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetKeyspacesRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtadmin.GetKeyspacesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtadmin.GetKeyspacesRequest} GetKeyspacesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetKeyspacesRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetKeyspacesRequest message.
         * @function verify
         * @memberof vtadmin.GetKeyspacesRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetKeyspacesRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cluster_ids != null && message.hasOwnProperty("cluster_ids")) {
                if (!Array.isArray(message.cluster_ids))
                    return "cluster_ids: array expected";
                for (var i = 0; i < message.cluster_ids.length; ++i)
                    if (!$util.isString(message.cluster_ids[i]))
                        return "cluster_ids: string[] expected";
            }
            return null;
        };

        /**
         * Creates a GetKeyspacesRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtadmin.GetKeyspacesRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtadmin.GetKeyspacesRequest} GetKeyspacesRequest
         */
        GetKeyspacesRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtadmin.GetKeyspacesRequest)
                return object;
            var message = new $root.vtadmin.GetKeyspacesRequest();
            if (object.cluster_ids) {
                if (!Array.isArray(object.cluster_ids))
                    throw TypeError(".vtadmin.GetKeyspacesRequest.cluster_ids: array expected");
                message.cluster_ids = [];
                for (var i = 0; i < object.cluster_ids.length; ++i)
                    message.cluster_ids[i] = String(object.cluster_ids[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetKeyspacesRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtadmin.GetKeyspacesRequest
         * @static
         * @param {vtadmin.GetKeyspacesRequest} message GetKeyspacesRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetKeyspacesRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.cluster_ids = [];
            if (message.cluster_ids && message.cluster_ids.length) {
                object.cluster_ids = [];
                for (var j = 0; j < message.cluster_ids.length; ++j)
                    object.cluster_ids[j] = message.cluster_ids[j];
            }
            return object;
        };

        /**
         * Converts this GetKeyspacesRequest to JSON.
         * @function toJSON
         * @memberof vtadmin.GetKeyspacesRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetKeyspacesRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetKeyspacesRequest;
    })();

    vtadmin.GetKeyspacesResponse = (function() {

        /**
         * Properties of a GetKeyspacesResponse.
         * @memberof vtadmin
         * @interface IGetKeyspacesResponse
         * @property {Array.<vtadmin.IKeyspace>|null} [keyspaces] GetKeyspacesResponse keyspaces
         */

        /**
         * Constructs a new GetKeyspacesResponse.
         * @memberof vtadmin
         * @classdesc Represents a GetKeyspacesResponse.
         * @implements IGetKeyspacesResponse
         * @constructor
         * @param {vtadmin.IGetKeyspacesResponse=} [properties] Properties to set
         */
        function GetKeyspacesResponse(properties) {
            this.keyspaces = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetKeyspacesResponse keyspaces.
         * @member {Array.<vtadmin.IKeyspace>} keyspaces
         * @memberof vtadmin.GetKeyspacesResponse
         * @instance
         */
        GetKeyspacesResponse.prototype.keyspaces = $util.emptyArray;

        /**
         * Creates a new GetKeyspacesResponse instance using the specified properties.
         * @function create
         * @memberof vtadmin.GetKeyspacesResponse
         * @static
         * @param {vtadmin.IGetKeyspacesResponse=} [properties] Properties to set
         * @returns {vtadmin.GetKeyspacesResponse} GetKeyspacesResponse instance
         */
        GetKeyspacesResponse.create = function create(properties) {
            return new GetKeyspacesResponse(properties);
        };

        /**
         * Encodes the specified GetKeyspacesResponse message. Does not implicitly {@link vtadmin.GetKeyspacesResponse.verify|verify} messages.
         * @function encode
         * @memberof vtadmin.GetKeyspacesResponse
         * @static
         * @param {vtadmin.IGetKeyspacesResponse} message GetKeyspacesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetKeyspacesResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keyspaces != null && message.keyspaces.length)
                for (var i = 0; i < message.keyspaces.length; ++i)
                    $root.vtadmin.Keyspace.encode(message.keyspaces[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetKeyspacesResponse message, length delimited. Does not implicitly {@link vtadmin.GetKeyspacesResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtadmin.GetKeyspacesResponse
         * @static
         * @param {vtadmin.IGetKeyspacesResponse} message GetKeyspacesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetKeyspacesResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetKeyspacesResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vtadmin.GetKeyspacesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtadmin.GetKeyspacesResponse} GetKeyspacesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetKeyspacesResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtadmin.GetKeyspacesResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.keyspaces && message.keyspaces.length))
                        message.keyspaces = [];
                    message.keyspaces.push($root.vtadmin.Keyspace.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetKeyspacesResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtadmin.GetKeyspacesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtadmin.GetKeyspacesResponse} GetKeyspacesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetKeyspacesResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetKeyspacesResponse message.
         * @function verify
         * @memberof vtadmin.GetKeyspacesResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetKeyspacesResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keyspaces != null && message.hasOwnProperty("keyspaces")) {
                if (!Array.isArray(message.keyspaces))
                    return "keyspaces: array expected";
                for (var i = 0; i < message.keyspaces.length; ++i) {
                    var error = $root.vtadmin.Keyspace.verify(message.keyspaces[i]);
                    if (error)
                        return "keyspaces." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetKeyspacesResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtadmin.GetKeyspacesResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtadmin.GetKeyspacesResponse} GetKeyspacesResponse
         */
        GetKeyspacesResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vtadmin.GetKeyspacesResponse)
                return object;
            var message = new $root.vtadmin.GetKeyspacesResponse();
            if (object.keyspaces) {
                if (!Array.isArray(object.keyspaces))
                    throw TypeError(".vtadmin.GetKeyspacesResponse.keyspaces: array expected");
                message.keyspaces = [];
                for (var i = 0; i < object.keyspaces.length; ++i) {
                    if (typeof object.keyspaces[i] !== "object")
                        throw TypeError(".vtadmin.GetKeyspacesResponse.keyspaces: object expected");
                    message.keyspaces[i] = $root.vtadmin.Keyspace.fromObject(object.keyspaces[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetKeyspacesResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtadmin.GetKeyspacesResponse
         * @static
         * @param {vtadmin.GetKeyspacesResponse} message GetKeyspacesResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetKeyspacesResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.keyspaces = [];
            if (message.keyspaces && message.keyspaces.length) {
                object.keyspaces = [];
                for (var j = 0; j < message.keyspaces.length; ++j)
                    object.keyspaces[j] = $root.vtadmin.Keyspace.toObject(message.keyspaces[j], options);
            }
            return object;
        };

        /**
         * Converts this GetKeyspacesResponse to JSON.
         * @function toJSON
         * @memberof vtadmin.GetKeyspacesResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetKeyspacesResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetKeyspacesResponse;
    })();

    vtadmin.GetSchemaRequest = (function() {

        /**
         * Properties of a GetSchemaRequest.
         * @memberof vtadmin
         * @interface IGetSchemaRequest
         * @property {string|null} [cluster_id] GetSchemaRequest cluster_id
         * @property {string|null} [keyspace] GetSchemaRequest keyspace
         * @property {string|null} [table] GetSchemaRequest table
         * @property {vtadmin.IGetSchemaTableSizeOptions|null} [table_size_options] GetSchemaRequest table_size_options
         */

        /**
         * Constructs a new GetSchemaRequest.
         * @memberof vtadmin
         * @classdesc Represents a GetSchemaRequest.
         * @implements IGetSchemaRequest
         * @constructor
         * @param {vtadmin.IGetSchemaRequest=} [properties] Properties to set
         */
        function GetSchemaRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetSchemaRequest cluster_id.
         * @member {string} cluster_id
         * @memberof vtadmin.GetSchemaRequest
         * @instance
         */
        GetSchemaRequest.prototype.cluster_id = "";

        /**
         * GetSchemaRequest keyspace.
         * @member {string} keyspace
         * @memberof vtadmin.GetSchemaRequest
         * @instance
         */
        GetSchemaRequest.prototype.keyspace = "";

        /**
         * GetSchemaRequest table.
         * @member {string} table
         * @memberof vtadmin.GetSchemaRequest
         * @instance
         */
        GetSchemaRequest.prototype.table = "";

        /**
         * GetSchemaRequest table_size_options.
         * @member {vtadmin.IGetSchemaTableSizeOptions|null|undefined} table_size_options
         * @memberof vtadmin.GetSchemaRequest
         * @instance
         */
        GetSchemaRequest.prototype.table_size_options = null;

        /**
         * Creates a new GetSchemaRequest instance using the specified properties.
         * @function create
         * @memberof vtadmin.GetSchemaRequest
         * @static
         * @param {vtadmin.IGetSchemaRequest=} [properties] Properties to set
         * @returns {vtadmin.GetSchemaRequest} GetSchemaRequest instance
         */
        GetSchemaRequest.create = function create(properties) {
            return new GetSchemaRequest(properties);
        };

        /**
         * Encodes the specified GetSchemaRequest message. Does not implicitly {@link vtadmin.GetSchemaRequest.verify|verify} messages.
         * @function encode
         * @memberof vtadmin.GetSchemaRequest
         * @static
         * @param {vtadmin.IGetSchemaRequest} message GetSchemaRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSchemaRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cluster_id != null && Object.hasOwnProperty.call(message, "cluster_id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.cluster_id);
            if (message.keyspace != null && Object.hasOwnProperty.call(message, "keyspace"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.keyspace);
            if (message.table != null && Object.hasOwnProperty.call(message, "table"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.table);
            if (message.table_size_options != null && Object.hasOwnProperty.call(message, "table_size_options"))
                $root.vtadmin.GetSchemaTableSizeOptions.encode(message.table_size_options, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetSchemaRequest message, length delimited. Does not implicitly {@link vtadmin.GetSchemaRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtadmin.GetSchemaRequest
         * @static
         * @param {vtadmin.IGetSchemaRequest} message GetSchemaRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSchemaRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetSchemaRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtadmin.GetSchemaRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtadmin.GetSchemaRequest} GetSchemaRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSchemaRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtadmin.GetSchemaRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.cluster_id = reader.string();
                    break;
                case 2:
                    message.keyspace = reader.string();
                    break;
                case 3:
                    message.table = reader.string();
                    break;
                case 4:
                    message.table_size_options = $root.vtadmin.GetSchemaTableSizeOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetSchemaRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtadmin.GetSchemaRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtadmin.GetSchemaRequest} GetSchemaRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSchemaRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetSchemaRequest message.
         * @function verify
         * @memberof vtadmin.GetSchemaRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetSchemaRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cluster_id != null && message.hasOwnProperty("cluster_id"))
                if (!$util.isString(message.cluster_id))
                    return "cluster_id: string expected";
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                if (!$util.isString(message.keyspace))
                    return "keyspace: string expected";
            if (message.table != null && message.hasOwnProperty("table"))
                if (!$util.isString(message.table))
                    return "table: string expected";
            if (message.table_size_options != null && message.hasOwnProperty("table_size_options")) {
                var error = $root.vtadmin.GetSchemaTableSizeOptions.verify(message.table_size_options);
                if (error)
                    return "table_size_options." + error;
            }
            return null;
        };

        /**
         * Creates a GetSchemaRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtadmin.GetSchemaRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtadmin.GetSchemaRequest} GetSchemaRequest
         */
        GetSchemaRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtadmin.GetSchemaRequest)
                return object;
            var message = new $root.vtadmin.GetSchemaRequest();
            if (object.cluster_id != null)
                message.cluster_id = String(object.cluster_id);
            if (object.keyspace != null)
                message.keyspace = String(object.keyspace);
            if (object.table != null)
                message.table = String(object.table);
            if (object.table_size_options != null) {
                if (typeof object.table_size_options !== "object")
                    throw TypeError(".vtadmin.GetSchemaRequest.table_size_options: object expected");
                message.table_size_options = $root.vtadmin.GetSchemaTableSizeOptions.fromObject(object.table_size_options);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetSchemaRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtadmin.GetSchemaRequest
         * @static
         * @param {vtadmin.GetSchemaRequest} message GetSchemaRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetSchemaRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.cluster_id = "";
                object.keyspace = "";
                object.table = "";
                object.table_size_options = null;
            }
            if (message.cluster_id != null && message.hasOwnProperty("cluster_id"))
                object.cluster_id = message.cluster_id;
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                object.keyspace = message.keyspace;
            if (message.table != null && message.hasOwnProperty("table"))
                object.table = message.table;
            if (message.table_size_options != null && message.hasOwnProperty("table_size_options"))
                object.table_size_options = $root.vtadmin.GetSchemaTableSizeOptions.toObject(message.table_size_options, options);
            return object;
        };

        /**
         * Converts this GetSchemaRequest to JSON.
         * @function toJSON
         * @memberof vtadmin.GetSchemaRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetSchemaRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetSchemaRequest;
    })();

    vtadmin.GetSchemasRequest = (function() {

        /**
         * Properties of a GetSchemasRequest.
         * @memberof vtadmin
         * @interface IGetSchemasRequest
         * @property {Array.<string>|null} [cluster_ids] GetSchemasRequest cluster_ids
         * @property {vtadmin.IGetSchemaTableSizeOptions|null} [table_size_options] GetSchemasRequest table_size_options
         */

        /**
         * Constructs a new GetSchemasRequest.
         * @memberof vtadmin
         * @classdesc Represents a GetSchemasRequest.
         * @implements IGetSchemasRequest
         * @constructor
         * @param {vtadmin.IGetSchemasRequest=} [properties] Properties to set
         */
        function GetSchemasRequest(properties) {
            this.cluster_ids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetSchemasRequest cluster_ids.
         * @member {Array.<string>} cluster_ids
         * @memberof vtadmin.GetSchemasRequest
         * @instance
         */
        GetSchemasRequest.prototype.cluster_ids = $util.emptyArray;

        /**
         * GetSchemasRequest table_size_options.
         * @member {vtadmin.IGetSchemaTableSizeOptions|null|undefined} table_size_options
         * @memberof vtadmin.GetSchemasRequest
         * @instance
         */
        GetSchemasRequest.prototype.table_size_options = null;

        /**
         * Creates a new GetSchemasRequest instance using the specified properties.
         * @function create
         * @memberof vtadmin.GetSchemasRequest
         * @static
         * @param {vtadmin.IGetSchemasRequest=} [properties] Properties to set
         * @returns {vtadmin.GetSchemasRequest} GetSchemasRequest instance
         */
        GetSchemasRequest.create = function create(properties) {
            return new GetSchemasRequest(properties);
        };

        /**
         * Encodes the specified GetSchemasRequest message. Does not implicitly {@link vtadmin.GetSchemasRequest.verify|verify} messages.
         * @function encode
         * @memberof vtadmin.GetSchemasRequest
         * @static
         * @param {vtadmin.IGetSchemasRequest} message GetSchemasRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSchemasRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cluster_ids != null && message.cluster_ids.length)
                for (var i = 0; i < message.cluster_ids.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.cluster_ids[i]);
            if (message.table_size_options != null && Object.hasOwnProperty.call(message, "table_size_options"))
                $root.vtadmin.GetSchemaTableSizeOptions.encode(message.table_size_options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetSchemasRequest message, length delimited. Does not implicitly {@link vtadmin.GetSchemasRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtadmin.GetSchemasRequest
         * @static
         * @param {vtadmin.IGetSchemasRequest} message GetSchemasRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSchemasRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetSchemasRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtadmin.GetSchemasRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtadmin.GetSchemasRequest} GetSchemasRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSchemasRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtadmin.GetSchemasRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.cluster_ids && message.cluster_ids.length))
                        message.cluster_ids = [];
                    message.cluster_ids.push(reader.string());
                    break;
                case 2:
                    message.table_size_options = $root.vtadmin.GetSchemaTableSizeOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetSchemasRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtadmin.GetSchemasRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtadmin.GetSchemasRequest} GetSchemasRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSchemasRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetSchemasRequest message.
         * @function verify
         * @memberof vtadmin.GetSchemasRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetSchemasRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cluster_ids != null && message.hasOwnProperty("cluster_ids")) {
                if (!Array.isArray(message.cluster_ids))
                    return "cluster_ids: array expected";
                for (var i = 0; i < message.cluster_ids.length; ++i)
                    if (!$util.isString(message.cluster_ids[i]))
                        return "cluster_ids: string[] expected";
            }
            if (message.table_size_options != null && message.hasOwnProperty("table_size_options")) {
                var error = $root.vtadmin.GetSchemaTableSizeOptions.verify(message.table_size_options);
                if (error)
                    return "table_size_options." + error;
            }
            return null;
        };

        /**
         * Creates a GetSchemasRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtadmin.GetSchemasRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtadmin.GetSchemasRequest} GetSchemasRequest
         */
        GetSchemasRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtadmin.GetSchemasRequest)
                return object;
            var message = new $root.vtadmin.GetSchemasRequest();
            if (object.cluster_ids) {
                if (!Array.isArray(object.cluster_ids))
                    throw TypeError(".vtadmin.GetSchemasRequest.cluster_ids: array expected");
                message.cluster_ids = [];
                for (var i = 0; i < object.cluster_ids.length; ++i)
                    message.cluster_ids[i] = String(object.cluster_ids[i]);
            }
            if (object.table_size_options != null) {
                if (typeof object.table_size_options !== "object")
                    throw TypeError(".vtadmin.GetSchemasRequest.table_size_options: object expected");
                message.table_size_options = $root.vtadmin.GetSchemaTableSizeOptions.fromObject(object.table_size_options);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetSchemasRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtadmin.GetSchemasRequest
         * @static
         * @param {vtadmin.GetSchemasRequest} message GetSchemasRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetSchemasRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.cluster_ids = [];
            if (options.defaults)
                object.table_size_options = null;
            if (message.cluster_ids && message.cluster_ids.length) {
                object.cluster_ids = [];
                for (var j = 0; j < message.cluster_ids.length; ++j)
                    object.cluster_ids[j] = message.cluster_ids[j];
            }
            if (message.table_size_options != null && message.hasOwnProperty("table_size_options"))
                object.table_size_options = $root.vtadmin.GetSchemaTableSizeOptions.toObject(message.table_size_options, options);
            return object;
        };

        /**
         * Converts this GetSchemasRequest to JSON.
         * @function toJSON
         * @memberof vtadmin.GetSchemasRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetSchemasRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetSchemasRequest;
    })();

    vtadmin.GetSchemasResponse = (function() {

        /**
         * Properties of a GetSchemasResponse.
         * @memberof vtadmin
         * @interface IGetSchemasResponse
         * @property {Array.<vtadmin.ISchema>|null} [schemas] GetSchemasResponse schemas
         */

        /**
         * Constructs a new GetSchemasResponse.
         * @memberof vtadmin
         * @classdesc Represents a GetSchemasResponse.
         * @implements IGetSchemasResponse
         * @constructor
         * @param {vtadmin.IGetSchemasResponse=} [properties] Properties to set
         */
        function GetSchemasResponse(properties) {
            this.schemas = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetSchemasResponse schemas.
         * @member {Array.<vtadmin.ISchema>} schemas
         * @memberof vtadmin.GetSchemasResponse
         * @instance
         */
        GetSchemasResponse.prototype.schemas = $util.emptyArray;

        /**
         * Creates a new GetSchemasResponse instance using the specified properties.
         * @function create
         * @memberof vtadmin.GetSchemasResponse
         * @static
         * @param {vtadmin.IGetSchemasResponse=} [properties] Properties to set
         * @returns {vtadmin.GetSchemasResponse} GetSchemasResponse instance
         */
        GetSchemasResponse.create = function create(properties) {
            return new GetSchemasResponse(properties);
        };

        /**
         * Encodes the specified GetSchemasResponse message. Does not implicitly {@link vtadmin.GetSchemasResponse.verify|verify} messages.
         * @function encode
         * @memberof vtadmin.GetSchemasResponse
         * @static
         * @param {vtadmin.IGetSchemasResponse} message GetSchemasResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSchemasResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.schemas != null && message.schemas.length)
                for (var i = 0; i < message.schemas.length; ++i)
                    $root.vtadmin.Schema.encode(message.schemas[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetSchemasResponse message, length delimited. Does not implicitly {@link vtadmin.GetSchemasResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtadmin.GetSchemasResponse
         * @static
         * @param {vtadmin.IGetSchemasResponse} message GetSchemasResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSchemasResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetSchemasResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vtadmin.GetSchemasResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtadmin.GetSchemasResponse} GetSchemasResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSchemasResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtadmin.GetSchemasResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.schemas && message.schemas.length))
                        message.schemas = [];
                    message.schemas.push($root.vtadmin.Schema.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetSchemasResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtadmin.GetSchemasResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtadmin.GetSchemasResponse} GetSchemasResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSchemasResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetSchemasResponse message.
         * @function verify
         * @memberof vtadmin.GetSchemasResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetSchemasResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.schemas != null && message.hasOwnProperty("schemas")) {
                if (!Array.isArray(message.schemas))
                    return "schemas: array expected";
                for (var i = 0; i < message.schemas.length; ++i) {
                    var error = $root.vtadmin.Schema.verify(message.schemas[i]);
                    if (error)
                        return "schemas." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetSchemasResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtadmin.GetSchemasResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtadmin.GetSchemasResponse} GetSchemasResponse
         */
        GetSchemasResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vtadmin.GetSchemasResponse)
                return object;
            var message = new $root.vtadmin.GetSchemasResponse();
            if (object.schemas) {
                if (!Array.isArray(object.schemas))
                    throw TypeError(".vtadmin.GetSchemasResponse.schemas: array expected");
                message.schemas = [];
                for (var i = 0; i < object.schemas.length; ++i) {
                    if (typeof object.schemas[i] !== "object")
                        throw TypeError(".vtadmin.GetSchemasResponse.schemas: object expected");
                    message.schemas[i] = $root.vtadmin.Schema.fromObject(object.schemas[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetSchemasResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtadmin.GetSchemasResponse
         * @static
         * @param {vtadmin.GetSchemasResponse} message GetSchemasResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetSchemasResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.schemas = [];
            if (message.schemas && message.schemas.length) {
                object.schemas = [];
                for (var j = 0; j < message.schemas.length; ++j)
                    object.schemas[j] = $root.vtadmin.Schema.toObject(message.schemas[j], options);
            }
            return object;
        };

        /**
         * Converts this GetSchemasResponse to JSON.
         * @function toJSON
         * @memberof vtadmin.GetSchemasResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetSchemasResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetSchemasResponse;
    })();

    vtadmin.GetSchemaTableSizeOptions = (function() {

        /**
         * Properties of a GetSchemaTableSizeOptions.
         * @memberof vtadmin
         * @interface IGetSchemaTableSizeOptions
         * @property {boolean|null} [aggregate_sizes] GetSchemaTableSizeOptions aggregate_sizes
         */

        /**
         * Constructs a new GetSchemaTableSizeOptions.
         * @memberof vtadmin
         * @classdesc Represents a GetSchemaTableSizeOptions.
         * @implements IGetSchemaTableSizeOptions
         * @constructor
         * @param {vtadmin.IGetSchemaTableSizeOptions=} [properties] Properties to set
         */
        function GetSchemaTableSizeOptions(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetSchemaTableSizeOptions aggregate_sizes.
         * @member {boolean} aggregate_sizes
         * @memberof vtadmin.GetSchemaTableSizeOptions
         * @instance
         */
        GetSchemaTableSizeOptions.prototype.aggregate_sizes = false;

        /**
         * Creates a new GetSchemaTableSizeOptions instance using the specified properties.
         * @function create
         * @memberof vtadmin.GetSchemaTableSizeOptions
         * @static
         * @param {vtadmin.IGetSchemaTableSizeOptions=} [properties] Properties to set
         * @returns {vtadmin.GetSchemaTableSizeOptions} GetSchemaTableSizeOptions instance
         */
        GetSchemaTableSizeOptions.create = function create(properties) {
            return new GetSchemaTableSizeOptions(properties);
        };

        /**
         * Encodes the specified GetSchemaTableSizeOptions message. Does not implicitly {@link vtadmin.GetSchemaTableSizeOptions.verify|verify} messages.
         * @function encode
         * @memberof vtadmin.GetSchemaTableSizeOptions
         * @static
         * @param {vtadmin.IGetSchemaTableSizeOptions} message GetSchemaTableSizeOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSchemaTableSizeOptions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.aggregate_sizes != null && Object.hasOwnProperty.call(message, "aggregate_sizes"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.aggregate_sizes);
            return writer;
        };

        /**
         * Encodes the specified GetSchemaTableSizeOptions message, length delimited. Does not implicitly {@link vtadmin.GetSchemaTableSizeOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtadmin.GetSchemaTableSizeOptions
         * @static
         * @param {vtadmin.IGetSchemaTableSizeOptions} message GetSchemaTableSizeOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSchemaTableSizeOptions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetSchemaTableSizeOptions message from the specified reader or buffer.
         * @function decode
         * @memberof vtadmin.GetSchemaTableSizeOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtadmin.GetSchemaTableSizeOptions} GetSchemaTableSizeOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSchemaTableSizeOptions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtadmin.GetSchemaTableSizeOptions();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.aggregate_sizes = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetSchemaTableSizeOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtadmin.GetSchemaTableSizeOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtadmin.GetSchemaTableSizeOptions} GetSchemaTableSizeOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSchemaTableSizeOptions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetSchemaTableSizeOptions message.
         * @function verify
         * @memberof vtadmin.GetSchemaTableSizeOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetSchemaTableSizeOptions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.aggregate_sizes != null && message.hasOwnProperty("aggregate_sizes"))
                if (typeof message.aggregate_sizes !== "boolean")
                    return "aggregate_sizes: boolean expected";
            return null;
        };

        /**
         * Creates a GetSchemaTableSizeOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtadmin.GetSchemaTableSizeOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtadmin.GetSchemaTableSizeOptions} GetSchemaTableSizeOptions
         */
        GetSchemaTableSizeOptions.fromObject = function fromObject(object) {
            if (object instanceof $root.vtadmin.GetSchemaTableSizeOptions)
                return object;
            var message = new $root.vtadmin.GetSchemaTableSizeOptions();
            if (object.aggregate_sizes != null)
                message.aggregate_sizes = Boolean(object.aggregate_sizes);
            return message;
        };

        /**
         * Creates a plain object from a GetSchemaTableSizeOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtadmin.GetSchemaTableSizeOptions
         * @static
         * @param {vtadmin.GetSchemaTableSizeOptions} message GetSchemaTableSizeOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetSchemaTableSizeOptions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.aggregate_sizes = false;
            if (message.aggregate_sizes != null && message.hasOwnProperty("aggregate_sizes"))
                object.aggregate_sizes = message.aggregate_sizes;
            return object;
        };

        /**
         * Converts this GetSchemaTableSizeOptions to JSON.
         * @function toJSON
         * @memberof vtadmin.GetSchemaTableSizeOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetSchemaTableSizeOptions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetSchemaTableSizeOptions;
    })();

    vtadmin.GetTabletRequest = (function() {

        /**
         * Properties of a GetTabletRequest.
         * @memberof vtadmin
         * @interface IGetTabletRequest
         * @property {string|null} [hostname] GetTabletRequest hostname
         * @property {Array.<string>|null} [cluster_ids] GetTabletRequest cluster_ids
         */

        /**
         * Constructs a new GetTabletRequest.
         * @memberof vtadmin
         * @classdesc Represents a GetTabletRequest.
         * @implements IGetTabletRequest
         * @constructor
         * @param {vtadmin.IGetTabletRequest=} [properties] Properties to set
         */
        function GetTabletRequest(properties) {
            this.cluster_ids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetTabletRequest hostname.
         * @member {string} hostname
         * @memberof vtadmin.GetTabletRequest
         * @instance
         */
        GetTabletRequest.prototype.hostname = "";

        /**
         * GetTabletRequest cluster_ids.
         * @member {Array.<string>} cluster_ids
         * @memberof vtadmin.GetTabletRequest
         * @instance
         */
        GetTabletRequest.prototype.cluster_ids = $util.emptyArray;

        /**
         * Creates a new GetTabletRequest instance using the specified properties.
         * @function create
         * @memberof vtadmin.GetTabletRequest
         * @static
         * @param {vtadmin.IGetTabletRequest=} [properties] Properties to set
         * @returns {vtadmin.GetTabletRequest} GetTabletRequest instance
         */
        GetTabletRequest.create = function create(properties) {
            return new GetTabletRequest(properties);
        };

        /**
         * Encodes the specified GetTabletRequest message. Does not implicitly {@link vtadmin.GetTabletRequest.verify|verify} messages.
         * @function encode
         * @memberof vtadmin.GetTabletRequest
         * @static
         * @param {vtadmin.IGetTabletRequest} message GetTabletRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTabletRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hostname != null && Object.hasOwnProperty.call(message, "hostname"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.hostname);
            if (message.cluster_ids != null && message.cluster_ids.length)
                for (var i = 0; i < message.cluster_ids.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.cluster_ids[i]);
            return writer;
        };

        /**
         * Encodes the specified GetTabletRequest message, length delimited. Does not implicitly {@link vtadmin.GetTabletRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtadmin.GetTabletRequest
         * @static
         * @param {vtadmin.IGetTabletRequest} message GetTabletRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTabletRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetTabletRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtadmin.GetTabletRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtadmin.GetTabletRequest} GetTabletRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTabletRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtadmin.GetTabletRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hostname = reader.string();
                    break;
                case 2:
                    if (!(message.cluster_ids && message.cluster_ids.length))
                        message.cluster_ids = [];
                    message.cluster_ids.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetTabletRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtadmin.GetTabletRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtadmin.GetTabletRequest} GetTabletRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTabletRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetTabletRequest message.
         * @function verify
         * @memberof vtadmin.GetTabletRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetTabletRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hostname != null && message.hasOwnProperty("hostname"))
                if (!$util.isString(message.hostname))
                    return "hostname: string expected";
            if (message.cluster_ids != null && message.hasOwnProperty("cluster_ids")) {
                if (!Array.isArray(message.cluster_ids))
                    return "cluster_ids: array expected";
                for (var i = 0; i < message.cluster_ids.length; ++i)
                    if (!$util.isString(message.cluster_ids[i]))
                        return "cluster_ids: string[] expected";
            }
            return null;
        };

        /**
         * Creates a GetTabletRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtadmin.GetTabletRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtadmin.GetTabletRequest} GetTabletRequest
         */
        GetTabletRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtadmin.GetTabletRequest)
                return object;
            var message = new $root.vtadmin.GetTabletRequest();
            if (object.hostname != null)
                message.hostname = String(object.hostname);
            if (object.cluster_ids) {
                if (!Array.isArray(object.cluster_ids))
                    throw TypeError(".vtadmin.GetTabletRequest.cluster_ids: array expected");
                message.cluster_ids = [];
                for (var i = 0; i < object.cluster_ids.length; ++i)
                    message.cluster_ids[i] = String(object.cluster_ids[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetTabletRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtadmin.GetTabletRequest
         * @static
         * @param {vtadmin.GetTabletRequest} message GetTabletRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetTabletRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.cluster_ids = [];
            if (options.defaults)
                object.hostname = "";
            if (message.hostname != null && message.hasOwnProperty("hostname"))
                object.hostname = message.hostname;
            if (message.cluster_ids && message.cluster_ids.length) {
                object.cluster_ids = [];
                for (var j = 0; j < message.cluster_ids.length; ++j)
                    object.cluster_ids[j] = message.cluster_ids[j];
            }
            return object;
        };

        /**
         * Converts this GetTabletRequest to JSON.
         * @function toJSON
         * @memberof vtadmin.GetTabletRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetTabletRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetTabletRequest;
    })();

    vtadmin.GetTabletsRequest = (function() {

        /**
         * Properties of a GetTabletsRequest.
         * @memberof vtadmin
         * @interface IGetTabletsRequest
         * @property {Array.<string>|null} [cluster_ids] GetTabletsRequest cluster_ids
         */

        /**
         * Constructs a new GetTabletsRequest.
         * @memberof vtadmin
         * @classdesc Represents a GetTabletsRequest.
         * @implements IGetTabletsRequest
         * @constructor
         * @param {vtadmin.IGetTabletsRequest=} [properties] Properties to set
         */
        function GetTabletsRequest(properties) {
            this.cluster_ids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetTabletsRequest cluster_ids.
         * @member {Array.<string>} cluster_ids
         * @memberof vtadmin.GetTabletsRequest
         * @instance
         */
        GetTabletsRequest.prototype.cluster_ids = $util.emptyArray;

        /**
         * Creates a new GetTabletsRequest instance using the specified properties.
         * @function create
         * @memberof vtadmin.GetTabletsRequest
         * @static
         * @param {vtadmin.IGetTabletsRequest=} [properties] Properties to set
         * @returns {vtadmin.GetTabletsRequest} GetTabletsRequest instance
         */
        GetTabletsRequest.create = function create(properties) {
            return new GetTabletsRequest(properties);
        };

        /**
         * Encodes the specified GetTabletsRequest message. Does not implicitly {@link vtadmin.GetTabletsRequest.verify|verify} messages.
         * @function encode
         * @memberof vtadmin.GetTabletsRequest
         * @static
         * @param {vtadmin.IGetTabletsRequest} message GetTabletsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTabletsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cluster_ids != null && message.cluster_ids.length)
                for (var i = 0; i < message.cluster_ids.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.cluster_ids[i]);
            return writer;
        };

        /**
         * Encodes the specified GetTabletsRequest message, length delimited. Does not implicitly {@link vtadmin.GetTabletsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtadmin.GetTabletsRequest
         * @static
         * @param {vtadmin.IGetTabletsRequest} message GetTabletsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTabletsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetTabletsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtadmin.GetTabletsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtadmin.GetTabletsRequest} GetTabletsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTabletsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtadmin.GetTabletsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.cluster_ids && message.cluster_ids.length))
                        message.cluster_ids = [];
                    message.cluster_ids.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetTabletsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtadmin.GetTabletsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtadmin.GetTabletsRequest} GetTabletsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTabletsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetTabletsRequest message.
         * @function verify
         * @memberof vtadmin.GetTabletsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetTabletsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cluster_ids != null && message.hasOwnProperty("cluster_ids")) {
                if (!Array.isArray(message.cluster_ids))
                    return "cluster_ids: array expected";
                for (var i = 0; i < message.cluster_ids.length; ++i)
                    if (!$util.isString(message.cluster_ids[i]))
                        return "cluster_ids: string[] expected";
            }
            return null;
        };

        /**
         * Creates a GetTabletsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtadmin.GetTabletsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtadmin.GetTabletsRequest} GetTabletsRequest
         */
        GetTabletsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtadmin.GetTabletsRequest)
                return object;
            var message = new $root.vtadmin.GetTabletsRequest();
            if (object.cluster_ids) {
                if (!Array.isArray(object.cluster_ids))
                    throw TypeError(".vtadmin.GetTabletsRequest.cluster_ids: array expected");
                message.cluster_ids = [];
                for (var i = 0; i < object.cluster_ids.length; ++i)
                    message.cluster_ids[i] = String(object.cluster_ids[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetTabletsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtadmin.GetTabletsRequest
         * @static
         * @param {vtadmin.GetTabletsRequest} message GetTabletsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetTabletsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.cluster_ids = [];
            if (message.cluster_ids && message.cluster_ids.length) {
                object.cluster_ids = [];
                for (var j = 0; j < message.cluster_ids.length; ++j)
                    object.cluster_ids[j] = message.cluster_ids[j];
            }
            return object;
        };

        /**
         * Converts this GetTabletsRequest to JSON.
         * @function toJSON
         * @memberof vtadmin.GetTabletsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetTabletsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetTabletsRequest;
    })();

    vtadmin.GetTabletsResponse = (function() {

        /**
         * Properties of a GetTabletsResponse.
         * @memberof vtadmin
         * @interface IGetTabletsResponse
         * @property {Array.<vtadmin.ITablet>|null} [tablets] GetTabletsResponse tablets
         */

        /**
         * Constructs a new GetTabletsResponse.
         * @memberof vtadmin
         * @classdesc Represents a GetTabletsResponse.
         * @implements IGetTabletsResponse
         * @constructor
         * @param {vtadmin.IGetTabletsResponse=} [properties] Properties to set
         */
        function GetTabletsResponse(properties) {
            this.tablets = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetTabletsResponse tablets.
         * @member {Array.<vtadmin.ITablet>} tablets
         * @memberof vtadmin.GetTabletsResponse
         * @instance
         */
        GetTabletsResponse.prototype.tablets = $util.emptyArray;

        /**
         * Creates a new GetTabletsResponse instance using the specified properties.
         * @function create
         * @memberof vtadmin.GetTabletsResponse
         * @static
         * @param {vtadmin.IGetTabletsResponse=} [properties] Properties to set
         * @returns {vtadmin.GetTabletsResponse} GetTabletsResponse instance
         */
        GetTabletsResponse.create = function create(properties) {
            return new GetTabletsResponse(properties);
        };

        /**
         * Encodes the specified GetTabletsResponse message. Does not implicitly {@link vtadmin.GetTabletsResponse.verify|verify} messages.
         * @function encode
         * @memberof vtadmin.GetTabletsResponse
         * @static
         * @param {vtadmin.IGetTabletsResponse} message GetTabletsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTabletsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tablets != null && message.tablets.length)
                for (var i = 0; i < message.tablets.length; ++i)
                    $root.vtadmin.Tablet.encode(message.tablets[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetTabletsResponse message, length delimited. Does not implicitly {@link vtadmin.GetTabletsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtadmin.GetTabletsResponse
         * @static
         * @param {vtadmin.IGetTabletsResponse} message GetTabletsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTabletsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetTabletsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vtadmin.GetTabletsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtadmin.GetTabletsResponse} GetTabletsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTabletsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtadmin.GetTabletsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.tablets && message.tablets.length))
                        message.tablets = [];
                    message.tablets.push($root.vtadmin.Tablet.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetTabletsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtadmin.GetTabletsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtadmin.GetTabletsResponse} GetTabletsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTabletsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetTabletsResponse message.
         * @function verify
         * @memberof vtadmin.GetTabletsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetTabletsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tablets != null && message.hasOwnProperty("tablets")) {
                if (!Array.isArray(message.tablets))
                    return "tablets: array expected";
                for (var i = 0; i < message.tablets.length; ++i) {
                    var error = $root.vtadmin.Tablet.verify(message.tablets[i]);
                    if (error)
                        return "tablets." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetTabletsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtadmin.GetTabletsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtadmin.GetTabletsResponse} GetTabletsResponse
         */
        GetTabletsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vtadmin.GetTabletsResponse)
                return object;
            var message = new $root.vtadmin.GetTabletsResponse();
            if (object.tablets) {
                if (!Array.isArray(object.tablets))
                    throw TypeError(".vtadmin.GetTabletsResponse.tablets: array expected");
                message.tablets = [];
                for (var i = 0; i < object.tablets.length; ++i) {
                    if (typeof object.tablets[i] !== "object")
                        throw TypeError(".vtadmin.GetTabletsResponse.tablets: object expected");
                    message.tablets[i] = $root.vtadmin.Tablet.fromObject(object.tablets[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetTabletsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtadmin.GetTabletsResponse
         * @static
         * @param {vtadmin.GetTabletsResponse} message GetTabletsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetTabletsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.tablets = [];
            if (message.tablets && message.tablets.length) {
                object.tablets = [];
                for (var j = 0; j < message.tablets.length; ++j)
                    object.tablets[j] = $root.vtadmin.Tablet.toObject(message.tablets[j], options);
            }
            return object;
        };

        /**
         * Converts this GetTabletsResponse to JSON.
         * @function toJSON
         * @memberof vtadmin.GetTabletsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetTabletsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetTabletsResponse;
    })();

    vtadmin.GetVSchemaRequest = (function() {

        /**
         * Properties of a GetVSchemaRequest.
         * @memberof vtadmin
         * @interface IGetVSchemaRequest
         * @property {string|null} [cluster_id] GetVSchemaRequest cluster_id
         * @property {string|null} [keyspace] GetVSchemaRequest keyspace
         */

        /**
         * Constructs a new GetVSchemaRequest.
         * @memberof vtadmin
         * @classdesc Represents a GetVSchemaRequest.
         * @implements IGetVSchemaRequest
         * @constructor
         * @param {vtadmin.IGetVSchemaRequest=} [properties] Properties to set
         */
        function GetVSchemaRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetVSchemaRequest cluster_id.
         * @member {string} cluster_id
         * @memberof vtadmin.GetVSchemaRequest
         * @instance
         */
        GetVSchemaRequest.prototype.cluster_id = "";

        /**
         * GetVSchemaRequest keyspace.
         * @member {string} keyspace
         * @memberof vtadmin.GetVSchemaRequest
         * @instance
         */
        GetVSchemaRequest.prototype.keyspace = "";

        /**
         * Creates a new GetVSchemaRequest instance using the specified properties.
         * @function create
         * @memberof vtadmin.GetVSchemaRequest
         * @static
         * @param {vtadmin.IGetVSchemaRequest=} [properties] Properties to set
         * @returns {vtadmin.GetVSchemaRequest} GetVSchemaRequest instance
         */
        GetVSchemaRequest.create = function create(properties) {
            return new GetVSchemaRequest(properties);
        };

        /**
         * Encodes the specified GetVSchemaRequest message. Does not implicitly {@link vtadmin.GetVSchemaRequest.verify|verify} messages.
         * @function encode
         * @memberof vtadmin.GetVSchemaRequest
         * @static
         * @param {vtadmin.IGetVSchemaRequest} message GetVSchemaRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetVSchemaRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cluster_id != null && Object.hasOwnProperty.call(message, "cluster_id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.cluster_id);
            if (message.keyspace != null && Object.hasOwnProperty.call(message, "keyspace"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.keyspace);
            return writer;
        };

        /**
         * Encodes the specified GetVSchemaRequest message, length delimited. Does not implicitly {@link vtadmin.GetVSchemaRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtadmin.GetVSchemaRequest
         * @static
         * @param {vtadmin.IGetVSchemaRequest} message GetVSchemaRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetVSchemaRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetVSchemaRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtadmin.GetVSchemaRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtadmin.GetVSchemaRequest} GetVSchemaRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetVSchemaRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtadmin.GetVSchemaRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.cluster_id = reader.string();
                    break;
                case 2:
                    message.keyspace = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetVSchemaRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtadmin.GetVSchemaRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtadmin.GetVSchemaRequest} GetVSchemaRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetVSchemaRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetVSchemaRequest message.
         * @function verify
         * @memberof vtadmin.GetVSchemaRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetVSchemaRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cluster_id != null && message.hasOwnProperty("cluster_id"))
                if (!$util.isString(message.cluster_id))
                    return "cluster_id: string expected";
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                if (!$util.isString(message.keyspace))
                    return "keyspace: string expected";
            return null;
        };

        /**
         * Creates a GetVSchemaRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtadmin.GetVSchemaRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtadmin.GetVSchemaRequest} GetVSchemaRequest
         */
        GetVSchemaRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtadmin.GetVSchemaRequest)
                return object;
            var message = new $root.vtadmin.GetVSchemaRequest();
            if (object.cluster_id != null)
                message.cluster_id = String(object.cluster_id);
            if (object.keyspace != null)
                message.keyspace = String(object.keyspace);
            return message;
        };

        /**
         * Creates a plain object from a GetVSchemaRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtadmin.GetVSchemaRequest
         * @static
         * @param {vtadmin.GetVSchemaRequest} message GetVSchemaRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetVSchemaRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.cluster_id = "";
                object.keyspace = "";
            }
            if (message.cluster_id != null && message.hasOwnProperty("cluster_id"))
                object.cluster_id = message.cluster_id;
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                object.keyspace = message.keyspace;
            return object;
        };

        /**
         * Converts this GetVSchemaRequest to JSON.
         * @function toJSON
         * @memberof vtadmin.GetVSchemaRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetVSchemaRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetVSchemaRequest;
    })();

    vtadmin.GetVSchemasRequest = (function() {

        /**
         * Properties of a GetVSchemasRequest.
         * @memberof vtadmin
         * @interface IGetVSchemasRequest
         * @property {Array.<string>|null} [cluster_ids] GetVSchemasRequest cluster_ids
         */

        /**
         * Constructs a new GetVSchemasRequest.
         * @memberof vtadmin
         * @classdesc Represents a GetVSchemasRequest.
         * @implements IGetVSchemasRequest
         * @constructor
         * @param {vtadmin.IGetVSchemasRequest=} [properties] Properties to set
         */
        function GetVSchemasRequest(properties) {
            this.cluster_ids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetVSchemasRequest cluster_ids.
         * @member {Array.<string>} cluster_ids
         * @memberof vtadmin.GetVSchemasRequest
         * @instance
         */
        GetVSchemasRequest.prototype.cluster_ids = $util.emptyArray;

        /**
         * Creates a new GetVSchemasRequest instance using the specified properties.
         * @function create
         * @memberof vtadmin.GetVSchemasRequest
         * @static
         * @param {vtadmin.IGetVSchemasRequest=} [properties] Properties to set
         * @returns {vtadmin.GetVSchemasRequest} GetVSchemasRequest instance
         */
        GetVSchemasRequest.create = function create(properties) {
            return new GetVSchemasRequest(properties);
        };

        /**
         * Encodes the specified GetVSchemasRequest message. Does not implicitly {@link vtadmin.GetVSchemasRequest.verify|verify} messages.
         * @function encode
         * @memberof vtadmin.GetVSchemasRequest
         * @static
         * @param {vtadmin.IGetVSchemasRequest} message GetVSchemasRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetVSchemasRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cluster_ids != null && message.cluster_ids.length)
                for (var i = 0; i < message.cluster_ids.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.cluster_ids[i]);
            return writer;
        };

        /**
         * Encodes the specified GetVSchemasRequest message, length delimited. Does not implicitly {@link vtadmin.GetVSchemasRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtadmin.GetVSchemasRequest
         * @static
         * @param {vtadmin.IGetVSchemasRequest} message GetVSchemasRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetVSchemasRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetVSchemasRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtadmin.GetVSchemasRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtadmin.GetVSchemasRequest} GetVSchemasRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetVSchemasRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtadmin.GetVSchemasRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.cluster_ids && message.cluster_ids.length))
                        message.cluster_ids = [];
                    message.cluster_ids.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetVSchemasRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtadmin.GetVSchemasRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtadmin.GetVSchemasRequest} GetVSchemasRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetVSchemasRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetVSchemasRequest message.
         * @function verify
         * @memberof vtadmin.GetVSchemasRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetVSchemasRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cluster_ids != null && message.hasOwnProperty("cluster_ids")) {
                if (!Array.isArray(message.cluster_ids))
                    return "cluster_ids: array expected";
                for (var i = 0; i < message.cluster_ids.length; ++i)
                    if (!$util.isString(message.cluster_ids[i]))
                        return "cluster_ids: string[] expected";
            }
            return null;
        };

        /**
         * Creates a GetVSchemasRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtadmin.GetVSchemasRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtadmin.GetVSchemasRequest} GetVSchemasRequest
         */
        GetVSchemasRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtadmin.GetVSchemasRequest)
                return object;
            var message = new $root.vtadmin.GetVSchemasRequest();
            if (object.cluster_ids) {
                if (!Array.isArray(object.cluster_ids))
                    throw TypeError(".vtadmin.GetVSchemasRequest.cluster_ids: array expected");
                message.cluster_ids = [];
                for (var i = 0; i < object.cluster_ids.length; ++i)
                    message.cluster_ids[i] = String(object.cluster_ids[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetVSchemasRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtadmin.GetVSchemasRequest
         * @static
         * @param {vtadmin.GetVSchemasRequest} message GetVSchemasRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetVSchemasRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.cluster_ids = [];
            if (message.cluster_ids && message.cluster_ids.length) {
                object.cluster_ids = [];
                for (var j = 0; j < message.cluster_ids.length; ++j)
                    object.cluster_ids[j] = message.cluster_ids[j];
            }
            return object;
        };

        /**
         * Converts this GetVSchemasRequest to JSON.
         * @function toJSON
         * @memberof vtadmin.GetVSchemasRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetVSchemasRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetVSchemasRequest;
    })();

    vtadmin.GetVSchemasResponse = (function() {

        /**
         * Properties of a GetVSchemasResponse.
         * @memberof vtadmin
         * @interface IGetVSchemasResponse
         * @property {Array.<vtadmin.IVSchema>|null} [v_schemas] GetVSchemasResponse v_schemas
         */

        /**
         * Constructs a new GetVSchemasResponse.
         * @memberof vtadmin
         * @classdesc Represents a GetVSchemasResponse.
         * @implements IGetVSchemasResponse
         * @constructor
         * @param {vtadmin.IGetVSchemasResponse=} [properties] Properties to set
         */
        function GetVSchemasResponse(properties) {
            this.v_schemas = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetVSchemasResponse v_schemas.
         * @member {Array.<vtadmin.IVSchema>} v_schemas
         * @memberof vtadmin.GetVSchemasResponse
         * @instance
         */
        GetVSchemasResponse.prototype.v_schemas = $util.emptyArray;

        /**
         * Creates a new GetVSchemasResponse instance using the specified properties.
         * @function create
         * @memberof vtadmin.GetVSchemasResponse
         * @static
         * @param {vtadmin.IGetVSchemasResponse=} [properties] Properties to set
         * @returns {vtadmin.GetVSchemasResponse} GetVSchemasResponse instance
         */
        GetVSchemasResponse.create = function create(properties) {
            return new GetVSchemasResponse(properties);
        };

        /**
         * Encodes the specified GetVSchemasResponse message. Does not implicitly {@link vtadmin.GetVSchemasResponse.verify|verify} messages.
         * @function encode
         * @memberof vtadmin.GetVSchemasResponse
         * @static
         * @param {vtadmin.IGetVSchemasResponse} message GetVSchemasResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetVSchemasResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.v_schemas != null && message.v_schemas.length)
                for (var i = 0; i < message.v_schemas.length; ++i)
                    $root.vtadmin.VSchema.encode(message.v_schemas[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetVSchemasResponse message, length delimited. Does not implicitly {@link vtadmin.GetVSchemasResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtadmin.GetVSchemasResponse
         * @static
         * @param {vtadmin.IGetVSchemasResponse} message GetVSchemasResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetVSchemasResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetVSchemasResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vtadmin.GetVSchemasResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtadmin.GetVSchemasResponse} GetVSchemasResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetVSchemasResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtadmin.GetVSchemasResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.v_schemas && message.v_schemas.length))
                        message.v_schemas = [];
                    message.v_schemas.push($root.vtadmin.VSchema.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetVSchemasResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtadmin.GetVSchemasResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtadmin.GetVSchemasResponse} GetVSchemasResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetVSchemasResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetVSchemasResponse message.
         * @function verify
         * @memberof vtadmin.GetVSchemasResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetVSchemasResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.v_schemas != null && message.hasOwnProperty("v_schemas")) {
                if (!Array.isArray(message.v_schemas))
                    return "v_schemas: array expected";
                for (var i = 0; i < message.v_schemas.length; ++i) {
                    var error = $root.vtadmin.VSchema.verify(message.v_schemas[i]);
                    if (error)
                        return "v_schemas." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetVSchemasResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtadmin.GetVSchemasResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtadmin.GetVSchemasResponse} GetVSchemasResponse
         */
        GetVSchemasResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vtadmin.GetVSchemasResponse)
                return object;
            var message = new $root.vtadmin.GetVSchemasResponse();
            if (object.v_schemas) {
                if (!Array.isArray(object.v_schemas))
                    throw TypeError(".vtadmin.GetVSchemasResponse.v_schemas: array expected");
                message.v_schemas = [];
                for (var i = 0; i < object.v_schemas.length; ++i) {
                    if (typeof object.v_schemas[i] !== "object")
                        throw TypeError(".vtadmin.GetVSchemasResponse.v_schemas: object expected");
                    message.v_schemas[i] = $root.vtadmin.VSchema.fromObject(object.v_schemas[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetVSchemasResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtadmin.GetVSchemasResponse
         * @static
         * @param {vtadmin.GetVSchemasResponse} message GetVSchemasResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetVSchemasResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.v_schemas = [];
            if (message.v_schemas && message.v_schemas.length) {
                object.v_schemas = [];
                for (var j = 0; j < message.v_schemas.length; ++j)
                    object.v_schemas[j] = $root.vtadmin.VSchema.toObject(message.v_schemas[j], options);
            }
            return object;
        };

        /**
         * Converts this GetVSchemasResponse to JSON.
         * @function toJSON
         * @memberof vtadmin.GetVSchemasResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetVSchemasResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetVSchemasResponse;
    })();

    vtadmin.GetWorkflowRequest = (function() {

        /**
         * Properties of a GetWorkflowRequest.
         * @memberof vtadmin
         * @interface IGetWorkflowRequest
         * @property {string|null} [cluster_id] GetWorkflowRequest cluster_id
         * @property {string|null} [keyspace] GetWorkflowRequest keyspace
         * @property {string|null} [name] GetWorkflowRequest name
         * @property {boolean|null} [active_only] GetWorkflowRequest active_only
         */

        /**
         * Constructs a new GetWorkflowRequest.
         * @memberof vtadmin
         * @classdesc Represents a GetWorkflowRequest.
         * @implements IGetWorkflowRequest
         * @constructor
         * @param {vtadmin.IGetWorkflowRequest=} [properties] Properties to set
         */
        function GetWorkflowRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetWorkflowRequest cluster_id.
         * @member {string} cluster_id
         * @memberof vtadmin.GetWorkflowRequest
         * @instance
         */
        GetWorkflowRequest.prototype.cluster_id = "";

        /**
         * GetWorkflowRequest keyspace.
         * @member {string} keyspace
         * @memberof vtadmin.GetWorkflowRequest
         * @instance
         */
        GetWorkflowRequest.prototype.keyspace = "";

        /**
         * GetWorkflowRequest name.
         * @member {string} name
         * @memberof vtadmin.GetWorkflowRequest
         * @instance
         */
        GetWorkflowRequest.prototype.name = "";

        /**
         * GetWorkflowRequest active_only.
         * @member {boolean} active_only
         * @memberof vtadmin.GetWorkflowRequest
         * @instance
         */
        GetWorkflowRequest.prototype.active_only = false;

        /**
         * Creates a new GetWorkflowRequest instance using the specified properties.
         * @function create
         * @memberof vtadmin.GetWorkflowRequest
         * @static
         * @param {vtadmin.IGetWorkflowRequest=} [properties] Properties to set
         * @returns {vtadmin.GetWorkflowRequest} GetWorkflowRequest instance
         */
        GetWorkflowRequest.create = function create(properties) {
            return new GetWorkflowRequest(properties);
        };

        /**
         * Encodes the specified GetWorkflowRequest message. Does not implicitly {@link vtadmin.GetWorkflowRequest.verify|verify} messages.
         * @function encode
         * @memberof vtadmin.GetWorkflowRequest
         * @static
         * @param {vtadmin.IGetWorkflowRequest} message GetWorkflowRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetWorkflowRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cluster_id != null && Object.hasOwnProperty.call(message, "cluster_id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.cluster_id);
            if (message.keyspace != null && Object.hasOwnProperty.call(message, "keyspace"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.keyspace);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.active_only != null && Object.hasOwnProperty.call(message, "active_only"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.active_only);
            return writer;
        };

        /**
         * Encodes the specified GetWorkflowRequest message, length delimited. Does not implicitly {@link vtadmin.GetWorkflowRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtadmin.GetWorkflowRequest
         * @static
         * @param {vtadmin.IGetWorkflowRequest} message GetWorkflowRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetWorkflowRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetWorkflowRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtadmin.GetWorkflowRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtadmin.GetWorkflowRequest} GetWorkflowRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetWorkflowRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtadmin.GetWorkflowRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.cluster_id = reader.string();
                    break;
                case 2:
                    message.keyspace = reader.string();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.active_only = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetWorkflowRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtadmin.GetWorkflowRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtadmin.GetWorkflowRequest} GetWorkflowRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetWorkflowRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetWorkflowRequest message.
         * @function verify
         * @memberof vtadmin.GetWorkflowRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetWorkflowRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cluster_id != null && message.hasOwnProperty("cluster_id"))
                if (!$util.isString(message.cluster_id))
                    return "cluster_id: string expected";
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                if (!$util.isString(message.keyspace))
                    return "keyspace: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.active_only != null && message.hasOwnProperty("active_only"))
                if (typeof message.active_only !== "boolean")
                    return "active_only: boolean expected";
            return null;
        };

        /**
         * Creates a GetWorkflowRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtadmin.GetWorkflowRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtadmin.GetWorkflowRequest} GetWorkflowRequest
         */
        GetWorkflowRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtadmin.GetWorkflowRequest)
                return object;
            var message = new $root.vtadmin.GetWorkflowRequest();
            if (object.cluster_id != null)
                message.cluster_id = String(object.cluster_id);
            if (object.keyspace != null)
                message.keyspace = String(object.keyspace);
            if (object.name != null)
                message.name = String(object.name);
            if (object.active_only != null)
                message.active_only = Boolean(object.active_only);
            return message;
        };

        /**
         * Creates a plain object from a GetWorkflowRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtadmin.GetWorkflowRequest
         * @static
         * @param {vtadmin.GetWorkflowRequest} message GetWorkflowRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetWorkflowRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.cluster_id = "";
                object.keyspace = "";
                object.name = "";
                object.active_only = false;
            }
            if (message.cluster_id != null && message.hasOwnProperty("cluster_id"))
                object.cluster_id = message.cluster_id;
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                object.keyspace = message.keyspace;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.active_only != null && message.hasOwnProperty("active_only"))
                object.active_only = message.active_only;
            return object;
        };

        /**
         * Converts this GetWorkflowRequest to JSON.
         * @function toJSON
         * @memberof vtadmin.GetWorkflowRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetWorkflowRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetWorkflowRequest;
    })();

    vtadmin.GetWorkflowsRequest = (function() {

        /**
         * Properties of a GetWorkflowsRequest.
         * @memberof vtadmin
         * @interface IGetWorkflowsRequest
         * @property {Array.<string>|null} [cluster_ids] GetWorkflowsRequest cluster_ids
         * @property {boolean|null} [active_only] GetWorkflowsRequest active_only
         * @property {Array.<string>|null} [keyspaces] GetWorkflowsRequest keyspaces
         * @property {Array.<string>|null} [ignore_keyspaces] GetWorkflowsRequest ignore_keyspaces
         */

        /**
         * Constructs a new GetWorkflowsRequest.
         * @memberof vtadmin
         * @classdesc Represents a GetWorkflowsRequest.
         * @implements IGetWorkflowsRequest
         * @constructor
         * @param {vtadmin.IGetWorkflowsRequest=} [properties] Properties to set
         */
        function GetWorkflowsRequest(properties) {
            this.cluster_ids = [];
            this.keyspaces = [];
            this.ignore_keyspaces = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetWorkflowsRequest cluster_ids.
         * @member {Array.<string>} cluster_ids
         * @memberof vtadmin.GetWorkflowsRequest
         * @instance
         */
        GetWorkflowsRequest.prototype.cluster_ids = $util.emptyArray;

        /**
         * GetWorkflowsRequest active_only.
         * @member {boolean} active_only
         * @memberof vtadmin.GetWorkflowsRequest
         * @instance
         */
        GetWorkflowsRequest.prototype.active_only = false;

        /**
         * GetWorkflowsRequest keyspaces.
         * @member {Array.<string>} keyspaces
         * @memberof vtadmin.GetWorkflowsRequest
         * @instance
         */
        GetWorkflowsRequest.prototype.keyspaces = $util.emptyArray;

        /**
         * GetWorkflowsRequest ignore_keyspaces.
         * @member {Array.<string>} ignore_keyspaces
         * @memberof vtadmin.GetWorkflowsRequest
         * @instance
         */
        GetWorkflowsRequest.prototype.ignore_keyspaces = $util.emptyArray;

        /**
         * Creates a new GetWorkflowsRequest instance using the specified properties.
         * @function create
         * @memberof vtadmin.GetWorkflowsRequest
         * @static
         * @param {vtadmin.IGetWorkflowsRequest=} [properties] Properties to set
         * @returns {vtadmin.GetWorkflowsRequest} GetWorkflowsRequest instance
         */
        GetWorkflowsRequest.create = function create(properties) {
            return new GetWorkflowsRequest(properties);
        };

        /**
         * Encodes the specified GetWorkflowsRequest message. Does not implicitly {@link vtadmin.GetWorkflowsRequest.verify|verify} messages.
         * @function encode
         * @memberof vtadmin.GetWorkflowsRequest
         * @static
         * @param {vtadmin.IGetWorkflowsRequest} message GetWorkflowsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetWorkflowsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cluster_ids != null && message.cluster_ids.length)
                for (var i = 0; i < message.cluster_ids.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.cluster_ids[i]);
            if (message.active_only != null && Object.hasOwnProperty.call(message, "active_only"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.active_only);
            if (message.keyspaces != null && message.keyspaces.length)
                for (var i = 0; i < message.keyspaces.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.keyspaces[i]);
            if (message.ignore_keyspaces != null && message.ignore_keyspaces.length)
                for (var i = 0; i < message.ignore_keyspaces.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.ignore_keyspaces[i]);
            return writer;
        };

        /**
         * Encodes the specified GetWorkflowsRequest message, length delimited. Does not implicitly {@link vtadmin.GetWorkflowsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtadmin.GetWorkflowsRequest
         * @static
         * @param {vtadmin.IGetWorkflowsRequest} message GetWorkflowsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetWorkflowsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetWorkflowsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtadmin.GetWorkflowsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtadmin.GetWorkflowsRequest} GetWorkflowsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetWorkflowsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtadmin.GetWorkflowsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.cluster_ids && message.cluster_ids.length))
                        message.cluster_ids = [];
                    message.cluster_ids.push(reader.string());
                    break;
                case 2:
                    message.active_only = reader.bool();
                    break;
                case 3:
                    if (!(message.keyspaces && message.keyspaces.length))
                        message.keyspaces = [];
                    message.keyspaces.push(reader.string());
                    break;
                case 4:
                    if (!(message.ignore_keyspaces && message.ignore_keyspaces.length))
                        message.ignore_keyspaces = [];
                    message.ignore_keyspaces.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetWorkflowsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtadmin.GetWorkflowsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtadmin.GetWorkflowsRequest} GetWorkflowsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetWorkflowsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetWorkflowsRequest message.
         * @function verify
         * @memberof vtadmin.GetWorkflowsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetWorkflowsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cluster_ids != null && message.hasOwnProperty("cluster_ids")) {
                if (!Array.isArray(message.cluster_ids))
                    return "cluster_ids: array expected";
                for (var i = 0; i < message.cluster_ids.length; ++i)
                    if (!$util.isString(message.cluster_ids[i]))
                        return "cluster_ids: string[] expected";
            }
            if (message.active_only != null && message.hasOwnProperty("active_only"))
                if (typeof message.active_only !== "boolean")
                    return "active_only: boolean expected";
            if (message.keyspaces != null && message.hasOwnProperty("keyspaces")) {
                if (!Array.isArray(message.keyspaces))
                    return "keyspaces: array expected";
                for (var i = 0; i < message.keyspaces.length; ++i)
                    if (!$util.isString(message.keyspaces[i]))
                        return "keyspaces: string[] expected";
            }
            if (message.ignore_keyspaces != null && message.hasOwnProperty("ignore_keyspaces")) {
                if (!Array.isArray(message.ignore_keyspaces))
                    return "ignore_keyspaces: array expected";
                for (var i = 0; i < message.ignore_keyspaces.length; ++i)
                    if (!$util.isString(message.ignore_keyspaces[i]))
                        return "ignore_keyspaces: string[] expected";
            }
            return null;
        };

        /**
         * Creates a GetWorkflowsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtadmin.GetWorkflowsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtadmin.GetWorkflowsRequest} GetWorkflowsRequest
         */
        GetWorkflowsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtadmin.GetWorkflowsRequest)
                return object;
            var message = new $root.vtadmin.GetWorkflowsRequest();
            if (object.cluster_ids) {
                if (!Array.isArray(object.cluster_ids))
                    throw TypeError(".vtadmin.GetWorkflowsRequest.cluster_ids: array expected");
                message.cluster_ids = [];
                for (var i = 0; i < object.cluster_ids.length; ++i)
                    message.cluster_ids[i] = String(object.cluster_ids[i]);
            }
            if (object.active_only != null)
                message.active_only = Boolean(object.active_only);
            if (object.keyspaces) {
                if (!Array.isArray(object.keyspaces))
                    throw TypeError(".vtadmin.GetWorkflowsRequest.keyspaces: array expected");
                message.keyspaces = [];
                for (var i = 0; i < object.keyspaces.length; ++i)
                    message.keyspaces[i] = String(object.keyspaces[i]);
            }
            if (object.ignore_keyspaces) {
                if (!Array.isArray(object.ignore_keyspaces))
                    throw TypeError(".vtadmin.GetWorkflowsRequest.ignore_keyspaces: array expected");
                message.ignore_keyspaces = [];
                for (var i = 0; i < object.ignore_keyspaces.length; ++i)
                    message.ignore_keyspaces[i] = String(object.ignore_keyspaces[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetWorkflowsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtadmin.GetWorkflowsRequest
         * @static
         * @param {vtadmin.GetWorkflowsRequest} message GetWorkflowsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetWorkflowsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.cluster_ids = [];
                object.keyspaces = [];
                object.ignore_keyspaces = [];
            }
            if (options.defaults)
                object.active_only = false;
            if (message.cluster_ids && message.cluster_ids.length) {
                object.cluster_ids = [];
                for (var j = 0; j < message.cluster_ids.length; ++j)
                    object.cluster_ids[j] = message.cluster_ids[j];
            }
            if (message.active_only != null && message.hasOwnProperty("active_only"))
                object.active_only = message.active_only;
            if (message.keyspaces && message.keyspaces.length) {
                object.keyspaces = [];
                for (var j = 0; j < message.keyspaces.length; ++j)
                    object.keyspaces[j] = message.keyspaces[j];
            }
            if (message.ignore_keyspaces && message.ignore_keyspaces.length) {
                object.ignore_keyspaces = [];
                for (var j = 0; j < message.ignore_keyspaces.length; ++j)
                    object.ignore_keyspaces[j] = message.ignore_keyspaces[j];
            }
            return object;
        };

        /**
         * Converts this GetWorkflowsRequest to JSON.
         * @function toJSON
         * @memberof vtadmin.GetWorkflowsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetWorkflowsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetWorkflowsRequest;
    })();

    vtadmin.GetWorkflowsResponse = (function() {

        /**
         * Properties of a GetWorkflowsResponse.
         * @memberof vtadmin
         * @interface IGetWorkflowsResponse
         * @property {Object.<string,vtadmin.IClusterWorkflows>|null} [workflows_by_cluster] GetWorkflowsResponse workflows_by_cluster
         */

        /**
         * Constructs a new GetWorkflowsResponse.
         * @memberof vtadmin
         * @classdesc Represents a GetWorkflowsResponse.
         * @implements IGetWorkflowsResponse
         * @constructor
         * @param {vtadmin.IGetWorkflowsResponse=} [properties] Properties to set
         */
        function GetWorkflowsResponse(properties) {
            this.workflows_by_cluster = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetWorkflowsResponse workflows_by_cluster.
         * @member {Object.<string,vtadmin.IClusterWorkflows>} workflows_by_cluster
         * @memberof vtadmin.GetWorkflowsResponse
         * @instance
         */
        GetWorkflowsResponse.prototype.workflows_by_cluster = $util.emptyObject;

        /**
         * Creates a new GetWorkflowsResponse instance using the specified properties.
         * @function create
         * @memberof vtadmin.GetWorkflowsResponse
         * @static
         * @param {vtadmin.IGetWorkflowsResponse=} [properties] Properties to set
         * @returns {vtadmin.GetWorkflowsResponse} GetWorkflowsResponse instance
         */
        GetWorkflowsResponse.create = function create(properties) {
            return new GetWorkflowsResponse(properties);
        };

        /**
         * Encodes the specified GetWorkflowsResponse message. Does not implicitly {@link vtadmin.GetWorkflowsResponse.verify|verify} messages.
         * @function encode
         * @memberof vtadmin.GetWorkflowsResponse
         * @static
         * @param {vtadmin.IGetWorkflowsResponse} message GetWorkflowsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetWorkflowsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.workflows_by_cluster != null && Object.hasOwnProperty.call(message, "workflows_by_cluster"))
                for (var keys = Object.keys(message.workflows_by_cluster), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.vtadmin.ClusterWorkflows.encode(message.workflows_by_cluster[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            return writer;
        };

        /**
         * Encodes the specified GetWorkflowsResponse message, length delimited. Does not implicitly {@link vtadmin.GetWorkflowsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtadmin.GetWorkflowsResponse
         * @static
         * @param {vtadmin.IGetWorkflowsResponse} message GetWorkflowsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetWorkflowsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetWorkflowsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vtadmin.GetWorkflowsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtadmin.GetWorkflowsResponse} GetWorkflowsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetWorkflowsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtadmin.GetWorkflowsResponse(), key, value;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (message.workflows_by_cluster === $util.emptyObject)
                        message.workflows_by_cluster = {};
                    var end2 = reader.uint32() + reader.pos;
                    key = "";
                    value = null;
                    while (reader.pos < end2) {
                        var tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.string();
                            break;
                        case 2:
                            value = $root.vtadmin.ClusterWorkflows.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.workflows_by_cluster[key] = value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetWorkflowsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtadmin.GetWorkflowsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtadmin.GetWorkflowsResponse} GetWorkflowsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetWorkflowsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetWorkflowsResponse message.
         * @function verify
         * @memberof vtadmin.GetWorkflowsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetWorkflowsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.workflows_by_cluster != null && message.hasOwnProperty("workflows_by_cluster")) {
                if (!$util.isObject(message.workflows_by_cluster))
                    return "workflows_by_cluster: object expected";
                var key = Object.keys(message.workflows_by_cluster);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.vtadmin.ClusterWorkflows.verify(message.workflows_by_cluster[key[i]]);
                    if (error)
                        return "workflows_by_cluster." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetWorkflowsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtadmin.GetWorkflowsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtadmin.GetWorkflowsResponse} GetWorkflowsResponse
         */
        GetWorkflowsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vtadmin.GetWorkflowsResponse)
                return object;
            var message = new $root.vtadmin.GetWorkflowsResponse();
            if (object.workflows_by_cluster) {
                if (typeof object.workflows_by_cluster !== "object")
                    throw TypeError(".vtadmin.GetWorkflowsResponse.workflows_by_cluster: object expected");
                message.workflows_by_cluster = {};
                for (var keys = Object.keys(object.workflows_by_cluster), i = 0; i < keys.length; ++i) {
                    if (typeof object.workflows_by_cluster[keys[i]] !== "object")
                        throw TypeError(".vtadmin.GetWorkflowsResponse.workflows_by_cluster: object expected");
                    message.workflows_by_cluster[keys[i]] = $root.vtadmin.ClusterWorkflows.fromObject(object.workflows_by_cluster[keys[i]]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetWorkflowsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtadmin.GetWorkflowsResponse
         * @static
         * @param {vtadmin.GetWorkflowsResponse} message GetWorkflowsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetWorkflowsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults)
                object.workflows_by_cluster = {};
            var keys2;
            if (message.workflows_by_cluster && (keys2 = Object.keys(message.workflows_by_cluster)).length) {
                object.workflows_by_cluster = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.workflows_by_cluster[keys2[j]] = $root.vtadmin.ClusterWorkflows.toObject(message.workflows_by_cluster[keys2[j]], options);
            }
            return object;
        };

        /**
         * Converts this GetWorkflowsResponse to JSON.
         * @function toJSON
         * @memberof vtadmin.GetWorkflowsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetWorkflowsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetWorkflowsResponse;
    })();

    vtadmin.VTExplainRequest = (function() {

        /**
         * Properties of a VTExplainRequest.
         * @memberof vtadmin
         * @interface IVTExplainRequest
         * @property {string|null} [cluster] VTExplainRequest cluster
         * @property {string|null} [keyspace] VTExplainRequest keyspace
         * @property {string|null} [sql] VTExplainRequest sql
         */

        /**
         * Constructs a new VTExplainRequest.
         * @memberof vtadmin
         * @classdesc Represents a VTExplainRequest.
         * @implements IVTExplainRequest
         * @constructor
         * @param {vtadmin.IVTExplainRequest=} [properties] Properties to set
         */
        function VTExplainRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VTExplainRequest cluster.
         * @member {string} cluster
         * @memberof vtadmin.VTExplainRequest
         * @instance
         */
        VTExplainRequest.prototype.cluster = "";

        /**
         * VTExplainRequest keyspace.
         * @member {string} keyspace
         * @memberof vtadmin.VTExplainRequest
         * @instance
         */
        VTExplainRequest.prototype.keyspace = "";

        /**
         * VTExplainRequest sql.
         * @member {string} sql
         * @memberof vtadmin.VTExplainRequest
         * @instance
         */
        VTExplainRequest.prototype.sql = "";

        /**
         * Creates a new VTExplainRequest instance using the specified properties.
         * @function create
         * @memberof vtadmin.VTExplainRequest
         * @static
         * @param {vtadmin.IVTExplainRequest=} [properties] Properties to set
         * @returns {vtadmin.VTExplainRequest} VTExplainRequest instance
         */
        VTExplainRequest.create = function create(properties) {
            return new VTExplainRequest(properties);
        };

        /**
         * Encodes the specified VTExplainRequest message. Does not implicitly {@link vtadmin.VTExplainRequest.verify|verify} messages.
         * @function encode
         * @memberof vtadmin.VTExplainRequest
         * @static
         * @param {vtadmin.IVTExplainRequest} message VTExplainRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VTExplainRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cluster != null && Object.hasOwnProperty.call(message, "cluster"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.cluster);
            if (message.keyspace != null && Object.hasOwnProperty.call(message, "keyspace"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.keyspace);
            if (message.sql != null && Object.hasOwnProperty.call(message, "sql"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.sql);
            return writer;
        };

        /**
         * Encodes the specified VTExplainRequest message, length delimited. Does not implicitly {@link vtadmin.VTExplainRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtadmin.VTExplainRequest
         * @static
         * @param {vtadmin.IVTExplainRequest} message VTExplainRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VTExplainRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VTExplainRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtadmin.VTExplainRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtadmin.VTExplainRequest} VTExplainRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VTExplainRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtadmin.VTExplainRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.cluster = reader.string();
                    break;
                case 2:
                    message.keyspace = reader.string();
                    break;
                case 3:
                    message.sql = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VTExplainRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtadmin.VTExplainRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtadmin.VTExplainRequest} VTExplainRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VTExplainRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VTExplainRequest message.
         * @function verify
         * @memberof vtadmin.VTExplainRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VTExplainRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cluster != null && message.hasOwnProperty("cluster"))
                if (!$util.isString(message.cluster))
                    return "cluster: string expected";
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                if (!$util.isString(message.keyspace))
                    return "keyspace: string expected";
            if (message.sql != null && message.hasOwnProperty("sql"))
                if (!$util.isString(message.sql))
                    return "sql: string expected";
            return null;
        };

        /**
         * Creates a VTExplainRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtadmin.VTExplainRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtadmin.VTExplainRequest} VTExplainRequest
         */
        VTExplainRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtadmin.VTExplainRequest)
                return object;
            var message = new $root.vtadmin.VTExplainRequest();
            if (object.cluster != null)
                message.cluster = String(object.cluster);
            if (object.keyspace != null)
                message.keyspace = String(object.keyspace);
            if (object.sql != null)
                message.sql = String(object.sql);
            return message;
        };

        /**
         * Creates a plain object from a VTExplainRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtadmin.VTExplainRequest
         * @static
         * @param {vtadmin.VTExplainRequest} message VTExplainRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VTExplainRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.cluster = "";
                object.keyspace = "";
                object.sql = "";
            }
            if (message.cluster != null && message.hasOwnProperty("cluster"))
                object.cluster = message.cluster;
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                object.keyspace = message.keyspace;
            if (message.sql != null && message.hasOwnProperty("sql"))
                object.sql = message.sql;
            return object;
        };

        /**
         * Converts this VTExplainRequest to JSON.
         * @function toJSON
         * @memberof vtadmin.VTExplainRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VTExplainRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VTExplainRequest;
    })();

    vtadmin.VTExplainResponse = (function() {

        /**
         * Properties of a VTExplainResponse.
         * @memberof vtadmin
         * @interface IVTExplainResponse
         * @property {string|null} [response] VTExplainResponse response
         */

        /**
         * Constructs a new VTExplainResponse.
         * @memberof vtadmin
         * @classdesc Represents a VTExplainResponse.
         * @implements IVTExplainResponse
         * @constructor
         * @param {vtadmin.IVTExplainResponse=} [properties] Properties to set
         */
        function VTExplainResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VTExplainResponse response.
         * @member {string} response
         * @memberof vtadmin.VTExplainResponse
         * @instance
         */
        VTExplainResponse.prototype.response = "";

        /**
         * Creates a new VTExplainResponse instance using the specified properties.
         * @function create
         * @memberof vtadmin.VTExplainResponse
         * @static
         * @param {vtadmin.IVTExplainResponse=} [properties] Properties to set
         * @returns {vtadmin.VTExplainResponse} VTExplainResponse instance
         */
        VTExplainResponse.create = function create(properties) {
            return new VTExplainResponse(properties);
        };

        /**
         * Encodes the specified VTExplainResponse message. Does not implicitly {@link vtadmin.VTExplainResponse.verify|verify} messages.
         * @function encode
         * @memberof vtadmin.VTExplainResponse
         * @static
         * @param {vtadmin.IVTExplainResponse} message VTExplainResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VTExplainResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.response != null && Object.hasOwnProperty.call(message, "response"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.response);
            return writer;
        };

        /**
         * Encodes the specified VTExplainResponse message, length delimited. Does not implicitly {@link vtadmin.VTExplainResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtadmin.VTExplainResponse
         * @static
         * @param {vtadmin.IVTExplainResponse} message VTExplainResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VTExplainResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VTExplainResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vtadmin.VTExplainResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtadmin.VTExplainResponse} VTExplainResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VTExplainResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtadmin.VTExplainResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.response = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VTExplainResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtadmin.VTExplainResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtadmin.VTExplainResponse} VTExplainResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VTExplainResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VTExplainResponse message.
         * @function verify
         * @memberof vtadmin.VTExplainResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VTExplainResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.response != null && message.hasOwnProperty("response"))
                if (!$util.isString(message.response))
                    return "response: string expected";
            return null;
        };

        /**
         * Creates a VTExplainResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtadmin.VTExplainResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtadmin.VTExplainResponse} VTExplainResponse
         */
        VTExplainResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vtadmin.VTExplainResponse)
                return object;
            var message = new $root.vtadmin.VTExplainResponse();
            if (object.response != null)
                message.response = String(object.response);
            return message;
        };

        /**
         * Creates a plain object from a VTExplainResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtadmin.VTExplainResponse
         * @static
         * @param {vtadmin.VTExplainResponse} message VTExplainResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VTExplainResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.response = "";
            if (message.response != null && message.hasOwnProperty("response"))
                object.response = message.response;
            return object;
        };

        /**
         * Converts this VTExplainResponse to JSON.
         * @function toJSON
         * @memberof vtadmin.VTExplainResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VTExplainResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VTExplainResponse;
    })();

    return vtadmin;
})();

$root.tabletmanagerdata = (function() {

    /**
     * Namespace tabletmanagerdata.
     * @exports tabletmanagerdata
     * @namespace
     */
    var tabletmanagerdata = {};

    tabletmanagerdata.TableDefinition = (function() {

        /**
         * Properties of a TableDefinition.
         * @memberof tabletmanagerdata
         * @interface ITableDefinition
         * @property {string|null} [name] TableDefinition name
         * @property {string|null} [schema] TableDefinition schema
         * @property {Array.<string>|null} [columns] TableDefinition columns
         * @property {Array.<string>|null} [primary_key_columns] TableDefinition primary_key_columns
         * @property {string|null} [type] TableDefinition type
         * @property {number|Long|null} [data_length] TableDefinition data_length
         * @property {number|Long|null} [row_count] TableDefinition row_count
         * @property {Array.<query.IField>|null} [fields] TableDefinition fields
         */

        /**
         * Constructs a new TableDefinition.
         * @memberof tabletmanagerdata
         * @classdesc Represents a TableDefinition.
         * @implements ITableDefinition
         * @constructor
         * @param {tabletmanagerdata.ITableDefinition=} [properties] Properties to set
         */
        function TableDefinition(properties) {
            this.columns = [];
            this.primary_key_columns = [];
            this.fields = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TableDefinition name.
         * @member {string} name
         * @memberof tabletmanagerdata.TableDefinition
         * @instance
         */
        TableDefinition.prototype.name = "";

        /**
         * TableDefinition schema.
         * @member {string} schema
         * @memberof tabletmanagerdata.TableDefinition
         * @instance
         */
        TableDefinition.prototype.schema = "";

        /**
         * TableDefinition columns.
         * @member {Array.<string>} columns
         * @memberof tabletmanagerdata.TableDefinition
         * @instance
         */
        TableDefinition.prototype.columns = $util.emptyArray;

        /**
         * TableDefinition primary_key_columns.
         * @member {Array.<string>} primary_key_columns
         * @memberof tabletmanagerdata.TableDefinition
         * @instance
         */
        TableDefinition.prototype.primary_key_columns = $util.emptyArray;

        /**
         * TableDefinition type.
         * @member {string} type
         * @memberof tabletmanagerdata.TableDefinition
         * @instance
         */
        TableDefinition.prototype.type = "";

        /**
         * TableDefinition data_length.
         * @member {number|Long} data_length
         * @memberof tabletmanagerdata.TableDefinition
         * @instance
         */
        TableDefinition.prototype.data_length = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * TableDefinition row_count.
         * @member {number|Long} row_count
         * @memberof tabletmanagerdata.TableDefinition
         * @instance
         */
        TableDefinition.prototype.row_count = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * TableDefinition fields.
         * @member {Array.<query.IField>} fields
         * @memberof tabletmanagerdata.TableDefinition
         * @instance
         */
        TableDefinition.prototype.fields = $util.emptyArray;

        /**
         * Creates a new TableDefinition instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.TableDefinition
         * @static
         * @param {tabletmanagerdata.ITableDefinition=} [properties] Properties to set
         * @returns {tabletmanagerdata.TableDefinition} TableDefinition instance
         */
        TableDefinition.create = function create(properties) {
            return new TableDefinition(properties);
        };

        /**
         * Encodes the specified TableDefinition message. Does not implicitly {@link tabletmanagerdata.TableDefinition.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.TableDefinition
         * @static
         * @param {tabletmanagerdata.ITableDefinition} message TableDefinition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TableDefinition.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.schema != null && Object.hasOwnProperty.call(message, "schema"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.schema);
            if (message.columns != null && message.columns.length)
                for (var i = 0; i < message.columns.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.columns[i]);
            if (message.primary_key_columns != null && message.primary_key_columns.length)
                for (var i = 0; i < message.primary_key_columns.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.primary_key_columns[i]);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.type);
            if (message.data_length != null && Object.hasOwnProperty.call(message, "data_length"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.data_length);
            if (message.row_count != null && Object.hasOwnProperty.call(message, "row_count"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.row_count);
            if (message.fields != null && message.fields.length)
                for (var i = 0; i < message.fields.length; ++i)
                    $root.query.Field.encode(message.fields[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TableDefinition message, length delimited. Does not implicitly {@link tabletmanagerdata.TableDefinition.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.TableDefinition
         * @static
         * @param {tabletmanagerdata.ITableDefinition} message TableDefinition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TableDefinition.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TableDefinition message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.TableDefinition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.TableDefinition} TableDefinition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TableDefinition.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.TableDefinition();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.schema = reader.string();
                    break;
                case 3:
                    if (!(message.columns && message.columns.length))
                        message.columns = [];
                    message.columns.push(reader.string());
                    break;
                case 4:
                    if (!(message.primary_key_columns && message.primary_key_columns.length))
                        message.primary_key_columns = [];
                    message.primary_key_columns.push(reader.string());
                    break;
                case 5:
                    message.type = reader.string();
                    break;
                case 6:
                    message.data_length = reader.uint64();
                    break;
                case 7:
                    message.row_count = reader.uint64();
                    break;
                case 8:
                    if (!(message.fields && message.fields.length))
                        message.fields = [];
                    message.fields.push($root.query.Field.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TableDefinition message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.TableDefinition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.TableDefinition} TableDefinition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TableDefinition.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TableDefinition message.
         * @function verify
         * @memberof tabletmanagerdata.TableDefinition
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TableDefinition.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.schema != null && message.hasOwnProperty("schema"))
                if (!$util.isString(message.schema))
                    return "schema: string expected";
            if (message.columns != null && message.hasOwnProperty("columns")) {
                if (!Array.isArray(message.columns))
                    return "columns: array expected";
                for (var i = 0; i < message.columns.length; ++i)
                    if (!$util.isString(message.columns[i]))
                        return "columns: string[] expected";
            }
            if (message.primary_key_columns != null && message.hasOwnProperty("primary_key_columns")) {
                if (!Array.isArray(message.primary_key_columns))
                    return "primary_key_columns: array expected";
                for (var i = 0; i < message.primary_key_columns.length; ++i)
                    if (!$util.isString(message.primary_key_columns[i]))
                        return "primary_key_columns: string[] expected";
            }
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isString(message.type))
                    return "type: string expected";
            if (message.data_length != null && message.hasOwnProperty("data_length"))
                if (!$util.isInteger(message.data_length) && !(message.data_length && $util.isInteger(message.data_length.low) && $util.isInteger(message.data_length.high)))
                    return "data_length: integer|Long expected";
            if (message.row_count != null && message.hasOwnProperty("row_count"))
                if (!$util.isInteger(message.row_count) && !(message.row_count && $util.isInteger(message.row_count.low) && $util.isInteger(message.row_count.high)))
                    return "row_count: integer|Long expected";
            if (message.fields != null && message.hasOwnProperty("fields")) {
                if (!Array.isArray(message.fields))
                    return "fields: array expected";
                for (var i = 0; i < message.fields.length; ++i) {
                    var error = $root.query.Field.verify(message.fields[i]);
                    if (error)
                        return "fields." + error;
                }
            }
            return null;
        };

        /**
         * Creates a TableDefinition message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.TableDefinition
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.TableDefinition} TableDefinition
         */
        TableDefinition.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.TableDefinition)
                return object;
            var message = new $root.tabletmanagerdata.TableDefinition();
            if (object.name != null)
                message.name = String(object.name);
            if (object.schema != null)
                message.schema = String(object.schema);
            if (object.columns) {
                if (!Array.isArray(object.columns))
                    throw TypeError(".tabletmanagerdata.TableDefinition.columns: array expected");
                message.columns = [];
                for (var i = 0; i < object.columns.length; ++i)
                    message.columns[i] = String(object.columns[i]);
            }
            if (object.primary_key_columns) {
                if (!Array.isArray(object.primary_key_columns))
                    throw TypeError(".tabletmanagerdata.TableDefinition.primary_key_columns: array expected");
                message.primary_key_columns = [];
                for (var i = 0; i < object.primary_key_columns.length; ++i)
                    message.primary_key_columns[i] = String(object.primary_key_columns[i]);
            }
            if (object.type != null)
                message.type = String(object.type);
            if (object.data_length != null)
                if ($util.Long)
                    (message.data_length = $util.Long.fromValue(object.data_length)).unsigned = true;
                else if (typeof object.data_length === "string")
                    message.data_length = parseInt(object.data_length, 10);
                else if (typeof object.data_length === "number")
                    message.data_length = object.data_length;
                else if (typeof object.data_length === "object")
                    message.data_length = new $util.LongBits(object.data_length.low >>> 0, object.data_length.high >>> 0).toNumber(true);
            if (object.row_count != null)
                if ($util.Long)
                    (message.row_count = $util.Long.fromValue(object.row_count)).unsigned = true;
                else if (typeof object.row_count === "string")
                    message.row_count = parseInt(object.row_count, 10);
                else if (typeof object.row_count === "number")
                    message.row_count = object.row_count;
                else if (typeof object.row_count === "object")
                    message.row_count = new $util.LongBits(object.row_count.low >>> 0, object.row_count.high >>> 0).toNumber(true);
            if (object.fields) {
                if (!Array.isArray(object.fields))
                    throw TypeError(".tabletmanagerdata.TableDefinition.fields: array expected");
                message.fields = [];
                for (var i = 0; i < object.fields.length; ++i) {
                    if (typeof object.fields[i] !== "object")
                        throw TypeError(".tabletmanagerdata.TableDefinition.fields: object expected");
                    message.fields[i] = $root.query.Field.fromObject(object.fields[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a TableDefinition message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.TableDefinition
         * @static
         * @param {tabletmanagerdata.TableDefinition} message TableDefinition
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TableDefinition.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.columns = [];
                object.primary_key_columns = [];
                object.fields = [];
            }
            if (options.defaults) {
                object.name = "";
                object.schema = "";
                object.type = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.data_length = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.data_length = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.row_count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.row_count = options.longs === String ? "0" : 0;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.schema != null && message.hasOwnProperty("schema"))
                object.schema = message.schema;
            if (message.columns && message.columns.length) {
                object.columns = [];
                for (var j = 0; j < message.columns.length; ++j)
                    object.columns[j] = message.columns[j];
            }
            if (message.primary_key_columns && message.primary_key_columns.length) {
                object.primary_key_columns = [];
                for (var j = 0; j < message.primary_key_columns.length; ++j)
                    object.primary_key_columns[j] = message.primary_key_columns[j];
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.data_length != null && message.hasOwnProperty("data_length"))
                if (typeof message.data_length === "number")
                    object.data_length = options.longs === String ? String(message.data_length) : message.data_length;
                else
                    object.data_length = options.longs === String ? $util.Long.prototype.toString.call(message.data_length) : options.longs === Number ? new $util.LongBits(message.data_length.low >>> 0, message.data_length.high >>> 0).toNumber(true) : message.data_length;
            if (message.row_count != null && message.hasOwnProperty("row_count"))
                if (typeof message.row_count === "number")
                    object.row_count = options.longs === String ? String(message.row_count) : message.row_count;
                else
                    object.row_count = options.longs === String ? $util.Long.prototype.toString.call(message.row_count) : options.longs === Number ? new $util.LongBits(message.row_count.low >>> 0, message.row_count.high >>> 0).toNumber(true) : message.row_count;
            if (message.fields && message.fields.length) {
                object.fields = [];
                for (var j = 0; j < message.fields.length; ++j)
                    object.fields[j] = $root.query.Field.toObject(message.fields[j], options);
            }
            return object;
        };

        /**
         * Converts this TableDefinition to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.TableDefinition
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TableDefinition.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TableDefinition;
    })();

    tabletmanagerdata.SchemaDefinition = (function() {

        /**
         * Properties of a SchemaDefinition.
         * @memberof tabletmanagerdata
         * @interface ISchemaDefinition
         * @property {string|null} [database_schema] SchemaDefinition database_schema
         * @property {Array.<tabletmanagerdata.ITableDefinition>|null} [table_definitions] SchemaDefinition table_definitions
         * @property {string|null} [version] SchemaDefinition version
         */

        /**
         * Constructs a new SchemaDefinition.
         * @memberof tabletmanagerdata
         * @classdesc Represents a SchemaDefinition.
         * @implements ISchemaDefinition
         * @constructor
         * @param {tabletmanagerdata.ISchemaDefinition=} [properties] Properties to set
         */
        function SchemaDefinition(properties) {
            this.table_definitions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SchemaDefinition database_schema.
         * @member {string} database_schema
         * @memberof tabletmanagerdata.SchemaDefinition
         * @instance
         */
        SchemaDefinition.prototype.database_schema = "";

        /**
         * SchemaDefinition table_definitions.
         * @member {Array.<tabletmanagerdata.ITableDefinition>} table_definitions
         * @memberof tabletmanagerdata.SchemaDefinition
         * @instance
         */
        SchemaDefinition.prototype.table_definitions = $util.emptyArray;

        /**
         * SchemaDefinition version.
         * @member {string} version
         * @memberof tabletmanagerdata.SchemaDefinition
         * @instance
         */
        SchemaDefinition.prototype.version = "";

        /**
         * Creates a new SchemaDefinition instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.SchemaDefinition
         * @static
         * @param {tabletmanagerdata.ISchemaDefinition=} [properties] Properties to set
         * @returns {tabletmanagerdata.SchemaDefinition} SchemaDefinition instance
         */
        SchemaDefinition.create = function create(properties) {
            return new SchemaDefinition(properties);
        };

        /**
         * Encodes the specified SchemaDefinition message. Does not implicitly {@link tabletmanagerdata.SchemaDefinition.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.SchemaDefinition
         * @static
         * @param {tabletmanagerdata.ISchemaDefinition} message SchemaDefinition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SchemaDefinition.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.database_schema != null && Object.hasOwnProperty.call(message, "database_schema"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.database_schema);
            if (message.table_definitions != null && message.table_definitions.length)
                for (var i = 0; i < message.table_definitions.length; ++i)
                    $root.tabletmanagerdata.TableDefinition.encode(message.table_definitions[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.version);
            return writer;
        };

        /**
         * Encodes the specified SchemaDefinition message, length delimited. Does not implicitly {@link tabletmanagerdata.SchemaDefinition.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.SchemaDefinition
         * @static
         * @param {tabletmanagerdata.ISchemaDefinition} message SchemaDefinition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SchemaDefinition.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SchemaDefinition message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.SchemaDefinition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.SchemaDefinition} SchemaDefinition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SchemaDefinition.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.SchemaDefinition();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.database_schema = reader.string();
                    break;
                case 2:
                    if (!(message.table_definitions && message.table_definitions.length))
                        message.table_definitions = [];
                    message.table_definitions.push($root.tabletmanagerdata.TableDefinition.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.version = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SchemaDefinition message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.SchemaDefinition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.SchemaDefinition} SchemaDefinition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SchemaDefinition.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SchemaDefinition message.
         * @function verify
         * @memberof tabletmanagerdata.SchemaDefinition
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SchemaDefinition.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.database_schema != null && message.hasOwnProperty("database_schema"))
                if (!$util.isString(message.database_schema))
                    return "database_schema: string expected";
            if (message.table_definitions != null && message.hasOwnProperty("table_definitions")) {
                if (!Array.isArray(message.table_definitions))
                    return "table_definitions: array expected";
                for (var i = 0; i < message.table_definitions.length; ++i) {
                    var error = $root.tabletmanagerdata.TableDefinition.verify(message.table_definitions[i]);
                    if (error)
                        return "table_definitions." + error;
                }
            }
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isString(message.version))
                    return "version: string expected";
            return null;
        };

        /**
         * Creates a SchemaDefinition message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.SchemaDefinition
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.SchemaDefinition} SchemaDefinition
         */
        SchemaDefinition.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.SchemaDefinition)
                return object;
            var message = new $root.tabletmanagerdata.SchemaDefinition();
            if (object.database_schema != null)
                message.database_schema = String(object.database_schema);
            if (object.table_definitions) {
                if (!Array.isArray(object.table_definitions))
                    throw TypeError(".tabletmanagerdata.SchemaDefinition.table_definitions: array expected");
                message.table_definitions = [];
                for (var i = 0; i < object.table_definitions.length; ++i) {
                    if (typeof object.table_definitions[i] !== "object")
                        throw TypeError(".tabletmanagerdata.SchemaDefinition.table_definitions: object expected");
                    message.table_definitions[i] = $root.tabletmanagerdata.TableDefinition.fromObject(object.table_definitions[i]);
                }
            }
            if (object.version != null)
                message.version = String(object.version);
            return message;
        };

        /**
         * Creates a plain object from a SchemaDefinition message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.SchemaDefinition
         * @static
         * @param {tabletmanagerdata.SchemaDefinition} message SchemaDefinition
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SchemaDefinition.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.table_definitions = [];
            if (options.defaults) {
                object.database_schema = "";
                object.version = "";
            }
            if (message.database_schema != null && message.hasOwnProperty("database_schema"))
                object.database_schema = message.database_schema;
            if (message.table_definitions && message.table_definitions.length) {
                object.table_definitions = [];
                for (var j = 0; j < message.table_definitions.length; ++j)
                    object.table_definitions[j] = $root.tabletmanagerdata.TableDefinition.toObject(message.table_definitions[j], options);
            }
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            return object;
        };

        /**
         * Converts this SchemaDefinition to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.SchemaDefinition
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SchemaDefinition.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SchemaDefinition;
    })();

    tabletmanagerdata.SchemaChangeResult = (function() {

        /**
         * Properties of a SchemaChangeResult.
         * @memberof tabletmanagerdata
         * @interface ISchemaChangeResult
         * @property {tabletmanagerdata.ISchemaDefinition|null} [before_schema] SchemaChangeResult before_schema
         * @property {tabletmanagerdata.ISchemaDefinition|null} [after_schema] SchemaChangeResult after_schema
         */

        /**
         * Constructs a new SchemaChangeResult.
         * @memberof tabletmanagerdata
         * @classdesc Represents a SchemaChangeResult.
         * @implements ISchemaChangeResult
         * @constructor
         * @param {tabletmanagerdata.ISchemaChangeResult=} [properties] Properties to set
         */
        function SchemaChangeResult(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SchemaChangeResult before_schema.
         * @member {tabletmanagerdata.ISchemaDefinition|null|undefined} before_schema
         * @memberof tabletmanagerdata.SchemaChangeResult
         * @instance
         */
        SchemaChangeResult.prototype.before_schema = null;

        /**
         * SchemaChangeResult after_schema.
         * @member {tabletmanagerdata.ISchemaDefinition|null|undefined} after_schema
         * @memberof tabletmanagerdata.SchemaChangeResult
         * @instance
         */
        SchemaChangeResult.prototype.after_schema = null;

        /**
         * Creates a new SchemaChangeResult instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.SchemaChangeResult
         * @static
         * @param {tabletmanagerdata.ISchemaChangeResult=} [properties] Properties to set
         * @returns {tabletmanagerdata.SchemaChangeResult} SchemaChangeResult instance
         */
        SchemaChangeResult.create = function create(properties) {
            return new SchemaChangeResult(properties);
        };

        /**
         * Encodes the specified SchemaChangeResult message. Does not implicitly {@link tabletmanagerdata.SchemaChangeResult.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.SchemaChangeResult
         * @static
         * @param {tabletmanagerdata.ISchemaChangeResult} message SchemaChangeResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SchemaChangeResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.before_schema != null && Object.hasOwnProperty.call(message, "before_schema"))
                $root.tabletmanagerdata.SchemaDefinition.encode(message.before_schema, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.after_schema != null && Object.hasOwnProperty.call(message, "after_schema"))
                $root.tabletmanagerdata.SchemaDefinition.encode(message.after_schema, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SchemaChangeResult message, length delimited. Does not implicitly {@link tabletmanagerdata.SchemaChangeResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.SchemaChangeResult
         * @static
         * @param {tabletmanagerdata.ISchemaChangeResult} message SchemaChangeResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SchemaChangeResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SchemaChangeResult message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.SchemaChangeResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.SchemaChangeResult} SchemaChangeResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SchemaChangeResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.SchemaChangeResult();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.before_schema = $root.tabletmanagerdata.SchemaDefinition.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.after_schema = $root.tabletmanagerdata.SchemaDefinition.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SchemaChangeResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.SchemaChangeResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.SchemaChangeResult} SchemaChangeResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SchemaChangeResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SchemaChangeResult message.
         * @function verify
         * @memberof tabletmanagerdata.SchemaChangeResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SchemaChangeResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.before_schema != null && message.hasOwnProperty("before_schema")) {
                var error = $root.tabletmanagerdata.SchemaDefinition.verify(message.before_schema);
                if (error)
                    return "before_schema." + error;
            }
            if (message.after_schema != null && message.hasOwnProperty("after_schema")) {
                var error = $root.tabletmanagerdata.SchemaDefinition.verify(message.after_schema);
                if (error)
                    return "after_schema." + error;
            }
            return null;
        };

        /**
         * Creates a SchemaChangeResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.SchemaChangeResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.SchemaChangeResult} SchemaChangeResult
         */
        SchemaChangeResult.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.SchemaChangeResult)
                return object;
            var message = new $root.tabletmanagerdata.SchemaChangeResult();
            if (object.before_schema != null) {
                if (typeof object.before_schema !== "object")
                    throw TypeError(".tabletmanagerdata.SchemaChangeResult.before_schema: object expected");
                message.before_schema = $root.tabletmanagerdata.SchemaDefinition.fromObject(object.before_schema);
            }
            if (object.after_schema != null) {
                if (typeof object.after_schema !== "object")
                    throw TypeError(".tabletmanagerdata.SchemaChangeResult.after_schema: object expected");
                message.after_schema = $root.tabletmanagerdata.SchemaDefinition.fromObject(object.after_schema);
            }
            return message;
        };

        /**
         * Creates a plain object from a SchemaChangeResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.SchemaChangeResult
         * @static
         * @param {tabletmanagerdata.SchemaChangeResult} message SchemaChangeResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SchemaChangeResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.before_schema = null;
                object.after_schema = null;
            }
            if (message.before_schema != null && message.hasOwnProperty("before_schema"))
                object.before_schema = $root.tabletmanagerdata.SchemaDefinition.toObject(message.before_schema, options);
            if (message.after_schema != null && message.hasOwnProperty("after_schema"))
                object.after_schema = $root.tabletmanagerdata.SchemaDefinition.toObject(message.after_schema, options);
            return object;
        };

        /**
         * Converts this SchemaChangeResult to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.SchemaChangeResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SchemaChangeResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SchemaChangeResult;
    })();

    tabletmanagerdata.UserPermission = (function() {

        /**
         * Properties of a UserPermission.
         * @memberof tabletmanagerdata
         * @interface IUserPermission
         * @property {string|null} [host] UserPermission host
         * @property {string|null} [user] UserPermission user
         * @property {number|Long|null} [password_checksum] UserPermission password_checksum
         * @property {Object.<string,string>|null} [privileges] UserPermission privileges
         */

        /**
         * Constructs a new UserPermission.
         * @memberof tabletmanagerdata
         * @classdesc Represents a UserPermission.
         * @implements IUserPermission
         * @constructor
         * @param {tabletmanagerdata.IUserPermission=} [properties] Properties to set
         */
        function UserPermission(properties) {
            this.privileges = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserPermission host.
         * @member {string} host
         * @memberof tabletmanagerdata.UserPermission
         * @instance
         */
        UserPermission.prototype.host = "";

        /**
         * UserPermission user.
         * @member {string} user
         * @memberof tabletmanagerdata.UserPermission
         * @instance
         */
        UserPermission.prototype.user = "";

        /**
         * UserPermission password_checksum.
         * @member {number|Long} password_checksum
         * @memberof tabletmanagerdata.UserPermission
         * @instance
         */
        UserPermission.prototype.password_checksum = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * UserPermission privileges.
         * @member {Object.<string,string>} privileges
         * @memberof tabletmanagerdata.UserPermission
         * @instance
         */
        UserPermission.prototype.privileges = $util.emptyObject;

        /**
         * Creates a new UserPermission instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.UserPermission
         * @static
         * @param {tabletmanagerdata.IUserPermission=} [properties] Properties to set
         * @returns {tabletmanagerdata.UserPermission} UserPermission instance
         */
        UserPermission.create = function create(properties) {
            return new UserPermission(properties);
        };

        /**
         * Encodes the specified UserPermission message. Does not implicitly {@link tabletmanagerdata.UserPermission.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.UserPermission
         * @static
         * @param {tabletmanagerdata.IUserPermission} message UserPermission message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserPermission.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.host != null && Object.hasOwnProperty.call(message, "host"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.host);
            if (message.user != null && Object.hasOwnProperty.call(message, "user"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.user);
            if (message.password_checksum != null && Object.hasOwnProperty.call(message, "password_checksum"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.password_checksum);
            if (message.privileges != null && Object.hasOwnProperty.call(message, "privileges"))
                for (var keys = Object.keys(message.privileges), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.privileges[keys[i]]).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UserPermission message, length delimited. Does not implicitly {@link tabletmanagerdata.UserPermission.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.UserPermission
         * @static
         * @param {tabletmanagerdata.IUserPermission} message UserPermission message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserPermission.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserPermission message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.UserPermission
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.UserPermission} UserPermission
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserPermission.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.UserPermission(), key, value;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.host = reader.string();
                    break;
                case 2:
                    message.user = reader.string();
                    break;
                case 3:
                    message.password_checksum = reader.uint64();
                    break;
                case 4:
                    if (message.privileges === $util.emptyObject)
                        message.privileges = {};
                    var end2 = reader.uint32() + reader.pos;
                    key = "";
                    value = "";
                    while (reader.pos < end2) {
                        var tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.string();
                            break;
                        case 2:
                            value = reader.string();
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.privileges[key] = value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserPermission message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.UserPermission
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.UserPermission} UserPermission
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserPermission.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserPermission message.
         * @function verify
         * @memberof tabletmanagerdata.UserPermission
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserPermission.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.host != null && message.hasOwnProperty("host"))
                if (!$util.isString(message.host))
                    return "host: string expected";
            if (message.user != null && message.hasOwnProperty("user"))
                if (!$util.isString(message.user))
                    return "user: string expected";
            if (message.password_checksum != null && message.hasOwnProperty("password_checksum"))
                if (!$util.isInteger(message.password_checksum) && !(message.password_checksum && $util.isInteger(message.password_checksum.low) && $util.isInteger(message.password_checksum.high)))
                    return "password_checksum: integer|Long expected";
            if (message.privileges != null && message.hasOwnProperty("privileges")) {
                if (!$util.isObject(message.privileges))
                    return "privileges: object expected";
                var key = Object.keys(message.privileges);
                for (var i = 0; i < key.length; ++i)
                    if (!$util.isString(message.privileges[key[i]]))
                        return "privileges: string{k:string} expected";
            }
            return null;
        };

        /**
         * Creates a UserPermission message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.UserPermission
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.UserPermission} UserPermission
         */
        UserPermission.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.UserPermission)
                return object;
            var message = new $root.tabletmanagerdata.UserPermission();
            if (object.host != null)
                message.host = String(object.host);
            if (object.user != null)
                message.user = String(object.user);
            if (object.password_checksum != null)
                if ($util.Long)
                    (message.password_checksum = $util.Long.fromValue(object.password_checksum)).unsigned = true;
                else if (typeof object.password_checksum === "string")
                    message.password_checksum = parseInt(object.password_checksum, 10);
                else if (typeof object.password_checksum === "number")
                    message.password_checksum = object.password_checksum;
                else if (typeof object.password_checksum === "object")
                    message.password_checksum = new $util.LongBits(object.password_checksum.low >>> 0, object.password_checksum.high >>> 0).toNumber(true);
            if (object.privileges) {
                if (typeof object.privileges !== "object")
                    throw TypeError(".tabletmanagerdata.UserPermission.privileges: object expected");
                message.privileges = {};
                for (var keys = Object.keys(object.privileges), i = 0; i < keys.length; ++i)
                    message.privileges[keys[i]] = String(object.privileges[keys[i]]);
            }
            return message;
        };

        /**
         * Creates a plain object from a UserPermission message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.UserPermission
         * @static
         * @param {tabletmanagerdata.UserPermission} message UserPermission
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserPermission.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults)
                object.privileges = {};
            if (options.defaults) {
                object.host = "";
                object.user = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.password_checksum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.password_checksum = options.longs === String ? "0" : 0;
            }
            if (message.host != null && message.hasOwnProperty("host"))
                object.host = message.host;
            if (message.user != null && message.hasOwnProperty("user"))
                object.user = message.user;
            if (message.password_checksum != null && message.hasOwnProperty("password_checksum"))
                if (typeof message.password_checksum === "number")
                    object.password_checksum = options.longs === String ? String(message.password_checksum) : message.password_checksum;
                else
                    object.password_checksum = options.longs === String ? $util.Long.prototype.toString.call(message.password_checksum) : options.longs === Number ? new $util.LongBits(message.password_checksum.low >>> 0, message.password_checksum.high >>> 0).toNumber(true) : message.password_checksum;
            var keys2;
            if (message.privileges && (keys2 = Object.keys(message.privileges)).length) {
                object.privileges = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.privileges[keys2[j]] = message.privileges[keys2[j]];
            }
            return object;
        };

        /**
         * Converts this UserPermission to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.UserPermission
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserPermission.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserPermission;
    })();

    tabletmanagerdata.DbPermission = (function() {

        /**
         * Properties of a DbPermission.
         * @memberof tabletmanagerdata
         * @interface IDbPermission
         * @property {string|null} [host] DbPermission host
         * @property {string|null} [db] DbPermission db
         * @property {string|null} [user] DbPermission user
         * @property {Object.<string,string>|null} [privileges] DbPermission privileges
         */

        /**
         * Constructs a new DbPermission.
         * @memberof tabletmanagerdata
         * @classdesc Represents a DbPermission.
         * @implements IDbPermission
         * @constructor
         * @param {tabletmanagerdata.IDbPermission=} [properties] Properties to set
         */
        function DbPermission(properties) {
            this.privileges = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DbPermission host.
         * @member {string} host
         * @memberof tabletmanagerdata.DbPermission
         * @instance
         */
        DbPermission.prototype.host = "";

        /**
         * DbPermission db.
         * @member {string} db
         * @memberof tabletmanagerdata.DbPermission
         * @instance
         */
        DbPermission.prototype.db = "";

        /**
         * DbPermission user.
         * @member {string} user
         * @memberof tabletmanagerdata.DbPermission
         * @instance
         */
        DbPermission.prototype.user = "";

        /**
         * DbPermission privileges.
         * @member {Object.<string,string>} privileges
         * @memberof tabletmanagerdata.DbPermission
         * @instance
         */
        DbPermission.prototype.privileges = $util.emptyObject;

        /**
         * Creates a new DbPermission instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.DbPermission
         * @static
         * @param {tabletmanagerdata.IDbPermission=} [properties] Properties to set
         * @returns {tabletmanagerdata.DbPermission} DbPermission instance
         */
        DbPermission.create = function create(properties) {
            return new DbPermission(properties);
        };

        /**
         * Encodes the specified DbPermission message. Does not implicitly {@link tabletmanagerdata.DbPermission.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.DbPermission
         * @static
         * @param {tabletmanagerdata.IDbPermission} message DbPermission message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DbPermission.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.host != null && Object.hasOwnProperty.call(message, "host"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.host);
            if (message.db != null && Object.hasOwnProperty.call(message, "db"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.db);
            if (message.user != null && Object.hasOwnProperty.call(message, "user"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.user);
            if (message.privileges != null && Object.hasOwnProperty.call(message, "privileges"))
                for (var keys = Object.keys(message.privileges), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.privileges[keys[i]]).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DbPermission message, length delimited. Does not implicitly {@link tabletmanagerdata.DbPermission.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.DbPermission
         * @static
         * @param {tabletmanagerdata.IDbPermission} message DbPermission message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DbPermission.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DbPermission message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.DbPermission
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.DbPermission} DbPermission
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DbPermission.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.DbPermission(), key, value;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.host = reader.string();
                    break;
                case 2:
                    message.db = reader.string();
                    break;
                case 3:
                    message.user = reader.string();
                    break;
                case 4:
                    if (message.privileges === $util.emptyObject)
                        message.privileges = {};
                    var end2 = reader.uint32() + reader.pos;
                    key = "";
                    value = "";
                    while (reader.pos < end2) {
                        var tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.string();
                            break;
                        case 2:
                            value = reader.string();
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.privileges[key] = value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DbPermission message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.DbPermission
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.DbPermission} DbPermission
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DbPermission.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DbPermission message.
         * @function verify
         * @memberof tabletmanagerdata.DbPermission
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DbPermission.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.host != null && message.hasOwnProperty("host"))
                if (!$util.isString(message.host))
                    return "host: string expected";
            if (message.db != null && message.hasOwnProperty("db"))
                if (!$util.isString(message.db))
                    return "db: string expected";
            if (message.user != null && message.hasOwnProperty("user"))
                if (!$util.isString(message.user))
                    return "user: string expected";
            if (message.privileges != null && message.hasOwnProperty("privileges")) {
                if (!$util.isObject(message.privileges))
                    return "privileges: object expected";
                var key = Object.keys(message.privileges);
                for (var i = 0; i < key.length; ++i)
                    if (!$util.isString(message.privileges[key[i]]))
                        return "privileges: string{k:string} expected";
            }
            return null;
        };

        /**
         * Creates a DbPermission message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.DbPermission
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.DbPermission} DbPermission
         */
        DbPermission.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.DbPermission)
                return object;
            var message = new $root.tabletmanagerdata.DbPermission();
            if (object.host != null)
                message.host = String(object.host);
            if (object.db != null)
                message.db = String(object.db);
            if (object.user != null)
                message.user = String(object.user);
            if (object.privileges) {
                if (typeof object.privileges !== "object")
                    throw TypeError(".tabletmanagerdata.DbPermission.privileges: object expected");
                message.privileges = {};
                for (var keys = Object.keys(object.privileges), i = 0; i < keys.length; ++i)
                    message.privileges[keys[i]] = String(object.privileges[keys[i]]);
            }
            return message;
        };

        /**
         * Creates a plain object from a DbPermission message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.DbPermission
         * @static
         * @param {tabletmanagerdata.DbPermission} message DbPermission
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DbPermission.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults)
                object.privileges = {};
            if (options.defaults) {
                object.host = "";
                object.db = "";
                object.user = "";
            }
            if (message.host != null && message.hasOwnProperty("host"))
                object.host = message.host;
            if (message.db != null && message.hasOwnProperty("db"))
                object.db = message.db;
            if (message.user != null && message.hasOwnProperty("user"))
                object.user = message.user;
            var keys2;
            if (message.privileges && (keys2 = Object.keys(message.privileges)).length) {
                object.privileges = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.privileges[keys2[j]] = message.privileges[keys2[j]];
            }
            return object;
        };

        /**
         * Converts this DbPermission to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.DbPermission
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DbPermission.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DbPermission;
    })();

    tabletmanagerdata.Permissions = (function() {

        /**
         * Properties of a Permissions.
         * @memberof tabletmanagerdata
         * @interface IPermissions
         * @property {Array.<tabletmanagerdata.IUserPermission>|null} [user_permissions] Permissions user_permissions
         * @property {Array.<tabletmanagerdata.IDbPermission>|null} [db_permissions] Permissions db_permissions
         */

        /**
         * Constructs a new Permissions.
         * @memberof tabletmanagerdata
         * @classdesc Represents a Permissions.
         * @implements IPermissions
         * @constructor
         * @param {tabletmanagerdata.IPermissions=} [properties] Properties to set
         */
        function Permissions(properties) {
            this.user_permissions = [];
            this.db_permissions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Permissions user_permissions.
         * @member {Array.<tabletmanagerdata.IUserPermission>} user_permissions
         * @memberof tabletmanagerdata.Permissions
         * @instance
         */
        Permissions.prototype.user_permissions = $util.emptyArray;

        /**
         * Permissions db_permissions.
         * @member {Array.<tabletmanagerdata.IDbPermission>} db_permissions
         * @memberof tabletmanagerdata.Permissions
         * @instance
         */
        Permissions.prototype.db_permissions = $util.emptyArray;

        /**
         * Creates a new Permissions instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.Permissions
         * @static
         * @param {tabletmanagerdata.IPermissions=} [properties] Properties to set
         * @returns {tabletmanagerdata.Permissions} Permissions instance
         */
        Permissions.create = function create(properties) {
            return new Permissions(properties);
        };

        /**
         * Encodes the specified Permissions message. Does not implicitly {@link tabletmanagerdata.Permissions.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.Permissions
         * @static
         * @param {tabletmanagerdata.IPermissions} message Permissions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Permissions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.user_permissions != null && message.user_permissions.length)
                for (var i = 0; i < message.user_permissions.length; ++i)
                    $root.tabletmanagerdata.UserPermission.encode(message.user_permissions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.db_permissions != null && message.db_permissions.length)
                for (var i = 0; i < message.db_permissions.length; ++i)
                    $root.tabletmanagerdata.DbPermission.encode(message.db_permissions[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Permissions message, length delimited. Does not implicitly {@link tabletmanagerdata.Permissions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.Permissions
         * @static
         * @param {tabletmanagerdata.IPermissions} message Permissions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Permissions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Permissions message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.Permissions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.Permissions} Permissions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Permissions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.Permissions();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.user_permissions && message.user_permissions.length))
                        message.user_permissions = [];
                    message.user_permissions.push($root.tabletmanagerdata.UserPermission.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.db_permissions && message.db_permissions.length))
                        message.db_permissions = [];
                    message.db_permissions.push($root.tabletmanagerdata.DbPermission.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Permissions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.Permissions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.Permissions} Permissions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Permissions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Permissions message.
         * @function verify
         * @memberof tabletmanagerdata.Permissions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Permissions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.user_permissions != null && message.hasOwnProperty("user_permissions")) {
                if (!Array.isArray(message.user_permissions))
                    return "user_permissions: array expected";
                for (var i = 0; i < message.user_permissions.length; ++i) {
                    var error = $root.tabletmanagerdata.UserPermission.verify(message.user_permissions[i]);
                    if (error)
                        return "user_permissions." + error;
                }
            }
            if (message.db_permissions != null && message.hasOwnProperty("db_permissions")) {
                if (!Array.isArray(message.db_permissions))
                    return "db_permissions: array expected";
                for (var i = 0; i < message.db_permissions.length; ++i) {
                    var error = $root.tabletmanagerdata.DbPermission.verify(message.db_permissions[i]);
                    if (error)
                        return "db_permissions." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Permissions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.Permissions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.Permissions} Permissions
         */
        Permissions.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.Permissions)
                return object;
            var message = new $root.tabletmanagerdata.Permissions();
            if (object.user_permissions) {
                if (!Array.isArray(object.user_permissions))
                    throw TypeError(".tabletmanagerdata.Permissions.user_permissions: array expected");
                message.user_permissions = [];
                for (var i = 0; i < object.user_permissions.length; ++i) {
                    if (typeof object.user_permissions[i] !== "object")
                        throw TypeError(".tabletmanagerdata.Permissions.user_permissions: object expected");
                    message.user_permissions[i] = $root.tabletmanagerdata.UserPermission.fromObject(object.user_permissions[i]);
                }
            }
            if (object.db_permissions) {
                if (!Array.isArray(object.db_permissions))
                    throw TypeError(".tabletmanagerdata.Permissions.db_permissions: array expected");
                message.db_permissions = [];
                for (var i = 0; i < object.db_permissions.length; ++i) {
                    if (typeof object.db_permissions[i] !== "object")
                        throw TypeError(".tabletmanagerdata.Permissions.db_permissions: object expected");
                    message.db_permissions[i] = $root.tabletmanagerdata.DbPermission.fromObject(object.db_permissions[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Permissions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.Permissions
         * @static
         * @param {tabletmanagerdata.Permissions} message Permissions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Permissions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.user_permissions = [];
                object.db_permissions = [];
            }
            if (message.user_permissions && message.user_permissions.length) {
                object.user_permissions = [];
                for (var j = 0; j < message.user_permissions.length; ++j)
                    object.user_permissions[j] = $root.tabletmanagerdata.UserPermission.toObject(message.user_permissions[j], options);
            }
            if (message.db_permissions && message.db_permissions.length) {
                object.db_permissions = [];
                for (var j = 0; j < message.db_permissions.length; ++j)
                    object.db_permissions[j] = $root.tabletmanagerdata.DbPermission.toObject(message.db_permissions[j], options);
            }
            return object;
        };

        /**
         * Converts this Permissions to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.Permissions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Permissions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Permissions;
    })();

    tabletmanagerdata.PingRequest = (function() {

        /**
         * Properties of a PingRequest.
         * @memberof tabletmanagerdata
         * @interface IPingRequest
         * @property {string|null} [payload] PingRequest payload
         */

        /**
         * Constructs a new PingRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents a PingRequest.
         * @implements IPingRequest
         * @constructor
         * @param {tabletmanagerdata.IPingRequest=} [properties] Properties to set
         */
        function PingRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PingRequest payload.
         * @member {string} payload
         * @memberof tabletmanagerdata.PingRequest
         * @instance
         */
        PingRequest.prototype.payload = "";

        /**
         * Creates a new PingRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.PingRequest
         * @static
         * @param {tabletmanagerdata.IPingRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.PingRequest} PingRequest instance
         */
        PingRequest.create = function create(properties) {
            return new PingRequest(properties);
        };

        /**
         * Encodes the specified PingRequest message. Does not implicitly {@link tabletmanagerdata.PingRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.PingRequest
         * @static
         * @param {tabletmanagerdata.IPingRequest} message PingRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PingRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.payload);
            return writer;
        };

        /**
         * Encodes the specified PingRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.PingRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.PingRequest
         * @static
         * @param {tabletmanagerdata.IPingRequest} message PingRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PingRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PingRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.PingRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.PingRequest} PingRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PingRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.PingRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.payload = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PingRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.PingRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.PingRequest} PingRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PingRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PingRequest message.
         * @function verify
         * @memberof tabletmanagerdata.PingRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PingRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!$util.isString(message.payload))
                    return "payload: string expected";
            return null;
        };

        /**
         * Creates a PingRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.PingRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.PingRequest} PingRequest
         */
        PingRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.PingRequest)
                return object;
            var message = new $root.tabletmanagerdata.PingRequest();
            if (object.payload != null)
                message.payload = String(object.payload);
            return message;
        };

        /**
         * Creates a plain object from a PingRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.PingRequest
         * @static
         * @param {tabletmanagerdata.PingRequest} message PingRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PingRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.payload = "";
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = message.payload;
            return object;
        };

        /**
         * Converts this PingRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.PingRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PingRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PingRequest;
    })();

    tabletmanagerdata.PingResponse = (function() {

        /**
         * Properties of a PingResponse.
         * @memberof tabletmanagerdata
         * @interface IPingResponse
         * @property {string|null} [payload] PingResponse payload
         */

        /**
         * Constructs a new PingResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents a PingResponse.
         * @implements IPingResponse
         * @constructor
         * @param {tabletmanagerdata.IPingResponse=} [properties] Properties to set
         */
        function PingResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PingResponse payload.
         * @member {string} payload
         * @memberof tabletmanagerdata.PingResponse
         * @instance
         */
        PingResponse.prototype.payload = "";

        /**
         * Creates a new PingResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.PingResponse
         * @static
         * @param {tabletmanagerdata.IPingResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.PingResponse} PingResponse instance
         */
        PingResponse.create = function create(properties) {
            return new PingResponse(properties);
        };

        /**
         * Encodes the specified PingResponse message. Does not implicitly {@link tabletmanagerdata.PingResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.PingResponse
         * @static
         * @param {tabletmanagerdata.IPingResponse} message PingResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PingResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.payload);
            return writer;
        };

        /**
         * Encodes the specified PingResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.PingResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.PingResponse
         * @static
         * @param {tabletmanagerdata.IPingResponse} message PingResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PingResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PingResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.PingResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.PingResponse} PingResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PingResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.PingResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.payload = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PingResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.PingResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.PingResponse} PingResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PingResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PingResponse message.
         * @function verify
         * @memberof tabletmanagerdata.PingResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PingResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!$util.isString(message.payload))
                    return "payload: string expected";
            return null;
        };

        /**
         * Creates a PingResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.PingResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.PingResponse} PingResponse
         */
        PingResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.PingResponse)
                return object;
            var message = new $root.tabletmanagerdata.PingResponse();
            if (object.payload != null)
                message.payload = String(object.payload);
            return message;
        };

        /**
         * Creates a plain object from a PingResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.PingResponse
         * @static
         * @param {tabletmanagerdata.PingResponse} message PingResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PingResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.payload = "";
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = message.payload;
            return object;
        };

        /**
         * Converts this PingResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.PingResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PingResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PingResponse;
    })();

    tabletmanagerdata.SleepRequest = (function() {

        /**
         * Properties of a SleepRequest.
         * @memberof tabletmanagerdata
         * @interface ISleepRequest
         * @property {number|Long|null} [duration] SleepRequest duration
         */

        /**
         * Constructs a new SleepRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents a SleepRequest.
         * @implements ISleepRequest
         * @constructor
         * @param {tabletmanagerdata.ISleepRequest=} [properties] Properties to set
         */
        function SleepRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SleepRequest duration.
         * @member {number|Long} duration
         * @memberof tabletmanagerdata.SleepRequest
         * @instance
         */
        SleepRequest.prototype.duration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new SleepRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.SleepRequest
         * @static
         * @param {tabletmanagerdata.ISleepRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.SleepRequest} SleepRequest instance
         */
        SleepRequest.create = function create(properties) {
            return new SleepRequest(properties);
        };

        /**
         * Encodes the specified SleepRequest message. Does not implicitly {@link tabletmanagerdata.SleepRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.SleepRequest
         * @static
         * @param {tabletmanagerdata.ISleepRequest} message SleepRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SleepRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.duration);
            return writer;
        };

        /**
         * Encodes the specified SleepRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.SleepRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.SleepRequest
         * @static
         * @param {tabletmanagerdata.ISleepRequest} message SleepRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SleepRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SleepRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.SleepRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.SleepRequest} SleepRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SleepRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.SleepRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.duration = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SleepRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.SleepRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.SleepRequest} SleepRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SleepRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SleepRequest message.
         * @function verify
         * @memberof tabletmanagerdata.SleepRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SleepRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (!$util.isInteger(message.duration) && !(message.duration && $util.isInteger(message.duration.low) && $util.isInteger(message.duration.high)))
                    return "duration: integer|Long expected";
            return null;
        };

        /**
         * Creates a SleepRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.SleepRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.SleepRequest} SleepRequest
         */
        SleepRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.SleepRequest)
                return object;
            var message = new $root.tabletmanagerdata.SleepRequest();
            if (object.duration != null)
                if ($util.Long)
                    (message.duration = $util.Long.fromValue(object.duration)).unsigned = false;
                else if (typeof object.duration === "string")
                    message.duration = parseInt(object.duration, 10);
                else if (typeof object.duration === "number")
                    message.duration = object.duration;
                else if (typeof object.duration === "object")
                    message.duration = new $util.LongBits(object.duration.low >>> 0, object.duration.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a SleepRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.SleepRequest
         * @static
         * @param {tabletmanagerdata.SleepRequest} message SleepRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SleepRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.duration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.duration = options.longs === String ? "0" : 0;
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (typeof message.duration === "number")
                    object.duration = options.longs === String ? String(message.duration) : message.duration;
                else
                    object.duration = options.longs === String ? $util.Long.prototype.toString.call(message.duration) : options.longs === Number ? new $util.LongBits(message.duration.low >>> 0, message.duration.high >>> 0).toNumber() : message.duration;
            return object;
        };

        /**
         * Converts this SleepRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.SleepRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SleepRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SleepRequest;
    })();

    tabletmanagerdata.SleepResponse = (function() {

        /**
         * Properties of a SleepResponse.
         * @memberof tabletmanagerdata
         * @interface ISleepResponse
         */

        /**
         * Constructs a new SleepResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents a SleepResponse.
         * @implements ISleepResponse
         * @constructor
         * @param {tabletmanagerdata.ISleepResponse=} [properties] Properties to set
         */
        function SleepResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new SleepResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.SleepResponse
         * @static
         * @param {tabletmanagerdata.ISleepResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.SleepResponse} SleepResponse instance
         */
        SleepResponse.create = function create(properties) {
            return new SleepResponse(properties);
        };

        /**
         * Encodes the specified SleepResponse message. Does not implicitly {@link tabletmanagerdata.SleepResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.SleepResponse
         * @static
         * @param {tabletmanagerdata.ISleepResponse} message SleepResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SleepResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified SleepResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.SleepResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.SleepResponse
         * @static
         * @param {tabletmanagerdata.ISleepResponse} message SleepResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SleepResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SleepResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.SleepResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.SleepResponse} SleepResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SleepResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.SleepResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SleepResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.SleepResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.SleepResponse} SleepResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SleepResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SleepResponse message.
         * @function verify
         * @memberof tabletmanagerdata.SleepResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SleepResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a SleepResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.SleepResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.SleepResponse} SleepResponse
         */
        SleepResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.SleepResponse)
                return object;
            return new $root.tabletmanagerdata.SleepResponse();
        };

        /**
         * Creates a plain object from a SleepResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.SleepResponse
         * @static
         * @param {tabletmanagerdata.SleepResponse} message SleepResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SleepResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this SleepResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.SleepResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SleepResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SleepResponse;
    })();

    tabletmanagerdata.ExecuteHookRequest = (function() {

        /**
         * Properties of an ExecuteHookRequest.
         * @memberof tabletmanagerdata
         * @interface IExecuteHookRequest
         * @property {string|null} [name] ExecuteHookRequest name
         * @property {Array.<string>|null} [parameters] ExecuteHookRequest parameters
         * @property {Object.<string,string>|null} [extra_env] ExecuteHookRequest extra_env
         */

        /**
         * Constructs a new ExecuteHookRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents an ExecuteHookRequest.
         * @implements IExecuteHookRequest
         * @constructor
         * @param {tabletmanagerdata.IExecuteHookRequest=} [properties] Properties to set
         */
        function ExecuteHookRequest(properties) {
            this.parameters = [];
            this.extra_env = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExecuteHookRequest name.
         * @member {string} name
         * @memberof tabletmanagerdata.ExecuteHookRequest
         * @instance
         */
        ExecuteHookRequest.prototype.name = "";

        /**
         * ExecuteHookRequest parameters.
         * @member {Array.<string>} parameters
         * @memberof tabletmanagerdata.ExecuteHookRequest
         * @instance
         */
        ExecuteHookRequest.prototype.parameters = $util.emptyArray;

        /**
         * ExecuteHookRequest extra_env.
         * @member {Object.<string,string>} extra_env
         * @memberof tabletmanagerdata.ExecuteHookRequest
         * @instance
         */
        ExecuteHookRequest.prototype.extra_env = $util.emptyObject;

        /**
         * Creates a new ExecuteHookRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.ExecuteHookRequest
         * @static
         * @param {tabletmanagerdata.IExecuteHookRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.ExecuteHookRequest} ExecuteHookRequest instance
         */
        ExecuteHookRequest.create = function create(properties) {
            return new ExecuteHookRequest(properties);
        };

        /**
         * Encodes the specified ExecuteHookRequest message. Does not implicitly {@link tabletmanagerdata.ExecuteHookRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.ExecuteHookRequest
         * @static
         * @param {tabletmanagerdata.IExecuteHookRequest} message ExecuteHookRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecuteHookRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.parameters != null && message.parameters.length)
                for (var i = 0; i < message.parameters.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.parameters[i]);
            if (message.extra_env != null && Object.hasOwnProperty.call(message, "extra_env"))
                for (var keys = Object.keys(message.extra_env), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.extra_env[keys[i]]).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ExecuteHookRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.ExecuteHookRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.ExecuteHookRequest
         * @static
         * @param {tabletmanagerdata.IExecuteHookRequest} message ExecuteHookRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecuteHookRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExecuteHookRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.ExecuteHookRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.ExecuteHookRequest} ExecuteHookRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecuteHookRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.ExecuteHookRequest(), key, value;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    if (!(message.parameters && message.parameters.length))
                        message.parameters = [];
                    message.parameters.push(reader.string());
                    break;
                case 3:
                    if (message.extra_env === $util.emptyObject)
                        message.extra_env = {};
                    var end2 = reader.uint32() + reader.pos;
                    key = "";
                    value = "";
                    while (reader.pos < end2) {
                        var tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.string();
                            break;
                        case 2:
                            value = reader.string();
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.extra_env[key] = value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExecuteHookRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.ExecuteHookRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.ExecuteHookRequest} ExecuteHookRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecuteHookRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExecuteHookRequest message.
         * @function verify
         * @memberof tabletmanagerdata.ExecuteHookRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExecuteHookRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.parameters != null && message.hasOwnProperty("parameters")) {
                if (!Array.isArray(message.parameters))
                    return "parameters: array expected";
                for (var i = 0; i < message.parameters.length; ++i)
                    if (!$util.isString(message.parameters[i]))
                        return "parameters: string[] expected";
            }
            if (message.extra_env != null && message.hasOwnProperty("extra_env")) {
                if (!$util.isObject(message.extra_env))
                    return "extra_env: object expected";
                var key = Object.keys(message.extra_env);
                for (var i = 0; i < key.length; ++i)
                    if (!$util.isString(message.extra_env[key[i]]))
                        return "extra_env: string{k:string} expected";
            }
            return null;
        };

        /**
         * Creates an ExecuteHookRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.ExecuteHookRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.ExecuteHookRequest} ExecuteHookRequest
         */
        ExecuteHookRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.ExecuteHookRequest)
                return object;
            var message = new $root.tabletmanagerdata.ExecuteHookRequest();
            if (object.name != null)
                message.name = String(object.name);
            if (object.parameters) {
                if (!Array.isArray(object.parameters))
                    throw TypeError(".tabletmanagerdata.ExecuteHookRequest.parameters: array expected");
                message.parameters = [];
                for (var i = 0; i < object.parameters.length; ++i)
                    message.parameters[i] = String(object.parameters[i]);
            }
            if (object.extra_env) {
                if (typeof object.extra_env !== "object")
                    throw TypeError(".tabletmanagerdata.ExecuteHookRequest.extra_env: object expected");
                message.extra_env = {};
                for (var keys = Object.keys(object.extra_env), i = 0; i < keys.length; ++i)
                    message.extra_env[keys[i]] = String(object.extra_env[keys[i]]);
            }
            return message;
        };

        /**
         * Creates a plain object from an ExecuteHookRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.ExecuteHookRequest
         * @static
         * @param {tabletmanagerdata.ExecuteHookRequest} message ExecuteHookRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExecuteHookRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.parameters = [];
            if (options.objects || options.defaults)
                object.extra_env = {};
            if (options.defaults)
                object.name = "";
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.parameters && message.parameters.length) {
                object.parameters = [];
                for (var j = 0; j < message.parameters.length; ++j)
                    object.parameters[j] = message.parameters[j];
            }
            var keys2;
            if (message.extra_env && (keys2 = Object.keys(message.extra_env)).length) {
                object.extra_env = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.extra_env[keys2[j]] = message.extra_env[keys2[j]];
            }
            return object;
        };

        /**
         * Converts this ExecuteHookRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.ExecuteHookRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExecuteHookRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExecuteHookRequest;
    })();

    tabletmanagerdata.ExecuteHookResponse = (function() {

        /**
         * Properties of an ExecuteHookResponse.
         * @memberof tabletmanagerdata
         * @interface IExecuteHookResponse
         * @property {number|Long|null} [exit_status] ExecuteHookResponse exit_status
         * @property {string|null} [stdout] ExecuteHookResponse stdout
         * @property {string|null} [stderr] ExecuteHookResponse stderr
         */

        /**
         * Constructs a new ExecuteHookResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents an ExecuteHookResponse.
         * @implements IExecuteHookResponse
         * @constructor
         * @param {tabletmanagerdata.IExecuteHookResponse=} [properties] Properties to set
         */
        function ExecuteHookResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExecuteHookResponse exit_status.
         * @member {number|Long} exit_status
         * @memberof tabletmanagerdata.ExecuteHookResponse
         * @instance
         */
        ExecuteHookResponse.prototype.exit_status = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ExecuteHookResponse stdout.
         * @member {string} stdout
         * @memberof tabletmanagerdata.ExecuteHookResponse
         * @instance
         */
        ExecuteHookResponse.prototype.stdout = "";

        /**
         * ExecuteHookResponse stderr.
         * @member {string} stderr
         * @memberof tabletmanagerdata.ExecuteHookResponse
         * @instance
         */
        ExecuteHookResponse.prototype.stderr = "";

        /**
         * Creates a new ExecuteHookResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.ExecuteHookResponse
         * @static
         * @param {tabletmanagerdata.IExecuteHookResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.ExecuteHookResponse} ExecuteHookResponse instance
         */
        ExecuteHookResponse.create = function create(properties) {
            return new ExecuteHookResponse(properties);
        };

        /**
         * Encodes the specified ExecuteHookResponse message. Does not implicitly {@link tabletmanagerdata.ExecuteHookResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.ExecuteHookResponse
         * @static
         * @param {tabletmanagerdata.IExecuteHookResponse} message ExecuteHookResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecuteHookResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.exit_status != null && Object.hasOwnProperty.call(message, "exit_status"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.exit_status);
            if (message.stdout != null && Object.hasOwnProperty.call(message, "stdout"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.stdout);
            if (message.stderr != null && Object.hasOwnProperty.call(message, "stderr"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.stderr);
            return writer;
        };

        /**
         * Encodes the specified ExecuteHookResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.ExecuteHookResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.ExecuteHookResponse
         * @static
         * @param {tabletmanagerdata.IExecuteHookResponse} message ExecuteHookResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecuteHookResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExecuteHookResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.ExecuteHookResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.ExecuteHookResponse} ExecuteHookResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecuteHookResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.ExecuteHookResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.exit_status = reader.int64();
                    break;
                case 2:
                    message.stdout = reader.string();
                    break;
                case 3:
                    message.stderr = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExecuteHookResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.ExecuteHookResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.ExecuteHookResponse} ExecuteHookResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecuteHookResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExecuteHookResponse message.
         * @function verify
         * @memberof tabletmanagerdata.ExecuteHookResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExecuteHookResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.exit_status != null && message.hasOwnProperty("exit_status"))
                if (!$util.isInteger(message.exit_status) && !(message.exit_status && $util.isInteger(message.exit_status.low) && $util.isInteger(message.exit_status.high)))
                    return "exit_status: integer|Long expected";
            if (message.stdout != null && message.hasOwnProperty("stdout"))
                if (!$util.isString(message.stdout))
                    return "stdout: string expected";
            if (message.stderr != null && message.hasOwnProperty("stderr"))
                if (!$util.isString(message.stderr))
                    return "stderr: string expected";
            return null;
        };

        /**
         * Creates an ExecuteHookResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.ExecuteHookResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.ExecuteHookResponse} ExecuteHookResponse
         */
        ExecuteHookResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.ExecuteHookResponse)
                return object;
            var message = new $root.tabletmanagerdata.ExecuteHookResponse();
            if (object.exit_status != null)
                if ($util.Long)
                    (message.exit_status = $util.Long.fromValue(object.exit_status)).unsigned = false;
                else if (typeof object.exit_status === "string")
                    message.exit_status = parseInt(object.exit_status, 10);
                else if (typeof object.exit_status === "number")
                    message.exit_status = object.exit_status;
                else if (typeof object.exit_status === "object")
                    message.exit_status = new $util.LongBits(object.exit_status.low >>> 0, object.exit_status.high >>> 0).toNumber();
            if (object.stdout != null)
                message.stdout = String(object.stdout);
            if (object.stderr != null)
                message.stderr = String(object.stderr);
            return message;
        };

        /**
         * Creates a plain object from an ExecuteHookResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.ExecuteHookResponse
         * @static
         * @param {tabletmanagerdata.ExecuteHookResponse} message ExecuteHookResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExecuteHookResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.exit_status = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.exit_status = options.longs === String ? "0" : 0;
                object.stdout = "";
                object.stderr = "";
            }
            if (message.exit_status != null && message.hasOwnProperty("exit_status"))
                if (typeof message.exit_status === "number")
                    object.exit_status = options.longs === String ? String(message.exit_status) : message.exit_status;
                else
                    object.exit_status = options.longs === String ? $util.Long.prototype.toString.call(message.exit_status) : options.longs === Number ? new $util.LongBits(message.exit_status.low >>> 0, message.exit_status.high >>> 0).toNumber() : message.exit_status;
            if (message.stdout != null && message.hasOwnProperty("stdout"))
                object.stdout = message.stdout;
            if (message.stderr != null && message.hasOwnProperty("stderr"))
                object.stderr = message.stderr;
            return object;
        };

        /**
         * Converts this ExecuteHookResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.ExecuteHookResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExecuteHookResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExecuteHookResponse;
    })();

    tabletmanagerdata.GetSchemaRequest = (function() {

        /**
         * Properties of a GetSchemaRequest.
         * @memberof tabletmanagerdata
         * @interface IGetSchemaRequest
         * @property {Array.<string>|null} [tables] GetSchemaRequest tables
         * @property {boolean|null} [include_views] GetSchemaRequest include_views
         * @property {Array.<string>|null} [exclude_tables] GetSchemaRequest exclude_tables
         */

        /**
         * Constructs a new GetSchemaRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents a GetSchemaRequest.
         * @implements IGetSchemaRequest
         * @constructor
         * @param {tabletmanagerdata.IGetSchemaRequest=} [properties] Properties to set
         */
        function GetSchemaRequest(properties) {
            this.tables = [];
            this.exclude_tables = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetSchemaRequest tables.
         * @member {Array.<string>} tables
         * @memberof tabletmanagerdata.GetSchemaRequest
         * @instance
         */
        GetSchemaRequest.prototype.tables = $util.emptyArray;

        /**
         * GetSchemaRequest include_views.
         * @member {boolean} include_views
         * @memberof tabletmanagerdata.GetSchemaRequest
         * @instance
         */
        GetSchemaRequest.prototype.include_views = false;

        /**
         * GetSchemaRequest exclude_tables.
         * @member {Array.<string>} exclude_tables
         * @memberof tabletmanagerdata.GetSchemaRequest
         * @instance
         */
        GetSchemaRequest.prototype.exclude_tables = $util.emptyArray;

        /**
         * Creates a new GetSchemaRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.GetSchemaRequest
         * @static
         * @param {tabletmanagerdata.IGetSchemaRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.GetSchemaRequest} GetSchemaRequest instance
         */
        GetSchemaRequest.create = function create(properties) {
            return new GetSchemaRequest(properties);
        };

        /**
         * Encodes the specified GetSchemaRequest message. Does not implicitly {@link tabletmanagerdata.GetSchemaRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.GetSchemaRequest
         * @static
         * @param {tabletmanagerdata.IGetSchemaRequest} message GetSchemaRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSchemaRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tables != null && message.tables.length)
                for (var i = 0; i < message.tables.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.tables[i]);
            if (message.include_views != null && Object.hasOwnProperty.call(message, "include_views"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.include_views);
            if (message.exclude_tables != null && message.exclude_tables.length)
                for (var i = 0; i < message.exclude_tables.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.exclude_tables[i]);
            return writer;
        };

        /**
         * Encodes the specified GetSchemaRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.GetSchemaRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.GetSchemaRequest
         * @static
         * @param {tabletmanagerdata.IGetSchemaRequest} message GetSchemaRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSchemaRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetSchemaRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.GetSchemaRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.GetSchemaRequest} GetSchemaRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSchemaRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.GetSchemaRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.tables && message.tables.length))
                        message.tables = [];
                    message.tables.push(reader.string());
                    break;
                case 2:
                    message.include_views = reader.bool();
                    break;
                case 3:
                    if (!(message.exclude_tables && message.exclude_tables.length))
                        message.exclude_tables = [];
                    message.exclude_tables.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetSchemaRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.GetSchemaRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.GetSchemaRequest} GetSchemaRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSchemaRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetSchemaRequest message.
         * @function verify
         * @memberof tabletmanagerdata.GetSchemaRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetSchemaRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tables != null && message.hasOwnProperty("tables")) {
                if (!Array.isArray(message.tables))
                    return "tables: array expected";
                for (var i = 0; i < message.tables.length; ++i)
                    if (!$util.isString(message.tables[i]))
                        return "tables: string[] expected";
            }
            if (message.include_views != null && message.hasOwnProperty("include_views"))
                if (typeof message.include_views !== "boolean")
                    return "include_views: boolean expected";
            if (message.exclude_tables != null && message.hasOwnProperty("exclude_tables")) {
                if (!Array.isArray(message.exclude_tables))
                    return "exclude_tables: array expected";
                for (var i = 0; i < message.exclude_tables.length; ++i)
                    if (!$util.isString(message.exclude_tables[i]))
                        return "exclude_tables: string[] expected";
            }
            return null;
        };

        /**
         * Creates a GetSchemaRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.GetSchemaRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.GetSchemaRequest} GetSchemaRequest
         */
        GetSchemaRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.GetSchemaRequest)
                return object;
            var message = new $root.tabletmanagerdata.GetSchemaRequest();
            if (object.tables) {
                if (!Array.isArray(object.tables))
                    throw TypeError(".tabletmanagerdata.GetSchemaRequest.tables: array expected");
                message.tables = [];
                for (var i = 0; i < object.tables.length; ++i)
                    message.tables[i] = String(object.tables[i]);
            }
            if (object.include_views != null)
                message.include_views = Boolean(object.include_views);
            if (object.exclude_tables) {
                if (!Array.isArray(object.exclude_tables))
                    throw TypeError(".tabletmanagerdata.GetSchemaRequest.exclude_tables: array expected");
                message.exclude_tables = [];
                for (var i = 0; i < object.exclude_tables.length; ++i)
                    message.exclude_tables[i] = String(object.exclude_tables[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetSchemaRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.GetSchemaRequest
         * @static
         * @param {tabletmanagerdata.GetSchemaRequest} message GetSchemaRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetSchemaRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.tables = [];
                object.exclude_tables = [];
            }
            if (options.defaults)
                object.include_views = false;
            if (message.tables && message.tables.length) {
                object.tables = [];
                for (var j = 0; j < message.tables.length; ++j)
                    object.tables[j] = message.tables[j];
            }
            if (message.include_views != null && message.hasOwnProperty("include_views"))
                object.include_views = message.include_views;
            if (message.exclude_tables && message.exclude_tables.length) {
                object.exclude_tables = [];
                for (var j = 0; j < message.exclude_tables.length; ++j)
                    object.exclude_tables[j] = message.exclude_tables[j];
            }
            return object;
        };

        /**
         * Converts this GetSchemaRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.GetSchemaRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetSchemaRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetSchemaRequest;
    })();

    tabletmanagerdata.GetSchemaResponse = (function() {

        /**
         * Properties of a GetSchemaResponse.
         * @memberof tabletmanagerdata
         * @interface IGetSchemaResponse
         * @property {tabletmanagerdata.ISchemaDefinition|null} [schema_definition] GetSchemaResponse schema_definition
         */

        /**
         * Constructs a new GetSchemaResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents a GetSchemaResponse.
         * @implements IGetSchemaResponse
         * @constructor
         * @param {tabletmanagerdata.IGetSchemaResponse=} [properties] Properties to set
         */
        function GetSchemaResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetSchemaResponse schema_definition.
         * @member {tabletmanagerdata.ISchemaDefinition|null|undefined} schema_definition
         * @memberof tabletmanagerdata.GetSchemaResponse
         * @instance
         */
        GetSchemaResponse.prototype.schema_definition = null;

        /**
         * Creates a new GetSchemaResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.GetSchemaResponse
         * @static
         * @param {tabletmanagerdata.IGetSchemaResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.GetSchemaResponse} GetSchemaResponse instance
         */
        GetSchemaResponse.create = function create(properties) {
            return new GetSchemaResponse(properties);
        };

        /**
         * Encodes the specified GetSchemaResponse message. Does not implicitly {@link tabletmanagerdata.GetSchemaResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.GetSchemaResponse
         * @static
         * @param {tabletmanagerdata.IGetSchemaResponse} message GetSchemaResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSchemaResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.schema_definition != null && Object.hasOwnProperty.call(message, "schema_definition"))
                $root.tabletmanagerdata.SchemaDefinition.encode(message.schema_definition, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetSchemaResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.GetSchemaResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.GetSchemaResponse
         * @static
         * @param {tabletmanagerdata.IGetSchemaResponse} message GetSchemaResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSchemaResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetSchemaResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.GetSchemaResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.GetSchemaResponse} GetSchemaResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSchemaResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.GetSchemaResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.schema_definition = $root.tabletmanagerdata.SchemaDefinition.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetSchemaResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.GetSchemaResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.GetSchemaResponse} GetSchemaResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSchemaResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetSchemaResponse message.
         * @function verify
         * @memberof tabletmanagerdata.GetSchemaResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetSchemaResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.schema_definition != null && message.hasOwnProperty("schema_definition")) {
                var error = $root.tabletmanagerdata.SchemaDefinition.verify(message.schema_definition);
                if (error)
                    return "schema_definition." + error;
            }
            return null;
        };

        /**
         * Creates a GetSchemaResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.GetSchemaResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.GetSchemaResponse} GetSchemaResponse
         */
        GetSchemaResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.GetSchemaResponse)
                return object;
            var message = new $root.tabletmanagerdata.GetSchemaResponse();
            if (object.schema_definition != null) {
                if (typeof object.schema_definition !== "object")
                    throw TypeError(".tabletmanagerdata.GetSchemaResponse.schema_definition: object expected");
                message.schema_definition = $root.tabletmanagerdata.SchemaDefinition.fromObject(object.schema_definition);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetSchemaResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.GetSchemaResponse
         * @static
         * @param {tabletmanagerdata.GetSchemaResponse} message GetSchemaResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetSchemaResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.schema_definition = null;
            if (message.schema_definition != null && message.hasOwnProperty("schema_definition"))
                object.schema_definition = $root.tabletmanagerdata.SchemaDefinition.toObject(message.schema_definition, options);
            return object;
        };

        /**
         * Converts this GetSchemaResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.GetSchemaResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetSchemaResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetSchemaResponse;
    })();

    tabletmanagerdata.GetPermissionsRequest = (function() {

        /**
         * Properties of a GetPermissionsRequest.
         * @memberof tabletmanagerdata
         * @interface IGetPermissionsRequest
         */

        /**
         * Constructs a new GetPermissionsRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents a GetPermissionsRequest.
         * @implements IGetPermissionsRequest
         * @constructor
         * @param {tabletmanagerdata.IGetPermissionsRequest=} [properties] Properties to set
         */
        function GetPermissionsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new GetPermissionsRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.GetPermissionsRequest
         * @static
         * @param {tabletmanagerdata.IGetPermissionsRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.GetPermissionsRequest} GetPermissionsRequest instance
         */
        GetPermissionsRequest.create = function create(properties) {
            return new GetPermissionsRequest(properties);
        };

        /**
         * Encodes the specified GetPermissionsRequest message. Does not implicitly {@link tabletmanagerdata.GetPermissionsRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.GetPermissionsRequest
         * @static
         * @param {tabletmanagerdata.IGetPermissionsRequest} message GetPermissionsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetPermissionsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified GetPermissionsRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.GetPermissionsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.GetPermissionsRequest
         * @static
         * @param {tabletmanagerdata.IGetPermissionsRequest} message GetPermissionsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetPermissionsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetPermissionsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.GetPermissionsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.GetPermissionsRequest} GetPermissionsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetPermissionsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.GetPermissionsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetPermissionsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.GetPermissionsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.GetPermissionsRequest} GetPermissionsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetPermissionsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetPermissionsRequest message.
         * @function verify
         * @memberof tabletmanagerdata.GetPermissionsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetPermissionsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a GetPermissionsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.GetPermissionsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.GetPermissionsRequest} GetPermissionsRequest
         */
        GetPermissionsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.GetPermissionsRequest)
                return object;
            return new $root.tabletmanagerdata.GetPermissionsRequest();
        };

        /**
         * Creates a plain object from a GetPermissionsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.GetPermissionsRequest
         * @static
         * @param {tabletmanagerdata.GetPermissionsRequest} message GetPermissionsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetPermissionsRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this GetPermissionsRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.GetPermissionsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetPermissionsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetPermissionsRequest;
    })();

    tabletmanagerdata.GetPermissionsResponse = (function() {

        /**
         * Properties of a GetPermissionsResponse.
         * @memberof tabletmanagerdata
         * @interface IGetPermissionsResponse
         * @property {tabletmanagerdata.IPermissions|null} [permissions] GetPermissionsResponse permissions
         */

        /**
         * Constructs a new GetPermissionsResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents a GetPermissionsResponse.
         * @implements IGetPermissionsResponse
         * @constructor
         * @param {tabletmanagerdata.IGetPermissionsResponse=} [properties] Properties to set
         */
        function GetPermissionsResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetPermissionsResponse permissions.
         * @member {tabletmanagerdata.IPermissions|null|undefined} permissions
         * @memberof tabletmanagerdata.GetPermissionsResponse
         * @instance
         */
        GetPermissionsResponse.prototype.permissions = null;

        /**
         * Creates a new GetPermissionsResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.GetPermissionsResponse
         * @static
         * @param {tabletmanagerdata.IGetPermissionsResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.GetPermissionsResponse} GetPermissionsResponse instance
         */
        GetPermissionsResponse.create = function create(properties) {
            return new GetPermissionsResponse(properties);
        };

        /**
         * Encodes the specified GetPermissionsResponse message. Does not implicitly {@link tabletmanagerdata.GetPermissionsResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.GetPermissionsResponse
         * @static
         * @param {tabletmanagerdata.IGetPermissionsResponse} message GetPermissionsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetPermissionsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.permissions != null && Object.hasOwnProperty.call(message, "permissions"))
                $root.tabletmanagerdata.Permissions.encode(message.permissions, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetPermissionsResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.GetPermissionsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.GetPermissionsResponse
         * @static
         * @param {tabletmanagerdata.IGetPermissionsResponse} message GetPermissionsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetPermissionsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetPermissionsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.GetPermissionsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.GetPermissionsResponse} GetPermissionsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetPermissionsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.GetPermissionsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.permissions = $root.tabletmanagerdata.Permissions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetPermissionsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.GetPermissionsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.GetPermissionsResponse} GetPermissionsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetPermissionsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetPermissionsResponse message.
         * @function verify
         * @memberof tabletmanagerdata.GetPermissionsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetPermissionsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.permissions != null && message.hasOwnProperty("permissions")) {
                var error = $root.tabletmanagerdata.Permissions.verify(message.permissions);
                if (error)
                    return "permissions." + error;
            }
            return null;
        };

        /**
         * Creates a GetPermissionsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.GetPermissionsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.GetPermissionsResponse} GetPermissionsResponse
         */
        GetPermissionsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.GetPermissionsResponse)
                return object;
            var message = new $root.tabletmanagerdata.GetPermissionsResponse();
            if (object.permissions != null) {
                if (typeof object.permissions !== "object")
                    throw TypeError(".tabletmanagerdata.GetPermissionsResponse.permissions: object expected");
                message.permissions = $root.tabletmanagerdata.Permissions.fromObject(object.permissions);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetPermissionsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.GetPermissionsResponse
         * @static
         * @param {tabletmanagerdata.GetPermissionsResponse} message GetPermissionsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetPermissionsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.permissions = null;
            if (message.permissions != null && message.hasOwnProperty("permissions"))
                object.permissions = $root.tabletmanagerdata.Permissions.toObject(message.permissions, options);
            return object;
        };

        /**
         * Converts this GetPermissionsResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.GetPermissionsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetPermissionsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetPermissionsResponse;
    })();

    tabletmanagerdata.SetReadOnlyRequest = (function() {

        /**
         * Properties of a SetReadOnlyRequest.
         * @memberof tabletmanagerdata
         * @interface ISetReadOnlyRequest
         */

        /**
         * Constructs a new SetReadOnlyRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents a SetReadOnlyRequest.
         * @implements ISetReadOnlyRequest
         * @constructor
         * @param {tabletmanagerdata.ISetReadOnlyRequest=} [properties] Properties to set
         */
        function SetReadOnlyRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new SetReadOnlyRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.SetReadOnlyRequest
         * @static
         * @param {tabletmanagerdata.ISetReadOnlyRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.SetReadOnlyRequest} SetReadOnlyRequest instance
         */
        SetReadOnlyRequest.create = function create(properties) {
            return new SetReadOnlyRequest(properties);
        };

        /**
         * Encodes the specified SetReadOnlyRequest message. Does not implicitly {@link tabletmanagerdata.SetReadOnlyRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.SetReadOnlyRequest
         * @static
         * @param {tabletmanagerdata.ISetReadOnlyRequest} message SetReadOnlyRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetReadOnlyRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified SetReadOnlyRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.SetReadOnlyRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.SetReadOnlyRequest
         * @static
         * @param {tabletmanagerdata.ISetReadOnlyRequest} message SetReadOnlyRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetReadOnlyRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetReadOnlyRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.SetReadOnlyRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.SetReadOnlyRequest} SetReadOnlyRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetReadOnlyRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.SetReadOnlyRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetReadOnlyRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.SetReadOnlyRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.SetReadOnlyRequest} SetReadOnlyRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetReadOnlyRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetReadOnlyRequest message.
         * @function verify
         * @memberof tabletmanagerdata.SetReadOnlyRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetReadOnlyRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a SetReadOnlyRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.SetReadOnlyRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.SetReadOnlyRequest} SetReadOnlyRequest
         */
        SetReadOnlyRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.SetReadOnlyRequest)
                return object;
            return new $root.tabletmanagerdata.SetReadOnlyRequest();
        };

        /**
         * Creates a plain object from a SetReadOnlyRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.SetReadOnlyRequest
         * @static
         * @param {tabletmanagerdata.SetReadOnlyRequest} message SetReadOnlyRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetReadOnlyRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this SetReadOnlyRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.SetReadOnlyRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetReadOnlyRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SetReadOnlyRequest;
    })();

    tabletmanagerdata.SetReadOnlyResponse = (function() {

        /**
         * Properties of a SetReadOnlyResponse.
         * @memberof tabletmanagerdata
         * @interface ISetReadOnlyResponse
         */

        /**
         * Constructs a new SetReadOnlyResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents a SetReadOnlyResponse.
         * @implements ISetReadOnlyResponse
         * @constructor
         * @param {tabletmanagerdata.ISetReadOnlyResponse=} [properties] Properties to set
         */
        function SetReadOnlyResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new SetReadOnlyResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.SetReadOnlyResponse
         * @static
         * @param {tabletmanagerdata.ISetReadOnlyResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.SetReadOnlyResponse} SetReadOnlyResponse instance
         */
        SetReadOnlyResponse.create = function create(properties) {
            return new SetReadOnlyResponse(properties);
        };

        /**
         * Encodes the specified SetReadOnlyResponse message. Does not implicitly {@link tabletmanagerdata.SetReadOnlyResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.SetReadOnlyResponse
         * @static
         * @param {tabletmanagerdata.ISetReadOnlyResponse} message SetReadOnlyResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetReadOnlyResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified SetReadOnlyResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.SetReadOnlyResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.SetReadOnlyResponse
         * @static
         * @param {tabletmanagerdata.ISetReadOnlyResponse} message SetReadOnlyResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetReadOnlyResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetReadOnlyResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.SetReadOnlyResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.SetReadOnlyResponse} SetReadOnlyResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetReadOnlyResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.SetReadOnlyResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetReadOnlyResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.SetReadOnlyResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.SetReadOnlyResponse} SetReadOnlyResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetReadOnlyResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetReadOnlyResponse message.
         * @function verify
         * @memberof tabletmanagerdata.SetReadOnlyResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetReadOnlyResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a SetReadOnlyResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.SetReadOnlyResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.SetReadOnlyResponse} SetReadOnlyResponse
         */
        SetReadOnlyResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.SetReadOnlyResponse)
                return object;
            return new $root.tabletmanagerdata.SetReadOnlyResponse();
        };

        /**
         * Creates a plain object from a SetReadOnlyResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.SetReadOnlyResponse
         * @static
         * @param {tabletmanagerdata.SetReadOnlyResponse} message SetReadOnlyResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetReadOnlyResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this SetReadOnlyResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.SetReadOnlyResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetReadOnlyResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SetReadOnlyResponse;
    })();

    tabletmanagerdata.SetReadWriteRequest = (function() {

        /**
         * Properties of a SetReadWriteRequest.
         * @memberof tabletmanagerdata
         * @interface ISetReadWriteRequest
         */

        /**
         * Constructs a new SetReadWriteRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents a SetReadWriteRequest.
         * @implements ISetReadWriteRequest
         * @constructor
         * @param {tabletmanagerdata.ISetReadWriteRequest=} [properties] Properties to set
         */
        function SetReadWriteRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new SetReadWriteRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.SetReadWriteRequest
         * @static
         * @param {tabletmanagerdata.ISetReadWriteRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.SetReadWriteRequest} SetReadWriteRequest instance
         */
        SetReadWriteRequest.create = function create(properties) {
            return new SetReadWriteRequest(properties);
        };

        /**
         * Encodes the specified SetReadWriteRequest message. Does not implicitly {@link tabletmanagerdata.SetReadWriteRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.SetReadWriteRequest
         * @static
         * @param {tabletmanagerdata.ISetReadWriteRequest} message SetReadWriteRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetReadWriteRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified SetReadWriteRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.SetReadWriteRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.SetReadWriteRequest
         * @static
         * @param {tabletmanagerdata.ISetReadWriteRequest} message SetReadWriteRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetReadWriteRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetReadWriteRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.SetReadWriteRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.SetReadWriteRequest} SetReadWriteRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetReadWriteRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.SetReadWriteRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetReadWriteRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.SetReadWriteRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.SetReadWriteRequest} SetReadWriteRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetReadWriteRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetReadWriteRequest message.
         * @function verify
         * @memberof tabletmanagerdata.SetReadWriteRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetReadWriteRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a SetReadWriteRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.SetReadWriteRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.SetReadWriteRequest} SetReadWriteRequest
         */
        SetReadWriteRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.SetReadWriteRequest)
                return object;
            return new $root.tabletmanagerdata.SetReadWriteRequest();
        };

        /**
         * Creates a plain object from a SetReadWriteRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.SetReadWriteRequest
         * @static
         * @param {tabletmanagerdata.SetReadWriteRequest} message SetReadWriteRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetReadWriteRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this SetReadWriteRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.SetReadWriteRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetReadWriteRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SetReadWriteRequest;
    })();

    tabletmanagerdata.SetReadWriteResponse = (function() {

        /**
         * Properties of a SetReadWriteResponse.
         * @memberof tabletmanagerdata
         * @interface ISetReadWriteResponse
         */

        /**
         * Constructs a new SetReadWriteResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents a SetReadWriteResponse.
         * @implements ISetReadWriteResponse
         * @constructor
         * @param {tabletmanagerdata.ISetReadWriteResponse=} [properties] Properties to set
         */
        function SetReadWriteResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new SetReadWriteResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.SetReadWriteResponse
         * @static
         * @param {tabletmanagerdata.ISetReadWriteResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.SetReadWriteResponse} SetReadWriteResponse instance
         */
        SetReadWriteResponse.create = function create(properties) {
            return new SetReadWriteResponse(properties);
        };

        /**
         * Encodes the specified SetReadWriteResponse message. Does not implicitly {@link tabletmanagerdata.SetReadWriteResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.SetReadWriteResponse
         * @static
         * @param {tabletmanagerdata.ISetReadWriteResponse} message SetReadWriteResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetReadWriteResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified SetReadWriteResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.SetReadWriteResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.SetReadWriteResponse
         * @static
         * @param {tabletmanagerdata.ISetReadWriteResponse} message SetReadWriteResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetReadWriteResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetReadWriteResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.SetReadWriteResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.SetReadWriteResponse} SetReadWriteResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetReadWriteResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.SetReadWriteResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetReadWriteResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.SetReadWriteResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.SetReadWriteResponse} SetReadWriteResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetReadWriteResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetReadWriteResponse message.
         * @function verify
         * @memberof tabletmanagerdata.SetReadWriteResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetReadWriteResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a SetReadWriteResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.SetReadWriteResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.SetReadWriteResponse} SetReadWriteResponse
         */
        SetReadWriteResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.SetReadWriteResponse)
                return object;
            return new $root.tabletmanagerdata.SetReadWriteResponse();
        };

        /**
         * Creates a plain object from a SetReadWriteResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.SetReadWriteResponse
         * @static
         * @param {tabletmanagerdata.SetReadWriteResponse} message SetReadWriteResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetReadWriteResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this SetReadWriteResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.SetReadWriteResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetReadWriteResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SetReadWriteResponse;
    })();

    tabletmanagerdata.ChangeTypeRequest = (function() {

        /**
         * Properties of a ChangeTypeRequest.
         * @memberof tabletmanagerdata
         * @interface IChangeTypeRequest
         * @property {topodata.TabletType|null} [tablet_type] ChangeTypeRequest tablet_type
         */

        /**
         * Constructs a new ChangeTypeRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents a ChangeTypeRequest.
         * @implements IChangeTypeRequest
         * @constructor
         * @param {tabletmanagerdata.IChangeTypeRequest=} [properties] Properties to set
         */
        function ChangeTypeRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChangeTypeRequest tablet_type.
         * @member {topodata.TabletType} tablet_type
         * @memberof tabletmanagerdata.ChangeTypeRequest
         * @instance
         */
        ChangeTypeRequest.prototype.tablet_type = 0;

        /**
         * Creates a new ChangeTypeRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.ChangeTypeRequest
         * @static
         * @param {tabletmanagerdata.IChangeTypeRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.ChangeTypeRequest} ChangeTypeRequest instance
         */
        ChangeTypeRequest.create = function create(properties) {
            return new ChangeTypeRequest(properties);
        };

        /**
         * Encodes the specified ChangeTypeRequest message. Does not implicitly {@link tabletmanagerdata.ChangeTypeRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.ChangeTypeRequest
         * @static
         * @param {tabletmanagerdata.IChangeTypeRequest} message ChangeTypeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeTypeRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tablet_type != null && Object.hasOwnProperty.call(message, "tablet_type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tablet_type);
            return writer;
        };

        /**
         * Encodes the specified ChangeTypeRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.ChangeTypeRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.ChangeTypeRequest
         * @static
         * @param {tabletmanagerdata.IChangeTypeRequest} message ChangeTypeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeTypeRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChangeTypeRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.ChangeTypeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.ChangeTypeRequest} ChangeTypeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeTypeRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.ChangeTypeRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tablet_type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChangeTypeRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.ChangeTypeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.ChangeTypeRequest} ChangeTypeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeTypeRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChangeTypeRequest message.
         * @function verify
         * @memberof tabletmanagerdata.ChangeTypeRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChangeTypeRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tablet_type != null && message.hasOwnProperty("tablet_type"))
                switch (message.tablet_type) {
                default:
                    return "tablet_type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                    break;
                }
            return null;
        };

        /**
         * Creates a ChangeTypeRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.ChangeTypeRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.ChangeTypeRequest} ChangeTypeRequest
         */
        ChangeTypeRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.ChangeTypeRequest)
                return object;
            var message = new $root.tabletmanagerdata.ChangeTypeRequest();
            switch (object.tablet_type) {
            case "UNKNOWN":
            case 0:
                message.tablet_type = 0;
                break;
            case "MASTER":
            case 1:
                message.tablet_type = 1;
                break;
            case "REPLICA":
            case 2:
                message.tablet_type = 2;
                break;
            case "RDONLY":
            case 3:
                message.tablet_type = 3;
                break;
            case "BATCH":
            case 3:
                message.tablet_type = 3;
                break;
            case "SPARE":
            case 4:
                message.tablet_type = 4;
                break;
            case "EXPERIMENTAL":
            case 5:
                message.tablet_type = 5;
                break;
            case "BACKUP":
            case 6:
                message.tablet_type = 6;
                break;
            case "RESTORE":
            case 7:
                message.tablet_type = 7;
                break;
            case "DRAINED":
            case 8:
                message.tablet_type = 8;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a ChangeTypeRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.ChangeTypeRequest
         * @static
         * @param {tabletmanagerdata.ChangeTypeRequest} message ChangeTypeRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChangeTypeRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.tablet_type = options.enums === String ? "UNKNOWN" : 0;
            if (message.tablet_type != null && message.hasOwnProperty("tablet_type"))
                object.tablet_type = options.enums === String ? $root.topodata.TabletType[message.tablet_type] : message.tablet_type;
            return object;
        };

        /**
         * Converts this ChangeTypeRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.ChangeTypeRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChangeTypeRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChangeTypeRequest;
    })();

    tabletmanagerdata.ChangeTypeResponse = (function() {

        /**
         * Properties of a ChangeTypeResponse.
         * @memberof tabletmanagerdata
         * @interface IChangeTypeResponse
         */

        /**
         * Constructs a new ChangeTypeResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents a ChangeTypeResponse.
         * @implements IChangeTypeResponse
         * @constructor
         * @param {tabletmanagerdata.IChangeTypeResponse=} [properties] Properties to set
         */
        function ChangeTypeResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ChangeTypeResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.ChangeTypeResponse
         * @static
         * @param {tabletmanagerdata.IChangeTypeResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.ChangeTypeResponse} ChangeTypeResponse instance
         */
        ChangeTypeResponse.create = function create(properties) {
            return new ChangeTypeResponse(properties);
        };

        /**
         * Encodes the specified ChangeTypeResponse message. Does not implicitly {@link tabletmanagerdata.ChangeTypeResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.ChangeTypeResponse
         * @static
         * @param {tabletmanagerdata.IChangeTypeResponse} message ChangeTypeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeTypeResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ChangeTypeResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.ChangeTypeResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.ChangeTypeResponse
         * @static
         * @param {tabletmanagerdata.IChangeTypeResponse} message ChangeTypeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeTypeResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChangeTypeResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.ChangeTypeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.ChangeTypeResponse} ChangeTypeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeTypeResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.ChangeTypeResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChangeTypeResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.ChangeTypeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.ChangeTypeResponse} ChangeTypeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeTypeResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChangeTypeResponse message.
         * @function verify
         * @memberof tabletmanagerdata.ChangeTypeResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChangeTypeResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ChangeTypeResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.ChangeTypeResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.ChangeTypeResponse} ChangeTypeResponse
         */
        ChangeTypeResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.ChangeTypeResponse)
                return object;
            return new $root.tabletmanagerdata.ChangeTypeResponse();
        };

        /**
         * Creates a plain object from a ChangeTypeResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.ChangeTypeResponse
         * @static
         * @param {tabletmanagerdata.ChangeTypeResponse} message ChangeTypeResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChangeTypeResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ChangeTypeResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.ChangeTypeResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChangeTypeResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChangeTypeResponse;
    })();

    tabletmanagerdata.RefreshStateRequest = (function() {

        /**
         * Properties of a RefreshStateRequest.
         * @memberof tabletmanagerdata
         * @interface IRefreshStateRequest
         */

        /**
         * Constructs a new RefreshStateRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents a RefreshStateRequest.
         * @implements IRefreshStateRequest
         * @constructor
         * @param {tabletmanagerdata.IRefreshStateRequest=} [properties] Properties to set
         */
        function RefreshStateRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new RefreshStateRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.RefreshStateRequest
         * @static
         * @param {tabletmanagerdata.IRefreshStateRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.RefreshStateRequest} RefreshStateRequest instance
         */
        RefreshStateRequest.create = function create(properties) {
            return new RefreshStateRequest(properties);
        };

        /**
         * Encodes the specified RefreshStateRequest message. Does not implicitly {@link tabletmanagerdata.RefreshStateRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.RefreshStateRequest
         * @static
         * @param {tabletmanagerdata.IRefreshStateRequest} message RefreshStateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RefreshStateRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified RefreshStateRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.RefreshStateRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.RefreshStateRequest
         * @static
         * @param {tabletmanagerdata.IRefreshStateRequest} message RefreshStateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RefreshStateRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RefreshStateRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.RefreshStateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.RefreshStateRequest} RefreshStateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RefreshStateRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.RefreshStateRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RefreshStateRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.RefreshStateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.RefreshStateRequest} RefreshStateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RefreshStateRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RefreshStateRequest message.
         * @function verify
         * @memberof tabletmanagerdata.RefreshStateRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RefreshStateRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a RefreshStateRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.RefreshStateRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.RefreshStateRequest} RefreshStateRequest
         */
        RefreshStateRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.RefreshStateRequest)
                return object;
            return new $root.tabletmanagerdata.RefreshStateRequest();
        };

        /**
         * Creates a plain object from a RefreshStateRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.RefreshStateRequest
         * @static
         * @param {tabletmanagerdata.RefreshStateRequest} message RefreshStateRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RefreshStateRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this RefreshStateRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.RefreshStateRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RefreshStateRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RefreshStateRequest;
    })();

    tabletmanagerdata.RefreshStateResponse = (function() {

        /**
         * Properties of a RefreshStateResponse.
         * @memberof tabletmanagerdata
         * @interface IRefreshStateResponse
         */

        /**
         * Constructs a new RefreshStateResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents a RefreshStateResponse.
         * @implements IRefreshStateResponse
         * @constructor
         * @param {tabletmanagerdata.IRefreshStateResponse=} [properties] Properties to set
         */
        function RefreshStateResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new RefreshStateResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.RefreshStateResponse
         * @static
         * @param {tabletmanagerdata.IRefreshStateResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.RefreshStateResponse} RefreshStateResponse instance
         */
        RefreshStateResponse.create = function create(properties) {
            return new RefreshStateResponse(properties);
        };

        /**
         * Encodes the specified RefreshStateResponse message. Does not implicitly {@link tabletmanagerdata.RefreshStateResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.RefreshStateResponse
         * @static
         * @param {tabletmanagerdata.IRefreshStateResponse} message RefreshStateResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RefreshStateResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified RefreshStateResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.RefreshStateResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.RefreshStateResponse
         * @static
         * @param {tabletmanagerdata.IRefreshStateResponse} message RefreshStateResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RefreshStateResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RefreshStateResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.RefreshStateResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.RefreshStateResponse} RefreshStateResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RefreshStateResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.RefreshStateResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RefreshStateResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.RefreshStateResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.RefreshStateResponse} RefreshStateResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RefreshStateResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RefreshStateResponse message.
         * @function verify
         * @memberof tabletmanagerdata.RefreshStateResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RefreshStateResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a RefreshStateResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.RefreshStateResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.RefreshStateResponse} RefreshStateResponse
         */
        RefreshStateResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.RefreshStateResponse)
                return object;
            return new $root.tabletmanagerdata.RefreshStateResponse();
        };

        /**
         * Creates a plain object from a RefreshStateResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.RefreshStateResponse
         * @static
         * @param {tabletmanagerdata.RefreshStateResponse} message RefreshStateResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RefreshStateResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this RefreshStateResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.RefreshStateResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RefreshStateResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RefreshStateResponse;
    })();

    tabletmanagerdata.RunHealthCheckRequest = (function() {

        /**
         * Properties of a RunHealthCheckRequest.
         * @memberof tabletmanagerdata
         * @interface IRunHealthCheckRequest
         */

        /**
         * Constructs a new RunHealthCheckRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents a RunHealthCheckRequest.
         * @implements IRunHealthCheckRequest
         * @constructor
         * @param {tabletmanagerdata.IRunHealthCheckRequest=} [properties] Properties to set
         */
        function RunHealthCheckRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new RunHealthCheckRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.RunHealthCheckRequest
         * @static
         * @param {tabletmanagerdata.IRunHealthCheckRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.RunHealthCheckRequest} RunHealthCheckRequest instance
         */
        RunHealthCheckRequest.create = function create(properties) {
            return new RunHealthCheckRequest(properties);
        };

        /**
         * Encodes the specified RunHealthCheckRequest message. Does not implicitly {@link tabletmanagerdata.RunHealthCheckRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.RunHealthCheckRequest
         * @static
         * @param {tabletmanagerdata.IRunHealthCheckRequest} message RunHealthCheckRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RunHealthCheckRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified RunHealthCheckRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.RunHealthCheckRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.RunHealthCheckRequest
         * @static
         * @param {tabletmanagerdata.IRunHealthCheckRequest} message RunHealthCheckRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RunHealthCheckRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RunHealthCheckRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.RunHealthCheckRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.RunHealthCheckRequest} RunHealthCheckRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RunHealthCheckRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.RunHealthCheckRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RunHealthCheckRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.RunHealthCheckRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.RunHealthCheckRequest} RunHealthCheckRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RunHealthCheckRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RunHealthCheckRequest message.
         * @function verify
         * @memberof tabletmanagerdata.RunHealthCheckRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RunHealthCheckRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a RunHealthCheckRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.RunHealthCheckRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.RunHealthCheckRequest} RunHealthCheckRequest
         */
        RunHealthCheckRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.RunHealthCheckRequest)
                return object;
            return new $root.tabletmanagerdata.RunHealthCheckRequest();
        };

        /**
         * Creates a plain object from a RunHealthCheckRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.RunHealthCheckRequest
         * @static
         * @param {tabletmanagerdata.RunHealthCheckRequest} message RunHealthCheckRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RunHealthCheckRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this RunHealthCheckRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.RunHealthCheckRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RunHealthCheckRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RunHealthCheckRequest;
    })();

    tabletmanagerdata.RunHealthCheckResponse = (function() {

        /**
         * Properties of a RunHealthCheckResponse.
         * @memberof tabletmanagerdata
         * @interface IRunHealthCheckResponse
         */

        /**
         * Constructs a new RunHealthCheckResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents a RunHealthCheckResponse.
         * @implements IRunHealthCheckResponse
         * @constructor
         * @param {tabletmanagerdata.IRunHealthCheckResponse=} [properties] Properties to set
         */
        function RunHealthCheckResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new RunHealthCheckResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.RunHealthCheckResponse
         * @static
         * @param {tabletmanagerdata.IRunHealthCheckResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.RunHealthCheckResponse} RunHealthCheckResponse instance
         */
        RunHealthCheckResponse.create = function create(properties) {
            return new RunHealthCheckResponse(properties);
        };

        /**
         * Encodes the specified RunHealthCheckResponse message. Does not implicitly {@link tabletmanagerdata.RunHealthCheckResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.RunHealthCheckResponse
         * @static
         * @param {tabletmanagerdata.IRunHealthCheckResponse} message RunHealthCheckResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RunHealthCheckResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified RunHealthCheckResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.RunHealthCheckResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.RunHealthCheckResponse
         * @static
         * @param {tabletmanagerdata.IRunHealthCheckResponse} message RunHealthCheckResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RunHealthCheckResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RunHealthCheckResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.RunHealthCheckResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.RunHealthCheckResponse} RunHealthCheckResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RunHealthCheckResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.RunHealthCheckResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RunHealthCheckResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.RunHealthCheckResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.RunHealthCheckResponse} RunHealthCheckResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RunHealthCheckResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RunHealthCheckResponse message.
         * @function verify
         * @memberof tabletmanagerdata.RunHealthCheckResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RunHealthCheckResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a RunHealthCheckResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.RunHealthCheckResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.RunHealthCheckResponse} RunHealthCheckResponse
         */
        RunHealthCheckResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.RunHealthCheckResponse)
                return object;
            return new $root.tabletmanagerdata.RunHealthCheckResponse();
        };

        /**
         * Creates a plain object from a RunHealthCheckResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.RunHealthCheckResponse
         * @static
         * @param {tabletmanagerdata.RunHealthCheckResponse} message RunHealthCheckResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RunHealthCheckResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this RunHealthCheckResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.RunHealthCheckResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RunHealthCheckResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RunHealthCheckResponse;
    })();

    tabletmanagerdata.IgnoreHealthErrorRequest = (function() {

        /**
         * Properties of an IgnoreHealthErrorRequest.
         * @memberof tabletmanagerdata
         * @interface IIgnoreHealthErrorRequest
         * @property {string|null} [pattern] IgnoreHealthErrorRequest pattern
         */

        /**
         * Constructs a new IgnoreHealthErrorRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents an IgnoreHealthErrorRequest.
         * @implements IIgnoreHealthErrorRequest
         * @constructor
         * @param {tabletmanagerdata.IIgnoreHealthErrorRequest=} [properties] Properties to set
         */
        function IgnoreHealthErrorRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IgnoreHealthErrorRequest pattern.
         * @member {string} pattern
         * @memberof tabletmanagerdata.IgnoreHealthErrorRequest
         * @instance
         */
        IgnoreHealthErrorRequest.prototype.pattern = "";

        /**
         * Creates a new IgnoreHealthErrorRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.IgnoreHealthErrorRequest
         * @static
         * @param {tabletmanagerdata.IIgnoreHealthErrorRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.IgnoreHealthErrorRequest} IgnoreHealthErrorRequest instance
         */
        IgnoreHealthErrorRequest.create = function create(properties) {
            return new IgnoreHealthErrorRequest(properties);
        };

        /**
         * Encodes the specified IgnoreHealthErrorRequest message. Does not implicitly {@link tabletmanagerdata.IgnoreHealthErrorRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.IgnoreHealthErrorRequest
         * @static
         * @param {tabletmanagerdata.IIgnoreHealthErrorRequest} message IgnoreHealthErrorRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IgnoreHealthErrorRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pattern != null && Object.hasOwnProperty.call(message, "pattern"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.pattern);
            return writer;
        };

        /**
         * Encodes the specified IgnoreHealthErrorRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.IgnoreHealthErrorRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.IgnoreHealthErrorRequest
         * @static
         * @param {tabletmanagerdata.IIgnoreHealthErrorRequest} message IgnoreHealthErrorRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IgnoreHealthErrorRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IgnoreHealthErrorRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.IgnoreHealthErrorRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.IgnoreHealthErrorRequest} IgnoreHealthErrorRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IgnoreHealthErrorRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.IgnoreHealthErrorRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pattern = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IgnoreHealthErrorRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.IgnoreHealthErrorRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.IgnoreHealthErrorRequest} IgnoreHealthErrorRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IgnoreHealthErrorRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IgnoreHealthErrorRequest message.
         * @function verify
         * @memberof tabletmanagerdata.IgnoreHealthErrorRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IgnoreHealthErrorRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pattern != null && message.hasOwnProperty("pattern"))
                if (!$util.isString(message.pattern))
                    return "pattern: string expected";
            return null;
        };

        /**
         * Creates an IgnoreHealthErrorRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.IgnoreHealthErrorRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.IgnoreHealthErrorRequest} IgnoreHealthErrorRequest
         */
        IgnoreHealthErrorRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.IgnoreHealthErrorRequest)
                return object;
            var message = new $root.tabletmanagerdata.IgnoreHealthErrorRequest();
            if (object.pattern != null)
                message.pattern = String(object.pattern);
            return message;
        };

        /**
         * Creates a plain object from an IgnoreHealthErrorRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.IgnoreHealthErrorRequest
         * @static
         * @param {tabletmanagerdata.IgnoreHealthErrorRequest} message IgnoreHealthErrorRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IgnoreHealthErrorRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.pattern = "";
            if (message.pattern != null && message.hasOwnProperty("pattern"))
                object.pattern = message.pattern;
            return object;
        };

        /**
         * Converts this IgnoreHealthErrorRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.IgnoreHealthErrorRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IgnoreHealthErrorRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IgnoreHealthErrorRequest;
    })();

    tabletmanagerdata.IgnoreHealthErrorResponse = (function() {

        /**
         * Properties of an IgnoreHealthErrorResponse.
         * @memberof tabletmanagerdata
         * @interface IIgnoreHealthErrorResponse
         */

        /**
         * Constructs a new IgnoreHealthErrorResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents an IgnoreHealthErrorResponse.
         * @implements IIgnoreHealthErrorResponse
         * @constructor
         * @param {tabletmanagerdata.IIgnoreHealthErrorResponse=} [properties] Properties to set
         */
        function IgnoreHealthErrorResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new IgnoreHealthErrorResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.IgnoreHealthErrorResponse
         * @static
         * @param {tabletmanagerdata.IIgnoreHealthErrorResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.IgnoreHealthErrorResponse} IgnoreHealthErrorResponse instance
         */
        IgnoreHealthErrorResponse.create = function create(properties) {
            return new IgnoreHealthErrorResponse(properties);
        };

        /**
         * Encodes the specified IgnoreHealthErrorResponse message. Does not implicitly {@link tabletmanagerdata.IgnoreHealthErrorResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.IgnoreHealthErrorResponse
         * @static
         * @param {tabletmanagerdata.IIgnoreHealthErrorResponse} message IgnoreHealthErrorResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IgnoreHealthErrorResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified IgnoreHealthErrorResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.IgnoreHealthErrorResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.IgnoreHealthErrorResponse
         * @static
         * @param {tabletmanagerdata.IIgnoreHealthErrorResponse} message IgnoreHealthErrorResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IgnoreHealthErrorResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IgnoreHealthErrorResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.IgnoreHealthErrorResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.IgnoreHealthErrorResponse} IgnoreHealthErrorResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IgnoreHealthErrorResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.IgnoreHealthErrorResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IgnoreHealthErrorResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.IgnoreHealthErrorResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.IgnoreHealthErrorResponse} IgnoreHealthErrorResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IgnoreHealthErrorResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IgnoreHealthErrorResponse message.
         * @function verify
         * @memberof tabletmanagerdata.IgnoreHealthErrorResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IgnoreHealthErrorResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates an IgnoreHealthErrorResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.IgnoreHealthErrorResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.IgnoreHealthErrorResponse} IgnoreHealthErrorResponse
         */
        IgnoreHealthErrorResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.IgnoreHealthErrorResponse)
                return object;
            return new $root.tabletmanagerdata.IgnoreHealthErrorResponse();
        };

        /**
         * Creates a plain object from an IgnoreHealthErrorResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.IgnoreHealthErrorResponse
         * @static
         * @param {tabletmanagerdata.IgnoreHealthErrorResponse} message IgnoreHealthErrorResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IgnoreHealthErrorResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this IgnoreHealthErrorResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.IgnoreHealthErrorResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IgnoreHealthErrorResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IgnoreHealthErrorResponse;
    })();

    tabletmanagerdata.ReloadSchemaRequest = (function() {

        /**
         * Properties of a ReloadSchemaRequest.
         * @memberof tabletmanagerdata
         * @interface IReloadSchemaRequest
         * @property {string|null} [wait_position] ReloadSchemaRequest wait_position
         */

        /**
         * Constructs a new ReloadSchemaRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents a ReloadSchemaRequest.
         * @implements IReloadSchemaRequest
         * @constructor
         * @param {tabletmanagerdata.IReloadSchemaRequest=} [properties] Properties to set
         */
        function ReloadSchemaRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReloadSchemaRequest wait_position.
         * @member {string} wait_position
         * @memberof tabletmanagerdata.ReloadSchemaRequest
         * @instance
         */
        ReloadSchemaRequest.prototype.wait_position = "";

        /**
         * Creates a new ReloadSchemaRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.ReloadSchemaRequest
         * @static
         * @param {tabletmanagerdata.IReloadSchemaRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.ReloadSchemaRequest} ReloadSchemaRequest instance
         */
        ReloadSchemaRequest.create = function create(properties) {
            return new ReloadSchemaRequest(properties);
        };

        /**
         * Encodes the specified ReloadSchemaRequest message. Does not implicitly {@link tabletmanagerdata.ReloadSchemaRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.ReloadSchemaRequest
         * @static
         * @param {tabletmanagerdata.IReloadSchemaRequest} message ReloadSchemaRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReloadSchemaRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.wait_position != null && Object.hasOwnProperty.call(message, "wait_position"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.wait_position);
            return writer;
        };

        /**
         * Encodes the specified ReloadSchemaRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.ReloadSchemaRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.ReloadSchemaRequest
         * @static
         * @param {tabletmanagerdata.IReloadSchemaRequest} message ReloadSchemaRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReloadSchemaRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReloadSchemaRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.ReloadSchemaRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.ReloadSchemaRequest} ReloadSchemaRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReloadSchemaRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.ReloadSchemaRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.wait_position = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReloadSchemaRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.ReloadSchemaRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.ReloadSchemaRequest} ReloadSchemaRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReloadSchemaRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReloadSchemaRequest message.
         * @function verify
         * @memberof tabletmanagerdata.ReloadSchemaRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReloadSchemaRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.wait_position != null && message.hasOwnProperty("wait_position"))
                if (!$util.isString(message.wait_position))
                    return "wait_position: string expected";
            return null;
        };

        /**
         * Creates a ReloadSchemaRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.ReloadSchemaRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.ReloadSchemaRequest} ReloadSchemaRequest
         */
        ReloadSchemaRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.ReloadSchemaRequest)
                return object;
            var message = new $root.tabletmanagerdata.ReloadSchemaRequest();
            if (object.wait_position != null)
                message.wait_position = String(object.wait_position);
            return message;
        };

        /**
         * Creates a plain object from a ReloadSchemaRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.ReloadSchemaRequest
         * @static
         * @param {tabletmanagerdata.ReloadSchemaRequest} message ReloadSchemaRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReloadSchemaRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.wait_position = "";
            if (message.wait_position != null && message.hasOwnProperty("wait_position"))
                object.wait_position = message.wait_position;
            return object;
        };

        /**
         * Converts this ReloadSchemaRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.ReloadSchemaRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReloadSchemaRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ReloadSchemaRequest;
    })();

    tabletmanagerdata.ReloadSchemaResponse = (function() {

        /**
         * Properties of a ReloadSchemaResponse.
         * @memberof tabletmanagerdata
         * @interface IReloadSchemaResponse
         */

        /**
         * Constructs a new ReloadSchemaResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents a ReloadSchemaResponse.
         * @implements IReloadSchemaResponse
         * @constructor
         * @param {tabletmanagerdata.IReloadSchemaResponse=} [properties] Properties to set
         */
        function ReloadSchemaResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ReloadSchemaResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.ReloadSchemaResponse
         * @static
         * @param {tabletmanagerdata.IReloadSchemaResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.ReloadSchemaResponse} ReloadSchemaResponse instance
         */
        ReloadSchemaResponse.create = function create(properties) {
            return new ReloadSchemaResponse(properties);
        };

        /**
         * Encodes the specified ReloadSchemaResponse message. Does not implicitly {@link tabletmanagerdata.ReloadSchemaResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.ReloadSchemaResponse
         * @static
         * @param {tabletmanagerdata.IReloadSchemaResponse} message ReloadSchemaResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReloadSchemaResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ReloadSchemaResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.ReloadSchemaResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.ReloadSchemaResponse
         * @static
         * @param {tabletmanagerdata.IReloadSchemaResponse} message ReloadSchemaResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReloadSchemaResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReloadSchemaResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.ReloadSchemaResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.ReloadSchemaResponse} ReloadSchemaResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReloadSchemaResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.ReloadSchemaResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReloadSchemaResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.ReloadSchemaResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.ReloadSchemaResponse} ReloadSchemaResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReloadSchemaResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReloadSchemaResponse message.
         * @function verify
         * @memberof tabletmanagerdata.ReloadSchemaResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReloadSchemaResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ReloadSchemaResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.ReloadSchemaResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.ReloadSchemaResponse} ReloadSchemaResponse
         */
        ReloadSchemaResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.ReloadSchemaResponse)
                return object;
            return new $root.tabletmanagerdata.ReloadSchemaResponse();
        };

        /**
         * Creates a plain object from a ReloadSchemaResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.ReloadSchemaResponse
         * @static
         * @param {tabletmanagerdata.ReloadSchemaResponse} message ReloadSchemaResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReloadSchemaResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ReloadSchemaResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.ReloadSchemaResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReloadSchemaResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ReloadSchemaResponse;
    })();

    tabletmanagerdata.PreflightSchemaRequest = (function() {

        /**
         * Properties of a PreflightSchemaRequest.
         * @memberof tabletmanagerdata
         * @interface IPreflightSchemaRequest
         * @property {Array.<string>|null} [changes] PreflightSchemaRequest changes
         */

        /**
         * Constructs a new PreflightSchemaRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents a PreflightSchemaRequest.
         * @implements IPreflightSchemaRequest
         * @constructor
         * @param {tabletmanagerdata.IPreflightSchemaRequest=} [properties] Properties to set
         */
        function PreflightSchemaRequest(properties) {
            this.changes = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PreflightSchemaRequest changes.
         * @member {Array.<string>} changes
         * @memberof tabletmanagerdata.PreflightSchemaRequest
         * @instance
         */
        PreflightSchemaRequest.prototype.changes = $util.emptyArray;

        /**
         * Creates a new PreflightSchemaRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.PreflightSchemaRequest
         * @static
         * @param {tabletmanagerdata.IPreflightSchemaRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.PreflightSchemaRequest} PreflightSchemaRequest instance
         */
        PreflightSchemaRequest.create = function create(properties) {
            return new PreflightSchemaRequest(properties);
        };

        /**
         * Encodes the specified PreflightSchemaRequest message. Does not implicitly {@link tabletmanagerdata.PreflightSchemaRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.PreflightSchemaRequest
         * @static
         * @param {tabletmanagerdata.IPreflightSchemaRequest} message PreflightSchemaRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PreflightSchemaRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.changes != null && message.changes.length)
                for (var i = 0; i < message.changes.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.changes[i]);
            return writer;
        };

        /**
         * Encodes the specified PreflightSchemaRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.PreflightSchemaRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.PreflightSchemaRequest
         * @static
         * @param {tabletmanagerdata.IPreflightSchemaRequest} message PreflightSchemaRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PreflightSchemaRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PreflightSchemaRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.PreflightSchemaRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.PreflightSchemaRequest} PreflightSchemaRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PreflightSchemaRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.PreflightSchemaRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.changes && message.changes.length))
                        message.changes = [];
                    message.changes.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PreflightSchemaRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.PreflightSchemaRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.PreflightSchemaRequest} PreflightSchemaRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PreflightSchemaRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PreflightSchemaRequest message.
         * @function verify
         * @memberof tabletmanagerdata.PreflightSchemaRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PreflightSchemaRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.changes != null && message.hasOwnProperty("changes")) {
                if (!Array.isArray(message.changes))
                    return "changes: array expected";
                for (var i = 0; i < message.changes.length; ++i)
                    if (!$util.isString(message.changes[i]))
                        return "changes: string[] expected";
            }
            return null;
        };

        /**
         * Creates a PreflightSchemaRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.PreflightSchemaRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.PreflightSchemaRequest} PreflightSchemaRequest
         */
        PreflightSchemaRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.PreflightSchemaRequest)
                return object;
            var message = new $root.tabletmanagerdata.PreflightSchemaRequest();
            if (object.changes) {
                if (!Array.isArray(object.changes))
                    throw TypeError(".tabletmanagerdata.PreflightSchemaRequest.changes: array expected");
                message.changes = [];
                for (var i = 0; i < object.changes.length; ++i)
                    message.changes[i] = String(object.changes[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a PreflightSchemaRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.PreflightSchemaRequest
         * @static
         * @param {tabletmanagerdata.PreflightSchemaRequest} message PreflightSchemaRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PreflightSchemaRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.changes = [];
            if (message.changes && message.changes.length) {
                object.changes = [];
                for (var j = 0; j < message.changes.length; ++j)
                    object.changes[j] = message.changes[j];
            }
            return object;
        };

        /**
         * Converts this PreflightSchemaRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.PreflightSchemaRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PreflightSchemaRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PreflightSchemaRequest;
    })();

    tabletmanagerdata.PreflightSchemaResponse = (function() {

        /**
         * Properties of a PreflightSchemaResponse.
         * @memberof tabletmanagerdata
         * @interface IPreflightSchemaResponse
         * @property {Array.<tabletmanagerdata.ISchemaChangeResult>|null} [change_results] PreflightSchemaResponse change_results
         */

        /**
         * Constructs a new PreflightSchemaResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents a PreflightSchemaResponse.
         * @implements IPreflightSchemaResponse
         * @constructor
         * @param {tabletmanagerdata.IPreflightSchemaResponse=} [properties] Properties to set
         */
        function PreflightSchemaResponse(properties) {
            this.change_results = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PreflightSchemaResponse change_results.
         * @member {Array.<tabletmanagerdata.ISchemaChangeResult>} change_results
         * @memberof tabletmanagerdata.PreflightSchemaResponse
         * @instance
         */
        PreflightSchemaResponse.prototype.change_results = $util.emptyArray;

        /**
         * Creates a new PreflightSchemaResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.PreflightSchemaResponse
         * @static
         * @param {tabletmanagerdata.IPreflightSchemaResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.PreflightSchemaResponse} PreflightSchemaResponse instance
         */
        PreflightSchemaResponse.create = function create(properties) {
            return new PreflightSchemaResponse(properties);
        };

        /**
         * Encodes the specified PreflightSchemaResponse message. Does not implicitly {@link tabletmanagerdata.PreflightSchemaResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.PreflightSchemaResponse
         * @static
         * @param {tabletmanagerdata.IPreflightSchemaResponse} message PreflightSchemaResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PreflightSchemaResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.change_results != null && message.change_results.length)
                for (var i = 0; i < message.change_results.length; ++i)
                    $root.tabletmanagerdata.SchemaChangeResult.encode(message.change_results[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PreflightSchemaResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.PreflightSchemaResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.PreflightSchemaResponse
         * @static
         * @param {tabletmanagerdata.IPreflightSchemaResponse} message PreflightSchemaResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PreflightSchemaResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PreflightSchemaResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.PreflightSchemaResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.PreflightSchemaResponse} PreflightSchemaResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PreflightSchemaResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.PreflightSchemaResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.change_results && message.change_results.length))
                        message.change_results = [];
                    message.change_results.push($root.tabletmanagerdata.SchemaChangeResult.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PreflightSchemaResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.PreflightSchemaResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.PreflightSchemaResponse} PreflightSchemaResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PreflightSchemaResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PreflightSchemaResponse message.
         * @function verify
         * @memberof tabletmanagerdata.PreflightSchemaResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PreflightSchemaResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.change_results != null && message.hasOwnProperty("change_results")) {
                if (!Array.isArray(message.change_results))
                    return "change_results: array expected";
                for (var i = 0; i < message.change_results.length; ++i) {
                    var error = $root.tabletmanagerdata.SchemaChangeResult.verify(message.change_results[i]);
                    if (error)
                        return "change_results." + error;
                }
            }
            return null;
        };

        /**
         * Creates a PreflightSchemaResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.PreflightSchemaResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.PreflightSchemaResponse} PreflightSchemaResponse
         */
        PreflightSchemaResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.PreflightSchemaResponse)
                return object;
            var message = new $root.tabletmanagerdata.PreflightSchemaResponse();
            if (object.change_results) {
                if (!Array.isArray(object.change_results))
                    throw TypeError(".tabletmanagerdata.PreflightSchemaResponse.change_results: array expected");
                message.change_results = [];
                for (var i = 0; i < object.change_results.length; ++i) {
                    if (typeof object.change_results[i] !== "object")
                        throw TypeError(".tabletmanagerdata.PreflightSchemaResponse.change_results: object expected");
                    message.change_results[i] = $root.tabletmanagerdata.SchemaChangeResult.fromObject(object.change_results[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a PreflightSchemaResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.PreflightSchemaResponse
         * @static
         * @param {tabletmanagerdata.PreflightSchemaResponse} message PreflightSchemaResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PreflightSchemaResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.change_results = [];
            if (message.change_results && message.change_results.length) {
                object.change_results = [];
                for (var j = 0; j < message.change_results.length; ++j)
                    object.change_results[j] = $root.tabletmanagerdata.SchemaChangeResult.toObject(message.change_results[j], options);
            }
            return object;
        };

        /**
         * Converts this PreflightSchemaResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.PreflightSchemaResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PreflightSchemaResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PreflightSchemaResponse;
    })();

    tabletmanagerdata.ApplySchemaRequest = (function() {

        /**
         * Properties of an ApplySchemaRequest.
         * @memberof tabletmanagerdata
         * @interface IApplySchemaRequest
         * @property {string|null} [sql] ApplySchemaRequest sql
         * @property {boolean|null} [force] ApplySchemaRequest force
         * @property {boolean|null} [allow_replication] ApplySchemaRequest allow_replication
         * @property {tabletmanagerdata.ISchemaDefinition|null} [before_schema] ApplySchemaRequest before_schema
         * @property {tabletmanagerdata.ISchemaDefinition|null} [after_schema] ApplySchemaRequest after_schema
         */

        /**
         * Constructs a new ApplySchemaRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents an ApplySchemaRequest.
         * @implements IApplySchemaRequest
         * @constructor
         * @param {tabletmanagerdata.IApplySchemaRequest=} [properties] Properties to set
         */
        function ApplySchemaRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApplySchemaRequest sql.
         * @member {string} sql
         * @memberof tabletmanagerdata.ApplySchemaRequest
         * @instance
         */
        ApplySchemaRequest.prototype.sql = "";

        /**
         * ApplySchemaRequest force.
         * @member {boolean} force
         * @memberof tabletmanagerdata.ApplySchemaRequest
         * @instance
         */
        ApplySchemaRequest.prototype.force = false;

        /**
         * ApplySchemaRequest allow_replication.
         * @member {boolean} allow_replication
         * @memberof tabletmanagerdata.ApplySchemaRequest
         * @instance
         */
        ApplySchemaRequest.prototype.allow_replication = false;

        /**
         * ApplySchemaRequest before_schema.
         * @member {tabletmanagerdata.ISchemaDefinition|null|undefined} before_schema
         * @memberof tabletmanagerdata.ApplySchemaRequest
         * @instance
         */
        ApplySchemaRequest.prototype.before_schema = null;

        /**
         * ApplySchemaRequest after_schema.
         * @member {tabletmanagerdata.ISchemaDefinition|null|undefined} after_schema
         * @memberof tabletmanagerdata.ApplySchemaRequest
         * @instance
         */
        ApplySchemaRequest.prototype.after_schema = null;

        /**
         * Creates a new ApplySchemaRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.ApplySchemaRequest
         * @static
         * @param {tabletmanagerdata.IApplySchemaRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.ApplySchemaRequest} ApplySchemaRequest instance
         */
        ApplySchemaRequest.create = function create(properties) {
            return new ApplySchemaRequest(properties);
        };

        /**
         * Encodes the specified ApplySchemaRequest message. Does not implicitly {@link tabletmanagerdata.ApplySchemaRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.ApplySchemaRequest
         * @static
         * @param {tabletmanagerdata.IApplySchemaRequest} message ApplySchemaRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplySchemaRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sql != null && Object.hasOwnProperty.call(message, "sql"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.sql);
            if (message.force != null && Object.hasOwnProperty.call(message, "force"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.force);
            if (message.allow_replication != null && Object.hasOwnProperty.call(message, "allow_replication"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.allow_replication);
            if (message.before_schema != null && Object.hasOwnProperty.call(message, "before_schema"))
                $root.tabletmanagerdata.SchemaDefinition.encode(message.before_schema, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.after_schema != null && Object.hasOwnProperty.call(message, "after_schema"))
                $root.tabletmanagerdata.SchemaDefinition.encode(message.after_schema, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ApplySchemaRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.ApplySchemaRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.ApplySchemaRequest
         * @static
         * @param {tabletmanagerdata.IApplySchemaRequest} message ApplySchemaRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplySchemaRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApplySchemaRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.ApplySchemaRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.ApplySchemaRequest} ApplySchemaRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplySchemaRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.ApplySchemaRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sql = reader.string();
                    break;
                case 2:
                    message.force = reader.bool();
                    break;
                case 3:
                    message.allow_replication = reader.bool();
                    break;
                case 4:
                    message.before_schema = $root.tabletmanagerdata.SchemaDefinition.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.after_schema = $root.tabletmanagerdata.SchemaDefinition.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApplySchemaRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.ApplySchemaRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.ApplySchemaRequest} ApplySchemaRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplySchemaRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApplySchemaRequest message.
         * @function verify
         * @memberof tabletmanagerdata.ApplySchemaRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApplySchemaRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sql != null && message.hasOwnProperty("sql"))
                if (!$util.isString(message.sql))
                    return "sql: string expected";
            if (message.force != null && message.hasOwnProperty("force"))
                if (typeof message.force !== "boolean")
                    return "force: boolean expected";
            if (message.allow_replication != null && message.hasOwnProperty("allow_replication"))
                if (typeof message.allow_replication !== "boolean")
                    return "allow_replication: boolean expected";
            if (message.before_schema != null && message.hasOwnProperty("before_schema")) {
                var error = $root.tabletmanagerdata.SchemaDefinition.verify(message.before_schema);
                if (error)
                    return "before_schema." + error;
            }
            if (message.after_schema != null && message.hasOwnProperty("after_schema")) {
                var error = $root.tabletmanagerdata.SchemaDefinition.verify(message.after_schema);
                if (error)
                    return "after_schema." + error;
            }
            return null;
        };

        /**
         * Creates an ApplySchemaRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.ApplySchemaRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.ApplySchemaRequest} ApplySchemaRequest
         */
        ApplySchemaRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.ApplySchemaRequest)
                return object;
            var message = new $root.tabletmanagerdata.ApplySchemaRequest();
            if (object.sql != null)
                message.sql = String(object.sql);
            if (object.force != null)
                message.force = Boolean(object.force);
            if (object.allow_replication != null)
                message.allow_replication = Boolean(object.allow_replication);
            if (object.before_schema != null) {
                if (typeof object.before_schema !== "object")
                    throw TypeError(".tabletmanagerdata.ApplySchemaRequest.before_schema: object expected");
                message.before_schema = $root.tabletmanagerdata.SchemaDefinition.fromObject(object.before_schema);
            }
            if (object.after_schema != null) {
                if (typeof object.after_schema !== "object")
                    throw TypeError(".tabletmanagerdata.ApplySchemaRequest.after_schema: object expected");
                message.after_schema = $root.tabletmanagerdata.SchemaDefinition.fromObject(object.after_schema);
            }
            return message;
        };

        /**
         * Creates a plain object from an ApplySchemaRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.ApplySchemaRequest
         * @static
         * @param {tabletmanagerdata.ApplySchemaRequest} message ApplySchemaRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ApplySchemaRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.sql = "";
                object.force = false;
                object.allow_replication = false;
                object.before_schema = null;
                object.after_schema = null;
            }
            if (message.sql != null && message.hasOwnProperty("sql"))
                object.sql = message.sql;
            if (message.force != null && message.hasOwnProperty("force"))
                object.force = message.force;
            if (message.allow_replication != null && message.hasOwnProperty("allow_replication"))
                object.allow_replication = message.allow_replication;
            if (message.before_schema != null && message.hasOwnProperty("before_schema"))
                object.before_schema = $root.tabletmanagerdata.SchemaDefinition.toObject(message.before_schema, options);
            if (message.after_schema != null && message.hasOwnProperty("after_schema"))
                object.after_schema = $root.tabletmanagerdata.SchemaDefinition.toObject(message.after_schema, options);
            return object;
        };

        /**
         * Converts this ApplySchemaRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.ApplySchemaRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ApplySchemaRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ApplySchemaRequest;
    })();

    tabletmanagerdata.ApplySchemaResponse = (function() {

        /**
         * Properties of an ApplySchemaResponse.
         * @memberof tabletmanagerdata
         * @interface IApplySchemaResponse
         * @property {tabletmanagerdata.ISchemaDefinition|null} [before_schema] ApplySchemaResponse before_schema
         * @property {tabletmanagerdata.ISchemaDefinition|null} [after_schema] ApplySchemaResponse after_schema
         */

        /**
         * Constructs a new ApplySchemaResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents an ApplySchemaResponse.
         * @implements IApplySchemaResponse
         * @constructor
         * @param {tabletmanagerdata.IApplySchemaResponse=} [properties] Properties to set
         */
        function ApplySchemaResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApplySchemaResponse before_schema.
         * @member {tabletmanagerdata.ISchemaDefinition|null|undefined} before_schema
         * @memberof tabletmanagerdata.ApplySchemaResponse
         * @instance
         */
        ApplySchemaResponse.prototype.before_schema = null;

        /**
         * ApplySchemaResponse after_schema.
         * @member {tabletmanagerdata.ISchemaDefinition|null|undefined} after_schema
         * @memberof tabletmanagerdata.ApplySchemaResponse
         * @instance
         */
        ApplySchemaResponse.prototype.after_schema = null;

        /**
         * Creates a new ApplySchemaResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.ApplySchemaResponse
         * @static
         * @param {tabletmanagerdata.IApplySchemaResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.ApplySchemaResponse} ApplySchemaResponse instance
         */
        ApplySchemaResponse.create = function create(properties) {
            return new ApplySchemaResponse(properties);
        };

        /**
         * Encodes the specified ApplySchemaResponse message. Does not implicitly {@link tabletmanagerdata.ApplySchemaResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.ApplySchemaResponse
         * @static
         * @param {tabletmanagerdata.IApplySchemaResponse} message ApplySchemaResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplySchemaResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.before_schema != null && Object.hasOwnProperty.call(message, "before_schema"))
                $root.tabletmanagerdata.SchemaDefinition.encode(message.before_schema, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.after_schema != null && Object.hasOwnProperty.call(message, "after_schema"))
                $root.tabletmanagerdata.SchemaDefinition.encode(message.after_schema, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ApplySchemaResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.ApplySchemaResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.ApplySchemaResponse
         * @static
         * @param {tabletmanagerdata.IApplySchemaResponse} message ApplySchemaResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplySchemaResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApplySchemaResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.ApplySchemaResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.ApplySchemaResponse} ApplySchemaResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplySchemaResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.ApplySchemaResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.before_schema = $root.tabletmanagerdata.SchemaDefinition.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.after_schema = $root.tabletmanagerdata.SchemaDefinition.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApplySchemaResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.ApplySchemaResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.ApplySchemaResponse} ApplySchemaResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplySchemaResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApplySchemaResponse message.
         * @function verify
         * @memberof tabletmanagerdata.ApplySchemaResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApplySchemaResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.before_schema != null && message.hasOwnProperty("before_schema")) {
                var error = $root.tabletmanagerdata.SchemaDefinition.verify(message.before_schema);
                if (error)
                    return "before_schema." + error;
            }
            if (message.after_schema != null && message.hasOwnProperty("after_schema")) {
                var error = $root.tabletmanagerdata.SchemaDefinition.verify(message.after_schema);
                if (error)
                    return "after_schema." + error;
            }
            return null;
        };

        /**
         * Creates an ApplySchemaResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.ApplySchemaResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.ApplySchemaResponse} ApplySchemaResponse
         */
        ApplySchemaResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.ApplySchemaResponse)
                return object;
            var message = new $root.tabletmanagerdata.ApplySchemaResponse();
            if (object.before_schema != null) {
                if (typeof object.before_schema !== "object")
                    throw TypeError(".tabletmanagerdata.ApplySchemaResponse.before_schema: object expected");
                message.before_schema = $root.tabletmanagerdata.SchemaDefinition.fromObject(object.before_schema);
            }
            if (object.after_schema != null) {
                if (typeof object.after_schema !== "object")
                    throw TypeError(".tabletmanagerdata.ApplySchemaResponse.after_schema: object expected");
                message.after_schema = $root.tabletmanagerdata.SchemaDefinition.fromObject(object.after_schema);
            }
            return message;
        };

        /**
         * Creates a plain object from an ApplySchemaResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.ApplySchemaResponse
         * @static
         * @param {tabletmanagerdata.ApplySchemaResponse} message ApplySchemaResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ApplySchemaResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.before_schema = null;
                object.after_schema = null;
            }
            if (message.before_schema != null && message.hasOwnProperty("before_schema"))
                object.before_schema = $root.tabletmanagerdata.SchemaDefinition.toObject(message.before_schema, options);
            if (message.after_schema != null && message.hasOwnProperty("after_schema"))
                object.after_schema = $root.tabletmanagerdata.SchemaDefinition.toObject(message.after_schema, options);
            return object;
        };

        /**
         * Converts this ApplySchemaResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.ApplySchemaResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ApplySchemaResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ApplySchemaResponse;
    })();

    tabletmanagerdata.LockTablesRequest = (function() {

        /**
         * Properties of a LockTablesRequest.
         * @memberof tabletmanagerdata
         * @interface ILockTablesRequest
         */

        /**
         * Constructs a new LockTablesRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents a LockTablesRequest.
         * @implements ILockTablesRequest
         * @constructor
         * @param {tabletmanagerdata.ILockTablesRequest=} [properties] Properties to set
         */
        function LockTablesRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new LockTablesRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.LockTablesRequest
         * @static
         * @param {tabletmanagerdata.ILockTablesRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.LockTablesRequest} LockTablesRequest instance
         */
        LockTablesRequest.create = function create(properties) {
            return new LockTablesRequest(properties);
        };

        /**
         * Encodes the specified LockTablesRequest message. Does not implicitly {@link tabletmanagerdata.LockTablesRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.LockTablesRequest
         * @static
         * @param {tabletmanagerdata.ILockTablesRequest} message LockTablesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LockTablesRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified LockTablesRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.LockTablesRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.LockTablesRequest
         * @static
         * @param {tabletmanagerdata.ILockTablesRequest} message LockTablesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LockTablesRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LockTablesRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.LockTablesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.LockTablesRequest} LockTablesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LockTablesRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.LockTablesRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LockTablesRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.LockTablesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.LockTablesRequest} LockTablesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LockTablesRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LockTablesRequest message.
         * @function verify
         * @memberof tabletmanagerdata.LockTablesRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LockTablesRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a LockTablesRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.LockTablesRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.LockTablesRequest} LockTablesRequest
         */
        LockTablesRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.LockTablesRequest)
                return object;
            return new $root.tabletmanagerdata.LockTablesRequest();
        };

        /**
         * Creates a plain object from a LockTablesRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.LockTablesRequest
         * @static
         * @param {tabletmanagerdata.LockTablesRequest} message LockTablesRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LockTablesRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this LockTablesRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.LockTablesRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LockTablesRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LockTablesRequest;
    })();

    tabletmanagerdata.LockTablesResponse = (function() {

        /**
         * Properties of a LockTablesResponse.
         * @memberof tabletmanagerdata
         * @interface ILockTablesResponse
         */

        /**
         * Constructs a new LockTablesResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents a LockTablesResponse.
         * @implements ILockTablesResponse
         * @constructor
         * @param {tabletmanagerdata.ILockTablesResponse=} [properties] Properties to set
         */
        function LockTablesResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new LockTablesResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.LockTablesResponse
         * @static
         * @param {tabletmanagerdata.ILockTablesResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.LockTablesResponse} LockTablesResponse instance
         */
        LockTablesResponse.create = function create(properties) {
            return new LockTablesResponse(properties);
        };

        /**
         * Encodes the specified LockTablesResponse message. Does not implicitly {@link tabletmanagerdata.LockTablesResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.LockTablesResponse
         * @static
         * @param {tabletmanagerdata.ILockTablesResponse} message LockTablesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LockTablesResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified LockTablesResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.LockTablesResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.LockTablesResponse
         * @static
         * @param {tabletmanagerdata.ILockTablesResponse} message LockTablesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LockTablesResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LockTablesResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.LockTablesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.LockTablesResponse} LockTablesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LockTablesResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.LockTablesResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LockTablesResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.LockTablesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.LockTablesResponse} LockTablesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LockTablesResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LockTablesResponse message.
         * @function verify
         * @memberof tabletmanagerdata.LockTablesResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LockTablesResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a LockTablesResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.LockTablesResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.LockTablesResponse} LockTablesResponse
         */
        LockTablesResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.LockTablesResponse)
                return object;
            return new $root.tabletmanagerdata.LockTablesResponse();
        };

        /**
         * Creates a plain object from a LockTablesResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.LockTablesResponse
         * @static
         * @param {tabletmanagerdata.LockTablesResponse} message LockTablesResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LockTablesResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this LockTablesResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.LockTablesResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LockTablesResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LockTablesResponse;
    })();

    tabletmanagerdata.UnlockTablesRequest = (function() {

        /**
         * Properties of an UnlockTablesRequest.
         * @memberof tabletmanagerdata
         * @interface IUnlockTablesRequest
         */

        /**
         * Constructs a new UnlockTablesRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents an UnlockTablesRequest.
         * @implements IUnlockTablesRequest
         * @constructor
         * @param {tabletmanagerdata.IUnlockTablesRequest=} [properties] Properties to set
         */
        function UnlockTablesRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new UnlockTablesRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.UnlockTablesRequest
         * @static
         * @param {tabletmanagerdata.IUnlockTablesRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.UnlockTablesRequest} UnlockTablesRequest instance
         */
        UnlockTablesRequest.create = function create(properties) {
            return new UnlockTablesRequest(properties);
        };

        /**
         * Encodes the specified UnlockTablesRequest message. Does not implicitly {@link tabletmanagerdata.UnlockTablesRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.UnlockTablesRequest
         * @static
         * @param {tabletmanagerdata.IUnlockTablesRequest} message UnlockTablesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnlockTablesRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified UnlockTablesRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.UnlockTablesRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.UnlockTablesRequest
         * @static
         * @param {tabletmanagerdata.IUnlockTablesRequest} message UnlockTablesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnlockTablesRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UnlockTablesRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.UnlockTablesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.UnlockTablesRequest} UnlockTablesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnlockTablesRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.UnlockTablesRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UnlockTablesRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.UnlockTablesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.UnlockTablesRequest} UnlockTablesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnlockTablesRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UnlockTablesRequest message.
         * @function verify
         * @memberof tabletmanagerdata.UnlockTablesRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UnlockTablesRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates an UnlockTablesRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.UnlockTablesRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.UnlockTablesRequest} UnlockTablesRequest
         */
        UnlockTablesRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.UnlockTablesRequest)
                return object;
            return new $root.tabletmanagerdata.UnlockTablesRequest();
        };

        /**
         * Creates a plain object from an UnlockTablesRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.UnlockTablesRequest
         * @static
         * @param {tabletmanagerdata.UnlockTablesRequest} message UnlockTablesRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UnlockTablesRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this UnlockTablesRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.UnlockTablesRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UnlockTablesRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UnlockTablesRequest;
    })();

    tabletmanagerdata.UnlockTablesResponse = (function() {

        /**
         * Properties of an UnlockTablesResponse.
         * @memberof tabletmanagerdata
         * @interface IUnlockTablesResponse
         */

        /**
         * Constructs a new UnlockTablesResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents an UnlockTablesResponse.
         * @implements IUnlockTablesResponse
         * @constructor
         * @param {tabletmanagerdata.IUnlockTablesResponse=} [properties] Properties to set
         */
        function UnlockTablesResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new UnlockTablesResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.UnlockTablesResponse
         * @static
         * @param {tabletmanagerdata.IUnlockTablesResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.UnlockTablesResponse} UnlockTablesResponse instance
         */
        UnlockTablesResponse.create = function create(properties) {
            return new UnlockTablesResponse(properties);
        };

        /**
         * Encodes the specified UnlockTablesResponse message. Does not implicitly {@link tabletmanagerdata.UnlockTablesResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.UnlockTablesResponse
         * @static
         * @param {tabletmanagerdata.IUnlockTablesResponse} message UnlockTablesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnlockTablesResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified UnlockTablesResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.UnlockTablesResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.UnlockTablesResponse
         * @static
         * @param {tabletmanagerdata.IUnlockTablesResponse} message UnlockTablesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnlockTablesResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UnlockTablesResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.UnlockTablesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.UnlockTablesResponse} UnlockTablesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnlockTablesResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.UnlockTablesResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UnlockTablesResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.UnlockTablesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.UnlockTablesResponse} UnlockTablesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnlockTablesResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UnlockTablesResponse message.
         * @function verify
         * @memberof tabletmanagerdata.UnlockTablesResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UnlockTablesResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates an UnlockTablesResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.UnlockTablesResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.UnlockTablesResponse} UnlockTablesResponse
         */
        UnlockTablesResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.UnlockTablesResponse)
                return object;
            return new $root.tabletmanagerdata.UnlockTablesResponse();
        };

        /**
         * Creates a plain object from an UnlockTablesResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.UnlockTablesResponse
         * @static
         * @param {tabletmanagerdata.UnlockTablesResponse} message UnlockTablesResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UnlockTablesResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this UnlockTablesResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.UnlockTablesResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UnlockTablesResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UnlockTablesResponse;
    })();

    tabletmanagerdata.ExecuteFetchAsDbaRequest = (function() {

        /**
         * Properties of an ExecuteFetchAsDbaRequest.
         * @memberof tabletmanagerdata
         * @interface IExecuteFetchAsDbaRequest
         * @property {Uint8Array|null} [query] ExecuteFetchAsDbaRequest query
         * @property {string|null} [db_name] ExecuteFetchAsDbaRequest db_name
         * @property {number|Long|null} [max_rows] ExecuteFetchAsDbaRequest max_rows
         * @property {boolean|null} [disable_binlogs] ExecuteFetchAsDbaRequest disable_binlogs
         * @property {boolean|null} [reload_schema] ExecuteFetchAsDbaRequest reload_schema
         */

        /**
         * Constructs a new ExecuteFetchAsDbaRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents an ExecuteFetchAsDbaRequest.
         * @implements IExecuteFetchAsDbaRequest
         * @constructor
         * @param {tabletmanagerdata.IExecuteFetchAsDbaRequest=} [properties] Properties to set
         */
        function ExecuteFetchAsDbaRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExecuteFetchAsDbaRequest query.
         * @member {Uint8Array} query
         * @memberof tabletmanagerdata.ExecuteFetchAsDbaRequest
         * @instance
         */
        ExecuteFetchAsDbaRequest.prototype.query = $util.newBuffer([]);

        /**
         * ExecuteFetchAsDbaRequest db_name.
         * @member {string} db_name
         * @memberof tabletmanagerdata.ExecuteFetchAsDbaRequest
         * @instance
         */
        ExecuteFetchAsDbaRequest.prototype.db_name = "";

        /**
         * ExecuteFetchAsDbaRequest max_rows.
         * @member {number|Long} max_rows
         * @memberof tabletmanagerdata.ExecuteFetchAsDbaRequest
         * @instance
         */
        ExecuteFetchAsDbaRequest.prototype.max_rows = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ExecuteFetchAsDbaRequest disable_binlogs.
         * @member {boolean} disable_binlogs
         * @memberof tabletmanagerdata.ExecuteFetchAsDbaRequest
         * @instance
         */
        ExecuteFetchAsDbaRequest.prototype.disable_binlogs = false;

        /**
         * ExecuteFetchAsDbaRequest reload_schema.
         * @member {boolean} reload_schema
         * @memberof tabletmanagerdata.ExecuteFetchAsDbaRequest
         * @instance
         */
        ExecuteFetchAsDbaRequest.prototype.reload_schema = false;

        /**
         * Creates a new ExecuteFetchAsDbaRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.ExecuteFetchAsDbaRequest
         * @static
         * @param {tabletmanagerdata.IExecuteFetchAsDbaRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.ExecuteFetchAsDbaRequest} ExecuteFetchAsDbaRequest instance
         */
        ExecuteFetchAsDbaRequest.create = function create(properties) {
            return new ExecuteFetchAsDbaRequest(properties);
        };

        /**
         * Encodes the specified ExecuteFetchAsDbaRequest message. Does not implicitly {@link tabletmanagerdata.ExecuteFetchAsDbaRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.ExecuteFetchAsDbaRequest
         * @static
         * @param {tabletmanagerdata.IExecuteFetchAsDbaRequest} message ExecuteFetchAsDbaRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecuteFetchAsDbaRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.query);
            if (message.db_name != null && Object.hasOwnProperty.call(message, "db_name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.db_name);
            if (message.max_rows != null && Object.hasOwnProperty.call(message, "max_rows"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.max_rows);
            if (message.disable_binlogs != null && Object.hasOwnProperty.call(message, "disable_binlogs"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.disable_binlogs);
            if (message.reload_schema != null && Object.hasOwnProperty.call(message, "reload_schema"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.reload_schema);
            return writer;
        };

        /**
         * Encodes the specified ExecuteFetchAsDbaRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.ExecuteFetchAsDbaRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.ExecuteFetchAsDbaRequest
         * @static
         * @param {tabletmanagerdata.IExecuteFetchAsDbaRequest} message ExecuteFetchAsDbaRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecuteFetchAsDbaRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExecuteFetchAsDbaRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.ExecuteFetchAsDbaRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.ExecuteFetchAsDbaRequest} ExecuteFetchAsDbaRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecuteFetchAsDbaRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.ExecuteFetchAsDbaRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.query = reader.bytes();
                    break;
                case 2:
                    message.db_name = reader.string();
                    break;
                case 3:
                    message.max_rows = reader.uint64();
                    break;
                case 4:
                    message.disable_binlogs = reader.bool();
                    break;
                case 5:
                    message.reload_schema = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExecuteFetchAsDbaRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.ExecuteFetchAsDbaRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.ExecuteFetchAsDbaRequest} ExecuteFetchAsDbaRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecuteFetchAsDbaRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExecuteFetchAsDbaRequest message.
         * @function verify
         * @memberof tabletmanagerdata.ExecuteFetchAsDbaRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExecuteFetchAsDbaRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.query != null && message.hasOwnProperty("query"))
                if (!(message.query && typeof message.query.length === "number" || $util.isString(message.query)))
                    return "query: buffer expected";
            if (message.db_name != null && message.hasOwnProperty("db_name"))
                if (!$util.isString(message.db_name))
                    return "db_name: string expected";
            if (message.max_rows != null && message.hasOwnProperty("max_rows"))
                if (!$util.isInteger(message.max_rows) && !(message.max_rows && $util.isInteger(message.max_rows.low) && $util.isInteger(message.max_rows.high)))
                    return "max_rows: integer|Long expected";
            if (message.disable_binlogs != null && message.hasOwnProperty("disable_binlogs"))
                if (typeof message.disable_binlogs !== "boolean")
                    return "disable_binlogs: boolean expected";
            if (message.reload_schema != null && message.hasOwnProperty("reload_schema"))
                if (typeof message.reload_schema !== "boolean")
                    return "reload_schema: boolean expected";
            return null;
        };

        /**
         * Creates an ExecuteFetchAsDbaRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.ExecuteFetchAsDbaRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.ExecuteFetchAsDbaRequest} ExecuteFetchAsDbaRequest
         */
        ExecuteFetchAsDbaRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.ExecuteFetchAsDbaRequest)
                return object;
            var message = new $root.tabletmanagerdata.ExecuteFetchAsDbaRequest();
            if (object.query != null)
                if (typeof object.query === "string")
                    $util.base64.decode(object.query, message.query = $util.newBuffer($util.base64.length(object.query)), 0);
                else if (object.query.length)
                    message.query = object.query;
            if (object.db_name != null)
                message.db_name = String(object.db_name);
            if (object.max_rows != null)
                if ($util.Long)
                    (message.max_rows = $util.Long.fromValue(object.max_rows)).unsigned = true;
                else if (typeof object.max_rows === "string")
                    message.max_rows = parseInt(object.max_rows, 10);
                else if (typeof object.max_rows === "number")
                    message.max_rows = object.max_rows;
                else if (typeof object.max_rows === "object")
                    message.max_rows = new $util.LongBits(object.max_rows.low >>> 0, object.max_rows.high >>> 0).toNumber(true);
            if (object.disable_binlogs != null)
                message.disable_binlogs = Boolean(object.disable_binlogs);
            if (object.reload_schema != null)
                message.reload_schema = Boolean(object.reload_schema);
            return message;
        };

        /**
         * Creates a plain object from an ExecuteFetchAsDbaRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.ExecuteFetchAsDbaRequest
         * @static
         * @param {tabletmanagerdata.ExecuteFetchAsDbaRequest} message ExecuteFetchAsDbaRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExecuteFetchAsDbaRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.query = "";
                else {
                    object.query = [];
                    if (options.bytes !== Array)
                        object.query = $util.newBuffer(object.query);
                }
                object.db_name = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.max_rows = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.max_rows = options.longs === String ? "0" : 0;
                object.disable_binlogs = false;
                object.reload_schema = false;
            }
            if (message.query != null && message.hasOwnProperty("query"))
                object.query = options.bytes === String ? $util.base64.encode(message.query, 0, message.query.length) : options.bytes === Array ? Array.prototype.slice.call(message.query) : message.query;
            if (message.db_name != null && message.hasOwnProperty("db_name"))
                object.db_name = message.db_name;
            if (message.max_rows != null && message.hasOwnProperty("max_rows"))
                if (typeof message.max_rows === "number")
                    object.max_rows = options.longs === String ? String(message.max_rows) : message.max_rows;
                else
                    object.max_rows = options.longs === String ? $util.Long.prototype.toString.call(message.max_rows) : options.longs === Number ? new $util.LongBits(message.max_rows.low >>> 0, message.max_rows.high >>> 0).toNumber(true) : message.max_rows;
            if (message.disable_binlogs != null && message.hasOwnProperty("disable_binlogs"))
                object.disable_binlogs = message.disable_binlogs;
            if (message.reload_schema != null && message.hasOwnProperty("reload_schema"))
                object.reload_schema = message.reload_schema;
            return object;
        };

        /**
         * Converts this ExecuteFetchAsDbaRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.ExecuteFetchAsDbaRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExecuteFetchAsDbaRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExecuteFetchAsDbaRequest;
    })();

    tabletmanagerdata.ExecuteFetchAsDbaResponse = (function() {

        /**
         * Properties of an ExecuteFetchAsDbaResponse.
         * @memberof tabletmanagerdata
         * @interface IExecuteFetchAsDbaResponse
         * @property {query.IQueryResult|null} [result] ExecuteFetchAsDbaResponse result
         */

        /**
         * Constructs a new ExecuteFetchAsDbaResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents an ExecuteFetchAsDbaResponse.
         * @implements IExecuteFetchAsDbaResponse
         * @constructor
         * @param {tabletmanagerdata.IExecuteFetchAsDbaResponse=} [properties] Properties to set
         */
        function ExecuteFetchAsDbaResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExecuteFetchAsDbaResponse result.
         * @member {query.IQueryResult|null|undefined} result
         * @memberof tabletmanagerdata.ExecuteFetchAsDbaResponse
         * @instance
         */
        ExecuteFetchAsDbaResponse.prototype.result = null;

        /**
         * Creates a new ExecuteFetchAsDbaResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.ExecuteFetchAsDbaResponse
         * @static
         * @param {tabletmanagerdata.IExecuteFetchAsDbaResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.ExecuteFetchAsDbaResponse} ExecuteFetchAsDbaResponse instance
         */
        ExecuteFetchAsDbaResponse.create = function create(properties) {
            return new ExecuteFetchAsDbaResponse(properties);
        };

        /**
         * Encodes the specified ExecuteFetchAsDbaResponse message. Does not implicitly {@link tabletmanagerdata.ExecuteFetchAsDbaResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.ExecuteFetchAsDbaResponse
         * @static
         * @param {tabletmanagerdata.IExecuteFetchAsDbaResponse} message ExecuteFetchAsDbaResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecuteFetchAsDbaResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                $root.query.QueryResult.encode(message.result, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ExecuteFetchAsDbaResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.ExecuteFetchAsDbaResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.ExecuteFetchAsDbaResponse
         * @static
         * @param {tabletmanagerdata.IExecuteFetchAsDbaResponse} message ExecuteFetchAsDbaResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecuteFetchAsDbaResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExecuteFetchAsDbaResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.ExecuteFetchAsDbaResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.ExecuteFetchAsDbaResponse} ExecuteFetchAsDbaResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecuteFetchAsDbaResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.ExecuteFetchAsDbaResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = $root.query.QueryResult.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExecuteFetchAsDbaResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.ExecuteFetchAsDbaResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.ExecuteFetchAsDbaResponse} ExecuteFetchAsDbaResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecuteFetchAsDbaResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExecuteFetchAsDbaResponse message.
         * @function verify
         * @memberof tabletmanagerdata.ExecuteFetchAsDbaResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExecuteFetchAsDbaResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result")) {
                var error = $root.query.QueryResult.verify(message.result);
                if (error)
                    return "result." + error;
            }
            return null;
        };

        /**
         * Creates an ExecuteFetchAsDbaResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.ExecuteFetchAsDbaResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.ExecuteFetchAsDbaResponse} ExecuteFetchAsDbaResponse
         */
        ExecuteFetchAsDbaResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.ExecuteFetchAsDbaResponse)
                return object;
            var message = new $root.tabletmanagerdata.ExecuteFetchAsDbaResponse();
            if (object.result != null) {
                if (typeof object.result !== "object")
                    throw TypeError(".tabletmanagerdata.ExecuteFetchAsDbaResponse.result: object expected");
                message.result = $root.query.QueryResult.fromObject(object.result);
            }
            return message;
        };

        /**
         * Creates a plain object from an ExecuteFetchAsDbaResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.ExecuteFetchAsDbaResponse
         * @static
         * @param {tabletmanagerdata.ExecuteFetchAsDbaResponse} message ExecuteFetchAsDbaResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExecuteFetchAsDbaResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = null;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = $root.query.QueryResult.toObject(message.result, options);
            return object;
        };

        /**
         * Converts this ExecuteFetchAsDbaResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.ExecuteFetchAsDbaResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExecuteFetchAsDbaResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExecuteFetchAsDbaResponse;
    })();

    tabletmanagerdata.ExecuteFetchAsAllPrivsRequest = (function() {

        /**
         * Properties of an ExecuteFetchAsAllPrivsRequest.
         * @memberof tabletmanagerdata
         * @interface IExecuteFetchAsAllPrivsRequest
         * @property {Uint8Array|null} [query] ExecuteFetchAsAllPrivsRequest query
         * @property {string|null} [db_name] ExecuteFetchAsAllPrivsRequest db_name
         * @property {number|Long|null} [max_rows] ExecuteFetchAsAllPrivsRequest max_rows
         * @property {boolean|null} [reload_schema] ExecuteFetchAsAllPrivsRequest reload_schema
         */

        /**
         * Constructs a new ExecuteFetchAsAllPrivsRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents an ExecuteFetchAsAllPrivsRequest.
         * @implements IExecuteFetchAsAllPrivsRequest
         * @constructor
         * @param {tabletmanagerdata.IExecuteFetchAsAllPrivsRequest=} [properties] Properties to set
         */
        function ExecuteFetchAsAllPrivsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExecuteFetchAsAllPrivsRequest query.
         * @member {Uint8Array} query
         * @memberof tabletmanagerdata.ExecuteFetchAsAllPrivsRequest
         * @instance
         */
        ExecuteFetchAsAllPrivsRequest.prototype.query = $util.newBuffer([]);

        /**
         * ExecuteFetchAsAllPrivsRequest db_name.
         * @member {string} db_name
         * @memberof tabletmanagerdata.ExecuteFetchAsAllPrivsRequest
         * @instance
         */
        ExecuteFetchAsAllPrivsRequest.prototype.db_name = "";

        /**
         * ExecuteFetchAsAllPrivsRequest max_rows.
         * @member {number|Long} max_rows
         * @memberof tabletmanagerdata.ExecuteFetchAsAllPrivsRequest
         * @instance
         */
        ExecuteFetchAsAllPrivsRequest.prototype.max_rows = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ExecuteFetchAsAllPrivsRequest reload_schema.
         * @member {boolean} reload_schema
         * @memberof tabletmanagerdata.ExecuteFetchAsAllPrivsRequest
         * @instance
         */
        ExecuteFetchAsAllPrivsRequest.prototype.reload_schema = false;

        /**
         * Creates a new ExecuteFetchAsAllPrivsRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.ExecuteFetchAsAllPrivsRequest
         * @static
         * @param {tabletmanagerdata.IExecuteFetchAsAllPrivsRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.ExecuteFetchAsAllPrivsRequest} ExecuteFetchAsAllPrivsRequest instance
         */
        ExecuteFetchAsAllPrivsRequest.create = function create(properties) {
            return new ExecuteFetchAsAllPrivsRequest(properties);
        };

        /**
         * Encodes the specified ExecuteFetchAsAllPrivsRequest message. Does not implicitly {@link tabletmanagerdata.ExecuteFetchAsAllPrivsRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.ExecuteFetchAsAllPrivsRequest
         * @static
         * @param {tabletmanagerdata.IExecuteFetchAsAllPrivsRequest} message ExecuteFetchAsAllPrivsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecuteFetchAsAllPrivsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.query);
            if (message.db_name != null && Object.hasOwnProperty.call(message, "db_name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.db_name);
            if (message.max_rows != null && Object.hasOwnProperty.call(message, "max_rows"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.max_rows);
            if (message.reload_schema != null && Object.hasOwnProperty.call(message, "reload_schema"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.reload_schema);
            return writer;
        };

        /**
         * Encodes the specified ExecuteFetchAsAllPrivsRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.ExecuteFetchAsAllPrivsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.ExecuteFetchAsAllPrivsRequest
         * @static
         * @param {tabletmanagerdata.IExecuteFetchAsAllPrivsRequest} message ExecuteFetchAsAllPrivsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecuteFetchAsAllPrivsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExecuteFetchAsAllPrivsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.ExecuteFetchAsAllPrivsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.ExecuteFetchAsAllPrivsRequest} ExecuteFetchAsAllPrivsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecuteFetchAsAllPrivsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.ExecuteFetchAsAllPrivsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.query = reader.bytes();
                    break;
                case 2:
                    message.db_name = reader.string();
                    break;
                case 3:
                    message.max_rows = reader.uint64();
                    break;
                case 4:
                    message.reload_schema = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExecuteFetchAsAllPrivsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.ExecuteFetchAsAllPrivsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.ExecuteFetchAsAllPrivsRequest} ExecuteFetchAsAllPrivsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecuteFetchAsAllPrivsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExecuteFetchAsAllPrivsRequest message.
         * @function verify
         * @memberof tabletmanagerdata.ExecuteFetchAsAllPrivsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExecuteFetchAsAllPrivsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.query != null && message.hasOwnProperty("query"))
                if (!(message.query && typeof message.query.length === "number" || $util.isString(message.query)))
                    return "query: buffer expected";
            if (message.db_name != null && message.hasOwnProperty("db_name"))
                if (!$util.isString(message.db_name))
                    return "db_name: string expected";
            if (message.max_rows != null && message.hasOwnProperty("max_rows"))
                if (!$util.isInteger(message.max_rows) && !(message.max_rows && $util.isInteger(message.max_rows.low) && $util.isInteger(message.max_rows.high)))
                    return "max_rows: integer|Long expected";
            if (message.reload_schema != null && message.hasOwnProperty("reload_schema"))
                if (typeof message.reload_schema !== "boolean")
                    return "reload_schema: boolean expected";
            return null;
        };

        /**
         * Creates an ExecuteFetchAsAllPrivsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.ExecuteFetchAsAllPrivsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.ExecuteFetchAsAllPrivsRequest} ExecuteFetchAsAllPrivsRequest
         */
        ExecuteFetchAsAllPrivsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.ExecuteFetchAsAllPrivsRequest)
                return object;
            var message = new $root.tabletmanagerdata.ExecuteFetchAsAllPrivsRequest();
            if (object.query != null)
                if (typeof object.query === "string")
                    $util.base64.decode(object.query, message.query = $util.newBuffer($util.base64.length(object.query)), 0);
                else if (object.query.length)
                    message.query = object.query;
            if (object.db_name != null)
                message.db_name = String(object.db_name);
            if (object.max_rows != null)
                if ($util.Long)
                    (message.max_rows = $util.Long.fromValue(object.max_rows)).unsigned = true;
                else if (typeof object.max_rows === "string")
                    message.max_rows = parseInt(object.max_rows, 10);
                else if (typeof object.max_rows === "number")
                    message.max_rows = object.max_rows;
                else if (typeof object.max_rows === "object")
                    message.max_rows = new $util.LongBits(object.max_rows.low >>> 0, object.max_rows.high >>> 0).toNumber(true);
            if (object.reload_schema != null)
                message.reload_schema = Boolean(object.reload_schema);
            return message;
        };

        /**
         * Creates a plain object from an ExecuteFetchAsAllPrivsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.ExecuteFetchAsAllPrivsRequest
         * @static
         * @param {tabletmanagerdata.ExecuteFetchAsAllPrivsRequest} message ExecuteFetchAsAllPrivsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExecuteFetchAsAllPrivsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.query = "";
                else {
                    object.query = [];
                    if (options.bytes !== Array)
                        object.query = $util.newBuffer(object.query);
                }
                object.db_name = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.max_rows = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.max_rows = options.longs === String ? "0" : 0;
                object.reload_schema = false;
            }
            if (message.query != null && message.hasOwnProperty("query"))
                object.query = options.bytes === String ? $util.base64.encode(message.query, 0, message.query.length) : options.bytes === Array ? Array.prototype.slice.call(message.query) : message.query;
            if (message.db_name != null && message.hasOwnProperty("db_name"))
                object.db_name = message.db_name;
            if (message.max_rows != null && message.hasOwnProperty("max_rows"))
                if (typeof message.max_rows === "number")
                    object.max_rows = options.longs === String ? String(message.max_rows) : message.max_rows;
                else
                    object.max_rows = options.longs === String ? $util.Long.prototype.toString.call(message.max_rows) : options.longs === Number ? new $util.LongBits(message.max_rows.low >>> 0, message.max_rows.high >>> 0).toNumber(true) : message.max_rows;
            if (message.reload_schema != null && message.hasOwnProperty("reload_schema"))
                object.reload_schema = message.reload_schema;
            return object;
        };

        /**
         * Converts this ExecuteFetchAsAllPrivsRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.ExecuteFetchAsAllPrivsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExecuteFetchAsAllPrivsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExecuteFetchAsAllPrivsRequest;
    })();

    tabletmanagerdata.ExecuteFetchAsAllPrivsResponse = (function() {

        /**
         * Properties of an ExecuteFetchAsAllPrivsResponse.
         * @memberof tabletmanagerdata
         * @interface IExecuteFetchAsAllPrivsResponse
         * @property {query.IQueryResult|null} [result] ExecuteFetchAsAllPrivsResponse result
         */

        /**
         * Constructs a new ExecuteFetchAsAllPrivsResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents an ExecuteFetchAsAllPrivsResponse.
         * @implements IExecuteFetchAsAllPrivsResponse
         * @constructor
         * @param {tabletmanagerdata.IExecuteFetchAsAllPrivsResponse=} [properties] Properties to set
         */
        function ExecuteFetchAsAllPrivsResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExecuteFetchAsAllPrivsResponse result.
         * @member {query.IQueryResult|null|undefined} result
         * @memberof tabletmanagerdata.ExecuteFetchAsAllPrivsResponse
         * @instance
         */
        ExecuteFetchAsAllPrivsResponse.prototype.result = null;

        /**
         * Creates a new ExecuteFetchAsAllPrivsResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.ExecuteFetchAsAllPrivsResponse
         * @static
         * @param {tabletmanagerdata.IExecuteFetchAsAllPrivsResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.ExecuteFetchAsAllPrivsResponse} ExecuteFetchAsAllPrivsResponse instance
         */
        ExecuteFetchAsAllPrivsResponse.create = function create(properties) {
            return new ExecuteFetchAsAllPrivsResponse(properties);
        };

        /**
         * Encodes the specified ExecuteFetchAsAllPrivsResponse message. Does not implicitly {@link tabletmanagerdata.ExecuteFetchAsAllPrivsResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.ExecuteFetchAsAllPrivsResponse
         * @static
         * @param {tabletmanagerdata.IExecuteFetchAsAllPrivsResponse} message ExecuteFetchAsAllPrivsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecuteFetchAsAllPrivsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                $root.query.QueryResult.encode(message.result, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ExecuteFetchAsAllPrivsResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.ExecuteFetchAsAllPrivsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.ExecuteFetchAsAllPrivsResponse
         * @static
         * @param {tabletmanagerdata.IExecuteFetchAsAllPrivsResponse} message ExecuteFetchAsAllPrivsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecuteFetchAsAllPrivsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExecuteFetchAsAllPrivsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.ExecuteFetchAsAllPrivsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.ExecuteFetchAsAllPrivsResponse} ExecuteFetchAsAllPrivsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecuteFetchAsAllPrivsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.ExecuteFetchAsAllPrivsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = $root.query.QueryResult.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExecuteFetchAsAllPrivsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.ExecuteFetchAsAllPrivsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.ExecuteFetchAsAllPrivsResponse} ExecuteFetchAsAllPrivsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecuteFetchAsAllPrivsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExecuteFetchAsAllPrivsResponse message.
         * @function verify
         * @memberof tabletmanagerdata.ExecuteFetchAsAllPrivsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExecuteFetchAsAllPrivsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result")) {
                var error = $root.query.QueryResult.verify(message.result);
                if (error)
                    return "result." + error;
            }
            return null;
        };

        /**
         * Creates an ExecuteFetchAsAllPrivsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.ExecuteFetchAsAllPrivsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.ExecuteFetchAsAllPrivsResponse} ExecuteFetchAsAllPrivsResponse
         */
        ExecuteFetchAsAllPrivsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.ExecuteFetchAsAllPrivsResponse)
                return object;
            var message = new $root.tabletmanagerdata.ExecuteFetchAsAllPrivsResponse();
            if (object.result != null) {
                if (typeof object.result !== "object")
                    throw TypeError(".tabletmanagerdata.ExecuteFetchAsAllPrivsResponse.result: object expected");
                message.result = $root.query.QueryResult.fromObject(object.result);
            }
            return message;
        };

        /**
         * Creates a plain object from an ExecuteFetchAsAllPrivsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.ExecuteFetchAsAllPrivsResponse
         * @static
         * @param {tabletmanagerdata.ExecuteFetchAsAllPrivsResponse} message ExecuteFetchAsAllPrivsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExecuteFetchAsAllPrivsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = null;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = $root.query.QueryResult.toObject(message.result, options);
            return object;
        };

        /**
         * Converts this ExecuteFetchAsAllPrivsResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.ExecuteFetchAsAllPrivsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExecuteFetchAsAllPrivsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExecuteFetchAsAllPrivsResponse;
    })();

    tabletmanagerdata.ExecuteFetchAsAppRequest = (function() {

        /**
         * Properties of an ExecuteFetchAsAppRequest.
         * @memberof tabletmanagerdata
         * @interface IExecuteFetchAsAppRequest
         * @property {Uint8Array|null} [query] ExecuteFetchAsAppRequest query
         * @property {number|Long|null} [max_rows] ExecuteFetchAsAppRequest max_rows
         */

        /**
         * Constructs a new ExecuteFetchAsAppRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents an ExecuteFetchAsAppRequest.
         * @implements IExecuteFetchAsAppRequest
         * @constructor
         * @param {tabletmanagerdata.IExecuteFetchAsAppRequest=} [properties] Properties to set
         */
        function ExecuteFetchAsAppRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExecuteFetchAsAppRequest query.
         * @member {Uint8Array} query
         * @memberof tabletmanagerdata.ExecuteFetchAsAppRequest
         * @instance
         */
        ExecuteFetchAsAppRequest.prototype.query = $util.newBuffer([]);

        /**
         * ExecuteFetchAsAppRequest max_rows.
         * @member {number|Long} max_rows
         * @memberof tabletmanagerdata.ExecuteFetchAsAppRequest
         * @instance
         */
        ExecuteFetchAsAppRequest.prototype.max_rows = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new ExecuteFetchAsAppRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.ExecuteFetchAsAppRequest
         * @static
         * @param {tabletmanagerdata.IExecuteFetchAsAppRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.ExecuteFetchAsAppRequest} ExecuteFetchAsAppRequest instance
         */
        ExecuteFetchAsAppRequest.create = function create(properties) {
            return new ExecuteFetchAsAppRequest(properties);
        };

        /**
         * Encodes the specified ExecuteFetchAsAppRequest message. Does not implicitly {@link tabletmanagerdata.ExecuteFetchAsAppRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.ExecuteFetchAsAppRequest
         * @static
         * @param {tabletmanagerdata.IExecuteFetchAsAppRequest} message ExecuteFetchAsAppRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecuteFetchAsAppRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.query);
            if (message.max_rows != null && Object.hasOwnProperty.call(message, "max_rows"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.max_rows);
            return writer;
        };

        /**
         * Encodes the specified ExecuteFetchAsAppRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.ExecuteFetchAsAppRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.ExecuteFetchAsAppRequest
         * @static
         * @param {tabletmanagerdata.IExecuteFetchAsAppRequest} message ExecuteFetchAsAppRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecuteFetchAsAppRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExecuteFetchAsAppRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.ExecuteFetchAsAppRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.ExecuteFetchAsAppRequest} ExecuteFetchAsAppRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecuteFetchAsAppRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.ExecuteFetchAsAppRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.query = reader.bytes();
                    break;
                case 2:
                    message.max_rows = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExecuteFetchAsAppRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.ExecuteFetchAsAppRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.ExecuteFetchAsAppRequest} ExecuteFetchAsAppRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecuteFetchAsAppRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExecuteFetchAsAppRequest message.
         * @function verify
         * @memberof tabletmanagerdata.ExecuteFetchAsAppRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExecuteFetchAsAppRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.query != null && message.hasOwnProperty("query"))
                if (!(message.query && typeof message.query.length === "number" || $util.isString(message.query)))
                    return "query: buffer expected";
            if (message.max_rows != null && message.hasOwnProperty("max_rows"))
                if (!$util.isInteger(message.max_rows) && !(message.max_rows && $util.isInteger(message.max_rows.low) && $util.isInteger(message.max_rows.high)))
                    return "max_rows: integer|Long expected";
            return null;
        };

        /**
         * Creates an ExecuteFetchAsAppRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.ExecuteFetchAsAppRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.ExecuteFetchAsAppRequest} ExecuteFetchAsAppRequest
         */
        ExecuteFetchAsAppRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.ExecuteFetchAsAppRequest)
                return object;
            var message = new $root.tabletmanagerdata.ExecuteFetchAsAppRequest();
            if (object.query != null)
                if (typeof object.query === "string")
                    $util.base64.decode(object.query, message.query = $util.newBuffer($util.base64.length(object.query)), 0);
                else if (object.query.length)
                    message.query = object.query;
            if (object.max_rows != null)
                if ($util.Long)
                    (message.max_rows = $util.Long.fromValue(object.max_rows)).unsigned = true;
                else if (typeof object.max_rows === "string")
                    message.max_rows = parseInt(object.max_rows, 10);
                else if (typeof object.max_rows === "number")
                    message.max_rows = object.max_rows;
                else if (typeof object.max_rows === "object")
                    message.max_rows = new $util.LongBits(object.max_rows.low >>> 0, object.max_rows.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from an ExecuteFetchAsAppRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.ExecuteFetchAsAppRequest
         * @static
         * @param {tabletmanagerdata.ExecuteFetchAsAppRequest} message ExecuteFetchAsAppRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExecuteFetchAsAppRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.query = "";
                else {
                    object.query = [];
                    if (options.bytes !== Array)
                        object.query = $util.newBuffer(object.query);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.max_rows = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.max_rows = options.longs === String ? "0" : 0;
            }
            if (message.query != null && message.hasOwnProperty("query"))
                object.query = options.bytes === String ? $util.base64.encode(message.query, 0, message.query.length) : options.bytes === Array ? Array.prototype.slice.call(message.query) : message.query;
            if (message.max_rows != null && message.hasOwnProperty("max_rows"))
                if (typeof message.max_rows === "number")
                    object.max_rows = options.longs === String ? String(message.max_rows) : message.max_rows;
                else
                    object.max_rows = options.longs === String ? $util.Long.prototype.toString.call(message.max_rows) : options.longs === Number ? new $util.LongBits(message.max_rows.low >>> 0, message.max_rows.high >>> 0).toNumber(true) : message.max_rows;
            return object;
        };

        /**
         * Converts this ExecuteFetchAsAppRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.ExecuteFetchAsAppRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExecuteFetchAsAppRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExecuteFetchAsAppRequest;
    })();

    tabletmanagerdata.ExecuteFetchAsAppResponse = (function() {

        /**
         * Properties of an ExecuteFetchAsAppResponse.
         * @memberof tabletmanagerdata
         * @interface IExecuteFetchAsAppResponse
         * @property {query.IQueryResult|null} [result] ExecuteFetchAsAppResponse result
         */

        /**
         * Constructs a new ExecuteFetchAsAppResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents an ExecuteFetchAsAppResponse.
         * @implements IExecuteFetchAsAppResponse
         * @constructor
         * @param {tabletmanagerdata.IExecuteFetchAsAppResponse=} [properties] Properties to set
         */
        function ExecuteFetchAsAppResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExecuteFetchAsAppResponse result.
         * @member {query.IQueryResult|null|undefined} result
         * @memberof tabletmanagerdata.ExecuteFetchAsAppResponse
         * @instance
         */
        ExecuteFetchAsAppResponse.prototype.result = null;

        /**
         * Creates a new ExecuteFetchAsAppResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.ExecuteFetchAsAppResponse
         * @static
         * @param {tabletmanagerdata.IExecuteFetchAsAppResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.ExecuteFetchAsAppResponse} ExecuteFetchAsAppResponse instance
         */
        ExecuteFetchAsAppResponse.create = function create(properties) {
            return new ExecuteFetchAsAppResponse(properties);
        };

        /**
         * Encodes the specified ExecuteFetchAsAppResponse message. Does not implicitly {@link tabletmanagerdata.ExecuteFetchAsAppResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.ExecuteFetchAsAppResponse
         * @static
         * @param {tabletmanagerdata.IExecuteFetchAsAppResponse} message ExecuteFetchAsAppResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecuteFetchAsAppResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                $root.query.QueryResult.encode(message.result, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ExecuteFetchAsAppResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.ExecuteFetchAsAppResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.ExecuteFetchAsAppResponse
         * @static
         * @param {tabletmanagerdata.IExecuteFetchAsAppResponse} message ExecuteFetchAsAppResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecuteFetchAsAppResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExecuteFetchAsAppResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.ExecuteFetchAsAppResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.ExecuteFetchAsAppResponse} ExecuteFetchAsAppResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecuteFetchAsAppResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.ExecuteFetchAsAppResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = $root.query.QueryResult.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExecuteFetchAsAppResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.ExecuteFetchAsAppResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.ExecuteFetchAsAppResponse} ExecuteFetchAsAppResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecuteFetchAsAppResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExecuteFetchAsAppResponse message.
         * @function verify
         * @memberof tabletmanagerdata.ExecuteFetchAsAppResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExecuteFetchAsAppResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result")) {
                var error = $root.query.QueryResult.verify(message.result);
                if (error)
                    return "result." + error;
            }
            return null;
        };

        /**
         * Creates an ExecuteFetchAsAppResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.ExecuteFetchAsAppResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.ExecuteFetchAsAppResponse} ExecuteFetchAsAppResponse
         */
        ExecuteFetchAsAppResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.ExecuteFetchAsAppResponse)
                return object;
            var message = new $root.tabletmanagerdata.ExecuteFetchAsAppResponse();
            if (object.result != null) {
                if (typeof object.result !== "object")
                    throw TypeError(".tabletmanagerdata.ExecuteFetchAsAppResponse.result: object expected");
                message.result = $root.query.QueryResult.fromObject(object.result);
            }
            return message;
        };

        /**
         * Creates a plain object from an ExecuteFetchAsAppResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.ExecuteFetchAsAppResponse
         * @static
         * @param {tabletmanagerdata.ExecuteFetchAsAppResponse} message ExecuteFetchAsAppResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExecuteFetchAsAppResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = null;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = $root.query.QueryResult.toObject(message.result, options);
            return object;
        };

        /**
         * Converts this ExecuteFetchAsAppResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.ExecuteFetchAsAppResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExecuteFetchAsAppResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExecuteFetchAsAppResponse;
    })();

    tabletmanagerdata.ReplicationStatusRequest = (function() {

        /**
         * Properties of a ReplicationStatusRequest.
         * @memberof tabletmanagerdata
         * @interface IReplicationStatusRequest
         */

        /**
         * Constructs a new ReplicationStatusRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents a ReplicationStatusRequest.
         * @implements IReplicationStatusRequest
         * @constructor
         * @param {tabletmanagerdata.IReplicationStatusRequest=} [properties] Properties to set
         */
        function ReplicationStatusRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ReplicationStatusRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.ReplicationStatusRequest
         * @static
         * @param {tabletmanagerdata.IReplicationStatusRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.ReplicationStatusRequest} ReplicationStatusRequest instance
         */
        ReplicationStatusRequest.create = function create(properties) {
            return new ReplicationStatusRequest(properties);
        };

        /**
         * Encodes the specified ReplicationStatusRequest message. Does not implicitly {@link tabletmanagerdata.ReplicationStatusRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.ReplicationStatusRequest
         * @static
         * @param {tabletmanagerdata.IReplicationStatusRequest} message ReplicationStatusRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReplicationStatusRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ReplicationStatusRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.ReplicationStatusRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.ReplicationStatusRequest
         * @static
         * @param {tabletmanagerdata.IReplicationStatusRequest} message ReplicationStatusRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReplicationStatusRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReplicationStatusRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.ReplicationStatusRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.ReplicationStatusRequest} ReplicationStatusRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReplicationStatusRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.ReplicationStatusRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReplicationStatusRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.ReplicationStatusRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.ReplicationStatusRequest} ReplicationStatusRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReplicationStatusRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReplicationStatusRequest message.
         * @function verify
         * @memberof tabletmanagerdata.ReplicationStatusRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReplicationStatusRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ReplicationStatusRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.ReplicationStatusRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.ReplicationStatusRequest} ReplicationStatusRequest
         */
        ReplicationStatusRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.ReplicationStatusRequest)
                return object;
            return new $root.tabletmanagerdata.ReplicationStatusRequest();
        };

        /**
         * Creates a plain object from a ReplicationStatusRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.ReplicationStatusRequest
         * @static
         * @param {tabletmanagerdata.ReplicationStatusRequest} message ReplicationStatusRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReplicationStatusRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ReplicationStatusRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.ReplicationStatusRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReplicationStatusRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ReplicationStatusRequest;
    })();

    tabletmanagerdata.ReplicationStatusResponse = (function() {

        /**
         * Properties of a ReplicationStatusResponse.
         * @memberof tabletmanagerdata
         * @interface IReplicationStatusResponse
         * @property {replicationdata.IStatus|null} [status] ReplicationStatusResponse status
         */

        /**
         * Constructs a new ReplicationStatusResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents a ReplicationStatusResponse.
         * @implements IReplicationStatusResponse
         * @constructor
         * @param {tabletmanagerdata.IReplicationStatusResponse=} [properties] Properties to set
         */
        function ReplicationStatusResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReplicationStatusResponse status.
         * @member {replicationdata.IStatus|null|undefined} status
         * @memberof tabletmanagerdata.ReplicationStatusResponse
         * @instance
         */
        ReplicationStatusResponse.prototype.status = null;

        /**
         * Creates a new ReplicationStatusResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.ReplicationStatusResponse
         * @static
         * @param {tabletmanagerdata.IReplicationStatusResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.ReplicationStatusResponse} ReplicationStatusResponse instance
         */
        ReplicationStatusResponse.create = function create(properties) {
            return new ReplicationStatusResponse(properties);
        };

        /**
         * Encodes the specified ReplicationStatusResponse message. Does not implicitly {@link tabletmanagerdata.ReplicationStatusResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.ReplicationStatusResponse
         * @static
         * @param {tabletmanagerdata.IReplicationStatusResponse} message ReplicationStatusResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReplicationStatusResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.replicationdata.Status.encode(message.status, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ReplicationStatusResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.ReplicationStatusResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.ReplicationStatusResponse
         * @static
         * @param {tabletmanagerdata.IReplicationStatusResponse} message ReplicationStatusResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReplicationStatusResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReplicationStatusResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.ReplicationStatusResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.ReplicationStatusResponse} ReplicationStatusResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReplicationStatusResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.ReplicationStatusResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.status = $root.replicationdata.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReplicationStatusResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.ReplicationStatusResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.ReplicationStatusResponse} ReplicationStatusResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReplicationStatusResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReplicationStatusResponse message.
         * @function verify
         * @memberof tabletmanagerdata.ReplicationStatusResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReplicationStatusResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.replicationdata.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a ReplicationStatusResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.ReplicationStatusResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.ReplicationStatusResponse} ReplicationStatusResponse
         */
        ReplicationStatusResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.ReplicationStatusResponse)
                return object;
            var message = new $root.tabletmanagerdata.ReplicationStatusResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".tabletmanagerdata.ReplicationStatusResponse.status: object expected");
                message.status = $root.replicationdata.Status.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a ReplicationStatusResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.ReplicationStatusResponse
         * @static
         * @param {tabletmanagerdata.ReplicationStatusResponse} message ReplicationStatusResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReplicationStatusResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.replicationdata.Status.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this ReplicationStatusResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.ReplicationStatusResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReplicationStatusResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ReplicationStatusResponse;
    })();

    tabletmanagerdata.MasterStatusRequest = (function() {

        /**
         * Properties of a MasterStatusRequest.
         * @memberof tabletmanagerdata
         * @interface IMasterStatusRequest
         */

        /**
         * Constructs a new MasterStatusRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents a MasterStatusRequest.
         * @implements IMasterStatusRequest
         * @constructor
         * @param {tabletmanagerdata.IMasterStatusRequest=} [properties] Properties to set
         */
        function MasterStatusRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new MasterStatusRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.MasterStatusRequest
         * @static
         * @param {tabletmanagerdata.IMasterStatusRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.MasterStatusRequest} MasterStatusRequest instance
         */
        MasterStatusRequest.create = function create(properties) {
            return new MasterStatusRequest(properties);
        };

        /**
         * Encodes the specified MasterStatusRequest message. Does not implicitly {@link tabletmanagerdata.MasterStatusRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.MasterStatusRequest
         * @static
         * @param {tabletmanagerdata.IMasterStatusRequest} message MasterStatusRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MasterStatusRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified MasterStatusRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.MasterStatusRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.MasterStatusRequest
         * @static
         * @param {tabletmanagerdata.IMasterStatusRequest} message MasterStatusRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MasterStatusRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MasterStatusRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.MasterStatusRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.MasterStatusRequest} MasterStatusRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MasterStatusRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.MasterStatusRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MasterStatusRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.MasterStatusRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.MasterStatusRequest} MasterStatusRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MasterStatusRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MasterStatusRequest message.
         * @function verify
         * @memberof tabletmanagerdata.MasterStatusRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MasterStatusRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a MasterStatusRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.MasterStatusRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.MasterStatusRequest} MasterStatusRequest
         */
        MasterStatusRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.MasterStatusRequest)
                return object;
            return new $root.tabletmanagerdata.MasterStatusRequest();
        };

        /**
         * Creates a plain object from a MasterStatusRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.MasterStatusRequest
         * @static
         * @param {tabletmanagerdata.MasterStatusRequest} message MasterStatusRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MasterStatusRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this MasterStatusRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.MasterStatusRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MasterStatusRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MasterStatusRequest;
    })();

    tabletmanagerdata.MasterStatusResponse = (function() {

        /**
         * Properties of a MasterStatusResponse.
         * @memberof tabletmanagerdata
         * @interface IMasterStatusResponse
         * @property {replicationdata.IMasterStatus|null} [status] MasterStatusResponse status
         */

        /**
         * Constructs a new MasterStatusResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents a MasterStatusResponse.
         * @implements IMasterStatusResponse
         * @constructor
         * @param {tabletmanagerdata.IMasterStatusResponse=} [properties] Properties to set
         */
        function MasterStatusResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MasterStatusResponse status.
         * @member {replicationdata.IMasterStatus|null|undefined} status
         * @memberof tabletmanagerdata.MasterStatusResponse
         * @instance
         */
        MasterStatusResponse.prototype.status = null;

        /**
         * Creates a new MasterStatusResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.MasterStatusResponse
         * @static
         * @param {tabletmanagerdata.IMasterStatusResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.MasterStatusResponse} MasterStatusResponse instance
         */
        MasterStatusResponse.create = function create(properties) {
            return new MasterStatusResponse(properties);
        };

        /**
         * Encodes the specified MasterStatusResponse message. Does not implicitly {@link tabletmanagerdata.MasterStatusResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.MasterStatusResponse
         * @static
         * @param {tabletmanagerdata.IMasterStatusResponse} message MasterStatusResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MasterStatusResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.replicationdata.MasterStatus.encode(message.status, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MasterStatusResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.MasterStatusResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.MasterStatusResponse
         * @static
         * @param {tabletmanagerdata.IMasterStatusResponse} message MasterStatusResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MasterStatusResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MasterStatusResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.MasterStatusResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.MasterStatusResponse} MasterStatusResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MasterStatusResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.MasterStatusResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.status = $root.replicationdata.MasterStatus.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MasterStatusResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.MasterStatusResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.MasterStatusResponse} MasterStatusResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MasterStatusResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MasterStatusResponse message.
         * @function verify
         * @memberof tabletmanagerdata.MasterStatusResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MasterStatusResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.replicationdata.MasterStatus.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a MasterStatusResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.MasterStatusResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.MasterStatusResponse} MasterStatusResponse
         */
        MasterStatusResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.MasterStatusResponse)
                return object;
            var message = new $root.tabletmanagerdata.MasterStatusResponse();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".tabletmanagerdata.MasterStatusResponse.status: object expected");
                message.status = $root.replicationdata.MasterStatus.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a MasterStatusResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.MasterStatusResponse
         * @static
         * @param {tabletmanagerdata.MasterStatusResponse} message MasterStatusResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MasterStatusResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = null;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.replicationdata.MasterStatus.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this MasterStatusResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.MasterStatusResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MasterStatusResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MasterStatusResponse;
    })();

    tabletmanagerdata.MasterPositionRequest = (function() {

        /**
         * Properties of a MasterPositionRequest.
         * @memberof tabletmanagerdata
         * @interface IMasterPositionRequest
         */

        /**
         * Constructs a new MasterPositionRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents a MasterPositionRequest.
         * @implements IMasterPositionRequest
         * @constructor
         * @param {tabletmanagerdata.IMasterPositionRequest=} [properties] Properties to set
         */
        function MasterPositionRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new MasterPositionRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.MasterPositionRequest
         * @static
         * @param {tabletmanagerdata.IMasterPositionRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.MasterPositionRequest} MasterPositionRequest instance
         */
        MasterPositionRequest.create = function create(properties) {
            return new MasterPositionRequest(properties);
        };

        /**
         * Encodes the specified MasterPositionRequest message. Does not implicitly {@link tabletmanagerdata.MasterPositionRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.MasterPositionRequest
         * @static
         * @param {tabletmanagerdata.IMasterPositionRequest} message MasterPositionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MasterPositionRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified MasterPositionRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.MasterPositionRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.MasterPositionRequest
         * @static
         * @param {tabletmanagerdata.IMasterPositionRequest} message MasterPositionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MasterPositionRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MasterPositionRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.MasterPositionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.MasterPositionRequest} MasterPositionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MasterPositionRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.MasterPositionRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MasterPositionRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.MasterPositionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.MasterPositionRequest} MasterPositionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MasterPositionRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MasterPositionRequest message.
         * @function verify
         * @memberof tabletmanagerdata.MasterPositionRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MasterPositionRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a MasterPositionRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.MasterPositionRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.MasterPositionRequest} MasterPositionRequest
         */
        MasterPositionRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.MasterPositionRequest)
                return object;
            return new $root.tabletmanagerdata.MasterPositionRequest();
        };

        /**
         * Creates a plain object from a MasterPositionRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.MasterPositionRequest
         * @static
         * @param {tabletmanagerdata.MasterPositionRequest} message MasterPositionRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MasterPositionRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this MasterPositionRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.MasterPositionRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MasterPositionRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MasterPositionRequest;
    })();

    tabletmanagerdata.MasterPositionResponse = (function() {

        /**
         * Properties of a MasterPositionResponse.
         * @memberof tabletmanagerdata
         * @interface IMasterPositionResponse
         * @property {string|null} [position] MasterPositionResponse position
         */

        /**
         * Constructs a new MasterPositionResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents a MasterPositionResponse.
         * @implements IMasterPositionResponse
         * @constructor
         * @param {tabletmanagerdata.IMasterPositionResponse=} [properties] Properties to set
         */
        function MasterPositionResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MasterPositionResponse position.
         * @member {string} position
         * @memberof tabletmanagerdata.MasterPositionResponse
         * @instance
         */
        MasterPositionResponse.prototype.position = "";

        /**
         * Creates a new MasterPositionResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.MasterPositionResponse
         * @static
         * @param {tabletmanagerdata.IMasterPositionResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.MasterPositionResponse} MasterPositionResponse instance
         */
        MasterPositionResponse.create = function create(properties) {
            return new MasterPositionResponse(properties);
        };

        /**
         * Encodes the specified MasterPositionResponse message. Does not implicitly {@link tabletmanagerdata.MasterPositionResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.MasterPositionResponse
         * @static
         * @param {tabletmanagerdata.IMasterPositionResponse} message MasterPositionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MasterPositionResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.position);
            return writer;
        };

        /**
         * Encodes the specified MasterPositionResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.MasterPositionResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.MasterPositionResponse
         * @static
         * @param {tabletmanagerdata.IMasterPositionResponse} message MasterPositionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MasterPositionResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MasterPositionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.MasterPositionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.MasterPositionResponse} MasterPositionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MasterPositionResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.MasterPositionResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.position = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MasterPositionResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.MasterPositionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.MasterPositionResponse} MasterPositionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MasterPositionResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MasterPositionResponse message.
         * @function verify
         * @memberof tabletmanagerdata.MasterPositionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MasterPositionResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.position != null && message.hasOwnProperty("position"))
                if (!$util.isString(message.position))
                    return "position: string expected";
            return null;
        };

        /**
         * Creates a MasterPositionResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.MasterPositionResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.MasterPositionResponse} MasterPositionResponse
         */
        MasterPositionResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.MasterPositionResponse)
                return object;
            var message = new $root.tabletmanagerdata.MasterPositionResponse();
            if (object.position != null)
                message.position = String(object.position);
            return message;
        };

        /**
         * Creates a plain object from a MasterPositionResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.MasterPositionResponse
         * @static
         * @param {tabletmanagerdata.MasterPositionResponse} message MasterPositionResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MasterPositionResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.position = "";
            if (message.position != null && message.hasOwnProperty("position"))
                object.position = message.position;
            return object;
        };

        /**
         * Converts this MasterPositionResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.MasterPositionResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MasterPositionResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MasterPositionResponse;
    })();

    tabletmanagerdata.WaitForPositionRequest = (function() {

        /**
         * Properties of a WaitForPositionRequest.
         * @memberof tabletmanagerdata
         * @interface IWaitForPositionRequest
         * @property {string|null} [position] WaitForPositionRequest position
         */

        /**
         * Constructs a new WaitForPositionRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents a WaitForPositionRequest.
         * @implements IWaitForPositionRequest
         * @constructor
         * @param {tabletmanagerdata.IWaitForPositionRequest=} [properties] Properties to set
         */
        function WaitForPositionRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WaitForPositionRequest position.
         * @member {string} position
         * @memberof tabletmanagerdata.WaitForPositionRequest
         * @instance
         */
        WaitForPositionRequest.prototype.position = "";

        /**
         * Creates a new WaitForPositionRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.WaitForPositionRequest
         * @static
         * @param {tabletmanagerdata.IWaitForPositionRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.WaitForPositionRequest} WaitForPositionRequest instance
         */
        WaitForPositionRequest.create = function create(properties) {
            return new WaitForPositionRequest(properties);
        };

        /**
         * Encodes the specified WaitForPositionRequest message. Does not implicitly {@link tabletmanagerdata.WaitForPositionRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.WaitForPositionRequest
         * @static
         * @param {tabletmanagerdata.IWaitForPositionRequest} message WaitForPositionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WaitForPositionRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.position);
            return writer;
        };

        /**
         * Encodes the specified WaitForPositionRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.WaitForPositionRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.WaitForPositionRequest
         * @static
         * @param {tabletmanagerdata.IWaitForPositionRequest} message WaitForPositionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WaitForPositionRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WaitForPositionRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.WaitForPositionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.WaitForPositionRequest} WaitForPositionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WaitForPositionRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.WaitForPositionRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.position = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WaitForPositionRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.WaitForPositionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.WaitForPositionRequest} WaitForPositionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WaitForPositionRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WaitForPositionRequest message.
         * @function verify
         * @memberof tabletmanagerdata.WaitForPositionRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WaitForPositionRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.position != null && message.hasOwnProperty("position"))
                if (!$util.isString(message.position))
                    return "position: string expected";
            return null;
        };

        /**
         * Creates a WaitForPositionRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.WaitForPositionRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.WaitForPositionRequest} WaitForPositionRequest
         */
        WaitForPositionRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.WaitForPositionRequest)
                return object;
            var message = new $root.tabletmanagerdata.WaitForPositionRequest();
            if (object.position != null)
                message.position = String(object.position);
            return message;
        };

        /**
         * Creates a plain object from a WaitForPositionRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.WaitForPositionRequest
         * @static
         * @param {tabletmanagerdata.WaitForPositionRequest} message WaitForPositionRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WaitForPositionRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.position = "";
            if (message.position != null && message.hasOwnProperty("position"))
                object.position = message.position;
            return object;
        };

        /**
         * Converts this WaitForPositionRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.WaitForPositionRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WaitForPositionRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WaitForPositionRequest;
    })();

    tabletmanagerdata.WaitForPositionResponse = (function() {

        /**
         * Properties of a WaitForPositionResponse.
         * @memberof tabletmanagerdata
         * @interface IWaitForPositionResponse
         */

        /**
         * Constructs a new WaitForPositionResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents a WaitForPositionResponse.
         * @implements IWaitForPositionResponse
         * @constructor
         * @param {tabletmanagerdata.IWaitForPositionResponse=} [properties] Properties to set
         */
        function WaitForPositionResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new WaitForPositionResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.WaitForPositionResponse
         * @static
         * @param {tabletmanagerdata.IWaitForPositionResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.WaitForPositionResponse} WaitForPositionResponse instance
         */
        WaitForPositionResponse.create = function create(properties) {
            return new WaitForPositionResponse(properties);
        };

        /**
         * Encodes the specified WaitForPositionResponse message. Does not implicitly {@link tabletmanagerdata.WaitForPositionResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.WaitForPositionResponse
         * @static
         * @param {tabletmanagerdata.IWaitForPositionResponse} message WaitForPositionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WaitForPositionResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified WaitForPositionResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.WaitForPositionResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.WaitForPositionResponse
         * @static
         * @param {tabletmanagerdata.IWaitForPositionResponse} message WaitForPositionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WaitForPositionResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WaitForPositionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.WaitForPositionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.WaitForPositionResponse} WaitForPositionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WaitForPositionResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.WaitForPositionResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WaitForPositionResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.WaitForPositionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.WaitForPositionResponse} WaitForPositionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WaitForPositionResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WaitForPositionResponse message.
         * @function verify
         * @memberof tabletmanagerdata.WaitForPositionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WaitForPositionResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a WaitForPositionResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.WaitForPositionResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.WaitForPositionResponse} WaitForPositionResponse
         */
        WaitForPositionResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.WaitForPositionResponse)
                return object;
            return new $root.tabletmanagerdata.WaitForPositionResponse();
        };

        /**
         * Creates a plain object from a WaitForPositionResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.WaitForPositionResponse
         * @static
         * @param {tabletmanagerdata.WaitForPositionResponse} message WaitForPositionResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WaitForPositionResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this WaitForPositionResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.WaitForPositionResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WaitForPositionResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WaitForPositionResponse;
    })();

    tabletmanagerdata.StopReplicationRequest = (function() {

        /**
         * Properties of a StopReplicationRequest.
         * @memberof tabletmanagerdata
         * @interface IStopReplicationRequest
         */

        /**
         * Constructs a new StopReplicationRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents a StopReplicationRequest.
         * @implements IStopReplicationRequest
         * @constructor
         * @param {tabletmanagerdata.IStopReplicationRequest=} [properties] Properties to set
         */
        function StopReplicationRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new StopReplicationRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.StopReplicationRequest
         * @static
         * @param {tabletmanagerdata.IStopReplicationRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.StopReplicationRequest} StopReplicationRequest instance
         */
        StopReplicationRequest.create = function create(properties) {
            return new StopReplicationRequest(properties);
        };

        /**
         * Encodes the specified StopReplicationRequest message. Does not implicitly {@link tabletmanagerdata.StopReplicationRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.StopReplicationRequest
         * @static
         * @param {tabletmanagerdata.IStopReplicationRequest} message StopReplicationRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopReplicationRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified StopReplicationRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.StopReplicationRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.StopReplicationRequest
         * @static
         * @param {tabletmanagerdata.IStopReplicationRequest} message StopReplicationRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopReplicationRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StopReplicationRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.StopReplicationRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.StopReplicationRequest} StopReplicationRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopReplicationRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.StopReplicationRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StopReplicationRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.StopReplicationRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.StopReplicationRequest} StopReplicationRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopReplicationRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StopReplicationRequest message.
         * @function verify
         * @memberof tabletmanagerdata.StopReplicationRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StopReplicationRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a StopReplicationRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.StopReplicationRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.StopReplicationRequest} StopReplicationRequest
         */
        StopReplicationRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.StopReplicationRequest)
                return object;
            return new $root.tabletmanagerdata.StopReplicationRequest();
        };

        /**
         * Creates a plain object from a StopReplicationRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.StopReplicationRequest
         * @static
         * @param {tabletmanagerdata.StopReplicationRequest} message StopReplicationRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StopReplicationRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this StopReplicationRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.StopReplicationRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StopReplicationRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StopReplicationRequest;
    })();

    tabletmanagerdata.StopReplicationResponse = (function() {

        /**
         * Properties of a StopReplicationResponse.
         * @memberof tabletmanagerdata
         * @interface IStopReplicationResponse
         */

        /**
         * Constructs a new StopReplicationResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents a StopReplicationResponse.
         * @implements IStopReplicationResponse
         * @constructor
         * @param {tabletmanagerdata.IStopReplicationResponse=} [properties] Properties to set
         */
        function StopReplicationResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new StopReplicationResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.StopReplicationResponse
         * @static
         * @param {tabletmanagerdata.IStopReplicationResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.StopReplicationResponse} StopReplicationResponse instance
         */
        StopReplicationResponse.create = function create(properties) {
            return new StopReplicationResponse(properties);
        };

        /**
         * Encodes the specified StopReplicationResponse message. Does not implicitly {@link tabletmanagerdata.StopReplicationResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.StopReplicationResponse
         * @static
         * @param {tabletmanagerdata.IStopReplicationResponse} message StopReplicationResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopReplicationResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified StopReplicationResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.StopReplicationResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.StopReplicationResponse
         * @static
         * @param {tabletmanagerdata.IStopReplicationResponse} message StopReplicationResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopReplicationResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StopReplicationResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.StopReplicationResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.StopReplicationResponse} StopReplicationResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopReplicationResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.StopReplicationResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StopReplicationResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.StopReplicationResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.StopReplicationResponse} StopReplicationResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopReplicationResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StopReplicationResponse message.
         * @function verify
         * @memberof tabletmanagerdata.StopReplicationResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StopReplicationResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a StopReplicationResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.StopReplicationResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.StopReplicationResponse} StopReplicationResponse
         */
        StopReplicationResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.StopReplicationResponse)
                return object;
            return new $root.tabletmanagerdata.StopReplicationResponse();
        };

        /**
         * Creates a plain object from a StopReplicationResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.StopReplicationResponse
         * @static
         * @param {tabletmanagerdata.StopReplicationResponse} message StopReplicationResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StopReplicationResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this StopReplicationResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.StopReplicationResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StopReplicationResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StopReplicationResponse;
    })();

    tabletmanagerdata.StopReplicationMinimumRequest = (function() {

        /**
         * Properties of a StopReplicationMinimumRequest.
         * @memberof tabletmanagerdata
         * @interface IStopReplicationMinimumRequest
         * @property {string|null} [position] StopReplicationMinimumRequest position
         * @property {number|Long|null} [wait_timeout] StopReplicationMinimumRequest wait_timeout
         */

        /**
         * Constructs a new StopReplicationMinimumRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents a StopReplicationMinimumRequest.
         * @implements IStopReplicationMinimumRequest
         * @constructor
         * @param {tabletmanagerdata.IStopReplicationMinimumRequest=} [properties] Properties to set
         */
        function StopReplicationMinimumRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StopReplicationMinimumRequest position.
         * @member {string} position
         * @memberof tabletmanagerdata.StopReplicationMinimumRequest
         * @instance
         */
        StopReplicationMinimumRequest.prototype.position = "";

        /**
         * StopReplicationMinimumRequest wait_timeout.
         * @member {number|Long} wait_timeout
         * @memberof tabletmanagerdata.StopReplicationMinimumRequest
         * @instance
         */
        StopReplicationMinimumRequest.prototype.wait_timeout = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new StopReplicationMinimumRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.StopReplicationMinimumRequest
         * @static
         * @param {tabletmanagerdata.IStopReplicationMinimumRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.StopReplicationMinimumRequest} StopReplicationMinimumRequest instance
         */
        StopReplicationMinimumRequest.create = function create(properties) {
            return new StopReplicationMinimumRequest(properties);
        };

        /**
         * Encodes the specified StopReplicationMinimumRequest message. Does not implicitly {@link tabletmanagerdata.StopReplicationMinimumRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.StopReplicationMinimumRequest
         * @static
         * @param {tabletmanagerdata.IStopReplicationMinimumRequest} message StopReplicationMinimumRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopReplicationMinimumRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.position);
            if (message.wait_timeout != null && Object.hasOwnProperty.call(message, "wait_timeout"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.wait_timeout);
            return writer;
        };

        /**
         * Encodes the specified StopReplicationMinimumRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.StopReplicationMinimumRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.StopReplicationMinimumRequest
         * @static
         * @param {tabletmanagerdata.IStopReplicationMinimumRequest} message StopReplicationMinimumRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopReplicationMinimumRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StopReplicationMinimumRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.StopReplicationMinimumRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.StopReplicationMinimumRequest} StopReplicationMinimumRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopReplicationMinimumRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.StopReplicationMinimumRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.position = reader.string();
                    break;
                case 2:
                    message.wait_timeout = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StopReplicationMinimumRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.StopReplicationMinimumRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.StopReplicationMinimumRequest} StopReplicationMinimumRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopReplicationMinimumRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StopReplicationMinimumRequest message.
         * @function verify
         * @memberof tabletmanagerdata.StopReplicationMinimumRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StopReplicationMinimumRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.position != null && message.hasOwnProperty("position"))
                if (!$util.isString(message.position))
                    return "position: string expected";
            if (message.wait_timeout != null && message.hasOwnProperty("wait_timeout"))
                if (!$util.isInteger(message.wait_timeout) && !(message.wait_timeout && $util.isInteger(message.wait_timeout.low) && $util.isInteger(message.wait_timeout.high)))
                    return "wait_timeout: integer|Long expected";
            return null;
        };

        /**
         * Creates a StopReplicationMinimumRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.StopReplicationMinimumRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.StopReplicationMinimumRequest} StopReplicationMinimumRequest
         */
        StopReplicationMinimumRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.StopReplicationMinimumRequest)
                return object;
            var message = new $root.tabletmanagerdata.StopReplicationMinimumRequest();
            if (object.position != null)
                message.position = String(object.position);
            if (object.wait_timeout != null)
                if ($util.Long)
                    (message.wait_timeout = $util.Long.fromValue(object.wait_timeout)).unsigned = false;
                else if (typeof object.wait_timeout === "string")
                    message.wait_timeout = parseInt(object.wait_timeout, 10);
                else if (typeof object.wait_timeout === "number")
                    message.wait_timeout = object.wait_timeout;
                else if (typeof object.wait_timeout === "object")
                    message.wait_timeout = new $util.LongBits(object.wait_timeout.low >>> 0, object.wait_timeout.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a StopReplicationMinimumRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.StopReplicationMinimumRequest
         * @static
         * @param {tabletmanagerdata.StopReplicationMinimumRequest} message StopReplicationMinimumRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StopReplicationMinimumRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.position = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.wait_timeout = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.wait_timeout = options.longs === String ? "0" : 0;
            }
            if (message.position != null && message.hasOwnProperty("position"))
                object.position = message.position;
            if (message.wait_timeout != null && message.hasOwnProperty("wait_timeout"))
                if (typeof message.wait_timeout === "number")
                    object.wait_timeout = options.longs === String ? String(message.wait_timeout) : message.wait_timeout;
                else
                    object.wait_timeout = options.longs === String ? $util.Long.prototype.toString.call(message.wait_timeout) : options.longs === Number ? new $util.LongBits(message.wait_timeout.low >>> 0, message.wait_timeout.high >>> 0).toNumber() : message.wait_timeout;
            return object;
        };

        /**
         * Converts this StopReplicationMinimumRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.StopReplicationMinimumRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StopReplicationMinimumRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StopReplicationMinimumRequest;
    })();

    tabletmanagerdata.StopReplicationMinimumResponse = (function() {

        /**
         * Properties of a StopReplicationMinimumResponse.
         * @memberof tabletmanagerdata
         * @interface IStopReplicationMinimumResponse
         * @property {string|null} [position] StopReplicationMinimumResponse position
         */

        /**
         * Constructs a new StopReplicationMinimumResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents a StopReplicationMinimumResponse.
         * @implements IStopReplicationMinimumResponse
         * @constructor
         * @param {tabletmanagerdata.IStopReplicationMinimumResponse=} [properties] Properties to set
         */
        function StopReplicationMinimumResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StopReplicationMinimumResponse position.
         * @member {string} position
         * @memberof tabletmanagerdata.StopReplicationMinimumResponse
         * @instance
         */
        StopReplicationMinimumResponse.prototype.position = "";

        /**
         * Creates a new StopReplicationMinimumResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.StopReplicationMinimumResponse
         * @static
         * @param {tabletmanagerdata.IStopReplicationMinimumResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.StopReplicationMinimumResponse} StopReplicationMinimumResponse instance
         */
        StopReplicationMinimumResponse.create = function create(properties) {
            return new StopReplicationMinimumResponse(properties);
        };

        /**
         * Encodes the specified StopReplicationMinimumResponse message. Does not implicitly {@link tabletmanagerdata.StopReplicationMinimumResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.StopReplicationMinimumResponse
         * @static
         * @param {tabletmanagerdata.IStopReplicationMinimumResponse} message StopReplicationMinimumResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopReplicationMinimumResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.position);
            return writer;
        };

        /**
         * Encodes the specified StopReplicationMinimumResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.StopReplicationMinimumResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.StopReplicationMinimumResponse
         * @static
         * @param {tabletmanagerdata.IStopReplicationMinimumResponse} message StopReplicationMinimumResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopReplicationMinimumResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StopReplicationMinimumResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.StopReplicationMinimumResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.StopReplicationMinimumResponse} StopReplicationMinimumResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopReplicationMinimumResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.StopReplicationMinimumResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.position = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StopReplicationMinimumResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.StopReplicationMinimumResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.StopReplicationMinimumResponse} StopReplicationMinimumResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopReplicationMinimumResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StopReplicationMinimumResponse message.
         * @function verify
         * @memberof tabletmanagerdata.StopReplicationMinimumResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StopReplicationMinimumResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.position != null && message.hasOwnProperty("position"))
                if (!$util.isString(message.position))
                    return "position: string expected";
            return null;
        };

        /**
         * Creates a StopReplicationMinimumResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.StopReplicationMinimumResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.StopReplicationMinimumResponse} StopReplicationMinimumResponse
         */
        StopReplicationMinimumResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.StopReplicationMinimumResponse)
                return object;
            var message = new $root.tabletmanagerdata.StopReplicationMinimumResponse();
            if (object.position != null)
                message.position = String(object.position);
            return message;
        };

        /**
         * Creates a plain object from a StopReplicationMinimumResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.StopReplicationMinimumResponse
         * @static
         * @param {tabletmanagerdata.StopReplicationMinimumResponse} message StopReplicationMinimumResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StopReplicationMinimumResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.position = "";
            if (message.position != null && message.hasOwnProperty("position"))
                object.position = message.position;
            return object;
        };

        /**
         * Converts this StopReplicationMinimumResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.StopReplicationMinimumResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StopReplicationMinimumResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StopReplicationMinimumResponse;
    })();

    tabletmanagerdata.StartReplicationRequest = (function() {

        /**
         * Properties of a StartReplicationRequest.
         * @memberof tabletmanagerdata
         * @interface IStartReplicationRequest
         */

        /**
         * Constructs a new StartReplicationRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents a StartReplicationRequest.
         * @implements IStartReplicationRequest
         * @constructor
         * @param {tabletmanagerdata.IStartReplicationRequest=} [properties] Properties to set
         */
        function StartReplicationRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new StartReplicationRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.StartReplicationRequest
         * @static
         * @param {tabletmanagerdata.IStartReplicationRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.StartReplicationRequest} StartReplicationRequest instance
         */
        StartReplicationRequest.create = function create(properties) {
            return new StartReplicationRequest(properties);
        };

        /**
         * Encodes the specified StartReplicationRequest message. Does not implicitly {@link tabletmanagerdata.StartReplicationRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.StartReplicationRequest
         * @static
         * @param {tabletmanagerdata.IStartReplicationRequest} message StartReplicationRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartReplicationRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified StartReplicationRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.StartReplicationRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.StartReplicationRequest
         * @static
         * @param {tabletmanagerdata.IStartReplicationRequest} message StartReplicationRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartReplicationRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StartReplicationRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.StartReplicationRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.StartReplicationRequest} StartReplicationRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartReplicationRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.StartReplicationRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StartReplicationRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.StartReplicationRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.StartReplicationRequest} StartReplicationRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartReplicationRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StartReplicationRequest message.
         * @function verify
         * @memberof tabletmanagerdata.StartReplicationRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StartReplicationRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a StartReplicationRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.StartReplicationRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.StartReplicationRequest} StartReplicationRequest
         */
        StartReplicationRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.StartReplicationRequest)
                return object;
            return new $root.tabletmanagerdata.StartReplicationRequest();
        };

        /**
         * Creates a plain object from a StartReplicationRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.StartReplicationRequest
         * @static
         * @param {tabletmanagerdata.StartReplicationRequest} message StartReplicationRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StartReplicationRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this StartReplicationRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.StartReplicationRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StartReplicationRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StartReplicationRequest;
    })();

    tabletmanagerdata.StartReplicationResponse = (function() {

        /**
         * Properties of a StartReplicationResponse.
         * @memberof tabletmanagerdata
         * @interface IStartReplicationResponse
         */

        /**
         * Constructs a new StartReplicationResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents a StartReplicationResponse.
         * @implements IStartReplicationResponse
         * @constructor
         * @param {tabletmanagerdata.IStartReplicationResponse=} [properties] Properties to set
         */
        function StartReplicationResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new StartReplicationResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.StartReplicationResponse
         * @static
         * @param {tabletmanagerdata.IStartReplicationResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.StartReplicationResponse} StartReplicationResponse instance
         */
        StartReplicationResponse.create = function create(properties) {
            return new StartReplicationResponse(properties);
        };

        /**
         * Encodes the specified StartReplicationResponse message. Does not implicitly {@link tabletmanagerdata.StartReplicationResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.StartReplicationResponse
         * @static
         * @param {tabletmanagerdata.IStartReplicationResponse} message StartReplicationResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartReplicationResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified StartReplicationResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.StartReplicationResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.StartReplicationResponse
         * @static
         * @param {tabletmanagerdata.IStartReplicationResponse} message StartReplicationResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartReplicationResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StartReplicationResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.StartReplicationResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.StartReplicationResponse} StartReplicationResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartReplicationResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.StartReplicationResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StartReplicationResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.StartReplicationResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.StartReplicationResponse} StartReplicationResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartReplicationResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StartReplicationResponse message.
         * @function verify
         * @memberof tabletmanagerdata.StartReplicationResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StartReplicationResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a StartReplicationResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.StartReplicationResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.StartReplicationResponse} StartReplicationResponse
         */
        StartReplicationResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.StartReplicationResponse)
                return object;
            return new $root.tabletmanagerdata.StartReplicationResponse();
        };

        /**
         * Creates a plain object from a StartReplicationResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.StartReplicationResponse
         * @static
         * @param {tabletmanagerdata.StartReplicationResponse} message StartReplicationResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StartReplicationResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this StartReplicationResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.StartReplicationResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StartReplicationResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StartReplicationResponse;
    })();

    tabletmanagerdata.StartReplicationUntilAfterRequest = (function() {

        /**
         * Properties of a StartReplicationUntilAfterRequest.
         * @memberof tabletmanagerdata
         * @interface IStartReplicationUntilAfterRequest
         * @property {string|null} [position] StartReplicationUntilAfterRequest position
         * @property {number|Long|null} [wait_timeout] StartReplicationUntilAfterRequest wait_timeout
         */

        /**
         * Constructs a new StartReplicationUntilAfterRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents a StartReplicationUntilAfterRequest.
         * @implements IStartReplicationUntilAfterRequest
         * @constructor
         * @param {tabletmanagerdata.IStartReplicationUntilAfterRequest=} [properties] Properties to set
         */
        function StartReplicationUntilAfterRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StartReplicationUntilAfterRequest position.
         * @member {string} position
         * @memberof tabletmanagerdata.StartReplicationUntilAfterRequest
         * @instance
         */
        StartReplicationUntilAfterRequest.prototype.position = "";

        /**
         * StartReplicationUntilAfterRequest wait_timeout.
         * @member {number|Long} wait_timeout
         * @memberof tabletmanagerdata.StartReplicationUntilAfterRequest
         * @instance
         */
        StartReplicationUntilAfterRequest.prototype.wait_timeout = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new StartReplicationUntilAfterRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.StartReplicationUntilAfterRequest
         * @static
         * @param {tabletmanagerdata.IStartReplicationUntilAfterRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.StartReplicationUntilAfterRequest} StartReplicationUntilAfterRequest instance
         */
        StartReplicationUntilAfterRequest.create = function create(properties) {
            return new StartReplicationUntilAfterRequest(properties);
        };

        /**
         * Encodes the specified StartReplicationUntilAfterRequest message. Does not implicitly {@link tabletmanagerdata.StartReplicationUntilAfterRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.StartReplicationUntilAfterRequest
         * @static
         * @param {tabletmanagerdata.IStartReplicationUntilAfterRequest} message StartReplicationUntilAfterRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartReplicationUntilAfterRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.position);
            if (message.wait_timeout != null && Object.hasOwnProperty.call(message, "wait_timeout"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.wait_timeout);
            return writer;
        };

        /**
         * Encodes the specified StartReplicationUntilAfterRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.StartReplicationUntilAfterRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.StartReplicationUntilAfterRequest
         * @static
         * @param {tabletmanagerdata.IStartReplicationUntilAfterRequest} message StartReplicationUntilAfterRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartReplicationUntilAfterRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StartReplicationUntilAfterRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.StartReplicationUntilAfterRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.StartReplicationUntilAfterRequest} StartReplicationUntilAfterRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartReplicationUntilAfterRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.StartReplicationUntilAfterRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.position = reader.string();
                    break;
                case 2:
                    message.wait_timeout = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StartReplicationUntilAfterRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.StartReplicationUntilAfterRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.StartReplicationUntilAfterRequest} StartReplicationUntilAfterRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartReplicationUntilAfterRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StartReplicationUntilAfterRequest message.
         * @function verify
         * @memberof tabletmanagerdata.StartReplicationUntilAfterRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StartReplicationUntilAfterRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.position != null && message.hasOwnProperty("position"))
                if (!$util.isString(message.position))
                    return "position: string expected";
            if (message.wait_timeout != null && message.hasOwnProperty("wait_timeout"))
                if (!$util.isInteger(message.wait_timeout) && !(message.wait_timeout && $util.isInteger(message.wait_timeout.low) && $util.isInteger(message.wait_timeout.high)))
                    return "wait_timeout: integer|Long expected";
            return null;
        };

        /**
         * Creates a StartReplicationUntilAfterRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.StartReplicationUntilAfterRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.StartReplicationUntilAfterRequest} StartReplicationUntilAfterRequest
         */
        StartReplicationUntilAfterRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.StartReplicationUntilAfterRequest)
                return object;
            var message = new $root.tabletmanagerdata.StartReplicationUntilAfterRequest();
            if (object.position != null)
                message.position = String(object.position);
            if (object.wait_timeout != null)
                if ($util.Long)
                    (message.wait_timeout = $util.Long.fromValue(object.wait_timeout)).unsigned = false;
                else if (typeof object.wait_timeout === "string")
                    message.wait_timeout = parseInt(object.wait_timeout, 10);
                else if (typeof object.wait_timeout === "number")
                    message.wait_timeout = object.wait_timeout;
                else if (typeof object.wait_timeout === "object")
                    message.wait_timeout = new $util.LongBits(object.wait_timeout.low >>> 0, object.wait_timeout.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a StartReplicationUntilAfterRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.StartReplicationUntilAfterRequest
         * @static
         * @param {tabletmanagerdata.StartReplicationUntilAfterRequest} message StartReplicationUntilAfterRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StartReplicationUntilAfterRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.position = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.wait_timeout = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.wait_timeout = options.longs === String ? "0" : 0;
            }
            if (message.position != null && message.hasOwnProperty("position"))
                object.position = message.position;
            if (message.wait_timeout != null && message.hasOwnProperty("wait_timeout"))
                if (typeof message.wait_timeout === "number")
                    object.wait_timeout = options.longs === String ? String(message.wait_timeout) : message.wait_timeout;
                else
                    object.wait_timeout = options.longs === String ? $util.Long.prototype.toString.call(message.wait_timeout) : options.longs === Number ? new $util.LongBits(message.wait_timeout.low >>> 0, message.wait_timeout.high >>> 0).toNumber() : message.wait_timeout;
            return object;
        };

        /**
         * Converts this StartReplicationUntilAfterRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.StartReplicationUntilAfterRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StartReplicationUntilAfterRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StartReplicationUntilAfterRequest;
    })();

    tabletmanagerdata.StartReplicationUntilAfterResponse = (function() {

        /**
         * Properties of a StartReplicationUntilAfterResponse.
         * @memberof tabletmanagerdata
         * @interface IStartReplicationUntilAfterResponse
         */

        /**
         * Constructs a new StartReplicationUntilAfterResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents a StartReplicationUntilAfterResponse.
         * @implements IStartReplicationUntilAfterResponse
         * @constructor
         * @param {tabletmanagerdata.IStartReplicationUntilAfterResponse=} [properties] Properties to set
         */
        function StartReplicationUntilAfterResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new StartReplicationUntilAfterResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.StartReplicationUntilAfterResponse
         * @static
         * @param {tabletmanagerdata.IStartReplicationUntilAfterResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.StartReplicationUntilAfterResponse} StartReplicationUntilAfterResponse instance
         */
        StartReplicationUntilAfterResponse.create = function create(properties) {
            return new StartReplicationUntilAfterResponse(properties);
        };

        /**
         * Encodes the specified StartReplicationUntilAfterResponse message. Does not implicitly {@link tabletmanagerdata.StartReplicationUntilAfterResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.StartReplicationUntilAfterResponse
         * @static
         * @param {tabletmanagerdata.IStartReplicationUntilAfterResponse} message StartReplicationUntilAfterResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartReplicationUntilAfterResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified StartReplicationUntilAfterResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.StartReplicationUntilAfterResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.StartReplicationUntilAfterResponse
         * @static
         * @param {tabletmanagerdata.IStartReplicationUntilAfterResponse} message StartReplicationUntilAfterResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartReplicationUntilAfterResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StartReplicationUntilAfterResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.StartReplicationUntilAfterResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.StartReplicationUntilAfterResponse} StartReplicationUntilAfterResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartReplicationUntilAfterResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.StartReplicationUntilAfterResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StartReplicationUntilAfterResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.StartReplicationUntilAfterResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.StartReplicationUntilAfterResponse} StartReplicationUntilAfterResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartReplicationUntilAfterResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StartReplicationUntilAfterResponse message.
         * @function verify
         * @memberof tabletmanagerdata.StartReplicationUntilAfterResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StartReplicationUntilAfterResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a StartReplicationUntilAfterResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.StartReplicationUntilAfterResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.StartReplicationUntilAfterResponse} StartReplicationUntilAfterResponse
         */
        StartReplicationUntilAfterResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.StartReplicationUntilAfterResponse)
                return object;
            return new $root.tabletmanagerdata.StartReplicationUntilAfterResponse();
        };

        /**
         * Creates a plain object from a StartReplicationUntilAfterResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.StartReplicationUntilAfterResponse
         * @static
         * @param {tabletmanagerdata.StartReplicationUntilAfterResponse} message StartReplicationUntilAfterResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StartReplicationUntilAfterResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this StartReplicationUntilAfterResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.StartReplicationUntilAfterResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StartReplicationUntilAfterResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StartReplicationUntilAfterResponse;
    })();

    tabletmanagerdata.GetReplicasRequest = (function() {

        /**
         * Properties of a GetReplicasRequest.
         * @memberof tabletmanagerdata
         * @interface IGetReplicasRequest
         */

        /**
         * Constructs a new GetReplicasRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents a GetReplicasRequest.
         * @implements IGetReplicasRequest
         * @constructor
         * @param {tabletmanagerdata.IGetReplicasRequest=} [properties] Properties to set
         */
        function GetReplicasRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new GetReplicasRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.GetReplicasRequest
         * @static
         * @param {tabletmanagerdata.IGetReplicasRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.GetReplicasRequest} GetReplicasRequest instance
         */
        GetReplicasRequest.create = function create(properties) {
            return new GetReplicasRequest(properties);
        };

        /**
         * Encodes the specified GetReplicasRequest message. Does not implicitly {@link tabletmanagerdata.GetReplicasRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.GetReplicasRequest
         * @static
         * @param {tabletmanagerdata.IGetReplicasRequest} message GetReplicasRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetReplicasRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified GetReplicasRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.GetReplicasRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.GetReplicasRequest
         * @static
         * @param {tabletmanagerdata.IGetReplicasRequest} message GetReplicasRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetReplicasRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetReplicasRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.GetReplicasRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.GetReplicasRequest} GetReplicasRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetReplicasRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.GetReplicasRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetReplicasRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.GetReplicasRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.GetReplicasRequest} GetReplicasRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetReplicasRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetReplicasRequest message.
         * @function verify
         * @memberof tabletmanagerdata.GetReplicasRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetReplicasRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a GetReplicasRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.GetReplicasRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.GetReplicasRequest} GetReplicasRequest
         */
        GetReplicasRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.GetReplicasRequest)
                return object;
            return new $root.tabletmanagerdata.GetReplicasRequest();
        };

        /**
         * Creates a plain object from a GetReplicasRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.GetReplicasRequest
         * @static
         * @param {tabletmanagerdata.GetReplicasRequest} message GetReplicasRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetReplicasRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this GetReplicasRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.GetReplicasRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetReplicasRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetReplicasRequest;
    })();

    tabletmanagerdata.GetReplicasResponse = (function() {

        /**
         * Properties of a GetReplicasResponse.
         * @memberof tabletmanagerdata
         * @interface IGetReplicasResponse
         * @property {Array.<string>|null} [addrs] GetReplicasResponse addrs
         */

        /**
         * Constructs a new GetReplicasResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents a GetReplicasResponse.
         * @implements IGetReplicasResponse
         * @constructor
         * @param {tabletmanagerdata.IGetReplicasResponse=} [properties] Properties to set
         */
        function GetReplicasResponse(properties) {
            this.addrs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetReplicasResponse addrs.
         * @member {Array.<string>} addrs
         * @memberof tabletmanagerdata.GetReplicasResponse
         * @instance
         */
        GetReplicasResponse.prototype.addrs = $util.emptyArray;

        /**
         * Creates a new GetReplicasResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.GetReplicasResponse
         * @static
         * @param {tabletmanagerdata.IGetReplicasResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.GetReplicasResponse} GetReplicasResponse instance
         */
        GetReplicasResponse.create = function create(properties) {
            return new GetReplicasResponse(properties);
        };

        /**
         * Encodes the specified GetReplicasResponse message. Does not implicitly {@link tabletmanagerdata.GetReplicasResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.GetReplicasResponse
         * @static
         * @param {tabletmanagerdata.IGetReplicasResponse} message GetReplicasResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetReplicasResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.addrs != null && message.addrs.length)
                for (var i = 0; i < message.addrs.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.addrs[i]);
            return writer;
        };

        /**
         * Encodes the specified GetReplicasResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.GetReplicasResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.GetReplicasResponse
         * @static
         * @param {tabletmanagerdata.IGetReplicasResponse} message GetReplicasResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetReplicasResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetReplicasResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.GetReplicasResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.GetReplicasResponse} GetReplicasResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetReplicasResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.GetReplicasResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.addrs && message.addrs.length))
                        message.addrs = [];
                    message.addrs.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetReplicasResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.GetReplicasResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.GetReplicasResponse} GetReplicasResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetReplicasResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetReplicasResponse message.
         * @function verify
         * @memberof tabletmanagerdata.GetReplicasResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetReplicasResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.addrs != null && message.hasOwnProperty("addrs")) {
                if (!Array.isArray(message.addrs))
                    return "addrs: array expected";
                for (var i = 0; i < message.addrs.length; ++i)
                    if (!$util.isString(message.addrs[i]))
                        return "addrs: string[] expected";
            }
            return null;
        };

        /**
         * Creates a GetReplicasResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.GetReplicasResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.GetReplicasResponse} GetReplicasResponse
         */
        GetReplicasResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.GetReplicasResponse)
                return object;
            var message = new $root.tabletmanagerdata.GetReplicasResponse();
            if (object.addrs) {
                if (!Array.isArray(object.addrs))
                    throw TypeError(".tabletmanagerdata.GetReplicasResponse.addrs: array expected");
                message.addrs = [];
                for (var i = 0; i < object.addrs.length; ++i)
                    message.addrs[i] = String(object.addrs[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetReplicasResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.GetReplicasResponse
         * @static
         * @param {tabletmanagerdata.GetReplicasResponse} message GetReplicasResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetReplicasResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.addrs = [];
            if (message.addrs && message.addrs.length) {
                object.addrs = [];
                for (var j = 0; j < message.addrs.length; ++j)
                    object.addrs[j] = message.addrs[j];
            }
            return object;
        };

        /**
         * Converts this GetReplicasResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.GetReplicasResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetReplicasResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetReplicasResponse;
    })();

    tabletmanagerdata.ResetReplicationRequest = (function() {

        /**
         * Properties of a ResetReplicationRequest.
         * @memberof tabletmanagerdata
         * @interface IResetReplicationRequest
         */

        /**
         * Constructs a new ResetReplicationRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents a ResetReplicationRequest.
         * @implements IResetReplicationRequest
         * @constructor
         * @param {tabletmanagerdata.IResetReplicationRequest=} [properties] Properties to set
         */
        function ResetReplicationRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ResetReplicationRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.ResetReplicationRequest
         * @static
         * @param {tabletmanagerdata.IResetReplicationRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.ResetReplicationRequest} ResetReplicationRequest instance
         */
        ResetReplicationRequest.create = function create(properties) {
            return new ResetReplicationRequest(properties);
        };

        /**
         * Encodes the specified ResetReplicationRequest message. Does not implicitly {@link tabletmanagerdata.ResetReplicationRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.ResetReplicationRequest
         * @static
         * @param {tabletmanagerdata.IResetReplicationRequest} message ResetReplicationRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResetReplicationRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ResetReplicationRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.ResetReplicationRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.ResetReplicationRequest
         * @static
         * @param {tabletmanagerdata.IResetReplicationRequest} message ResetReplicationRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResetReplicationRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResetReplicationRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.ResetReplicationRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.ResetReplicationRequest} ResetReplicationRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResetReplicationRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.ResetReplicationRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResetReplicationRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.ResetReplicationRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.ResetReplicationRequest} ResetReplicationRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResetReplicationRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResetReplicationRequest message.
         * @function verify
         * @memberof tabletmanagerdata.ResetReplicationRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResetReplicationRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ResetReplicationRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.ResetReplicationRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.ResetReplicationRequest} ResetReplicationRequest
         */
        ResetReplicationRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.ResetReplicationRequest)
                return object;
            return new $root.tabletmanagerdata.ResetReplicationRequest();
        };

        /**
         * Creates a plain object from a ResetReplicationRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.ResetReplicationRequest
         * @static
         * @param {tabletmanagerdata.ResetReplicationRequest} message ResetReplicationRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResetReplicationRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ResetReplicationRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.ResetReplicationRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResetReplicationRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResetReplicationRequest;
    })();

    tabletmanagerdata.ResetReplicationResponse = (function() {

        /**
         * Properties of a ResetReplicationResponse.
         * @memberof tabletmanagerdata
         * @interface IResetReplicationResponse
         */

        /**
         * Constructs a new ResetReplicationResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents a ResetReplicationResponse.
         * @implements IResetReplicationResponse
         * @constructor
         * @param {tabletmanagerdata.IResetReplicationResponse=} [properties] Properties to set
         */
        function ResetReplicationResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ResetReplicationResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.ResetReplicationResponse
         * @static
         * @param {tabletmanagerdata.IResetReplicationResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.ResetReplicationResponse} ResetReplicationResponse instance
         */
        ResetReplicationResponse.create = function create(properties) {
            return new ResetReplicationResponse(properties);
        };

        /**
         * Encodes the specified ResetReplicationResponse message. Does not implicitly {@link tabletmanagerdata.ResetReplicationResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.ResetReplicationResponse
         * @static
         * @param {tabletmanagerdata.IResetReplicationResponse} message ResetReplicationResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResetReplicationResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ResetReplicationResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.ResetReplicationResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.ResetReplicationResponse
         * @static
         * @param {tabletmanagerdata.IResetReplicationResponse} message ResetReplicationResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResetReplicationResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResetReplicationResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.ResetReplicationResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.ResetReplicationResponse} ResetReplicationResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResetReplicationResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.ResetReplicationResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResetReplicationResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.ResetReplicationResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.ResetReplicationResponse} ResetReplicationResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResetReplicationResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResetReplicationResponse message.
         * @function verify
         * @memberof tabletmanagerdata.ResetReplicationResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResetReplicationResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ResetReplicationResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.ResetReplicationResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.ResetReplicationResponse} ResetReplicationResponse
         */
        ResetReplicationResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.ResetReplicationResponse)
                return object;
            return new $root.tabletmanagerdata.ResetReplicationResponse();
        };

        /**
         * Creates a plain object from a ResetReplicationResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.ResetReplicationResponse
         * @static
         * @param {tabletmanagerdata.ResetReplicationResponse} message ResetReplicationResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResetReplicationResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ResetReplicationResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.ResetReplicationResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResetReplicationResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResetReplicationResponse;
    })();

    tabletmanagerdata.VReplicationExecRequest = (function() {

        /**
         * Properties of a VReplicationExecRequest.
         * @memberof tabletmanagerdata
         * @interface IVReplicationExecRequest
         * @property {string|null} [query] VReplicationExecRequest query
         */

        /**
         * Constructs a new VReplicationExecRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents a VReplicationExecRequest.
         * @implements IVReplicationExecRequest
         * @constructor
         * @param {tabletmanagerdata.IVReplicationExecRequest=} [properties] Properties to set
         */
        function VReplicationExecRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VReplicationExecRequest query.
         * @member {string} query
         * @memberof tabletmanagerdata.VReplicationExecRequest
         * @instance
         */
        VReplicationExecRequest.prototype.query = "";

        /**
         * Creates a new VReplicationExecRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.VReplicationExecRequest
         * @static
         * @param {tabletmanagerdata.IVReplicationExecRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.VReplicationExecRequest} VReplicationExecRequest instance
         */
        VReplicationExecRequest.create = function create(properties) {
            return new VReplicationExecRequest(properties);
        };

        /**
         * Encodes the specified VReplicationExecRequest message. Does not implicitly {@link tabletmanagerdata.VReplicationExecRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.VReplicationExecRequest
         * @static
         * @param {tabletmanagerdata.IVReplicationExecRequest} message VReplicationExecRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VReplicationExecRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.query);
            return writer;
        };

        /**
         * Encodes the specified VReplicationExecRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.VReplicationExecRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.VReplicationExecRequest
         * @static
         * @param {tabletmanagerdata.IVReplicationExecRequest} message VReplicationExecRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VReplicationExecRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VReplicationExecRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.VReplicationExecRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.VReplicationExecRequest} VReplicationExecRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VReplicationExecRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.VReplicationExecRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.query = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VReplicationExecRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.VReplicationExecRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.VReplicationExecRequest} VReplicationExecRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VReplicationExecRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VReplicationExecRequest message.
         * @function verify
         * @memberof tabletmanagerdata.VReplicationExecRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VReplicationExecRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.query != null && message.hasOwnProperty("query"))
                if (!$util.isString(message.query))
                    return "query: string expected";
            return null;
        };

        /**
         * Creates a VReplicationExecRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.VReplicationExecRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.VReplicationExecRequest} VReplicationExecRequest
         */
        VReplicationExecRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.VReplicationExecRequest)
                return object;
            var message = new $root.tabletmanagerdata.VReplicationExecRequest();
            if (object.query != null)
                message.query = String(object.query);
            return message;
        };

        /**
         * Creates a plain object from a VReplicationExecRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.VReplicationExecRequest
         * @static
         * @param {tabletmanagerdata.VReplicationExecRequest} message VReplicationExecRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VReplicationExecRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.query = "";
            if (message.query != null && message.hasOwnProperty("query"))
                object.query = message.query;
            return object;
        };

        /**
         * Converts this VReplicationExecRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.VReplicationExecRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VReplicationExecRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VReplicationExecRequest;
    })();

    tabletmanagerdata.VReplicationExecResponse = (function() {

        /**
         * Properties of a VReplicationExecResponse.
         * @memberof tabletmanagerdata
         * @interface IVReplicationExecResponse
         * @property {query.IQueryResult|null} [result] VReplicationExecResponse result
         */

        /**
         * Constructs a new VReplicationExecResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents a VReplicationExecResponse.
         * @implements IVReplicationExecResponse
         * @constructor
         * @param {tabletmanagerdata.IVReplicationExecResponse=} [properties] Properties to set
         */
        function VReplicationExecResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VReplicationExecResponse result.
         * @member {query.IQueryResult|null|undefined} result
         * @memberof tabletmanagerdata.VReplicationExecResponse
         * @instance
         */
        VReplicationExecResponse.prototype.result = null;

        /**
         * Creates a new VReplicationExecResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.VReplicationExecResponse
         * @static
         * @param {tabletmanagerdata.IVReplicationExecResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.VReplicationExecResponse} VReplicationExecResponse instance
         */
        VReplicationExecResponse.create = function create(properties) {
            return new VReplicationExecResponse(properties);
        };

        /**
         * Encodes the specified VReplicationExecResponse message. Does not implicitly {@link tabletmanagerdata.VReplicationExecResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.VReplicationExecResponse
         * @static
         * @param {tabletmanagerdata.IVReplicationExecResponse} message VReplicationExecResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VReplicationExecResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                $root.query.QueryResult.encode(message.result, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified VReplicationExecResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.VReplicationExecResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.VReplicationExecResponse
         * @static
         * @param {tabletmanagerdata.IVReplicationExecResponse} message VReplicationExecResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VReplicationExecResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VReplicationExecResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.VReplicationExecResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.VReplicationExecResponse} VReplicationExecResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VReplicationExecResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.VReplicationExecResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = $root.query.QueryResult.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VReplicationExecResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.VReplicationExecResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.VReplicationExecResponse} VReplicationExecResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VReplicationExecResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VReplicationExecResponse message.
         * @function verify
         * @memberof tabletmanagerdata.VReplicationExecResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VReplicationExecResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result")) {
                var error = $root.query.QueryResult.verify(message.result);
                if (error)
                    return "result." + error;
            }
            return null;
        };

        /**
         * Creates a VReplicationExecResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.VReplicationExecResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.VReplicationExecResponse} VReplicationExecResponse
         */
        VReplicationExecResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.VReplicationExecResponse)
                return object;
            var message = new $root.tabletmanagerdata.VReplicationExecResponse();
            if (object.result != null) {
                if (typeof object.result !== "object")
                    throw TypeError(".tabletmanagerdata.VReplicationExecResponse.result: object expected");
                message.result = $root.query.QueryResult.fromObject(object.result);
            }
            return message;
        };

        /**
         * Creates a plain object from a VReplicationExecResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.VReplicationExecResponse
         * @static
         * @param {tabletmanagerdata.VReplicationExecResponse} message VReplicationExecResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VReplicationExecResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = null;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = $root.query.QueryResult.toObject(message.result, options);
            return object;
        };

        /**
         * Converts this VReplicationExecResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.VReplicationExecResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VReplicationExecResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VReplicationExecResponse;
    })();

    tabletmanagerdata.VReplicationWaitForPosRequest = (function() {

        /**
         * Properties of a VReplicationWaitForPosRequest.
         * @memberof tabletmanagerdata
         * @interface IVReplicationWaitForPosRequest
         * @property {number|Long|null} [id] VReplicationWaitForPosRequest id
         * @property {string|null} [position] VReplicationWaitForPosRequest position
         */

        /**
         * Constructs a new VReplicationWaitForPosRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents a VReplicationWaitForPosRequest.
         * @implements IVReplicationWaitForPosRequest
         * @constructor
         * @param {tabletmanagerdata.IVReplicationWaitForPosRequest=} [properties] Properties to set
         */
        function VReplicationWaitForPosRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VReplicationWaitForPosRequest id.
         * @member {number|Long} id
         * @memberof tabletmanagerdata.VReplicationWaitForPosRequest
         * @instance
         */
        VReplicationWaitForPosRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * VReplicationWaitForPosRequest position.
         * @member {string} position
         * @memberof tabletmanagerdata.VReplicationWaitForPosRequest
         * @instance
         */
        VReplicationWaitForPosRequest.prototype.position = "";

        /**
         * Creates a new VReplicationWaitForPosRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.VReplicationWaitForPosRequest
         * @static
         * @param {tabletmanagerdata.IVReplicationWaitForPosRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.VReplicationWaitForPosRequest} VReplicationWaitForPosRequest instance
         */
        VReplicationWaitForPosRequest.create = function create(properties) {
            return new VReplicationWaitForPosRequest(properties);
        };

        /**
         * Encodes the specified VReplicationWaitForPosRequest message. Does not implicitly {@link tabletmanagerdata.VReplicationWaitForPosRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.VReplicationWaitForPosRequest
         * @static
         * @param {tabletmanagerdata.IVReplicationWaitForPosRequest} message VReplicationWaitForPosRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VReplicationWaitForPosRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.id);
            if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.position);
            return writer;
        };

        /**
         * Encodes the specified VReplicationWaitForPosRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.VReplicationWaitForPosRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.VReplicationWaitForPosRequest
         * @static
         * @param {tabletmanagerdata.IVReplicationWaitForPosRequest} message VReplicationWaitForPosRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VReplicationWaitForPosRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VReplicationWaitForPosRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.VReplicationWaitForPosRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.VReplicationWaitForPosRequest} VReplicationWaitForPosRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VReplicationWaitForPosRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.VReplicationWaitForPosRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int64();
                    break;
                case 2:
                    message.position = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VReplicationWaitForPosRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.VReplicationWaitForPosRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.VReplicationWaitForPosRequest} VReplicationWaitForPosRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VReplicationWaitForPosRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VReplicationWaitForPosRequest message.
         * @function verify
         * @memberof tabletmanagerdata.VReplicationWaitForPosRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VReplicationWaitForPosRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            if (message.position != null && message.hasOwnProperty("position"))
                if (!$util.isString(message.position))
                    return "position: string expected";
            return null;
        };

        /**
         * Creates a VReplicationWaitForPosRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.VReplicationWaitForPosRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.VReplicationWaitForPosRequest} VReplicationWaitForPosRequest
         */
        VReplicationWaitForPosRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.VReplicationWaitForPosRequest)
                return object;
            var message = new $root.tabletmanagerdata.VReplicationWaitForPosRequest();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = false;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
            if (object.position != null)
                message.position = String(object.position);
            return message;
        };

        /**
         * Creates a plain object from a VReplicationWaitForPosRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.VReplicationWaitForPosRequest
         * @static
         * @param {tabletmanagerdata.VReplicationWaitForPosRequest} message VReplicationWaitForPosRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VReplicationWaitForPosRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
                object.position = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
            if (message.position != null && message.hasOwnProperty("position"))
                object.position = message.position;
            return object;
        };

        /**
         * Converts this VReplicationWaitForPosRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.VReplicationWaitForPosRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VReplicationWaitForPosRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VReplicationWaitForPosRequest;
    })();

    tabletmanagerdata.VReplicationWaitForPosResponse = (function() {

        /**
         * Properties of a VReplicationWaitForPosResponse.
         * @memberof tabletmanagerdata
         * @interface IVReplicationWaitForPosResponse
         */

        /**
         * Constructs a new VReplicationWaitForPosResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents a VReplicationWaitForPosResponse.
         * @implements IVReplicationWaitForPosResponse
         * @constructor
         * @param {tabletmanagerdata.IVReplicationWaitForPosResponse=} [properties] Properties to set
         */
        function VReplicationWaitForPosResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new VReplicationWaitForPosResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.VReplicationWaitForPosResponse
         * @static
         * @param {tabletmanagerdata.IVReplicationWaitForPosResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.VReplicationWaitForPosResponse} VReplicationWaitForPosResponse instance
         */
        VReplicationWaitForPosResponse.create = function create(properties) {
            return new VReplicationWaitForPosResponse(properties);
        };

        /**
         * Encodes the specified VReplicationWaitForPosResponse message. Does not implicitly {@link tabletmanagerdata.VReplicationWaitForPosResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.VReplicationWaitForPosResponse
         * @static
         * @param {tabletmanagerdata.IVReplicationWaitForPosResponse} message VReplicationWaitForPosResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VReplicationWaitForPosResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified VReplicationWaitForPosResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.VReplicationWaitForPosResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.VReplicationWaitForPosResponse
         * @static
         * @param {tabletmanagerdata.IVReplicationWaitForPosResponse} message VReplicationWaitForPosResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VReplicationWaitForPosResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VReplicationWaitForPosResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.VReplicationWaitForPosResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.VReplicationWaitForPosResponse} VReplicationWaitForPosResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VReplicationWaitForPosResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.VReplicationWaitForPosResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VReplicationWaitForPosResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.VReplicationWaitForPosResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.VReplicationWaitForPosResponse} VReplicationWaitForPosResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VReplicationWaitForPosResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VReplicationWaitForPosResponse message.
         * @function verify
         * @memberof tabletmanagerdata.VReplicationWaitForPosResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VReplicationWaitForPosResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a VReplicationWaitForPosResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.VReplicationWaitForPosResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.VReplicationWaitForPosResponse} VReplicationWaitForPosResponse
         */
        VReplicationWaitForPosResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.VReplicationWaitForPosResponse)
                return object;
            return new $root.tabletmanagerdata.VReplicationWaitForPosResponse();
        };

        /**
         * Creates a plain object from a VReplicationWaitForPosResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.VReplicationWaitForPosResponse
         * @static
         * @param {tabletmanagerdata.VReplicationWaitForPosResponse} message VReplicationWaitForPosResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VReplicationWaitForPosResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this VReplicationWaitForPosResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.VReplicationWaitForPosResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VReplicationWaitForPosResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VReplicationWaitForPosResponse;
    })();

    tabletmanagerdata.InitMasterRequest = (function() {

        /**
         * Properties of an InitMasterRequest.
         * @memberof tabletmanagerdata
         * @interface IInitMasterRequest
         */

        /**
         * Constructs a new InitMasterRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents an InitMasterRequest.
         * @implements IInitMasterRequest
         * @constructor
         * @param {tabletmanagerdata.IInitMasterRequest=} [properties] Properties to set
         */
        function InitMasterRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new InitMasterRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.InitMasterRequest
         * @static
         * @param {tabletmanagerdata.IInitMasterRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.InitMasterRequest} InitMasterRequest instance
         */
        InitMasterRequest.create = function create(properties) {
            return new InitMasterRequest(properties);
        };

        /**
         * Encodes the specified InitMasterRequest message. Does not implicitly {@link tabletmanagerdata.InitMasterRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.InitMasterRequest
         * @static
         * @param {tabletmanagerdata.IInitMasterRequest} message InitMasterRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InitMasterRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified InitMasterRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.InitMasterRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.InitMasterRequest
         * @static
         * @param {tabletmanagerdata.IInitMasterRequest} message InitMasterRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InitMasterRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InitMasterRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.InitMasterRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.InitMasterRequest} InitMasterRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InitMasterRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.InitMasterRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InitMasterRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.InitMasterRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.InitMasterRequest} InitMasterRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InitMasterRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InitMasterRequest message.
         * @function verify
         * @memberof tabletmanagerdata.InitMasterRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InitMasterRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates an InitMasterRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.InitMasterRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.InitMasterRequest} InitMasterRequest
         */
        InitMasterRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.InitMasterRequest)
                return object;
            return new $root.tabletmanagerdata.InitMasterRequest();
        };

        /**
         * Creates a plain object from an InitMasterRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.InitMasterRequest
         * @static
         * @param {tabletmanagerdata.InitMasterRequest} message InitMasterRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InitMasterRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this InitMasterRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.InitMasterRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InitMasterRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return InitMasterRequest;
    })();

    tabletmanagerdata.InitMasterResponse = (function() {

        /**
         * Properties of an InitMasterResponse.
         * @memberof tabletmanagerdata
         * @interface IInitMasterResponse
         * @property {string|null} [position] InitMasterResponse position
         */

        /**
         * Constructs a new InitMasterResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents an InitMasterResponse.
         * @implements IInitMasterResponse
         * @constructor
         * @param {tabletmanagerdata.IInitMasterResponse=} [properties] Properties to set
         */
        function InitMasterResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InitMasterResponse position.
         * @member {string} position
         * @memberof tabletmanagerdata.InitMasterResponse
         * @instance
         */
        InitMasterResponse.prototype.position = "";

        /**
         * Creates a new InitMasterResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.InitMasterResponse
         * @static
         * @param {tabletmanagerdata.IInitMasterResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.InitMasterResponse} InitMasterResponse instance
         */
        InitMasterResponse.create = function create(properties) {
            return new InitMasterResponse(properties);
        };

        /**
         * Encodes the specified InitMasterResponse message. Does not implicitly {@link tabletmanagerdata.InitMasterResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.InitMasterResponse
         * @static
         * @param {tabletmanagerdata.IInitMasterResponse} message InitMasterResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InitMasterResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.position);
            return writer;
        };

        /**
         * Encodes the specified InitMasterResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.InitMasterResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.InitMasterResponse
         * @static
         * @param {tabletmanagerdata.IInitMasterResponse} message InitMasterResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InitMasterResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InitMasterResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.InitMasterResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.InitMasterResponse} InitMasterResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InitMasterResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.InitMasterResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.position = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InitMasterResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.InitMasterResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.InitMasterResponse} InitMasterResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InitMasterResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InitMasterResponse message.
         * @function verify
         * @memberof tabletmanagerdata.InitMasterResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InitMasterResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.position != null && message.hasOwnProperty("position"))
                if (!$util.isString(message.position))
                    return "position: string expected";
            return null;
        };

        /**
         * Creates an InitMasterResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.InitMasterResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.InitMasterResponse} InitMasterResponse
         */
        InitMasterResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.InitMasterResponse)
                return object;
            var message = new $root.tabletmanagerdata.InitMasterResponse();
            if (object.position != null)
                message.position = String(object.position);
            return message;
        };

        /**
         * Creates a plain object from an InitMasterResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.InitMasterResponse
         * @static
         * @param {tabletmanagerdata.InitMasterResponse} message InitMasterResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InitMasterResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.position = "";
            if (message.position != null && message.hasOwnProperty("position"))
                object.position = message.position;
            return object;
        };

        /**
         * Converts this InitMasterResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.InitMasterResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InitMasterResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return InitMasterResponse;
    })();

    tabletmanagerdata.PopulateReparentJournalRequest = (function() {

        /**
         * Properties of a PopulateReparentJournalRequest.
         * @memberof tabletmanagerdata
         * @interface IPopulateReparentJournalRequest
         * @property {number|Long|null} [time_created_ns] PopulateReparentJournalRequest time_created_ns
         * @property {string|null} [action_name] PopulateReparentJournalRequest action_name
         * @property {topodata.ITabletAlias|null} [master_alias] PopulateReparentJournalRequest master_alias
         * @property {string|null} [replication_position] PopulateReparentJournalRequest replication_position
         */

        /**
         * Constructs a new PopulateReparentJournalRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents a PopulateReparentJournalRequest.
         * @implements IPopulateReparentJournalRequest
         * @constructor
         * @param {tabletmanagerdata.IPopulateReparentJournalRequest=} [properties] Properties to set
         */
        function PopulateReparentJournalRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PopulateReparentJournalRequest time_created_ns.
         * @member {number|Long} time_created_ns
         * @memberof tabletmanagerdata.PopulateReparentJournalRequest
         * @instance
         */
        PopulateReparentJournalRequest.prototype.time_created_ns = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PopulateReparentJournalRequest action_name.
         * @member {string} action_name
         * @memberof tabletmanagerdata.PopulateReparentJournalRequest
         * @instance
         */
        PopulateReparentJournalRequest.prototype.action_name = "";

        /**
         * PopulateReparentJournalRequest master_alias.
         * @member {topodata.ITabletAlias|null|undefined} master_alias
         * @memberof tabletmanagerdata.PopulateReparentJournalRequest
         * @instance
         */
        PopulateReparentJournalRequest.prototype.master_alias = null;

        /**
         * PopulateReparentJournalRequest replication_position.
         * @member {string} replication_position
         * @memberof tabletmanagerdata.PopulateReparentJournalRequest
         * @instance
         */
        PopulateReparentJournalRequest.prototype.replication_position = "";

        /**
         * Creates a new PopulateReparentJournalRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.PopulateReparentJournalRequest
         * @static
         * @param {tabletmanagerdata.IPopulateReparentJournalRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.PopulateReparentJournalRequest} PopulateReparentJournalRequest instance
         */
        PopulateReparentJournalRequest.create = function create(properties) {
            return new PopulateReparentJournalRequest(properties);
        };

        /**
         * Encodes the specified PopulateReparentJournalRequest message. Does not implicitly {@link tabletmanagerdata.PopulateReparentJournalRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.PopulateReparentJournalRequest
         * @static
         * @param {tabletmanagerdata.IPopulateReparentJournalRequest} message PopulateReparentJournalRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PopulateReparentJournalRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.time_created_ns != null && Object.hasOwnProperty.call(message, "time_created_ns"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.time_created_ns);
            if (message.action_name != null && Object.hasOwnProperty.call(message, "action_name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.action_name);
            if (message.master_alias != null && Object.hasOwnProperty.call(message, "master_alias"))
                $root.topodata.TabletAlias.encode(message.master_alias, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.replication_position != null && Object.hasOwnProperty.call(message, "replication_position"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.replication_position);
            return writer;
        };

        /**
         * Encodes the specified PopulateReparentJournalRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.PopulateReparentJournalRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.PopulateReparentJournalRequest
         * @static
         * @param {tabletmanagerdata.IPopulateReparentJournalRequest} message PopulateReparentJournalRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PopulateReparentJournalRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PopulateReparentJournalRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.PopulateReparentJournalRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.PopulateReparentJournalRequest} PopulateReparentJournalRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PopulateReparentJournalRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.PopulateReparentJournalRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.time_created_ns = reader.int64();
                    break;
                case 2:
                    message.action_name = reader.string();
                    break;
                case 3:
                    message.master_alias = $root.topodata.TabletAlias.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.replication_position = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PopulateReparentJournalRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.PopulateReparentJournalRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.PopulateReparentJournalRequest} PopulateReparentJournalRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PopulateReparentJournalRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PopulateReparentJournalRequest message.
         * @function verify
         * @memberof tabletmanagerdata.PopulateReparentJournalRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PopulateReparentJournalRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.time_created_ns != null && message.hasOwnProperty("time_created_ns"))
                if (!$util.isInteger(message.time_created_ns) && !(message.time_created_ns && $util.isInteger(message.time_created_ns.low) && $util.isInteger(message.time_created_ns.high)))
                    return "time_created_ns: integer|Long expected";
            if (message.action_name != null && message.hasOwnProperty("action_name"))
                if (!$util.isString(message.action_name))
                    return "action_name: string expected";
            if (message.master_alias != null && message.hasOwnProperty("master_alias")) {
                var error = $root.topodata.TabletAlias.verify(message.master_alias);
                if (error)
                    return "master_alias." + error;
            }
            if (message.replication_position != null && message.hasOwnProperty("replication_position"))
                if (!$util.isString(message.replication_position))
                    return "replication_position: string expected";
            return null;
        };

        /**
         * Creates a PopulateReparentJournalRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.PopulateReparentJournalRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.PopulateReparentJournalRequest} PopulateReparentJournalRequest
         */
        PopulateReparentJournalRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.PopulateReparentJournalRequest)
                return object;
            var message = new $root.tabletmanagerdata.PopulateReparentJournalRequest();
            if (object.time_created_ns != null)
                if ($util.Long)
                    (message.time_created_ns = $util.Long.fromValue(object.time_created_ns)).unsigned = false;
                else if (typeof object.time_created_ns === "string")
                    message.time_created_ns = parseInt(object.time_created_ns, 10);
                else if (typeof object.time_created_ns === "number")
                    message.time_created_ns = object.time_created_ns;
                else if (typeof object.time_created_ns === "object")
                    message.time_created_ns = new $util.LongBits(object.time_created_ns.low >>> 0, object.time_created_ns.high >>> 0).toNumber();
            if (object.action_name != null)
                message.action_name = String(object.action_name);
            if (object.master_alias != null) {
                if (typeof object.master_alias !== "object")
                    throw TypeError(".tabletmanagerdata.PopulateReparentJournalRequest.master_alias: object expected");
                message.master_alias = $root.topodata.TabletAlias.fromObject(object.master_alias);
            }
            if (object.replication_position != null)
                message.replication_position = String(object.replication_position);
            return message;
        };

        /**
         * Creates a plain object from a PopulateReparentJournalRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.PopulateReparentJournalRequest
         * @static
         * @param {tabletmanagerdata.PopulateReparentJournalRequest} message PopulateReparentJournalRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PopulateReparentJournalRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.time_created_ns = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.time_created_ns = options.longs === String ? "0" : 0;
                object.action_name = "";
                object.master_alias = null;
                object.replication_position = "";
            }
            if (message.time_created_ns != null && message.hasOwnProperty("time_created_ns"))
                if (typeof message.time_created_ns === "number")
                    object.time_created_ns = options.longs === String ? String(message.time_created_ns) : message.time_created_ns;
                else
                    object.time_created_ns = options.longs === String ? $util.Long.prototype.toString.call(message.time_created_ns) : options.longs === Number ? new $util.LongBits(message.time_created_ns.low >>> 0, message.time_created_ns.high >>> 0).toNumber() : message.time_created_ns;
            if (message.action_name != null && message.hasOwnProperty("action_name"))
                object.action_name = message.action_name;
            if (message.master_alias != null && message.hasOwnProperty("master_alias"))
                object.master_alias = $root.topodata.TabletAlias.toObject(message.master_alias, options);
            if (message.replication_position != null && message.hasOwnProperty("replication_position"))
                object.replication_position = message.replication_position;
            return object;
        };

        /**
         * Converts this PopulateReparentJournalRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.PopulateReparentJournalRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PopulateReparentJournalRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PopulateReparentJournalRequest;
    })();

    tabletmanagerdata.PopulateReparentJournalResponse = (function() {

        /**
         * Properties of a PopulateReparentJournalResponse.
         * @memberof tabletmanagerdata
         * @interface IPopulateReparentJournalResponse
         */

        /**
         * Constructs a new PopulateReparentJournalResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents a PopulateReparentJournalResponse.
         * @implements IPopulateReparentJournalResponse
         * @constructor
         * @param {tabletmanagerdata.IPopulateReparentJournalResponse=} [properties] Properties to set
         */
        function PopulateReparentJournalResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new PopulateReparentJournalResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.PopulateReparentJournalResponse
         * @static
         * @param {tabletmanagerdata.IPopulateReparentJournalResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.PopulateReparentJournalResponse} PopulateReparentJournalResponse instance
         */
        PopulateReparentJournalResponse.create = function create(properties) {
            return new PopulateReparentJournalResponse(properties);
        };

        /**
         * Encodes the specified PopulateReparentJournalResponse message. Does not implicitly {@link tabletmanagerdata.PopulateReparentJournalResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.PopulateReparentJournalResponse
         * @static
         * @param {tabletmanagerdata.IPopulateReparentJournalResponse} message PopulateReparentJournalResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PopulateReparentJournalResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified PopulateReparentJournalResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.PopulateReparentJournalResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.PopulateReparentJournalResponse
         * @static
         * @param {tabletmanagerdata.IPopulateReparentJournalResponse} message PopulateReparentJournalResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PopulateReparentJournalResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PopulateReparentJournalResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.PopulateReparentJournalResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.PopulateReparentJournalResponse} PopulateReparentJournalResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PopulateReparentJournalResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.PopulateReparentJournalResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PopulateReparentJournalResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.PopulateReparentJournalResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.PopulateReparentJournalResponse} PopulateReparentJournalResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PopulateReparentJournalResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PopulateReparentJournalResponse message.
         * @function verify
         * @memberof tabletmanagerdata.PopulateReparentJournalResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PopulateReparentJournalResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a PopulateReparentJournalResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.PopulateReparentJournalResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.PopulateReparentJournalResponse} PopulateReparentJournalResponse
         */
        PopulateReparentJournalResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.PopulateReparentJournalResponse)
                return object;
            return new $root.tabletmanagerdata.PopulateReparentJournalResponse();
        };

        /**
         * Creates a plain object from a PopulateReparentJournalResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.PopulateReparentJournalResponse
         * @static
         * @param {tabletmanagerdata.PopulateReparentJournalResponse} message PopulateReparentJournalResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PopulateReparentJournalResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this PopulateReparentJournalResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.PopulateReparentJournalResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PopulateReparentJournalResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PopulateReparentJournalResponse;
    })();

    tabletmanagerdata.InitReplicaRequest = (function() {

        /**
         * Properties of an InitReplicaRequest.
         * @memberof tabletmanagerdata
         * @interface IInitReplicaRequest
         * @property {topodata.ITabletAlias|null} [parent] InitReplicaRequest parent
         * @property {string|null} [replication_position] InitReplicaRequest replication_position
         * @property {number|Long|null} [time_created_ns] InitReplicaRequest time_created_ns
         */

        /**
         * Constructs a new InitReplicaRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents an InitReplicaRequest.
         * @implements IInitReplicaRequest
         * @constructor
         * @param {tabletmanagerdata.IInitReplicaRequest=} [properties] Properties to set
         */
        function InitReplicaRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InitReplicaRequest parent.
         * @member {topodata.ITabletAlias|null|undefined} parent
         * @memberof tabletmanagerdata.InitReplicaRequest
         * @instance
         */
        InitReplicaRequest.prototype.parent = null;

        /**
         * InitReplicaRequest replication_position.
         * @member {string} replication_position
         * @memberof tabletmanagerdata.InitReplicaRequest
         * @instance
         */
        InitReplicaRequest.prototype.replication_position = "";

        /**
         * InitReplicaRequest time_created_ns.
         * @member {number|Long} time_created_ns
         * @memberof tabletmanagerdata.InitReplicaRequest
         * @instance
         */
        InitReplicaRequest.prototype.time_created_ns = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new InitReplicaRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.InitReplicaRequest
         * @static
         * @param {tabletmanagerdata.IInitReplicaRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.InitReplicaRequest} InitReplicaRequest instance
         */
        InitReplicaRequest.create = function create(properties) {
            return new InitReplicaRequest(properties);
        };

        /**
         * Encodes the specified InitReplicaRequest message. Does not implicitly {@link tabletmanagerdata.InitReplicaRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.InitReplicaRequest
         * @static
         * @param {tabletmanagerdata.IInitReplicaRequest} message InitReplicaRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InitReplicaRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.parent != null && Object.hasOwnProperty.call(message, "parent"))
                $root.topodata.TabletAlias.encode(message.parent, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.replication_position != null && Object.hasOwnProperty.call(message, "replication_position"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.replication_position);
            if (message.time_created_ns != null && Object.hasOwnProperty.call(message, "time_created_ns"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.time_created_ns);
            return writer;
        };

        /**
         * Encodes the specified InitReplicaRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.InitReplicaRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.InitReplicaRequest
         * @static
         * @param {tabletmanagerdata.IInitReplicaRequest} message InitReplicaRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InitReplicaRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InitReplicaRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.InitReplicaRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.InitReplicaRequest} InitReplicaRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InitReplicaRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.InitReplicaRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.parent = $root.topodata.TabletAlias.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.replication_position = reader.string();
                    break;
                case 3:
                    message.time_created_ns = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InitReplicaRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.InitReplicaRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.InitReplicaRequest} InitReplicaRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InitReplicaRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InitReplicaRequest message.
         * @function verify
         * @memberof tabletmanagerdata.InitReplicaRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InitReplicaRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.parent != null && message.hasOwnProperty("parent")) {
                var error = $root.topodata.TabletAlias.verify(message.parent);
                if (error)
                    return "parent." + error;
            }
            if (message.replication_position != null && message.hasOwnProperty("replication_position"))
                if (!$util.isString(message.replication_position))
                    return "replication_position: string expected";
            if (message.time_created_ns != null && message.hasOwnProperty("time_created_ns"))
                if (!$util.isInteger(message.time_created_ns) && !(message.time_created_ns && $util.isInteger(message.time_created_ns.low) && $util.isInteger(message.time_created_ns.high)))
                    return "time_created_ns: integer|Long expected";
            return null;
        };

        /**
         * Creates an InitReplicaRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.InitReplicaRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.InitReplicaRequest} InitReplicaRequest
         */
        InitReplicaRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.InitReplicaRequest)
                return object;
            var message = new $root.tabletmanagerdata.InitReplicaRequest();
            if (object.parent != null) {
                if (typeof object.parent !== "object")
                    throw TypeError(".tabletmanagerdata.InitReplicaRequest.parent: object expected");
                message.parent = $root.topodata.TabletAlias.fromObject(object.parent);
            }
            if (object.replication_position != null)
                message.replication_position = String(object.replication_position);
            if (object.time_created_ns != null)
                if ($util.Long)
                    (message.time_created_ns = $util.Long.fromValue(object.time_created_ns)).unsigned = false;
                else if (typeof object.time_created_ns === "string")
                    message.time_created_ns = parseInt(object.time_created_ns, 10);
                else if (typeof object.time_created_ns === "number")
                    message.time_created_ns = object.time_created_ns;
                else if (typeof object.time_created_ns === "object")
                    message.time_created_ns = new $util.LongBits(object.time_created_ns.low >>> 0, object.time_created_ns.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an InitReplicaRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.InitReplicaRequest
         * @static
         * @param {tabletmanagerdata.InitReplicaRequest} message InitReplicaRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InitReplicaRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.parent = null;
                object.replication_position = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.time_created_ns = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.time_created_ns = options.longs === String ? "0" : 0;
            }
            if (message.parent != null && message.hasOwnProperty("parent"))
                object.parent = $root.topodata.TabletAlias.toObject(message.parent, options);
            if (message.replication_position != null && message.hasOwnProperty("replication_position"))
                object.replication_position = message.replication_position;
            if (message.time_created_ns != null && message.hasOwnProperty("time_created_ns"))
                if (typeof message.time_created_ns === "number")
                    object.time_created_ns = options.longs === String ? String(message.time_created_ns) : message.time_created_ns;
                else
                    object.time_created_ns = options.longs === String ? $util.Long.prototype.toString.call(message.time_created_ns) : options.longs === Number ? new $util.LongBits(message.time_created_ns.low >>> 0, message.time_created_ns.high >>> 0).toNumber() : message.time_created_ns;
            return object;
        };

        /**
         * Converts this InitReplicaRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.InitReplicaRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InitReplicaRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return InitReplicaRequest;
    })();

    tabletmanagerdata.InitReplicaResponse = (function() {

        /**
         * Properties of an InitReplicaResponse.
         * @memberof tabletmanagerdata
         * @interface IInitReplicaResponse
         */

        /**
         * Constructs a new InitReplicaResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents an InitReplicaResponse.
         * @implements IInitReplicaResponse
         * @constructor
         * @param {tabletmanagerdata.IInitReplicaResponse=} [properties] Properties to set
         */
        function InitReplicaResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new InitReplicaResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.InitReplicaResponse
         * @static
         * @param {tabletmanagerdata.IInitReplicaResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.InitReplicaResponse} InitReplicaResponse instance
         */
        InitReplicaResponse.create = function create(properties) {
            return new InitReplicaResponse(properties);
        };

        /**
         * Encodes the specified InitReplicaResponse message. Does not implicitly {@link tabletmanagerdata.InitReplicaResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.InitReplicaResponse
         * @static
         * @param {tabletmanagerdata.IInitReplicaResponse} message InitReplicaResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InitReplicaResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified InitReplicaResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.InitReplicaResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.InitReplicaResponse
         * @static
         * @param {tabletmanagerdata.IInitReplicaResponse} message InitReplicaResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InitReplicaResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InitReplicaResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.InitReplicaResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.InitReplicaResponse} InitReplicaResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InitReplicaResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.InitReplicaResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InitReplicaResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.InitReplicaResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.InitReplicaResponse} InitReplicaResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InitReplicaResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InitReplicaResponse message.
         * @function verify
         * @memberof tabletmanagerdata.InitReplicaResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InitReplicaResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates an InitReplicaResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.InitReplicaResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.InitReplicaResponse} InitReplicaResponse
         */
        InitReplicaResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.InitReplicaResponse)
                return object;
            return new $root.tabletmanagerdata.InitReplicaResponse();
        };

        /**
         * Creates a plain object from an InitReplicaResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.InitReplicaResponse
         * @static
         * @param {tabletmanagerdata.InitReplicaResponse} message InitReplicaResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InitReplicaResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this InitReplicaResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.InitReplicaResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InitReplicaResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return InitReplicaResponse;
    })();

    tabletmanagerdata.DemoteMasterRequest = (function() {

        /**
         * Properties of a DemoteMasterRequest.
         * @memberof tabletmanagerdata
         * @interface IDemoteMasterRequest
         */

        /**
         * Constructs a new DemoteMasterRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents a DemoteMasterRequest.
         * @implements IDemoteMasterRequest
         * @constructor
         * @param {tabletmanagerdata.IDemoteMasterRequest=} [properties] Properties to set
         */
        function DemoteMasterRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new DemoteMasterRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.DemoteMasterRequest
         * @static
         * @param {tabletmanagerdata.IDemoteMasterRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.DemoteMasterRequest} DemoteMasterRequest instance
         */
        DemoteMasterRequest.create = function create(properties) {
            return new DemoteMasterRequest(properties);
        };

        /**
         * Encodes the specified DemoteMasterRequest message. Does not implicitly {@link tabletmanagerdata.DemoteMasterRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.DemoteMasterRequest
         * @static
         * @param {tabletmanagerdata.IDemoteMasterRequest} message DemoteMasterRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DemoteMasterRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified DemoteMasterRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.DemoteMasterRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.DemoteMasterRequest
         * @static
         * @param {tabletmanagerdata.IDemoteMasterRequest} message DemoteMasterRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DemoteMasterRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DemoteMasterRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.DemoteMasterRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.DemoteMasterRequest} DemoteMasterRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DemoteMasterRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.DemoteMasterRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DemoteMasterRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.DemoteMasterRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.DemoteMasterRequest} DemoteMasterRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DemoteMasterRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DemoteMasterRequest message.
         * @function verify
         * @memberof tabletmanagerdata.DemoteMasterRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DemoteMasterRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a DemoteMasterRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.DemoteMasterRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.DemoteMasterRequest} DemoteMasterRequest
         */
        DemoteMasterRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.DemoteMasterRequest)
                return object;
            return new $root.tabletmanagerdata.DemoteMasterRequest();
        };

        /**
         * Creates a plain object from a DemoteMasterRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.DemoteMasterRequest
         * @static
         * @param {tabletmanagerdata.DemoteMasterRequest} message DemoteMasterRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DemoteMasterRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this DemoteMasterRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.DemoteMasterRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DemoteMasterRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DemoteMasterRequest;
    })();

    tabletmanagerdata.DemoteMasterResponse = (function() {

        /**
         * Properties of a DemoteMasterResponse.
         * @memberof tabletmanagerdata
         * @interface IDemoteMasterResponse
         * @property {string|null} [deprecated_position] DemoteMasterResponse deprecated_position
         * @property {replicationdata.IMasterStatus|null} [master_status] DemoteMasterResponse master_status
         */

        /**
         * Constructs a new DemoteMasterResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents a DemoteMasterResponse.
         * @implements IDemoteMasterResponse
         * @constructor
         * @param {tabletmanagerdata.IDemoteMasterResponse=} [properties] Properties to set
         */
        function DemoteMasterResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DemoteMasterResponse deprecated_position.
         * @member {string} deprecated_position
         * @memberof tabletmanagerdata.DemoteMasterResponse
         * @instance
         */
        DemoteMasterResponse.prototype.deprecated_position = "";

        /**
         * DemoteMasterResponse master_status.
         * @member {replicationdata.IMasterStatus|null|undefined} master_status
         * @memberof tabletmanagerdata.DemoteMasterResponse
         * @instance
         */
        DemoteMasterResponse.prototype.master_status = null;

        /**
         * Creates a new DemoteMasterResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.DemoteMasterResponse
         * @static
         * @param {tabletmanagerdata.IDemoteMasterResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.DemoteMasterResponse} DemoteMasterResponse instance
         */
        DemoteMasterResponse.create = function create(properties) {
            return new DemoteMasterResponse(properties);
        };

        /**
         * Encodes the specified DemoteMasterResponse message. Does not implicitly {@link tabletmanagerdata.DemoteMasterResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.DemoteMasterResponse
         * @static
         * @param {tabletmanagerdata.IDemoteMasterResponse} message DemoteMasterResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DemoteMasterResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.deprecated_position != null && Object.hasOwnProperty.call(message, "deprecated_position"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.deprecated_position);
            if (message.master_status != null && Object.hasOwnProperty.call(message, "master_status"))
                $root.replicationdata.MasterStatus.encode(message.master_status, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DemoteMasterResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.DemoteMasterResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.DemoteMasterResponse
         * @static
         * @param {tabletmanagerdata.IDemoteMasterResponse} message DemoteMasterResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DemoteMasterResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DemoteMasterResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.DemoteMasterResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.DemoteMasterResponse} DemoteMasterResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DemoteMasterResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.DemoteMasterResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.deprecated_position = reader.string();
                    break;
                case 2:
                    message.master_status = $root.replicationdata.MasterStatus.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DemoteMasterResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.DemoteMasterResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.DemoteMasterResponse} DemoteMasterResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DemoteMasterResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DemoteMasterResponse message.
         * @function verify
         * @memberof tabletmanagerdata.DemoteMasterResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DemoteMasterResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.deprecated_position != null && message.hasOwnProperty("deprecated_position"))
                if (!$util.isString(message.deprecated_position))
                    return "deprecated_position: string expected";
            if (message.master_status != null && message.hasOwnProperty("master_status")) {
                var error = $root.replicationdata.MasterStatus.verify(message.master_status);
                if (error)
                    return "master_status." + error;
            }
            return null;
        };

        /**
         * Creates a DemoteMasterResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.DemoteMasterResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.DemoteMasterResponse} DemoteMasterResponse
         */
        DemoteMasterResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.DemoteMasterResponse)
                return object;
            var message = new $root.tabletmanagerdata.DemoteMasterResponse();
            if (object.deprecated_position != null)
                message.deprecated_position = String(object.deprecated_position);
            if (object.master_status != null) {
                if (typeof object.master_status !== "object")
                    throw TypeError(".tabletmanagerdata.DemoteMasterResponse.master_status: object expected");
                message.master_status = $root.replicationdata.MasterStatus.fromObject(object.master_status);
            }
            return message;
        };

        /**
         * Creates a plain object from a DemoteMasterResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.DemoteMasterResponse
         * @static
         * @param {tabletmanagerdata.DemoteMasterResponse} message DemoteMasterResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DemoteMasterResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.deprecated_position = "";
                object.master_status = null;
            }
            if (message.deprecated_position != null && message.hasOwnProperty("deprecated_position"))
                object.deprecated_position = message.deprecated_position;
            if (message.master_status != null && message.hasOwnProperty("master_status"))
                object.master_status = $root.replicationdata.MasterStatus.toObject(message.master_status, options);
            return object;
        };

        /**
         * Converts this DemoteMasterResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.DemoteMasterResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DemoteMasterResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DemoteMasterResponse;
    })();

    tabletmanagerdata.UndoDemoteMasterRequest = (function() {

        /**
         * Properties of an UndoDemoteMasterRequest.
         * @memberof tabletmanagerdata
         * @interface IUndoDemoteMasterRequest
         */

        /**
         * Constructs a new UndoDemoteMasterRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents an UndoDemoteMasterRequest.
         * @implements IUndoDemoteMasterRequest
         * @constructor
         * @param {tabletmanagerdata.IUndoDemoteMasterRequest=} [properties] Properties to set
         */
        function UndoDemoteMasterRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new UndoDemoteMasterRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.UndoDemoteMasterRequest
         * @static
         * @param {tabletmanagerdata.IUndoDemoteMasterRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.UndoDemoteMasterRequest} UndoDemoteMasterRequest instance
         */
        UndoDemoteMasterRequest.create = function create(properties) {
            return new UndoDemoteMasterRequest(properties);
        };

        /**
         * Encodes the specified UndoDemoteMasterRequest message. Does not implicitly {@link tabletmanagerdata.UndoDemoteMasterRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.UndoDemoteMasterRequest
         * @static
         * @param {tabletmanagerdata.IUndoDemoteMasterRequest} message UndoDemoteMasterRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UndoDemoteMasterRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified UndoDemoteMasterRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.UndoDemoteMasterRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.UndoDemoteMasterRequest
         * @static
         * @param {tabletmanagerdata.IUndoDemoteMasterRequest} message UndoDemoteMasterRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UndoDemoteMasterRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UndoDemoteMasterRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.UndoDemoteMasterRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.UndoDemoteMasterRequest} UndoDemoteMasterRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UndoDemoteMasterRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.UndoDemoteMasterRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UndoDemoteMasterRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.UndoDemoteMasterRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.UndoDemoteMasterRequest} UndoDemoteMasterRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UndoDemoteMasterRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UndoDemoteMasterRequest message.
         * @function verify
         * @memberof tabletmanagerdata.UndoDemoteMasterRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UndoDemoteMasterRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates an UndoDemoteMasterRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.UndoDemoteMasterRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.UndoDemoteMasterRequest} UndoDemoteMasterRequest
         */
        UndoDemoteMasterRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.UndoDemoteMasterRequest)
                return object;
            return new $root.tabletmanagerdata.UndoDemoteMasterRequest();
        };

        /**
         * Creates a plain object from an UndoDemoteMasterRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.UndoDemoteMasterRequest
         * @static
         * @param {tabletmanagerdata.UndoDemoteMasterRequest} message UndoDemoteMasterRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UndoDemoteMasterRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this UndoDemoteMasterRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.UndoDemoteMasterRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UndoDemoteMasterRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UndoDemoteMasterRequest;
    })();

    tabletmanagerdata.UndoDemoteMasterResponse = (function() {

        /**
         * Properties of an UndoDemoteMasterResponse.
         * @memberof tabletmanagerdata
         * @interface IUndoDemoteMasterResponse
         */

        /**
         * Constructs a new UndoDemoteMasterResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents an UndoDemoteMasterResponse.
         * @implements IUndoDemoteMasterResponse
         * @constructor
         * @param {tabletmanagerdata.IUndoDemoteMasterResponse=} [properties] Properties to set
         */
        function UndoDemoteMasterResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new UndoDemoteMasterResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.UndoDemoteMasterResponse
         * @static
         * @param {tabletmanagerdata.IUndoDemoteMasterResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.UndoDemoteMasterResponse} UndoDemoteMasterResponse instance
         */
        UndoDemoteMasterResponse.create = function create(properties) {
            return new UndoDemoteMasterResponse(properties);
        };

        /**
         * Encodes the specified UndoDemoteMasterResponse message. Does not implicitly {@link tabletmanagerdata.UndoDemoteMasterResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.UndoDemoteMasterResponse
         * @static
         * @param {tabletmanagerdata.IUndoDemoteMasterResponse} message UndoDemoteMasterResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UndoDemoteMasterResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified UndoDemoteMasterResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.UndoDemoteMasterResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.UndoDemoteMasterResponse
         * @static
         * @param {tabletmanagerdata.IUndoDemoteMasterResponse} message UndoDemoteMasterResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UndoDemoteMasterResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UndoDemoteMasterResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.UndoDemoteMasterResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.UndoDemoteMasterResponse} UndoDemoteMasterResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UndoDemoteMasterResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.UndoDemoteMasterResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UndoDemoteMasterResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.UndoDemoteMasterResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.UndoDemoteMasterResponse} UndoDemoteMasterResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UndoDemoteMasterResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UndoDemoteMasterResponse message.
         * @function verify
         * @memberof tabletmanagerdata.UndoDemoteMasterResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UndoDemoteMasterResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates an UndoDemoteMasterResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.UndoDemoteMasterResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.UndoDemoteMasterResponse} UndoDemoteMasterResponse
         */
        UndoDemoteMasterResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.UndoDemoteMasterResponse)
                return object;
            return new $root.tabletmanagerdata.UndoDemoteMasterResponse();
        };

        /**
         * Creates a plain object from an UndoDemoteMasterResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.UndoDemoteMasterResponse
         * @static
         * @param {tabletmanagerdata.UndoDemoteMasterResponse} message UndoDemoteMasterResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UndoDemoteMasterResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this UndoDemoteMasterResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.UndoDemoteMasterResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UndoDemoteMasterResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UndoDemoteMasterResponse;
    })();

    tabletmanagerdata.ReplicaWasPromotedRequest = (function() {

        /**
         * Properties of a ReplicaWasPromotedRequest.
         * @memberof tabletmanagerdata
         * @interface IReplicaWasPromotedRequest
         */

        /**
         * Constructs a new ReplicaWasPromotedRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents a ReplicaWasPromotedRequest.
         * @implements IReplicaWasPromotedRequest
         * @constructor
         * @param {tabletmanagerdata.IReplicaWasPromotedRequest=} [properties] Properties to set
         */
        function ReplicaWasPromotedRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ReplicaWasPromotedRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.ReplicaWasPromotedRequest
         * @static
         * @param {tabletmanagerdata.IReplicaWasPromotedRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.ReplicaWasPromotedRequest} ReplicaWasPromotedRequest instance
         */
        ReplicaWasPromotedRequest.create = function create(properties) {
            return new ReplicaWasPromotedRequest(properties);
        };

        /**
         * Encodes the specified ReplicaWasPromotedRequest message. Does not implicitly {@link tabletmanagerdata.ReplicaWasPromotedRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.ReplicaWasPromotedRequest
         * @static
         * @param {tabletmanagerdata.IReplicaWasPromotedRequest} message ReplicaWasPromotedRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReplicaWasPromotedRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ReplicaWasPromotedRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.ReplicaWasPromotedRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.ReplicaWasPromotedRequest
         * @static
         * @param {tabletmanagerdata.IReplicaWasPromotedRequest} message ReplicaWasPromotedRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReplicaWasPromotedRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReplicaWasPromotedRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.ReplicaWasPromotedRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.ReplicaWasPromotedRequest} ReplicaWasPromotedRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReplicaWasPromotedRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.ReplicaWasPromotedRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReplicaWasPromotedRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.ReplicaWasPromotedRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.ReplicaWasPromotedRequest} ReplicaWasPromotedRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReplicaWasPromotedRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReplicaWasPromotedRequest message.
         * @function verify
         * @memberof tabletmanagerdata.ReplicaWasPromotedRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReplicaWasPromotedRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ReplicaWasPromotedRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.ReplicaWasPromotedRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.ReplicaWasPromotedRequest} ReplicaWasPromotedRequest
         */
        ReplicaWasPromotedRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.ReplicaWasPromotedRequest)
                return object;
            return new $root.tabletmanagerdata.ReplicaWasPromotedRequest();
        };

        /**
         * Creates a plain object from a ReplicaWasPromotedRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.ReplicaWasPromotedRequest
         * @static
         * @param {tabletmanagerdata.ReplicaWasPromotedRequest} message ReplicaWasPromotedRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReplicaWasPromotedRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ReplicaWasPromotedRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.ReplicaWasPromotedRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReplicaWasPromotedRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ReplicaWasPromotedRequest;
    })();

    tabletmanagerdata.ReplicaWasPromotedResponse = (function() {

        /**
         * Properties of a ReplicaWasPromotedResponse.
         * @memberof tabletmanagerdata
         * @interface IReplicaWasPromotedResponse
         */

        /**
         * Constructs a new ReplicaWasPromotedResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents a ReplicaWasPromotedResponse.
         * @implements IReplicaWasPromotedResponse
         * @constructor
         * @param {tabletmanagerdata.IReplicaWasPromotedResponse=} [properties] Properties to set
         */
        function ReplicaWasPromotedResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ReplicaWasPromotedResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.ReplicaWasPromotedResponse
         * @static
         * @param {tabletmanagerdata.IReplicaWasPromotedResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.ReplicaWasPromotedResponse} ReplicaWasPromotedResponse instance
         */
        ReplicaWasPromotedResponse.create = function create(properties) {
            return new ReplicaWasPromotedResponse(properties);
        };

        /**
         * Encodes the specified ReplicaWasPromotedResponse message. Does not implicitly {@link tabletmanagerdata.ReplicaWasPromotedResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.ReplicaWasPromotedResponse
         * @static
         * @param {tabletmanagerdata.IReplicaWasPromotedResponse} message ReplicaWasPromotedResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReplicaWasPromotedResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ReplicaWasPromotedResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.ReplicaWasPromotedResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.ReplicaWasPromotedResponse
         * @static
         * @param {tabletmanagerdata.IReplicaWasPromotedResponse} message ReplicaWasPromotedResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReplicaWasPromotedResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReplicaWasPromotedResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.ReplicaWasPromotedResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.ReplicaWasPromotedResponse} ReplicaWasPromotedResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReplicaWasPromotedResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.ReplicaWasPromotedResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReplicaWasPromotedResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.ReplicaWasPromotedResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.ReplicaWasPromotedResponse} ReplicaWasPromotedResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReplicaWasPromotedResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReplicaWasPromotedResponse message.
         * @function verify
         * @memberof tabletmanagerdata.ReplicaWasPromotedResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReplicaWasPromotedResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ReplicaWasPromotedResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.ReplicaWasPromotedResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.ReplicaWasPromotedResponse} ReplicaWasPromotedResponse
         */
        ReplicaWasPromotedResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.ReplicaWasPromotedResponse)
                return object;
            return new $root.tabletmanagerdata.ReplicaWasPromotedResponse();
        };

        /**
         * Creates a plain object from a ReplicaWasPromotedResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.ReplicaWasPromotedResponse
         * @static
         * @param {tabletmanagerdata.ReplicaWasPromotedResponse} message ReplicaWasPromotedResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReplicaWasPromotedResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ReplicaWasPromotedResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.ReplicaWasPromotedResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReplicaWasPromotedResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ReplicaWasPromotedResponse;
    })();

    tabletmanagerdata.SetMasterRequest = (function() {

        /**
         * Properties of a SetMasterRequest.
         * @memberof tabletmanagerdata
         * @interface ISetMasterRequest
         * @property {topodata.ITabletAlias|null} [parent] SetMasterRequest parent
         * @property {number|Long|null} [time_created_ns] SetMasterRequest time_created_ns
         * @property {boolean|null} [force_start_replication] SetMasterRequest force_start_replication
         * @property {string|null} [wait_position] SetMasterRequest wait_position
         */

        /**
         * Constructs a new SetMasterRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents a SetMasterRequest.
         * @implements ISetMasterRequest
         * @constructor
         * @param {tabletmanagerdata.ISetMasterRequest=} [properties] Properties to set
         */
        function SetMasterRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetMasterRequest parent.
         * @member {topodata.ITabletAlias|null|undefined} parent
         * @memberof tabletmanagerdata.SetMasterRequest
         * @instance
         */
        SetMasterRequest.prototype.parent = null;

        /**
         * SetMasterRequest time_created_ns.
         * @member {number|Long} time_created_ns
         * @memberof tabletmanagerdata.SetMasterRequest
         * @instance
         */
        SetMasterRequest.prototype.time_created_ns = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SetMasterRequest force_start_replication.
         * @member {boolean} force_start_replication
         * @memberof tabletmanagerdata.SetMasterRequest
         * @instance
         */
        SetMasterRequest.prototype.force_start_replication = false;

        /**
         * SetMasterRequest wait_position.
         * @member {string} wait_position
         * @memberof tabletmanagerdata.SetMasterRequest
         * @instance
         */
        SetMasterRequest.prototype.wait_position = "";

        /**
         * Creates a new SetMasterRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.SetMasterRequest
         * @static
         * @param {tabletmanagerdata.ISetMasterRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.SetMasterRequest} SetMasterRequest instance
         */
        SetMasterRequest.create = function create(properties) {
            return new SetMasterRequest(properties);
        };

        /**
         * Encodes the specified SetMasterRequest message. Does not implicitly {@link tabletmanagerdata.SetMasterRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.SetMasterRequest
         * @static
         * @param {tabletmanagerdata.ISetMasterRequest} message SetMasterRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetMasterRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.parent != null && Object.hasOwnProperty.call(message, "parent"))
                $root.topodata.TabletAlias.encode(message.parent, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.time_created_ns != null && Object.hasOwnProperty.call(message, "time_created_ns"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.time_created_ns);
            if (message.force_start_replication != null && Object.hasOwnProperty.call(message, "force_start_replication"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.force_start_replication);
            if (message.wait_position != null && Object.hasOwnProperty.call(message, "wait_position"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.wait_position);
            return writer;
        };

        /**
         * Encodes the specified SetMasterRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.SetMasterRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.SetMasterRequest
         * @static
         * @param {tabletmanagerdata.ISetMasterRequest} message SetMasterRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetMasterRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetMasterRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.SetMasterRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.SetMasterRequest} SetMasterRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetMasterRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.SetMasterRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.parent = $root.topodata.TabletAlias.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.time_created_ns = reader.int64();
                    break;
                case 3:
                    message.force_start_replication = reader.bool();
                    break;
                case 4:
                    message.wait_position = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetMasterRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.SetMasterRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.SetMasterRequest} SetMasterRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetMasterRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetMasterRequest message.
         * @function verify
         * @memberof tabletmanagerdata.SetMasterRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetMasterRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.parent != null && message.hasOwnProperty("parent")) {
                var error = $root.topodata.TabletAlias.verify(message.parent);
                if (error)
                    return "parent." + error;
            }
            if (message.time_created_ns != null && message.hasOwnProperty("time_created_ns"))
                if (!$util.isInteger(message.time_created_ns) && !(message.time_created_ns && $util.isInteger(message.time_created_ns.low) && $util.isInteger(message.time_created_ns.high)))
                    return "time_created_ns: integer|Long expected";
            if (message.force_start_replication != null && message.hasOwnProperty("force_start_replication"))
                if (typeof message.force_start_replication !== "boolean")
                    return "force_start_replication: boolean expected";
            if (message.wait_position != null && message.hasOwnProperty("wait_position"))
                if (!$util.isString(message.wait_position))
                    return "wait_position: string expected";
            return null;
        };

        /**
         * Creates a SetMasterRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.SetMasterRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.SetMasterRequest} SetMasterRequest
         */
        SetMasterRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.SetMasterRequest)
                return object;
            var message = new $root.tabletmanagerdata.SetMasterRequest();
            if (object.parent != null) {
                if (typeof object.parent !== "object")
                    throw TypeError(".tabletmanagerdata.SetMasterRequest.parent: object expected");
                message.parent = $root.topodata.TabletAlias.fromObject(object.parent);
            }
            if (object.time_created_ns != null)
                if ($util.Long)
                    (message.time_created_ns = $util.Long.fromValue(object.time_created_ns)).unsigned = false;
                else if (typeof object.time_created_ns === "string")
                    message.time_created_ns = parseInt(object.time_created_ns, 10);
                else if (typeof object.time_created_ns === "number")
                    message.time_created_ns = object.time_created_ns;
                else if (typeof object.time_created_ns === "object")
                    message.time_created_ns = new $util.LongBits(object.time_created_ns.low >>> 0, object.time_created_ns.high >>> 0).toNumber();
            if (object.force_start_replication != null)
                message.force_start_replication = Boolean(object.force_start_replication);
            if (object.wait_position != null)
                message.wait_position = String(object.wait_position);
            return message;
        };

        /**
         * Creates a plain object from a SetMasterRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.SetMasterRequest
         * @static
         * @param {tabletmanagerdata.SetMasterRequest} message SetMasterRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetMasterRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.parent = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.time_created_ns = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.time_created_ns = options.longs === String ? "0" : 0;
                object.force_start_replication = false;
                object.wait_position = "";
            }
            if (message.parent != null && message.hasOwnProperty("parent"))
                object.parent = $root.topodata.TabletAlias.toObject(message.parent, options);
            if (message.time_created_ns != null && message.hasOwnProperty("time_created_ns"))
                if (typeof message.time_created_ns === "number")
                    object.time_created_ns = options.longs === String ? String(message.time_created_ns) : message.time_created_ns;
                else
                    object.time_created_ns = options.longs === String ? $util.Long.prototype.toString.call(message.time_created_ns) : options.longs === Number ? new $util.LongBits(message.time_created_ns.low >>> 0, message.time_created_ns.high >>> 0).toNumber() : message.time_created_ns;
            if (message.force_start_replication != null && message.hasOwnProperty("force_start_replication"))
                object.force_start_replication = message.force_start_replication;
            if (message.wait_position != null && message.hasOwnProperty("wait_position"))
                object.wait_position = message.wait_position;
            return object;
        };

        /**
         * Converts this SetMasterRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.SetMasterRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetMasterRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SetMasterRequest;
    })();

    tabletmanagerdata.SetMasterResponse = (function() {

        /**
         * Properties of a SetMasterResponse.
         * @memberof tabletmanagerdata
         * @interface ISetMasterResponse
         */

        /**
         * Constructs a new SetMasterResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents a SetMasterResponse.
         * @implements ISetMasterResponse
         * @constructor
         * @param {tabletmanagerdata.ISetMasterResponse=} [properties] Properties to set
         */
        function SetMasterResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new SetMasterResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.SetMasterResponse
         * @static
         * @param {tabletmanagerdata.ISetMasterResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.SetMasterResponse} SetMasterResponse instance
         */
        SetMasterResponse.create = function create(properties) {
            return new SetMasterResponse(properties);
        };

        /**
         * Encodes the specified SetMasterResponse message. Does not implicitly {@link tabletmanagerdata.SetMasterResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.SetMasterResponse
         * @static
         * @param {tabletmanagerdata.ISetMasterResponse} message SetMasterResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetMasterResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified SetMasterResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.SetMasterResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.SetMasterResponse
         * @static
         * @param {tabletmanagerdata.ISetMasterResponse} message SetMasterResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetMasterResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetMasterResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.SetMasterResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.SetMasterResponse} SetMasterResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetMasterResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.SetMasterResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetMasterResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.SetMasterResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.SetMasterResponse} SetMasterResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetMasterResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetMasterResponse message.
         * @function verify
         * @memberof tabletmanagerdata.SetMasterResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetMasterResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a SetMasterResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.SetMasterResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.SetMasterResponse} SetMasterResponse
         */
        SetMasterResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.SetMasterResponse)
                return object;
            return new $root.tabletmanagerdata.SetMasterResponse();
        };

        /**
         * Creates a plain object from a SetMasterResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.SetMasterResponse
         * @static
         * @param {tabletmanagerdata.SetMasterResponse} message SetMasterResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetMasterResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this SetMasterResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.SetMasterResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetMasterResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SetMasterResponse;
    })();

    tabletmanagerdata.ReplicaWasRestartedRequest = (function() {

        /**
         * Properties of a ReplicaWasRestartedRequest.
         * @memberof tabletmanagerdata
         * @interface IReplicaWasRestartedRequest
         * @property {topodata.ITabletAlias|null} [parent] ReplicaWasRestartedRequest parent
         */

        /**
         * Constructs a new ReplicaWasRestartedRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents a ReplicaWasRestartedRequest.
         * @implements IReplicaWasRestartedRequest
         * @constructor
         * @param {tabletmanagerdata.IReplicaWasRestartedRequest=} [properties] Properties to set
         */
        function ReplicaWasRestartedRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReplicaWasRestartedRequest parent.
         * @member {topodata.ITabletAlias|null|undefined} parent
         * @memberof tabletmanagerdata.ReplicaWasRestartedRequest
         * @instance
         */
        ReplicaWasRestartedRequest.prototype.parent = null;

        /**
         * Creates a new ReplicaWasRestartedRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.ReplicaWasRestartedRequest
         * @static
         * @param {tabletmanagerdata.IReplicaWasRestartedRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.ReplicaWasRestartedRequest} ReplicaWasRestartedRequest instance
         */
        ReplicaWasRestartedRequest.create = function create(properties) {
            return new ReplicaWasRestartedRequest(properties);
        };

        /**
         * Encodes the specified ReplicaWasRestartedRequest message. Does not implicitly {@link tabletmanagerdata.ReplicaWasRestartedRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.ReplicaWasRestartedRequest
         * @static
         * @param {tabletmanagerdata.IReplicaWasRestartedRequest} message ReplicaWasRestartedRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReplicaWasRestartedRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.parent != null && Object.hasOwnProperty.call(message, "parent"))
                $root.topodata.TabletAlias.encode(message.parent, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ReplicaWasRestartedRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.ReplicaWasRestartedRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.ReplicaWasRestartedRequest
         * @static
         * @param {tabletmanagerdata.IReplicaWasRestartedRequest} message ReplicaWasRestartedRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReplicaWasRestartedRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReplicaWasRestartedRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.ReplicaWasRestartedRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.ReplicaWasRestartedRequest} ReplicaWasRestartedRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReplicaWasRestartedRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.ReplicaWasRestartedRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.parent = $root.topodata.TabletAlias.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReplicaWasRestartedRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.ReplicaWasRestartedRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.ReplicaWasRestartedRequest} ReplicaWasRestartedRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReplicaWasRestartedRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReplicaWasRestartedRequest message.
         * @function verify
         * @memberof tabletmanagerdata.ReplicaWasRestartedRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReplicaWasRestartedRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.parent != null && message.hasOwnProperty("parent")) {
                var error = $root.topodata.TabletAlias.verify(message.parent);
                if (error)
                    return "parent." + error;
            }
            return null;
        };

        /**
         * Creates a ReplicaWasRestartedRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.ReplicaWasRestartedRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.ReplicaWasRestartedRequest} ReplicaWasRestartedRequest
         */
        ReplicaWasRestartedRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.ReplicaWasRestartedRequest)
                return object;
            var message = new $root.tabletmanagerdata.ReplicaWasRestartedRequest();
            if (object.parent != null) {
                if (typeof object.parent !== "object")
                    throw TypeError(".tabletmanagerdata.ReplicaWasRestartedRequest.parent: object expected");
                message.parent = $root.topodata.TabletAlias.fromObject(object.parent);
            }
            return message;
        };

        /**
         * Creates a plain object from a ReplicaWasRestartedRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.ReplicaWasRestartedRequest
         * @static
         * @param {tabletmanagerdata.ReplicaWasRestartedRequest} message ReplicaWasRestartedRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReplicaWasRestartedRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.parent = null;
            if (message.parent != null && message.hasOwnProperty("parent"))
                object.parent = $root.topodata.TabletAlias.toObject(message.parent, options);
            return object;
        };

        /**
         * Converts this ReplicaWasRestartedRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.ReplicaWasRestartedRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReplicaWasRestartedRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ReplicaWasRestartedRequest;
    })();

    tabletmanagerdata.ReplicaWasRestartedResponse = (function() {

        /**
         * Properties of a ReplicaWasRestartedResponse.
         * @memberof tabletmanagerdata
         * @interface IReplicaWasRestartedResponse
         */

        /**
         * Constructs a new ReplicaWasRestartedResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents a ReplicaWasRestartedResponse.
         * @implements IReplicaWasRestartedResponse
         * @constructor
         * @param {tabletmanagerdata.IReplicaWasRestartedResponse=} [properties] Properties to set
         */
        function ReplicaWasRestartedResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ReplicaWasRestartedResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.ReplicaWasRestartedResponse
         * @static
         * @param {tabletmanagerdata.IReplicaWasRestartedResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.ReplicaWasRestartedResponse} ReplicaWasRestartedResponse instance
         */
        ReplicaWasRestartedResponse.create = function create(properties) {
            return new ReplicaWasRestartedResponse(properties);
        };

        /**
         * Encodes the specified ReplicaWasRestartedResponse message. Does not implicitly {@link tabletmanagerdata.ReplicaWasRestartedResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.ReplicaWasRestartedResponse
         * @static
         * @param {tabletmanagerdata.IReplicaWasRestartedResponse} message ReplicaWasRestartedResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReplicaWasRestartedResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ReplicaWasRestartedResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.ReplicaWasRestartedResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.ReplicaWasRestartedResponse
         * @static
         * @param {tabletmanagerdata.IReplicaWasRestartedResponse} message ReplicaWasRestartedResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReplicaWasRestartedResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReplicaWasRestartedResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.ReplicaWasRestartedResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.ReplicaWasRestartedResponse} ReplicaWasRestartedResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReplicaWasRestartedResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.ReplicaWasRestartedResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReplicaWasRestartedResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.ReplicaWasRestartedResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.ReplicaWasRestartedResponse} ReplicaWasRestartedResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReplicaWasRestartedResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReplicaWasRestartedResponse message.
         * @function verify
         * @memberof tabletmanagerdata.ReplicaWasRestartedResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReplicaWasRestartedResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ReplicaWasRestartedResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.ReplicaWasRestartedResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.ReplicaWasRestartedResponse} ReplicaWasRestartedResponse
         */
        ReplicaWasRestartedResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.ReplicaWasRestartedResponse)
                return object;
            return new $root.tabletmanagerdata.ReplicaWasRestartedResponse();
        };

        /**
         * Creates a plain object from a ReplicaWasRestartedResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.ReplicaWasRestartedResponse
         * @static
         * @param {tabletmanagerdata.ReplicaWasRestartedResponse} message ReplicaWasRestartedResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReplicaWasRestartedResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ReplicaWasRestartedResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.ReplicaWasRestartedResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReplicaWasRestartedResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ReplicaWasRestartedResponse;
    })();

    tabletmanagerdata.StopReplicationAndGetStatusRequest = (function() {

        /**
         * Properties of a StopReplicationAndGetStatusRequest.
         * @memberof tabletmanagerdata
         * @interface IStopReplicationAndGetStatusRequest
         * @property {replicationdata.StopReplicationMode|null} [stop_replication_mode] StopReplicationAndGetStatusRequest stop_replication_mode
         */

        /**
         * Constructs a new StopReplicationAndGetStatusRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents a StopReplicationAndGetStatusRequest.
         * @implements IStopReplicationAndGetStatusRequest
         * @constructor
         * @param {tabletmanagerdata.IStopReplicationAndGetStatusRequest=} [properties] Properties to set
         */
        function StopReplicationAndGetStatusRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StopReplicationAndGetStatusRequest stop_replication_mode.
         * @member {replicationdata.StopReplicationMode} stop_replication_mode
         * @memberof tabletmanagerdata.StopReplicationAndGetStatusRequest
         * @instance
         */
        StopReplicationAndGetStatusRequest.prototype.stop_replication_mode = 0;

        /**
         * Creates a new StopReplicationAndGetStatusRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.StopReplicationAndGetStatusRequest
         * @static
         * @param {tabletmanagerdata.IStopReplicationAndGetStatusRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.StopReplicationAndGetStatusRequest} StopReplicationAndGetStatusRequest instance
         */
        StopReplicationAndGetStatusRequest.create = function create(properties) {
            return new StopReplicationAndGetStatusRequest(properties);
        };

        /**
         * Encodes the specified StopReplicationAndGetStatusRequest message. Does not implicitly {@link tabletmanagerdata.StopReplicationAndGetStatusRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.StopReplicationAndGetStatusRequest
         * @static
         * @param {tabletmanagerdata.IStopReplicationAndGetStatusRequest} message StopReplicationAndGetStatusRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopReplicationAndGetStatusRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stop_replication_mode != null && Object.hasOwnProperty.call(message, "stop_replication_mode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.stop_replication_mode);
            return writer;
        };

        /**
         * Encodes the specified StopReplicationAndGetStatusRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.StopReplicationAndGetStatusRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.StopReplicationAndGetStatusRequest
         * @static
         * @param {tabletmanagerdata.IStopReplicationAndGetStatusRequest} message StopReplicationAndGetStatusRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopReplicationAndGetStatusRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StopReplicationAndGetStatusRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.StopReplicationAndGetStatusRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.StopReplicationAndGetStatusRequest} StopReplicationAndGetStatusRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopReplicationAndGetStatusRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.StopReplicationAndGetStatusRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.stop_replication_mode = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StopReplicationAndGetStatusRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.StopReplicationAndGetStatusRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.StopReplicationAndGetStatusRequest} StopReplicationAndGetStatusRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopReplicationAndGetStatusRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StopReplicationAndGetStatusRequest message.
         * @function verify
         * @memberof tabletmanagerdata.StopReplicationAndGetStatusRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StopReplicationAndGetStatusRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.stop_replication_mode != null && message.hasOwnProperty("stop_replication_mode"))
                switch (message.stop_replication_mode) {
                default:
                    return "stop_replication_mode: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a StopReplicationAndGetStatusRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.StopReplicationAndGetStatusRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.StopReplicationAndGetStatusRequest} StopReplicationAndGetStatusRequest
         */
        StopReplicationAndGetStatusRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.StopReplicationAndGetStatusRequest)
                return object;
            var message = new $root.tabletmanagerdata.StopReplicationAndGetStatusRequest();
            switch (object.stop_replication_mode) {
            case "IOANDSQLTHREAD":
            case 0:
                message.stop_replication_mode = 0;
                break;
            case "IOTHREADONLY":
            case 1:
                message.stop_replication_mode = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a StopReplicationAndGetStatusRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.StopReplicationAndGetStatusRequest
         * @static
         * @param {tabletmanagerdata.StopReplicationAndGetStatusRequest} message StopReplicationAndGetStatusRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StopReplicationAndGetStatusRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.stop_replication_mode = options.enums === String ? "IOANDSQLTHREAD" : 0;
            if (message.stop_replication_mode != null && message.hasOwnProperty("stop_replication_mode"))
                object.stop_replication_mode = options.enums === String ? $root.replicationdata.StopReplicationMode[message.stop_replication_mode] : message.stop_replication_mode;
            return object;
        };

        /**
         * Converts this StopReplicationAndGetStatusRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.StopReplicationAndGetStatusRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StopReplicationAndGetStatusRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StopReplicationAndGetStatusRequest;
    })();

    tabletmanagerdata.StopReplicationAndGetStatusResponse = (function() {

        /**
         * Properties of a StopReplicationAndGetStatusResponse.
         * @memberof tabletmanagerdata
         * @interface IStopReplicationAndGetStatusResponse
         * @property {replicationdata.IStatus|null} [hybrid_status] StopReplicationAndGetStatusResponse hybrid_status
         * @property {replicationdata.IStopReplicationStatus|null} [status] StopReplicationAndGetStatusResponse status
         */

        /**
         * Constructs a new StopReplicationAndGetStatusResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents a StopReplicationAndGetStatusResponse.
         * @implements IStopReplicationAndGetStatusResponse
         * @constructor
         * @param {tabletmanagerdata.IStopReplicationAndGetStatusResponse=} [properties] Properties to set
         */
        function StopReplicationAndGetStatusResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StopReplicationAndGetStatusResponse hybrid_status.
         * @member {replicationdata.IStatus|null|undefined} hybrid_status
         * @memberof tabletmanagerdata.StopReplicationAndGetStatusResponse
         * @instance
         */
        StopReplicationAndGetStatusResponse.prototype.hybrid_status = null;

        /**
         * StopReplicationAndGetStatusResponse status.
         * @member {replicationdata.IStopReplicationStatus|null|undefined} status
         * @memberof tabletmanagerdata.StopReplicationAndGetStatusResponse
         * @instance
         */
        StopReplicationAndGetStatusResponse.prototype.status = null;

        /**
         * Creates a new StopReplicationAndGetStatusResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.StopReplicationAndGetStatusResponse
         * @static
         * @param {tabletmanagerdata.IStopReplicationAndGetStatusResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.StopReplicationAndGetStatusResponse} StopReplicationAndGetStatusResponse instance
         */
        StopReplicationAndGetStatusResponse.create = function create(properties) {
            return new StopReplicationAndGetStatusResponse(properties);
        };

        /**
         * Encodes the specified StopReplicationAndGetStatusResponse message. Does not implicitly {@link tabletmanagerdata.StopReplicationAndGetStatusResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.StopReplicationAndGetStatusResponse
         * @static
         * @param {tabletmanagerdata.IStopReplicationAndGetStatusResponse} message StopReplicationAndGetStatusResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopReplicationAndGetStatusResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hybrid_status != null && Object.hasOwnProperty.call(message, "hybrid_status"))
                $root.replicationdata.Status.encode(message.hybrid_status, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.replicationdata.StopReplicationStatus.encode(message.status, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified StopReplicationAndGetStatusResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.StopReplicationAndGetStatusResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.StopReplicationAndGetStatusResponse
         * @static
         * @param {tabletmanagerdata.IStopReplicationAndGetStatusResponse} message StopReplicationAndGetStatusResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopReplicationAndGetStatusResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StopReplicationAndGetStatusResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.StopReplicationAndGetStatusResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.StopReplicationAndGetStatusResponse} StopReplicationAndGetStatusResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopReplicationAndGetStatusResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.StopReplicationAndGetStatusResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hybrid_status = $root.replicationdata.Status.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.status = $root.replicationdata.StopReplicationStatus.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StopReplicationAndGetStatusResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.StopReplicationAndGetStatusResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.StopReplicationAndGetStatusResponse} StopReplicationAndGetStatusResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopReplicationAndGetStatusResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StopReplicationAndGetStatusResponse message.
         * @function verify
         * @memberof tabletmanagerdata.StopReplicationAndGetStatusResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StopReplicationAndGetStatusResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hybrid_status != null && message.hasOwnProperty("hybrid_status")) {
                var error = $root.replicationdata.Status.verify(message.hybrid_status);
                if (error)
                    return "hybrid_status." + error;
            }
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.replicationdata.StopReplicationStatus.verify(message.status);
                if (error)
                    return "status." + error;
            }
            return null;
        };

        /**
         * Creates a StopReplicationAndGetStatusResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.StopReplicationAndGetStatusResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.StopReplicationAndGetStatusResponse} StopReplicationAndGetStatusResponse
         */
        StopReplicationAndGetStatusResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.StopReplicationAndGetStatusResponse)
                return object;
            var message = new $root.tabletmanagerdata.StopReplicationAndGetStatusResponse();
            if (object.hybrid_status != null) {
                if (typeof object.hybrid_status !== "object")
                    throw TypeError(".tabletmanagerdata.StopReplicationAndGetStatusResponse.hybrid_status: object expected");
                message.hybrid_status = $root.replicationdata.Status.fromObject(object.hybrid_status);
            }
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".tabletmanagerdata.StopReplicationAndGetStatusResponse.status: object expected");
                message.status = $root.replicationdata.StopReplicationStatus.fromObject(object.status);
            }
            return message;
        };

        /**
         * Creates a plain object from a StopReplicationAndGetStatusResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.StopReplicationAndGetStatusResponse
         * @static
         * @param {tabletmanagerdata.StopReplicationAndGetStatusResponse} message StopReplicationAndGetStatusResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StopReplicationAndGetStatusResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.hybrid_status = null;
                object.status = null;
            }
            if (message.hybrid_status != null && message.hasOwnProperty("hybrid_status"))
                object.hybrid_status = $root.replicationdata.Status.toObject(message.hybrid_status, options);
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.replicationdata.StopReplicationStatus.toObject(message.status, options);
            return object;
        };

        /**
         * Converts this StopReplicationAndGetStatusResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.StopReplicationAndGetStatusResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StopReplicationAndGetStatusResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StopReplicationAndGetStatusResponse;
    })();

    tabletmanagerdata.PromoteReplicaRequest = (function() {

        /**
         * Properties of a PromoteReplicaRequest.
         * @memberof tabletmanagerdata
         * @interface IPromoteReplicaRequest
         */

        /**
         * Constructs a new PromoteReplicaRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents a PromoteReplicaRequest.
         * @implements IPromoteReplicaRequest
         * @constructor
         * @param {tabletmanagerdata.IPromoteReplicaRequest=} [properties] Properties to set
         */
        function PromoteReplicaRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new PromoteReplicaRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.PromoteReplicaRequest
         * @static
         * @param {tabletmanagerdata.IPromoteReplicaRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.PromoteReplicaRequest} PromoteReplicaRequest instance
         */
        PromoteReplicaRequest.create = function create(properties) {
            return new PromoteReplicaRequest(properties);
        };

        /**
         * Encodes the specified PromoteReplicaRequest message. Does not implicitly {@link tabletmanagerdata.PromoteReplicaRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.PromoteReplicaRequest
         * @static
         * @param {tabletmanagerdata.IPromoteReplicaRequest} message PromoteReplicaRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PromoteReplicaRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified PromoteReplicaRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.PromoteReplicaRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.PromoteReplicaRequest
         * @static
         * @param {tabletmanagerdata.IPromoteReplicaRequest} message PromoteReplicaRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PromoteReplicaRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PromoteReplicaRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.PromoteReplicaRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.PromoteReplicaRequest} PromoteReplicaRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PromoteReplicaRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.PromoteReplicaRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PromoteReplicaRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.PromoteReplicaRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.PromoteReplicaRequest} PromoteReplicaRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PromoteReplicaRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PromoteReplicaRequest message.
         * @function verify
         * @memberof tabletmanagerdata.PromoteReplicaRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PromoteReplicaRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a PromoteReplicaRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.PromoteReplicaRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.PromoteReplicaRequest} PromoteReplicaRequest
         */
        PromoteReplicaRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.PromoteReplicaRequest)
                return object;
            return new $root.tabletmanagerdata.PromoteReplicaRequest();
        };

        /**
         * Creates a plain object from a PromoteReplicaRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.PromoteReplicaRequest
         * @static
         * @param {tabletmanagerdata.PromoteReplicaRequest} message PromoteReplicaRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PromoteReplicaRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this PromoteReplicaRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.PromoteReplicaRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PromoteReplicaRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PromoteReplicaRequest;
    })();

    tabletmanagerdata.PromoteReplicaResponse = (function() {

        /**
         * Properties of a PromoteReplicaResponse.
         * @memberof tabletmanagerdata
         * @interface IPromoteReplicaResponse
         * @property {string|null} [position] PromoteReplicaResponse position
         */

        /**
         * Constructs a new PromoteReplicaResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents a PromoteReplicaResponse.
         * @implements IPromoteReplicaResponse
         * @constructor
         * @param {tabletmanagerdata.IPromoteReplicaResponse=} [properties] Properties to set
         */
        function PromoteReplicaResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PromoteReplicaResponse position.
         * @member {string} position
         * @memberof tabletmanagerdata.PromoteReplicaResponse
         * @instance
         */
        PromoteReplicaResponse.prototype.position = "";

        /**
         * Creates a new PromoteReplicaResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.PromoteReplicaResponse
         * @static
         * @param {tabletmanagerdata.IPromoteReplicaResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.PromoteReplicaResponse} PromoteReplicaResponse instance
         */
        PromoteReplicaResponse.create = function create(properties) {
            return new PromoteReplicaResponse(properties);
        };

        /**
         * Encodes the specified PromoteReplicaResponse message. Does not implicitly {@link tabletmanagerdata.PromoteReplicaResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.PromoteReplicaResponse
         * @static
         * @param {tabletmanagerdata.IPromoteReplicaResponse} message PromoteReplicaResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PromoteReplicaResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.position);
            return writer;
        };

        /**
         * Encodes the specified PromoteReplicaResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.PromoteReplicaResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.PromoteReplicaResponse
         * @static
         * @param {tabletmanagerdata.IPromoteReplicaResponse} message PromoteReplicaResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PromoteReplicaResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PromoteReplicaResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.PromoteReplicaResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.PromoteReplicaResponse} PromoteReplicaResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PromoteReplicaResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.PromoteReplicaResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.position = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PromoteReplicaResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.PromoteReplicaResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.PromoteReplicaResponse} PromoteReplicaResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PromoteReplicaResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PromoteReplicaResponse message.
         * @function verify
         * @memberof tabletmanagerdata.PromoteReplicaResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PromoteReplicaResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.position != null && message.hasOwnProperty("position"))
                if (!$util.isString(message.position))
                    return "position: string expected";
            return null;
        };

        /**
         * Creates a PromoteReplicaResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.PromoteReplicaResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.PromoteReplicaResponse} PromoteReplicaResponse
         */
        PromoteReplicaResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.PromoteReplicaResponse)
                return object;
            var message = new $root.tabletmanagerdata.PromoteReplicaResponse();
            if (object.position != null)
                message.position = String(object.position);
            return message;
        };

        /**
         * Creates a plain object from a PromoteReplicaResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.PromoteReplicaResponse
         * @static
         * @param {tabletmanagerdata.PromoteReplicaResponse} message PromoteReplicaResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PromoteReplicaResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.position = "";
            if (message.position != null && message.hasOwnProperty("position"))
                object.position = message.position;
            return object;
        };

        /**
         * Converts this PromoteReplicaResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.PromoteReplicaResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PromoteReplicaResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PromoteReplicaResponse;
    })();

    tabletmanagerdata.BackupRequest = (function() {

        /**
         * Properties of a BackupRequest.
         * @memberof tabletmanagerdata
         * @interface IBackupRequest
         * @property {number|Long|null} [concurrency] BackupRequest concurrency
         * @property {boolean|null} [allowMaster] BackupRequest allowMaster
         */

        /**
         * Constructs a new BackupRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents a BackupRequest.
         * @implements IBackupRequest
         * @constructor
         * @param {tabletmanagerdata.IBackupRequest=} [properties] Properties to set
         */
        function BackupRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BackupRequest concurrency.
         * @member {number|Long} concurrency
         * @memberof tabletmanagerdata.BackupRequest
         * @instance
         */
        BackupRequest.prototype.concurrency = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BackupRequest allowMaster.
         * @member {boolean} allowMaster
         * @memberof tabletmanagerdata.BackupRequest
         * @instance
         */
        BackupRequest.prototype.allowMaster = false;

        /**
         * Creates a new BackupRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.BackupRequest
         * @static
         * @param {tabletmanagerdata.IBackupRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.BackupRequest} BackupRequest instance
         */
        BackupRequest.create = function create(properties) {
            return new BackupRequest(properties);
        };

        /**
         * Encodes the specified BackupRequest message. Does not implicitly {@link tabletmanagerdata.BackupRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.BackupRequest
         * @static
         * @param {tabletmanagerdata.IBackupRequest} message BackupRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BackupRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.concurrency != null && Object.hasOwnProperty.call(message, "concurrency"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.concurrency);
            if (message.allowMaster != null && Object.hasOwnProperty.call(message, "allowMaster"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.allowMaster);
            return writer;
        };

        /**
         * Encodes the specified BackupRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.BackupRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.BackupRequest
         * @static
         * @param {tabletmanagerdata.IBackupRequest} message BackupRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BackupRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BackupRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.BackupRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.BackupRequest} BackupRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BackupRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.BackupRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.concurrency = reader.int64();
                    break;
                case 2:
                    message.allowMaster = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BackupRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.BackupRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.BackupRequest} BackupRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BackupRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BackupRequest message.
         * @function verify
         * @memberof tabletmanagerdata.BackupRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BackupRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.concurrency != null && message.hasOwnProperty("concurrency"))
                if (!$util.isInteger(message.concurrency) && !(message.concurrency && $util.isInteger(message.concurrency.low) && $util.isInteger(message.concurrency.high)))
                    return "concurrency: integer|Long expected";
            if (message.allowMaster != null && message.hasOwnProperty("allowMaster"))
                if (typeof message.allowMaster !== "boolean")
                    return "allowMaster: boolean expected";
            return null;
        };

        /**
         * Creates a BackupRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.BackupRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.BackupRequest} BackupRequest
         */
        BackupRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.BackupRequest)
                return object;
            var message = new $root.tabletmanagerdata.BackupRequest();
            if (object.concurrency != null)
                if ($util.Long)
                    (message.concurrency = $util.Long.fromValue(object.concurrency)).unsigned = false;
                else if (typeof object.concurrency === "string")
                    message.concurrency = parseInt(object.concurrency, 10);
                else if (typeof object.concurrency === "number")
                    message.concurrency = object.concurrency;
                else if (typeof object.concurrency === "object")
                    message.concurrency = new $util.LongBits(object.concurrency.low >>> 0, object.concurrency.high >>> 0).toNumber();
            if (object.allowMaster != null)
                message.allowMaster = Boolean(object.allowMaster);
            return message;
        };

        /**
         * Creates a plain object from a BackupRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.BackupRequest
         * @static
         * @param {tabletmanagerdata.BackupRequest} message BackupRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BackupRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.concurrency = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.concurrency = options.longs === String ? "0" : 0;
                object.allowMaster = false;
            }
            if (message.concurrency != null && message.hasOwnProperty("concurrency"))
                if (typeof message.concurrency === "number")
                    object.concurrency = options.longs === String ? String(message.concurrency) : message.concurrency;
                else
                    object.concurrency = options.longs === String ? $util.Long.prototype.toString.call(message.concurrency) : options.longs === Number ? new $util.LongBits(message.concurrency.low >>> 0, message.concurrency.high >>> 0).toNumber() : message.concurrency;
            if (message.allowMaster != null && message.hasOwnProperty("allowMaster"))
                object.allowMaster = message.allowMaster;
            return object;
        };

        /**
         * Converts this BackupRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.BackupRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BackupRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BackupRequest;
    })();

    tabletmanagerdata.BackupResponse = (function() {

        /**
         * Properties of a BackupResponse.
         * @memberof tabletmanagerdata
         * @interface IBackupResponse
         * @property {logutil.IEvent|null} [event] BackupResponse event
         */

        /**
         * Constructs a new BackupResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents a BackupResponse.
         * @implements IBackupResponse
         * @constructor
         * @param {tabletmanagerdata.IBackupResponse=} [properties] Properties to set
         */
        function BackupResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BackupResponse event.
         * @member {logutil.IEvent|null|undefined} event
         * @memberof tabletmanagerdata.BackupResponse
         * @instance
         */
        BackupResponse.prototype.event = null;

        /**
         * Creates a new BackupResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.BackupResponse
         * @static
         * @param {tabletmanagerdata.IBackupResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.BackupResponse} BackupResponse instance
         */
        BackupResponse.create = function create(properties) {
            return new BackupResponse(properties);
        };

        /**
         * Encodes the specified BackupResponse message. Does not implicitly {@link tabletmanagerdata.BackupResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.BackupResponse
         * @static
         * @param {tabletmanagerdata.IBackupResponse} message BackupResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BackupResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.event != null && Object.hasOwnProperty.call(message, "event"))
                $root.logutil.Event.encode(message.event, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BackupResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.BackupResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.BackupResponse
         * @static
         * @param {tabletmanagerdata.IBackupResponse} message BackupResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BackupResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BackupResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.BackupResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.BackupResponse} BackupResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BackupResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.BackupResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.event = $root.logutil.Event.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BackupResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.BackupResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.BackupResponse} BackupResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BackupResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BackupResponse message.
         * @function verify
         * @memberof tabletmanagerdata.BackupResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BackupResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.event != null && message.hasOwnProperty("event")) {
                var error = $root.logutil.Event.verify(message.event);
                if (error)
                    return "event." + error;
            }
            return null;
        };

        /**
         * Creates a BackupResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.BackupResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.BackupResponse} BackupResponse
         */
        BackupResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.BackupResponse)
                return object;
            var message = new $root.tabletmanagerdata.BackupResponse();
            if (object.event != null) {
                if (typeof object.event !== "object")
                    throw TypeError(".tabletmanagerdata.BackupResponse.event: object expected");
                message.event = $root.logutil.Event.fromObject(object.event);
            }
            return message;
        };

        /**
         * Creates a plain object from a BackupResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.BackupResponse
         * @static
         * @param {tabletmanagerdata.BackupResponse} message BackupResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BackupResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.event = null;
            if (message.event != null && message.hasOwnProperty("event"))
                object.event = $root.logutil.Event.toObject(message.event, options);
            return object;
        };

        /**
         * Converts this BackupResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.BackupResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BackupResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BackupResponse;
    })();

    tabletmanagerdata.RestoreFromBackupRequest = (function() {

        /**
         * Properties of a RestoreFromBackupRequest.
         * @memberof tabletmanagerdata
         * @interface IRestoreFromBackupRequest
         */

        /**
         * Constructs a new RestoreFromBackupRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents a RestoreFromBackupRequest.
         * @implements IRestoreFromBackupRequest
         * @constructor
         * @param {tabletmanagerdata.IRestoreFromBackupRequest=} [properties] Properties to set
         */
        function RestoreFromBackupRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new RestoreFromBackupRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.RestoreFromBackupRequest
         * @static
         * @param {tabletmanagerdata.IRestoreFromBackupRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.RestoreFromBackupRequest} RestoreFromBackupRequest instance
         */
        RestoreFromBackupRequest.create = function create(properties) {
            return new RestoreFromBackupRequest(properties);
        };

        /**
         * Encodes the specified RestoreFromBackupRequest message. Does not implicitly {@link tabletmanagerdata.RestoreFromBackupRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.RestoreFromBackupRequest
         * @static
         * @param {tabletmanagerdata.IRestoreFromBackupRequest} message RestoreFromBackupRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RestoreFromBackupRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified RestoreFromBackupRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.RestoreFromBackupRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.RestoreFromBackupRequest
         * @static
         * @param {tabletmanagerdata.IRestoreFromBackupRequest} message RestoreFromBackupRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RestoreFromBackupRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RestoreFromBackupRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.RestoreFromBackupRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.RestoreFromBackupRequest} RestoreFromBackupRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RestoreFromBackupRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.RestoreFromBackupRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RestoreFromBackupRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.RestoreFromBackupRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.RestoreFromBackupRequest} RestoreFromBackupRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RestoreFromBackupRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RestoreFromBackupRequest message.
         * @function verify
         * @memberof tabletmanagerdata.RestoreFromBackupRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RestoreFromBackupRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a RestoreFromBackupRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.RestoreFromBackupRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.RestoreFromBackupRequest} RestoreFromBackupRequest
         */
        RestoreFromBackupRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.RestoreFromBackupRequest)
                return object;
            return new $root.tabletmanagerdata.RestoreFromBackupRequest();
        };

        /**
         * Creates a plain object from a RestoreFromBackupRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.RestoreFromBackupRequest
         * @static
         * @param {tabletmanagerdata.RestoreFromBackupRequest} message RestoreFromBackupRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RestoreFromBackupRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this RestoreFromBackupRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.RestoreFromBackupRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RestoreFromBackupRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RestoreFromBackupRequest;
    })();

    tabletmanagerdata.RestoreFromBackupResponse = (function() {

        /**
         * Properties of a RestoreFromBackupResponse.
         * @memberof tabletmanagerdata
         * @interface IRestoreFromBackupResponse
         * @property {logutil.IEvent|null} [event] RestoreFromBackupResponse event
         */

        /**
         * Constructs a new RestoreFromBackupResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents a RestoreFromBackupResponse.
         * @implements IRestoreFromBackupResponse
         * @constructor
         * @param {tabletmanagerdata.IRestoreFromBackupResponse=} [properties] Properties to set
         */
        function RestoreFromBackupResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RestoreFromBackupResponse event.
         * @member {logutil.IEvent|null|undefined} event
         * @memberof tabletmanagerdata.RestoreFromBackupResponse
         * @instance
         */
        RestoreFromBackupResponse.prototype.event = null;

        /**
         * Creates a new RestoreFromBackupResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.RestoreFromBackupResponse
         * @static
         * @param {tabletmanagerdata.IRestoreFromBackupResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.RestoreFromBackupResponse} RestoreFromBackupResponse instance
         */
        RestoreFromBackupResponse.create = function create(properties) {
            return new RestoreFromBackupResponse(properties);
        };

        /**
         * Encodes the specified RestoreFromBackupResponse message. Does not implicitly {@link tabletmanagerdata.RestoreFromBackupResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.RestoreFromBackupResponse
         * @static
         * @param {tabletmanagerdata.IRestoreFromBackupResponse} message RestoreFromBackupResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RestoreFromBackupResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.event != null && Object.hasOwnProperty.call(message, "event"))
                $root.logutil.Event.encode(message.event, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RestoreFromBackupResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.RestoreFromBackupResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.RestoreFromBackupResponse
         * @static
         * @param {tabletmanagerdata.IRestoreFromBackupResponse} message RestoreFromBackupResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RestoreFromBackupResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RestoreFromBackupResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.RestoreFromBackupResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.RestoreFromBackupResponse} RestoreFromBackupResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RestoreFromBackupResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.RestoreFromBackupResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.event = $root.logutil.Event.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RestoreFromBackupResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.RestoreFromBackupResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.RestoreFromBackupResponse} RestoreFromBackupResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RestoreFromBackupResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RestoreFromBackupResponse message.
         * @function verify
         * @memberof tabletmanagerdata.RestoreFromBackupResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RestoreFromBackupResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.event != null && message.hasOwnProperty("event")) {
                var error = $root.logutil.Event.verify(message.event);
                if (error)
                    return "event." + error;
            }
            return null;
        };

        /**
         * Creates a RestoreFromBackupResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.RestoreFromBackupResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.RestoreFromBackupResponse} RestoreFromBackupResponse
         */
        RestoreFromBackupResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.RestoreFromBackupResponse)
                return object;
            var message = new $root.tabletmanagerdata.RestoreFromBackupResponse();
            if (object.event != null) {
                if (typeof object.event !== "object")
                    throw TypeError(".tabletmanagerdata.RestoreFromBackupResponse.event: object expected");
                message.event = $root.logutil.Event.fromObject(object.event);
            }
            return message;
        };

        /**
         * Creates a plain object from a RestoreFromBackupResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.RestoreFromBackupResponse
         * @static
         * @param {tabletmanagerdata.RestoreFromBackupResponse} message RestoreFromBackupResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RestoreFromBackupResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.event = null;
            if (message.event != null && message.hasOwnProperty("event"))
                object.event = $root.logutil.Event.toObject(message.event, options);
            return object;
        };

        /**
         * Converts this RestoreFromBackupResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.RestoreFromBackupResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RestoreFromBackupResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RestoreFromBackupResponse;
    })();

    tabletmanagerdata.VExecRequest = (function() {

        /**
         * Properties of a VExecRequest.
         * @memberof tabletmanagerdata
         * @interface IVExecRequest
         * @property {string|null} [query] VExecRequest query
         * @property {string|null} [workflow] VExecRequest workflow
         * @property {string|null} [keyspace] VExecRequest keyspace
         */

        /**
         * Constructs a new VExecRequest.
         * @memberof tabletmanagerdata
         * @classdesc Represents a VExecRequest.
         * @implements IVExecRequest
         * @constructor
         * @param {tabletmanagerdata.IVExecRequest=} [properties] Properties to set
         */
        function VExecRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VExecRequest query.
         * @member {string} query
         * @memberof tabletmanagerdata.VExecRequest
         * @instance
         */
        VExecRequest.prototype.query = "";

        /**
         * VExecRequest workflow.
         * @member {string} workflow
         * @memberof tabletmanagerdata.VExecRequest
         * @instance
         */
        VExecRequest.prototype.workflow = "";

        /**
         * VExecRequest keyspace.
         * @member {string} keyspace
         * @memberof tabletmanagerdata.VExecRequest
         * @instance
         */
        VExecRequest.prototype.keyspace = "";

        /**
         * Creates a new VExecRequest instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.VExecRequest
         * @static
         * @param {tabletmanagerdata.IVExecRequest=} [properties] Properties to set
         * @returns {tabletmanagerdata.VExecRequest} VExecRequest instance
         */
        VExecRequest.create = function create(properties) {
            return new VExecRequest(properties);
        };

        /**
         * Encodes the specified VExecRequest message. Does not implicitly {@link tabletmanagerdata.VExecRequest.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.VExecRequest
         * @static
         * @param {tabletmanagerdata.IVExecRequest} message VExecRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VExecRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.query);
            if (message.workflow != null && Object.hasOwnProperty.call(message, "workflow"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.workflow);
            if (message.keyspace != null && Object.hasOwnProperty.call(message, "keyspace"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.keyspace);
            return writer;
        };

        /**
         * Encodes the specified VExecRequest message, length delimited. Does not implicitly {@link tabletmanagerdata.VExecRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.VExecRequest
         * @static
         * @param {tabletmanagerdata.IVExecRequest} message VExecRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VExecRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VExecRequest message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.VExecRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.VExecRequest} VExecRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VExecRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.VExecRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.query = reader.string();
                    break;
                case 2:
                    message.workflow = reader.string();
                    break;
                case 3:
                    message.keyspace = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VExecRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.VExecRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.VExecRequest} VExecRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VExecRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VExecRequest message.
         * @function verify
         * @memberof tabletmanagerdata.VExecRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VExecRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.query != null && message.hasOwnProperty("query"))
                if (!$util.isString(message.query))
                    return "query: string expected";
            if (message.workflow != null && message.hasOwnProperty("workflow"))
                if (!$util.isString(message.workflow))
                    return "workflow: string expected";
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                if (!$util.isString(message.keyspace))
                    return "keyspace: string expected";
            return null;
        };

        /**
         * Creates a VExecRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.VExecRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.VExecRequest} VExecRequest
         */
        VExecRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.VExecRequest)
                return object;
            var message = new $root.tabletmanagerdata.VExecRequest();
            if (object.query != null)
                message.query = String(object.query);
            if (object.workflow != null)
                message.workflow = String(object.workflow);
            if (object.keyspace != null)
                message.keyspace = String(object.keyspace);
            return message;
        };

        /**
         * Creates a plain object from a VExecRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.VExecRequest
         * @static
         * @param {tabletmanagerdata.VExecRequest} message VExecRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VExecRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.query = "";
                object.workflow = "";
                object.keyspace = "";
            }
            if (message.query != null && message.hasOwnProperty("query"))
                object.query = message.query;
            if (message.workflow != null && message.hasOwnProperty("workflow"))
                object.workflow = message.workflow;
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                object.keyspace = message.keyspace;
            return object;
        };

        /**
         * Converts this VExecRequest to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.VExecRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VExecRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VExecRequest;
    })();

    tabletmanagerdata.VExecResponse = (function() {

        /**
         * Properties of a VExecResponse.
         * @memberof tabletmanagerdata
         * @interface IVExecResponse
         * @property {query.IQueryResult|null} [result] VExecResponse result
         */

        /**
         * Constructs a new VExecResponse.
         * @memberof tabletmanagerdata
         * @classdesc Represents a VExecResponse.
         * @implements IVExecResponse
         * @constructor
         * @param {tabletmanagerdata.IVExecResponse=} [properties] Properties to set
         */
        function VExecResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VExecResponse result.
         * @member {query.IQueryResult|null|undefined} result
         * @memberof tabletmanagerdata.VExecResponse
         * @instance
         */
        VExecResponse.prototype.result = null;

        /**
         * Creates a new VExecResponse instance using the specified properties.
         * @function create
         * @memberof tabletmanagerdata.VExecResponse
         * @static
         * @param {tabletmanagerdata.IVExecResponse=} [properties] Properties to set
         * @returns {tabletmanagerdata.VExecResponse} VExecResponse instance
         */
        VExecResponse.create = function create(properties) {
            return new VExecResponse(properties);
        };

        /**
         * Encodes the specified VExecResponse message. Does not implicitly {@link tabletmanagerdata.VExecResponse.verify|verify} messages.
         * @function encode
         * @memberof tabletmanagerdata.VExecResponse
         * @static
         * @param {tabletmanagerdata.IVExecResponse} message VExecResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VExecResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                $root.query.QueryResult.encode(message.result, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified VExecResponse message, length delimited. Does not implicitly {@link tabletmanagerdata.VExecResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tabletmanagerdata.VExecResponse
         * @static
         * @param {tabletmanagerdata.IVExecResponse} message VExecResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VExecResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VExecResponse message from the specified reader or buffer.
         * @function decode
         * @memberof tabletmanagerdata.VExecResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tabletmanagerdata.VExecResponse} VExecResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VExecResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.tabletmanagerdata.VExecResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = $root.query.QueryResult.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VExecResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tabletmanagerdata.VExecResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tabletmanagerdata.VExecResponse} VExecResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VExecResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VExecResponse message.
         * @function verify
         * @memberof tabletmanagerdata.VExecResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VExecResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result")) {
                var error = $root.query.QueryResult.verify(message.result);
                if (error)
                    return "result." + error;
            }
            return null;
        };

        /**
         * Creates a VExecResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tabletmanagerdata.VExecResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tabletmanagerdata.VExecResponse} VExecResponse
         */
        VExecResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.tabletmanagerdata.VExecResponse)
                return object;
            var message = new $root.tabletmanagerdata.VExecResponse();
            if (object.result != null) {
                if (typeof object.result !== "object")
                    throw TypeError(".tabletmanagerdata.VExecResponse.result: object expected");
                message.result = $root.query.QueryResult.fromObject(object.result);
            }
            return message;
        };

        /**
         * Creates a plain object from a VExecResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tabletmanagerdata.VExecResponse
         * @static
         * @param {tabletmanagerdata.VExecResponse} message VExecResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VExecResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = null;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = $root.query.QueryResult.toObject(message.result, options);
            return object;
        };

        /**
         * Converts this VExecResponse to JSON.
         * @function toJSON
         * @memberof tabletmanagerdata.VExecResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VExecResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VExecResponse;
    })();

    return tabletmanagerdata;
})();

$root.query = (function() {

    /**
     * Namespace query.
     * @exports query
     * @namespace
     */
    var query = {};

    query.Target = (function() {

        /**
         * Properties of a Target.
         * @memberof query
         * @interface ITarget
         * @property {string|null} [keyspace] Target keyspace
         * @property {string|null} [shard] Target shard
         * @property {topodata.TabletType|null} [tablet_type] Target tablet_type
         * @property {string|null} [cell] Target cell
         */

        /**
         * Constructs a new Target.
         * @memberof query
         * @classdesc Represents a Target.
         * @implements ITarget
         * @constructor
         * @param {query.ITarget=} [properties] Properties to set
         */
        function Target(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Target keyspace.
         * @member {string} keyspace
         * @memberof query.Target
         * @instance
         */
        Target.prototype.keyspace = "";

        /**
         * Target shard.
         * @member {string} shard
         * @memberof query.Target
         * @instance
         */
        Target.prototype.shard = "";

        /**
         * Target tablet_type.
         * @member {topodata.TabletType} tablet_type
         * @memberof query.Target
         * @instance
         */
        Target.prototype.tablet_type = 0;

        /**
         * Target cell.
         * @member {string} cell
         * @memberof query.Target
         * @instance
         */
        Target.prototype.cell = "";

        /**
         * Creates a new Target instance using the specified properties.
         * @function create
         * @memberof query.Target
         * @static
         * @param {query.ITarget=} [properties] Properties to set
         * @returns {query.Target} Target instance
         */
        Target.create = function create(properties) {
            return new Target(properties);
        };

        /**
         * Encodes the specified Target message. Does not implicitly {@link query.Target.verify|verify} messages.
         * @function encode
         * @memberof query.Target
         * @static
         * @param {query.ITarget} message Target message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Target.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keyspace != null && Object.hasOwnProperty.call(message, "keyspace"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.keyspace);
            if (message.shard != null && Object.hasOwnProperty.call(message, "shard"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.shard);
            if (message.tablet_type != null && Object.hasOwnProperty.call(message, "tablet_type"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.tablet_type);
            if (message.cell != null && Object.hasOwnProperty.call(message, "cell"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.cell);
            return writer;
        };

        /**
         * Encodes the specified Target message, length delimited. Does not implicitly {@link query.Target.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.Target
         * @static
         * @param {query.ITarget} message Target message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Target.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Target message from the specified reader or buffer.
         * @function decode
         * @memberof query.Target
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.Target} Target
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Target.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.Target();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.keyspace = reader.string();
                    break;
                case 2:
                    message.shard = reader.string();
                    break;
                case 3:
                    message.tablet_type = reader.int32();
                    break;
                case 4:
                    message.cell = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Target message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.Target
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.Target} Target
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Target.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Target message.
         * @function verify
         * @memberof query.Target
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Target.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                if (!$util.isString(message.keyspace))
                    return "keyspace: string expected";
            if (message.shard != null && message.hasOwnProperty("shard"))
                if (!$util.isString(message.shard))
                    return "shard: string expected";
            if (message.tablet_type != null && message.hasOwnProperty("tablet_type"))
                switch (message.tablet_type) {
                default:
                    return "tablet_type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                    break;
                }
            if (message.cell != null && message.hasOwnProperty("cell"))
                if (!$util.isString(message.cell))
                    return "cell: string expected";
            return null;
        };

        /**
         * Creates a Target message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.Target
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.Target} Target
         */
        Target.fromObject = function fromObject(object) {
            if (object instanceof $root.query.Target)
                return object;
            var message = new $root.query.Target();
            if (object.keyspace != null)
                message.keyspace = String(object.keyspace);
            if (object.shard != null)
                message.shard = String(object.shard);
            switch (object.tablet_type) {
            case "UNKNOWN":
            case 0:
                message.tablet_type = 0;
                break;
            case "MASTER":
            case 1:
                message.tablet_type = 1;
                break;
            case "REPLICA":
            case 2:
                message.tablet_type = 2;
                break;
            case "RDONLY":
            case 3:
                message.tablet_type = 3;
                break;
            case "BATCH":
            case 3:
                message.tablet_type = 3;
                break;
            case "SPARE":
            case 4:
                message.tablet_type = 4;
                break;
            case "EXPERIMENTAL":
            case 5:
                message.tablet_type = 5;
                break;
            case "BACKUP":
            case 6:
                message.tablet_type = 6;
                break;
            case "RESTORE":
            case 7:
                message.tablet_type = 7;
                break;
            case "DRAINED":
            case 8:
                message.tablet_type = 8;
                break;
            }
            if (object.cell != null)
                message.cell = String(object.cell);
            return message;
        };

        /**
         * Creates a plain object from a Target message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.Target
         * @static
         * @param {query.Target} message Target
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Target.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.keyspace = "";
                object.shard = "";
                object.tablet_type = options.enums === String ? "UNKNOWN" : 0;
                object.cell = "";
            }
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                object.keyspace = message.keyspace;
            if (message.shard != null && message.hasOwnProperty("shard"))
                object.shard = message.shard;
            if (message.tablet_type != null && message.hasOwnProperty("tablet_type"))
                object.tablet_type = options.enums === String ? $root.topodata.TabletType[message.tablet_type] : message.tablet_type;
            if (message.cell != null && message.hasOwnProperty("cell"))
                object.cell = message.cell;
            return object;
        };

        /**
         * Converts this Target to JSON.
         * @function toJSON
         * @memberof query.Target
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Target.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Target;
    })();

    query.VTGateCallerID = (function() {

        /**
         * Properties of a VTGateCallerID.
         * @memberof query
         * @interface IVTGateCallerID
         * @property {string|null} [username] VTGateCallerID username
         * @property {Array.<string>|null} [groups] VTGateCallerID groups
         */

        /**
         * Constructs a new VTGateCallerID.
         * @memberof query
         * @classdesc Represents a VTGateCallerID.
         * @implements IVTGateCallerID
         * @constructor
         * @param {query.IVTGateCallerID=} [properties] Properties to set
         */
        function VTGateCallerID(properties) {
            this.groups = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VTGateCallerID username.
         * @member {string} username
         * @memberof query.VTGateCallerID
         * @instance
         */
        VTGateCallerID.prototype.username = "";

        /**
         * VTGateCallerID groups.
         * @member {Array.<string>} groups
         * @memberof query.VTGateCallerID
         * @instance
         */
        VTGateCallerID.prototype.groups = $util.emptyArray;

        /**
         * Creates a new VTGateCallerID instance using the specified properties.
         * @function create
         * @memberof query.VTGateCallerID
         * @static
         * @param {query.IVTGateCallerID=} [properties] Properties to set
         * @returns {query.VTGateCallerID} VTGateCallerID instance
         */
        VTGateCallerID.create = function create(properties) {
            return new VTGateCallerID(properties);
        };

        /**
         * Encodes the specified VTGateCallerID message. Does not implicitly {@link query.VTGateCallerID.verify|verify} messages.
         * @function encode
         * @memberof query.VTGateCallerID
         * @static
         * @param {query.IVTGateCallerID} message VTGateCallerID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VTGateCallerID.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.username);
            if (message.groups != null && message.groups.length)
                for (var i = 0; i < message.groups.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.groups[i]);
            return writer;
        };

        /**
         * Encodes the specified VTGateCallerID message, length delimited. Does not implicitly {@link query.VTGateCallerID.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.VTGateCallerID
         * @static
         * @param {query.IVTGateCallerID} message VTGateCallerID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VTGateCallerID.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VTGateCallerID message from the specified reader or buffer.
         * @function decode
         * @memberof query.VTGateCallerID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.VTGateCallerID} VTGateCallerID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VTGateCallerID.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.VTGateCallerID();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.username = reader.string();
                    break;
                case 2:
                    if (!(message.groups && message.groups.length))
                        message.groups = [];
                    message.groups.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VTGateCallerID message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.VTGateCallerID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.VTGateCallerID} VTGateCallerID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VTGateCallerID.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VTGateCallerID message.
         * @function verify
         * @memberof query.VTGateCallerID
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VTGateCallerID.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            if (message.groups != null && message.hasOwnProperty("groups")) {
                if (!Array.isArray(message.groups))
                    return "groups: array expected";
                for (var i = 0; i < message.groups.length; ++i)
                    if (!$util.isString(message.groups[i]))
                        return "groups: string[] expected";
            }
            return null;
        };

        /**
         * Creates a VTGateCallerID message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.VTGateCallerID
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.VTGateCallerID} VTGateCallerID
         */
        VTGateCallerID.fromObject = function fromObject(object) {
            if (object instanceof $root.query.VTGateCallerID)
                return object;
            var message = new $root.query.VTGateCallerID();
            if (object.username != null)
                message.username = String(object.username);
            if (object.groups) {
                if (!Array.isArray(object.groups))
                    throw TypeError(".query.VTGateCallerID.groups: array expected");
                message.groups = [];
                for (var i = 0; i < object.groups.length; ++i)
                    message.groups[i] = String(object.groups[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a VTGateCallerID message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.VTGateCallerID
         * @static
         * @param {query.VTGateCallerID} message VTGateCallerID
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VTGateCallerID.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.groups = [];
            if (options.defaults)
                object.username = "";
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            if (message.groups && message.groups.length) {
                object.groups = [];
                for (var j = 0; j < message.groups.length; ++j)
                    object.groups[j] = message.groups[j];
            }
            return object;
        };

        /**
         * Converts this VTGateCallerID to JSON.
         * @function toJSON
         * @memberof query.VTGateCallerID
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VTGateCallerID.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VTGateCallerID;
    })();

    query.EventToken = (function() {

        /**
         * Properties of an EventToken.
         * @memberof query
         * @interface IEventToken
         * @property {number|Long|null} [timestamp] EventToken timestamp
         * @property {string|null} [shard] EventToken shard
         * @property {string|null} [position] EventToken position
         */

        /**
         * Constructs a new EventToken.
         * @memberof query
         * @classdesc Represents an EventToken.
         * @implements IEventToken
         * @constructor
         * @param {query.IEventToken=} [properties] Properties to set
         */
        function EventToken(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EventToken timestamp.
         * @member {number|Long} timestamp
         * @memberof query.EventToken
         * @instance
         */
        EventToken.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * EventToken shard.
         * @member {string} shard
         * @memberof query.EventToken
         * @instance
         */
        EventToken.prototype.shard = "";

        /**
         * EventToken position.
         * @member {string} position
         * @memberof query.EventToken
         * @instance
         */
        EventToken.prototype.position = "";

        /**
         * Creates a new EventToken instance using the specified properties.
         * @function create
         * @memberof query.EventToken
         * @static
         * @param {query.IEventToken=} [properties] Properties to set
         * @returns {query.EventToken} EventToken instance
         */
        EventToken.create = function create(properties) {
            return new EventToken(properties);
        };

        /**
         * Encodes the specified EventToken message. Does not implicitly {@link query.EventToken.verify|verify} messages.
         * @function encode
         * @memberof query.EventToken
         * @static
         * @param {query.IEventToken} message EventToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.timestamp);
            if (message.shard != null && Object.hasOwnProperty.call(message, "shard"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.shard);
            if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.position);
            return writer;
        };

        /**
         * Encodes the specified EventToken message, length delimited. Does not implicitly {@link query.EventToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.EventToken
         * @static
         * @param {query.IEventToken} message EventToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EventToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EventToken message from the specified reader or buffer.
         * @function decode
         * @memberof query.EventToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.EventToken} EventToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.EventToken();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.timestamp = reader.int64();
                    break;
                case 2:
                    message.shard = reader.string();
                    break;
                case 3:
                    message.position = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EventToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.EventToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.EventToken} EventToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EventToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EventToken message.
         * @function verify
         * @memberof query.EventToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EventToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.shard != null && message.hasOwnProperty("shard"))
                if (!$util.isString(message.shard))
                    return "shard: string expected";
            if (message.position != null && message.hasOwnProperty("position"))
                if (!$util.isString(message.position))
                    return "position: string expected";
            return null;
        };

        /**
         * Creates an EventToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.EventToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.EventToken} EventToken
         */
        EventToken.fromObject = function fromObject(object) {
            if (object instanceof $root.query.EventToken)
                return object;
            var message = new $root.query.EventToken();
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.shard != null)
                message.shard = String(object.shard);
            if (object.position != null)
                message.position = String(object.position);
            return message;
        };

        /**
         * Creates a plain object from an EventToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.EventToken
         * @static
         * @param {query.EventToken} message EventToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EventToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                object.shard = "";
                object.position = "";
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.shard != null && message.hasOwnProperty("shard"))
                object.shard = message.shard;
            if (message.position != null && message.hasOwnProperty("position"))
                object.position = message.position;
            return object;
        };

        /**
         * Converts this EventToken to JSON.
         * @function toJSON
         * @memberof query.EventToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EventToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EventToken;
    })();

    /**
     * MySqlFlag enum.
     * @name query.MySqlFlag
     * @enum {number}
     * @property {number} EMPTY=0 EMPTY value
     * @property {number} NOT_NULL_FLAG=1 NOT_NULL_FLAG value
     * @property {number} PRI_KEY_FLAG=2 PRI_KEY_FLAG value
     * @property {number} UNIQUE_KEY_FLAG=4 UNIQUE_KEY_FLAG value
     * @property {number} MULTIPLE_KEY_FLAG=8 MULTIPLE_KEY_FLAG value
     * @property {number} BLOB_FLAG=16 BLOB_FLAG value
     * @property {number} UNSIGNED_FLAG=32 UNSIGNED_FLAG value
     * @property {number} ZEROFILL_FLAG=64 ZEROFILL_FLAG value
     * @property {number} BINARY_FLAG=128 BINARY_FLAG value
     * @property {number} ENUM_FLAG=256 ENUM_FLAG value
     * @property {number} AUTO_INCREMENT_FLAG=512 AUTO_INCREMENT_FLAG value
     * @property {number} TIMESTAMP_FLAG=1024 TIMESTAMP_FLAG value
     * @property {number} SET_FLAG=2048 SET_FLAG value
     * @property {number} NO_DEFAULT_VALUE_FLAG=4096 NO_DEFAULT_VALUE_FLAG value
     * @property {number} ON_UPDATE_NOW_FLAG=8192 ON_UPDATE_NOW_FLAG value
     * @property {number} NUM_FLAG=32768 NUM_FLAG value
     * @property {number} PART_KEY_FLAG=16384 PART_KEY_FLAG value
     * @property {number} GROUP_FLAG=32768 GROUP_FLAG value
     * @property {number} UNIQUE_FLAG=65536 UNIQUE_FLAG value
     * @property {number} BINCMP_FLAG=131072 BINCMP_FLAG value
     */
    query.MySqlFlag = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "EMPTY"] = 0;
        values[valuesById[1] = "NOT_NULL_FLAG"] = 1;
        values[valuesById[2] = "PRI_KEY_FLAG"] = 2;
        values[valuesById[4] = "UNIQUE_KEY_FLAG"] = 4;
        values[valuesById[8] = "MULTIPLE_KEY_FLAG"] = 8;
        values[valuesById[16] = "BLOB_FLAG"] = 16;
        values[valuesById[32] = "UNSIGNED_FLAG"] = 32;
        values[valuesById[64] = "ZEROFILL_FLAG"] = 64;
        values[valuesById[128] = "BINARY_FLAG"] = 128;
        values[valuesById[256] = "ENUM_FLAG"] = 256;
        values[valuesById[512] = "AUTO_INCREMENT_FLAG"] = 512;
        values[valuesById[1024] = "TIMESTAMP_FLAG"] = 1024;
        values[valuesById[2048] = "SET_FLAG"] = 2048;
        values[valuesById[4096] = "NO_DEFAULT_VALUE_FLAG"] = 4096;
        values[valuesById[8192] = "ON_UPDATE_NOW_FLAG"] = 8192;
        values[valuesById[32768] = "NUM_FLAG"] = 32768;
        values[valuesById[16384] = "PART_KEY_FLAG"] = 16384;
        values["GROUP_FLAG"] = 32768;
        values[valuesById[65536] = "UNIQUE_FLAG"] = 65536;
        values[valuesById[131072] = "BINCMP_FLAG"] = 131072;
        return values;
    })();

    /**
     * Flag enum.
     * @name query.Flag
     * @enum {number}
     * @property {number} NONE=0 NONE value
     * @property {number} ISINTEGRAL=256 ISINTEGRAL value
     * @property {number} ISUNSIGNED=512 ISUNSIGNED value
     * @property {number} ISFLOAT=1024 ISFLOAT value
     * @property {number} ISQUOTED=2048 ISQUOTED value
     * @property {number} ISTEXT=4096 ISTEXT value
     * @property {number} ISBINARY=8192 ISBINARY value
     */
    query.Flag = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NONE"] = 0;
        values[valuesById[256] = "ISINTEGRAL"] = 256;
        values[valuesById[512] = "ISUNSIGNED"] = 512;
        values[valuesById[1024] = "ISFLOAT"] = 1024;
        values[valuesById[2048] = "ISQUOTED"] = 2048;
        values[valuesById[4096] = "ISTEXT"] = 4096;
        values[valuesById[8192] = "ISBINARY"] = 8192;
        return values;
    })();

    /**
     * Type enum.
     * @name query.Type
     * @enum {number}
     * @property {number} NULL_TYPE=0 NULL_TYPE value
     * @property {number} INT8=257 INT8 value
     * @property {number} UINT8=770 UINT8 value
     * @property {number} INT16=259 INT16 value
     * @property {number} UINT16=772 UINT16 value
     * @property {number} INT24=261 INT24 value
     * @property {number} UINT24=774 UINT24 value
     * @property {number} INT32=263 INT32 value
     * @property {number} UINT32=776 UINT32 value
     * @property {number} INT64=265 INT64 value
     * @property {number} UINT64=778 UINT64 value
     * @property {number} FLOAT32=1035 FLOAT32 value
     * @property {number} FLOAT64=1036 FLOAT64 value
     * @property {number} TIMESTAMP=2061 TIMESTAMP value
     * @property {number} DATE=2062 DATE value
     * @property {number} TIME=2063 TIME value
     * @property {number} DATETIME=2064 DATETIME value
     * @property {number} YEAR=785 YEAR value
     * @property {number} DECIMAL=18 DECIMAL value
     * @property {number} TEXT=6163 TEXT value
     * @property {number} BLOB=10260 BLOB value
     * @property {number} VARCHAR=6165 VARCHAR value
     * @property {number} VARBINARY=10262 VARBINARY value
     * @property {number} CHAR=6167 CHAR value
     * @property {number} BINARY=10264 BINARY value
     * @property {number} BIT=2073 BIT value
     * @property {number} ENUM=2074 ENUM value
     * @property {number} SET=2075 SET value
     * @property {number} TUPLE=28 TUPLE value
     * @property {number} GEOMETRY=2077 GEOMETRY value
     * @property {number} JSON=2078 JSON value
     * @property {number} EXPRESSION=31 EXPRESSION value
     */
    query.Type = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NULL_TYPE"] = 0;
        values[valuesById[257] = "INT8"] = 257;
        values[valuesById[770] = "UINT8"] = 770;
        values[valuesById[259] = "INT16"] = 259;
        values[valuesById[772] = "UINT16"] = 772;
        values[valuesById[261] = "INT24"] = 261;
        values[valuesById[774] = "UINT24"] = 774;
        values[valuesById[263] = "INT32"] = 263;
        values[valuesById[776] = "UINT32"] = 776;
        values[valuesById[265] = "INT64"] = 265;
        values[valuesById[778] = "UINT64"] = 778;
        values[valuesById[1035] = "FLOAT32"] = 1035;
        values[valuesById[1036] = "FLOAT64"] = 1036;
        values[valuesById[2061] = "TIMESTAMP"] = 2061;
        values[valuesById[2062] = "DATE"] = 2062;
        values[valuesById[2063] = "TIME"] = 2063;
        values[valuesById[2064] = "DATETIME"] = 2064;
        values[valuesById[785] = "YEAR"] = 785;
        values[valuesById[18] = "DECIMAL"] = 18;
        values[valuesById[6163] = "TEXT"] = 6163;
        values[valuesById[10260] = "BLOB"] = 10260;
        values[valuesById[6165] = "VARCHAR"] = 6165;
        values[valuesById[10262] = "VARBINARY"] = 10262;
        values[valuesById[6167] = "CHAR"] = 6167;
        values[valuesById[10264] = "BINARY"] = 10264;
        values[valuesById[2073] = "BIT"] = 2073;
        values[valuesById[2074] = "ENUM"] = 2074;
        values[valuesById[2075] = "SET"] = 2075;
        values[valuesById[28] = "TUPLE"] = 28;
        values[valuesById[2077] = "GEOMETRY"] = 2077;
        values[valuesById[2078] = "JSON"] = 2078;
        values[valuesById[31] = "EXPRESSION"] = 31;
        return values;
    })();

    query.Value = (function() {

        /**
         * Properties of a Value.
         * @memberof query
         * @interface IValue
         * @property {query.Type|null} [type] Value type
         * @property {Uint8Array|null} [value] Value value
         */

        /**
         * Constructs a new Value.
         * @memberof query
         * @classdesc Represents a Value.
         * @implements IValue
         * @constructor
         * @param {query.IValue=} [properties] Properties to set
         */
        function Value(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Value type.
         * @member {query.Type} type
         * @memberof query.Value
         * @instance
         */
        Value.prototype.type = 0;

        /**
         * Value value.
         * @member {Uint8Array} value
         * @memberof query.Value
         * @instance
         */
        Value.prototype.value = $util.newBuffer([]);

        /**
         * Creates a new Value instance using the specified properties.
         * @function create
         * @memberof query.Value
         * @static
         * @param {query.IValue=} [properties] Properties to set
         * @returns {query.Value} Value instance
         */
        Value.create = function create(properties) {
            return new Value(properties);
        };

        /**
         * Encodes the specified Value message. Does not implicitly {@link query.Value.verify|verify} messages.
         * @function encode
         * @memberof query.Value
         * @static
         * @param {query.IValue} message Value message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Value.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
            return writer;
        };

        /**
         * Encodes the specified Value message, length delimited. Does not implicitly {@link query.Value.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.Value
         * @static
         * @param {query.IValue} message Value message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Value.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Value message from the specified reader or buffer.
         * @function decode
         * @memberof query.Value
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.Value} Value
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Value.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.Value();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.value = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Value message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.Value
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.Value} Value
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Value.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Value message.
         * @function verify
         * @memberof query.Value
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Value.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 257:
                case 770:
                case 259:
                case 772:
                case 261:
                case 774:
                case 263:
                case 776:
                case 265:
                case 778:
                case 1035:
                case 1036:
                case 2061:
                case 2062:
                case 2063:
                case 2064:
                case 785:
                case 18:
                case 6163:
                case 10260:
                case 6165:
                case 10262:
                case 6167:
                case 10264:
                case 2073:
                case 2074:
                case 2075:
                case 28:
                case 2077:
                case 2078:
                case 31:
                    break;
                }
            if (message.value != null && message.hasOwnProperty("value"))
                if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                    return "value: buffer expected";
            return null;
        };

        /**
         * Creates a Value message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.Value
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.Value} Value
         */
        Value.fromObject = function fromObject(object) {
            if (object instanceof $root.query.Value)
                return object;
            var message = new $root.query.Value();
            switch (object.type) {
            case "NULL_TYPE":
            case 0:
                message.type = 0;
                break;
            case "INT8":
            case 257:
                message.type = 257;
                break;
            case "UINT8":
            case 770:
                message.type = 770;
                break;
            case "INT16":
            case 259:
                message.type = 259;
                break;
            case "UINT16":
            case 772:
                message.type = 772;
                break;
            case "INT24":
            case 261:
                message.type = 261;
                break;
            case "UINT24":
            case 774:
                message.type = 774;
                break;
            case "INT32":
            case 263:
                message.type = 263;
                break;
            case "UINT32":
            case 776:
                message.type = 776;
                break;
            case "INT64":
            case 265:
                message.type = 265;
                break;
            case "UINT64":
            case 778:
                message.type = 778;
                break;
            case "FLOAT32":
            case 1035:
                message.type = 1035;
                break;
            case "FLOAT64":
            case 1036:
                message.type = 1036;
                break;
            case "TIMESTAMP":
            case 2061:
                message.type = 2061;
                break;
            case "DATE":
            case 2062:
                message.type = 2062;
                break;
            case "TIME":
            case 2063:
                message.type = 2063;
                break;
            case "DATETIME":
            case 2064:
                message.type = 2064;
                break;
            case "YEAR":
            case 785:
                message.type = 785;
                break;
            case "DECIMAL":
            case 18:
                message.type = 18;
                break;
            case "TEXT":
            case 6163:
                message.type = 6163;
                break;
            case "BLOB":
            case 10260:
                message.type = 10260;
                break;
            case "VARCHAR":
            case 6165:
                message.type = 6165;
                break;
            case "VARBINARY":
            case 10262:
                message.type = 10262;
                break;
            case "CHAR":
            case 6167:
                message.type = 6167;
                break;
            case "BINARY":
            case 10264:
                message.type = 10264;
                break;
            case "BIT":
            case 2073:
                message.type = 2073;
                break;
            case "ENUM":
            case 2074:
                message.type = 2074;
                break;
            case "SET":
            case 2075:
                message.type = 2075;
                break;
            case "TUPLE":
            case 28:
                message.type = 28;
                break;
            case "GEOMETRY":
            case 2077:
                message.type = 2077;
                break;
            case "JSON":
            case 2078:
                message.type = 2078;
                break;
            case "EXPRESSION":
            case 31:
                message.type = 31;
                break;
            }
            if (object.value != null)
                if (typeof object.value === "string")
                    $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                else if (object.value.length)
                    message.value = object.value;
            return message;
        };

        /**
         * Creates a plain object from a Value message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.Value
         * @static
         * @param {query.Value} message Value
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Value.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "NULL_TYPE" : 0;
                if (options.bytes === String)
                    object.value = "";
                else {
                    object.value = [];
                    if (options.bytes !== Array)
                        object.value = $util.newBuffer(object.value);
                }
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.query.Type[message.type] : message.type;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
            return object;
        };

        /**
         * Converts this Value to JSON.
         * @function toJSON
         * @memberof query.Value
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Value.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Value;
    })();

    query.BindVariable = (function() {

        /**
         * Properties of a BindVariable.
         * @memberof query
         * @interface IBindVariable
         * @property {query.Type|null} [type] BindVariable type
         * @property {Uint8Array|null} [value] BindVariable value
         * @property {Array.<query.IValue>|null} [values] BindVariable values
         */

        /**
         * Constructs a new BindVariable.
         * @memberof query
         * @classdesc Represents a BindVariable.
         * @implements IBindVariable
         * @constructor
         * @param {query.IBindVariable=} [properties] Properties to set
         */
        function BindVariable(properties) {
            this.values = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BindVariable type.
         * @member {query.Type} type
         * @memberof query.BindVariable
         * @instance
         */
        BindVariable.prototype.type = 0;

        /**
         * BindVariable value.
         * @member {Uint8Array} value
         * @memberof query.BindVariable
         * @instance
         */
        BindVariable.prototype.value = $util.newBuffer([]);

        /**
         * BindVariable values.
         * @member {Array.<query.IValue>} values
         * @memberof query.BindVariable
         * @instance
         */
        BindVariable.prototype.values = $util.emptyArray;

        /**
         * Creates a new BindVariable instance using the specified properties.
         * @function create
         * @memberof query.BindVariable
         * @static
         * @param {query.IBindVariable=} [properties] Properties to set
         * @returns {query.BindVariable} BindVariable instance
         */
        BindVariable.create = function create(properties) {
            return new BindVariable(properties);
        };

        /**
         * Encodes the specified BindVariable message. Does not implicitly {@link query.BindVariable.verify|verify} messages.
         * @function encode
         * @memberof query.BindVariable
         * @static
         * @param {query.IBindVariable} message BindVariable message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BindVariable.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
            if (message.values != null && message.values.length)
                for (var i = 0; i < message.values.length; ++i)
                    $root.query.Value.encode(message.values[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BindVariable message, length delimited. Does not implicitly {@link query.BindVariable.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.BindVariable
         * @static
         * @param {query.IBindVariable} message BindVariable message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BindVariable.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BindVariable message from the specified reader or buffer.
         * @function decode
         * @memberof query.BindVariable
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.BindVariable} BindVariable
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BindVariable.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.BindVariable();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.value = reader.bytes();
                    break;
                case 3:
                    if (!(message.values && message.values.length))
                        message.values = [];
                    message.values.push($root.query.Value.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BindVariable message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.BindVariable
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.BindVariable} BindVariable
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BindVariable.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BindVariable message.
         * @function verify
         * @memberof query.BindVariable
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BindVariable.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 257:
                case 770:
                case 259:
                case 772:
                case 261:
                case 774:
                case 263:
                case 776:
                case 265:
                case 778:
                case 1035:
                case 1036:
                case 2061:
                case 2062:
                case 2063:
                case 2064:
                case 785:
                case 18:
                case 6163:
                case 10260:
                case 6165:
                case 10262:
                case 6167:
                case 10264:
                case 2073:
                case 2074:
                case 2075:
                case 28:
                case 2077:
                case 2078:
                case 31:
                    break;
                }
            if (message.value != null && message.hasOwnProperty("value"))
                if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                    return "value: buffer expected";
            if (message.values != null && message.hasOwnProperty("values")) {
                if (!Array.isArray(message.values))
                    return "values: array expected";
                for (var i = 0; i < message.values.length; ++i) {
                    var error = $root.query.Value.verify(message.values[i]);
                    if (error)
                        return "values." + error;
                }
            }
            return null;
        };

        /**
         * Creates a BindVariable message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.BindVariable
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.BindVariable} BindVariable
         */
        BindVariable.fromObject = function fromObject(object) {
            if (object instanceof $root.query.BindVariable)
                return object;
            var message = new $root.query.BindVariable();
            switch (object.type) {
            case "NULL_TYPE":
            case 0:
                message.type = 0;
                break;
            case "INT8":
            case 257:
                message.type = 257;
                break;
            case "UINT8":
            case 770:
                message.type = 770;
                break;
            case "INT16":
            case 259:
                message.type = 259;
                break;
            case "UINT16":
            case 772:
                message.type = 772;
                break;
            case "INT24":
            case 261:
                message.type = 261;
                break;
            case "UINT24":
            case 774:
                message.type = 774;
                break;
            case "INT32":
            case 263:
                message.type = 263;
                break;
            case "UINT32":
            case 776:
                message.type = 776;
                break;
            case "INT64":
            case 265:
                message.type = 265;
                break;
            case "UINT64":
            case 778:
                message.type = 778;
                break;
            case "FLOAT32":
            case 1035:
                message.type = 1035;
                break;
            case "FLOAT64":
            case 1036:
                message.type = 1036;
                break;
            case "TIMESTAMP":
            case 2061:
                message.type = 2061;
                break;
            case "DATE":
            case 2062:
                message.type = 2062;
                break;
            case "TIME":
            case 2063:
                message.type = 2063;
                break;
            case "DATETIME":
            case 2064:
                message.type = 2064;
                break;
            case "YEAR":
            case 785:
                message.type = 785;
                break;
            case "DECIMAL":
            case 18:
                message.type = 18;
                break;
            case "TEXT":
            case 6163:
                message.type = 6163;
                break;
            case "BLOB":
            case 10260:
                message.type = 10260;
                break;
            case "VARCHAR":
            case 6165:
                message.type = 6165;
                break;
            case "VARBINARY":
            case 10262:
                message.type = 10262;
                break;
            case "CHAR":
            case 6167:
                message.type = 6167;
                break;
            case "BINARY":
            case 10264:
                message.type = 10264;
                break;
            case "BIT":
            case 2073:
                message.type = 2073;
                break;
            case "ENUM":
            case 2074:
                message.type = 2074;
                break;
            case "SET":
            case 2075:
                message.type = 2075;
                break;
            case "TUPLE":
            case 28:
                message.type = 28;
                break;
            case "GEOMETRY":
            case 2077:
                message.type = 2077;
                break;
            case "JSON":
            case 2078:
                message.type = 2078;
                break;
            case "EXPRESSION":
            case 31:
                message.type = 31;
                break;
            }
            if (object.value != null)
                if (typeof object.value === "string")
                    $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                else if (object.value.length)
                    message.value = object.value;
            if (object.values) {
                if (!Array.isArray(object.values))
                    throw TypeError(".query.BindVariable.values: array expected");
                message.values = [];
                for (var i = 0; i < object.values.length; ++i) {
                    if (typeof object.values[i] !== "object")
                        throw TypeError(".query.BindVariable.values: object expected");
                    message.values[i] = $root.query.Value.fromObject(object.values[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a BindVariable message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.BindVariable
         * @static
         * @param {query.BindVariable} message BindVariable
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BindVariable.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.values = [];
            if (options.defaults) {
                object.type = options.enums === String ? "NULL_TYPE" : 0;
                if (options.bytes === String)
                    object.value = "";
                else {
                    object.value = [];
                    if (options.bytes !== Array)
                        object.value = $util.newBuffer(object.value);
                }
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.query.Type[message.type] : message.type;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
            if (message.values && message.values.length) {
                object.values = [];
                for (var j = 0; j < message.values.length; ++j)
                    object.values[j] = $root.query.Value.toObject(message.values[j], options);
            }
            return object;
        };

        /**
         * Converts this BindVariable to JSON.
         * @function toJSON
         * @memberof query.BindVariable
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BindVariable.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BindVariable;
    })();

    query.BoundQuery = (function() {

        /**
         * Properties of a BoundQuery.
         * @memberof query
         * @interface IBoundQuery
         * @property {string|null} [sql] BoundQuery sql
         * @property {Object.<string,query.IBindVariable>|null} [bind_variables] BoundQuery bind_variables
         */

        /**
         * Constructs a new BoundQuery.
         * @memberof query
         * @classdesc Represents a BoundQuery.
         * @implements IBoundQuery
         * @constructor
         * @param {query.IBoundQuery=} [properties] Properties to set
         */
        function BoundQuery(properties) {
            this.bind_variables = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BoundQuery sql.
         * @member {string} sql
         * @memberof query.BoundQuery
         * @instance
         */
        BoundQuery.prototype.sql = "";

        /**
         * BoundQuery bind_variables.
         * @member {Object.<string,query.IBindVariable>} bind_variables
         * @memberof query.BoundQuery
         * @instance
         */
        BoundQuery.prototype.bind_variables = $util.emptyObject;

        /**
         * Creates a new BoundQuery instance using the specified properties.
         * @function create
         * @memberof query.BoundQuery
         * @static
         * @param {query.IBoundQuery=} [properties] Properties to set
         * @returns {query.BoundQuery} BoundQuery instance
         */
        BoundQuery.create = function create(properties) {
            return new BoundQuery(properties);
        };

        /**
         * Encodes the specified BoundQuery message. Does not implicitly {@link query.BoundQuery.verify|verify} messages.
         * @function encode
         * @memberof query.BoundQuery
         * @static
         * @param {query.IBoundQuery} message BoundQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BoundQuery.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sql != null && Object.hasOwnProperty.call(message, "sql"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.sql);
            if (message.bind_variables != null && Object.hasOwnProperty.call(message, "bind_variables"))
                for (var keys = Object.keys(message.bind_variables), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.query.BindVariable.encode(message.bind_variables[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            return writer;
        };

        /**
         * Encodes the specified BoundQuery message, length delimited. Does not implicitly {@link query.BoundQuery.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.BoundQuery
         * @static
         * @param {query.IBoundQuery} message BoundQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BoundQuery.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BoundQuery message from the specified reader or buffer.
         * @function decode
         * @memberof query.BoundQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.BoundQuery} BoundQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BoundQuery.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.BoundQuery(), key, value;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sql = reader.string();
                    break;
                case 2:
                    if (message.bind_variables === $util.emptyObject)
                        message.bind_variables = {};
                    var end2 = reader.uint32() + reader.pos;
                    key = "";
                    value = null;
                    while (reader.pos < end2) {
                        var tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.string();
                            break;
                        case 2:
                            value = $root.query.BindVariable.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.bind_variables[key] = value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BoundQuery message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.BoundQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.BoundQuery} BoundQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BoundQuery.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BoundQuery message.
         * @function verify
         * @memberof query.BoundQuery
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BoundQuery.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sql != null && message.hasOwnProperty("sql"))
                if (!$util.isString(message.sql))
                    return "sql: string expected";
            if (message.bind_variables != null && message.hasOwnProperty("bind_variables")) {
                if (!$util.isObject(message.bind_variables))
                    return "bind_variables: object expected";
                var key = Object.keys(message.bind_variables);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.query.BindVariable.verify(message.bind_variables[key[i]]);
                    if (error)
                        return "bind_variables." + error;
                }
            }
            return null;
        };

        /**
         * Creates a BoundQuery message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.BoundQuery
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.BoundQuery} BoundQuery
         */
        BoundQuery.fromObject = function fromObject(object) {
            if (object instanceof $root.query.BoundQuery)
                return object;
            var message = new $root.query.BoundQuery();
            if (object.sql != null)
                message.sql = String(object.sql);
            if (object.bind_variables) {
                if (typeof object.bind_variables !== "object")
                    throw TypeError(".query.BoundQuery.bind_variables: object expected");
                message.bind_variables = {};
                for (var keys = Object.keys(object.bind_variables), i = 0; i < keys.length; ++i) {
                    if (typeof object.bind_variables[keys[i]] !== "object")
                        throw TypeError(".query.BoundQuery.bind_variables: object expected");
                    message.bind_variables[keys[i]] = $root.query.BindVariable.fromObject(object.bind_variables[keys[i]]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a BoundQuery message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.BoundQuery
         * @static
         * @param {query.BoundQuery} message BoundQuery
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BoundQuery.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults)
                object.bind_variables = {};
            if (options.defaults)
                object.sql = "";
            if (message.sql != null && message.hasOwnProperty("sql"))
                object.sql = message.sql;
            var keys2;
            if (message.bind_variables && (keys2 = Object.keys(message.bind_variables)).length) {
                object.bind_variables = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.bind_variables[keys2[j]] = $root.query.BindVariable.toObject(message.bind_variables[keys2[j]], options);
            }
            return object;
        };

        /**
         * Converts this BoundQuery to JSON.
         * @function toJSON
         * @memberof query.BoundQuery
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BoundQuery.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BoundQuery;
    })();

    query.ExecuteOptions = (function() {

        /**
         * Properties of an ExecuteOptions.
         * @memberof query
         * @interface IExecuteOptions
         * @property {query.ExecuteOptions.IncludedFields|null} [included_fields] ExecuteOptions included_fields
         * @property {boolean|null} [client_found_rows] ExecuteOptions client_found_rows
         * @property {query.ExecuteOptions.Workload|null} [workload] ExecuteOptions workload
         * @property {number|Long|null} [sql_select_limit] ExecuteOptions sql_select_limit
         * @property {query.ExecuteOptions.TransactionIsolation|null} [transaction_isolation] ExecuteOptions transaction_isolation
         * @property {boolean|null} [skip_query_plan_cache] ExecuteOptions skip_query_plan_cache
         * @property {query.ExecuteOptions.PlannerVersion|null} [planner_version] ExecuteOptions planner_version
         * @property {boolean|null} [has_created_temp_tables] ExecuteOptions has_created_temp_tables
         */

        /**
         * Constructs a new ExecuteOptions.
         * @memberof query
         * @classdesc Represents an ExecuteOptions.
         * @implements IExecuteOptions
         * @constructor
         * @param {query.IExecuteOptions=} [properties] Properties to set
         */
        function ExecuteOptions(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExecuteOptions included_fields.
         * @member {query.ExecuteOptions.IncludedFields} included_fields
         * @memberof query.ExecuteOptions
         * @instance
         */
        ExecuteOptions.prototype.included_fields = 0;

        /**
         * ExecuteOptions client_found_rows.
         * @member {boolean} client_found_rows
         * @memberof query.ExecuteOptions
         * @instance
         */
        ExecuteOptions.prototype.client_found_rows = false;

        /**
         * ExecuteOptions workload.
         * @member {query.ExecuteOptions.Workload} workload
         * @memberof query.ExecuteOptions
         * @instance
         */
        ExecuteOptions.prototype.workload = 0;

        /**
         * ExecuteOptions sql_select_limit.
         * @member {number|Long} sql_select_limit
         * @memberof query.ExecuteOptions
         * @instance
         */
        ExecuteOptions.prototype.sql_select_limit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ExecuteOptions transaction_isolation.
         * @member {query.ExecuteOptions.TransactionIsolation} transaction_isolation
         * @memberof query.ExecuteOptions
         * @instance
         */
        ExecuteOptions.prototype.transaction_isolation = 0;

        /**
         * ExecuteOptions skip_query_plan_cache.
         * @member {boolean} skip_query_plan_cache
         * @memberof query.ExecuteOptions
         * @instance
         */
        ExecuteOptions.prototype.skip_query_plan_cache = false;

        /**
         * ExecuteOptions planner_version.
         * @member {query.ExecuteOptions.PlannerVersion} planner_version
         * @memberof query.ExecuteOptions
         * @instance
         */
        ExecuteOptions.prototype.planner_version = 0;

        /**
         * ExecuteOptions has_created_temp_tables.
         * @member {boolean} has_created_temp_tables
         * @memberof query.ExecuteOptions
         * @instance
         */
        ExecuteOptions.prototype.has_created_temp_tables = false;

        /**
         * Creates a new ExecuteOptions instance using the specified properties.
         * @function create
         * @memberof query.ExecuteOptions
         * @static
         * @param {query.IExecuteOptions=} [properties] Properties to set
         * @returns {query.ExecuteOptions} ExecuteOptions instance
         */
        ExecuteOptions.create = function create(properties) {
            return new ExecuteOptions(properties);
        };

        /**
         * Encodes the specified ExecuteOptions message. Does not implicitly {@link query.ExecuteOptions.verify|verify} messages.
         * @function encode
         * @memberof query.ExecuteOptions
         * @static
         * @param {query.IExecuteOptions} message ExecuteOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecuteOptions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.included_fields != null && Object.hasOwnProperty.call(message, "included_fields"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.included_fields);
            if (message.client_found_rows != null && Object.hasOwnProperty.call(message, "client_found_rows"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.client_found_rows);
            if (message.workload != null && Object.hasOwnProperty.call(message, "workload"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.workload);
            if (message.sql_select_limit != null && Object.hasOwnProperty.call(message, "sql_select_limit"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.sql_select_limit);
            if (message.transaction_isolation != null && Object.hasOwnProperty.call(message, "transaction_isolation"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.transaction_isolation);
            if (message.skip_query_plan_cache != null && Object.hasOwnProperty.call(message, "skip_query_plan_cache"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.skip_query_plan_cache);
            if (message.planner_version != null && Object.hasOwnProperty.call(message, "planner_version"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.planner_version);
            if (message.has_created_temp_tables != null && Object.hasOwnProperty.call(message, "has_created_temp_tables"))
                writer.uint32(/* id 12, wireType 0 =*/96).bool(message.has_created_temp_tables);
            return writer;
        };

        /**
         * Encodes the specified ExecuteOptions message, length delimited. Does not implicitly {@link query.ExecuteOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.ExecuteOptions
         * @static
         * @param {query.IExecuteOptions} message ExecuteOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecuteOptions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExecuteOptions message from the specified reader or buffer.
         * @function decode
         * @memberof query.ExecuteOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.ExecuteOptions} ExecuteOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecuteOptions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.ExecuteOptions();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 4:
                    message.included_fields = reader.int32();
                    break;
                case 5:
                    message.client_found_rows = reader.bool();
                    break;
                case 6:
                    message.workload = reader.int32();
                    break;
                case 8:
                    message.sql_select_limit = reader.int64();
                    break;
                case 9:
                    message.transaction_isolation = reader.int32();
                    break;
                case 10:
                    message.skip_query_plan_cache = reader.bool();
                    break;
                case 11:
                    message.planner_version = reader.int32();
                    break;
                case 12:
                    message.has_created_temp_tables = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExecuteOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.ExecuteOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.ExecuteOptions} ExecuteOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecuteOptions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExecuteOptions message.
         * @function verify
         * @memberof query.ExecuteOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExecuteOptions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.included_fields != null && message.hasOwnProperty("included_fields"))
                switch (message.included_fields) {
                default:
                    return "included_fields: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.client_found_rows != null && message.hasOwnProperty("client_found_rows"))
                if (typeof message.client_found_rows !== "boolean")
                    return "client_found_rows: boolean expected";
            if (message.workload != null && message.hasOwnProperty("workload"))
                switch (message.workload) {
                default:
                    return "workload: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.sql_select_limit != null && message.hasOwnProperty("sql_select_limit"))
                if (!$util.isInteger(message.sql_select_limit) && !(message.sql_select_limit && $util.isInteger(message.sql_select_limit.low) && $util.isInteger(message.sql_select_limit.high)))
                    return "sql_select_limit: integer|Long expected";
            if (message.transaction_isolation != null && message.hasOwnProperty("transaction_isolation"))
                switch (message.transaction_isolation) {
                default:
                    return "transaction_isolation: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.skip_query_plan_cache != null && message.hasOwnProperty("skip_query_plan_cache"))
                if (typeof message.skip_query_plan_cache !== "boolean")
                    return "skip_query_plan_cache: boolean expected";
            if (message.planner_version != null && message.hasOwnProperty("planner_version"))
                switch (message.planner_version) {
                default:
                    return "planner_version: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.has_created_temp_tables != null && message.hasOwnProperty("has_created_temp_tables"))
                if (typeof message.has_created_temp_tables !== "boolean")
                    return "has_created_temp_tables: boolean expected";
            return null;
        };

        /**
         * Creates an ExecuteOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.ExecuteOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.ExecuteOptions} ExecuteOptions
         */
        ExecuteOptions.fromObject = function fromObject(object) {
            if (object instanceof $root.query.ExecuteOptions)
                return object;
            var message = new $root.query.ExecuteOptions();
            switch (object.included_fields) {
            case "TYPE_AND_NAME":
            case 0:
                message.included_fields = 0;
                break;
            case "TYPE_ONLY":
            case 1:
                message.included_fields = 1;
                break;
            case "ALL":
            case 2:
                message.included_fields = 2;
                break;
            }
            if (object.client_found_rows != null)
                message.client_found_rows = Boolean(object.client_found_rows);
            switch (object.workload) {
            case "UNSPECIFIED":
            case 0:
                message.workload = 0;
                break;
            case "OLTP":
            case 1:
                message.workload = 1;
                break;
            case "OLAP":
            case 2:
                message.workload = 2;
                break;
            case "DBA":
            case 3:
                message.workload = 3;
                break;
            }
            if (object.sql_select_limit != null)
                if ($util.Long)
                    (message.sql_select_limit = $util.Long.fromValue(object.sql_select_limit)).unsigned = false;
                else if (typeof object.sql_select_limit === "string")
                    message.sql_select_limit = parseInt(object.sql_select_limit, 10);
                else if (typeof object.sql_select_limit === "number")
                    message.sql_select_limit = object.sql_select_limit;
                else if (typeof object.sql_select_limit === "object")
                    message.sql_select_limit = new $util.LongBits(object.sql_select_limit.low >>> 0, object.sql_select_limit.high >>> 0).toNumber();
            switch (object.transaction_isolation) {
            case "DEFAULT":
            case 0:
                message.transaction_isolation = 0;
                break;
            case "REPEATABLE_READ":
            case 1:
                message.transaction_isolation = 1;
                break;
            case "READ_COMMITTED":
            case 2:
                message.transaction_isolation = 2;
                break;
            case "READ_UNCOMMITTED":
            case 3:
                message.transaction_isolation = 3;
                break;
            case "SERIALIZABLE":
            case 4:
                message.transaction_isolation = 4;
                break;
            case "CONSISTENT_SNAPSHOT_READ_ONLY":
            case 5:
                message.transaction_isolation = 5;
                break;
            case "AUTOCOMMIT":
            case 6:
                message.transaction_isolation = 6;
                break;
            }
            if (object.skip_query_plan_cache != null)
                message.skip_query_plan_cache = Boolean(object.skip_query_plan_cache);
            switch (object.planner_version) {
            case "DEFAULT_PLANNER":
            case 0:
                message.planner_version = 0;
                break;
            case "V3":
            case 1:
                message.planner_version = 1;
                break;
            case "Gen4":
            case 2:
                message.planner_version = 2;
                break;
            case "Gen4Greedy":
            case 3:
                message.planner_version = 3;
                break;
            case "Gen4Left2Right":
            case 4:
                message.planner_version = 4;
                break;
            case "Gen4WithFallback":
            case 5:
                message.planner_version = 5;
                break;
            }
            if (object.has_created_temp_tables != null)
                message.has_created_temp_tables = Boolean(object.has_created_temp_tables);
            return message;
        };

        /**
         * Creates a plain object from an ExecuteOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.ExecuteOptions
         * @static
         * @param {query.ExecuteOptions} message ExecuteOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExecuteOptions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.included_fields = options.enums === String ? "TYPE_AND_NAME" : 0;
                object.client_found_rows = false;
                object.workload = options.enums === String ? "UNSPECIFIED" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.sql_select_limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.sql_select_limit = options.longs === String ? "0" : 0;
                object.transaction_isolation = options.enums === String ? "DEFAULT" : 0;
                object.skip_query_plan_cache = false;
                object.planner_version = options.enums === String ? "DEFAULT_PLANNER" : 0;
                object.has_created_temp_tables = false;
            }
            if (message.included_fields != null && message.hasOwnProperty("included_fields"))
                object.included_fields = options.enums === String ? $root.query.ExecuteOptions.IncludedFields[message.included_fields] : message.included_fields;
            if (message.client_found_rows != null && message.hasOwnProperty("client_found_rows"))
                object.client_found_rows = message.client_found_rows;
            if (message.workload != null && message.hasOwnProperty("workload"))
                object.workload = options.enums === String ? $root.query.ExecuteOptions.Workload[message.workload] : message.workload;
            if (message.sql_select_limit != null && message.hasOwnProperty("sql_select_limit"))
                if (typeof message.sql_select_limit === "number")
                    object.sql_select_limit = options.longs === String ? String(message.sql_select_limit) : message.sql_select_limit;
                else
                    object.sql_select_limit = options.longs === String ? $util.Long.prototype.toString.call(message.sql_select_limit) : options.longs === Number ? new $util.LongBits(message.sql_select_limit.low >>> 0, message.sql_select_limit.high >>> 0).toNumber() : message.sql_select_limit;
            if (message.transaction_isolation != null && message.hasOwnProperty("transaction_isolation"))
                object.transaction_isolation = options.enums === String ? $root.query.ExecuteOptions.TransactionIsolation[message.transaction_isolation] : message.transaction_isolation;
            if (message.skip_query_plan_cache != null && message.hasOwnProperty("skip_query_plan_cache"))
                object.skip_query_plan_cache = message.skip_query_plan_cache;
            if (message.planner_version != null && message.hasOwnProperty("planner_version"))
                object.planner_version = options.enums === String ? $root.query.ExecuteOptions.PlannerVersion[message.planner_version] : message.planner_version;
            if (message.has_created_temp_tables != null && message.hasOwnProperty("has_created_temp_tables"))
                object.has_created_temp_tables = message.has_created_temp_tables;
            return object;
        };

        /**
         * Converts this ExecuteOptions to JSON.
         * @function toJSON
         * @memberof query.ExecuteOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExecuteOptions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * IncludedFields enum.
         * @name query.ExecuteOptions.IncludedFields
         * @enum {number}
         * @property {number} TYPE_AND_NAME=0 TYPE_AND_NAME value
         * @property {number} TYPE_ONLY=1 TYPE_ONLY value
         * @property {number} ALL=2 ALL value
         */
        ExecuteOptions.IncludedFields = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "TYPE_AND_NAME"] = 0;
            values[valuesById[1] = "TYPE_ONLY"] = 1;
            values[valuesById[2] = "ALL"] = 2;
            return values;
        })();

        /**
         * Workload enum.
         * @name query.ExecuteOptions.Workload
         * @enum {number}
         * @property {number} UNSPECIFIED=0 UNSPECIFIED value
         * @property {number} OLTP=1 OLTP value
         * @property {number} OLAP=2 OLAP value
         * @property {number} DBA=3 DBA value
         */
        ExecuteOptions.Workload = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNSPECIFIED"] = 0;
            values[valuesById[1] = "OLTP"] = 1;
            values[valuesById[2] = "OLAP"] = 2;
            values[valuesById[3] = "DBA"] = 3;
            return values;
        })();

        /**
         * TransactionIsolation enum.
         * @name query.ExecuteOptions.TransactionIsolation
         * @enum {number}
         * @property {number} DEFAULT=0 DEFAULT value
         * @property {number} REPEATABLE_READ=1 REPEATABLE_READ value
         * @property {number} READ_COMMITTED=2 READ_COMMITTED value
         * @property {number} READ_UNCOMMITTED=3 READ_UNCOMMITTED value
         * @property {number} SERIALIZABLE=4 SERIALIZABLE value
         * @property {number} CONSISTENT_SNAPSHOT_READ_ONLY=5 CONSISTENT_SNAPSHOT_READ_ONLY value
         * @property {number} AUTOCOMMIT=6 AUTOCOMMIT value
         */
        ExecuteOptions.TransactionIsolation = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "DEFAULT"] = 0;
            values[valuesById[1] = "REPEATABLE_READ"] = 1;
            values[valuesById[2] = "READ_COMMITTED"] = 2;
            values[valuesById[3] = "READ_UNCOMMITTED"] = 3;
            values[valuesById[4] = "SERIALIZABLE"] = 4;
            values[valuesById[5] = "CONSISTENT_SNAPSHOT_READ_ONLY"] = 5;
            values[valuesById[6] = "AUTOCOMMIT"] = 6;
            return values;
        })();

        /**
         * PlannerVersion enum.
         * @name query.ExecuteOptions.PlannerVersion
         * @enum {number}
         * @property {number} DEFAULT_PLANNER=0 DEFAULT_PLANNER value
         * @property {number} V3=1 V3 value
         * @property {number} Gen4=2 Gen4 value
         * @property {number} Gen4Greedy=3 Gen4Greedy value
         * @property {number} Gen4Left2Right=4 Gen4Left2Right value
         * @property {number} Gen4WithFallback=5 Gen4WithFallback value
         */
        ExecuteOptions.PlannerVersion = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "DEFAULT_PLANNER"] = 0;
            values[valuesById[1] = "V3"] = 1;
            values[valuesById[2] = "Gen4"] = 2;
            values[valuesById[3] = "Gen4Greedy"] = 3;
            values[valuesById[4] = "Gen4Left2Right"] = 4;
            values[valuesById[5] = "Gen4WithFallback"] = 5;
            return values;
        })();

        return ExecuteOptions;
    })();

    query.Field = (function() {

        /**
         * Properties of a Field.
         * @memberof query
         * @interface IField
         * @property {string|null} [name] Field name
         * @property {query.Type|null} [type] Field type
         * @property {string|null} [table] Field table
         * @property {string|null} [org_table] Field org_table
         * @property {string|null} [database] Field database
         * @property {string|null} [org_name] Field org_name
         * @property {number|null} [column_length] Field column_length
         * @property {number|null} [charset] Field charset
         * @property {number|null} [decimals] Field decimals
         * @property {number|null} [flags] Field flags
         * @property {string|null} [column_type] Field column_type
         */

        /**
         * Constructs a new Field.
         * @memberof query
         * @classdesc Represents a Field.
         * @implements IField
         * @constructor
         * @param {query.IField=} [properties] Properties to set
         */
        function Field(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Field name.
         * @member {string} name
         * @memberof query.Field
         * @instance
         */
        Field.prototype.name = "";

        /**
         * Field type.
         * @member {query.Type} type
         * @memberof query.Field
         * @instance
         */
        Field.prototype.type = 0;

        /**
         * Field table.
         * @member {string} table
         * @memberof query.Field
         * @instance
         */
        Field.prototype.table = "";

        /**
         * Field org_table.
         * @member {string} org_table
         * @memberof query.Field
         * @instance
         */
        Field.prototype.org_table = "";

        /**
         * Field database.
         * @member {string} database
         * @memberof query.Field
         * @instance
         */
        Field.prototype.database = "";

        /**
         * Field org_name.
         * @member {string} org_name
         * @memberof query.Field
         * @instance
         */
        Field.prototype.org_name = "";

        /**
         * Field column_length.
         * @member {number} column_length
         * @memberof query.Field
         * @instance
         */
        Field.prototype.column_length = 0;

        /**
         * Field charset.
         * @member {number} charset
         * @memberof query.Field
         * @instance
         */
        Field.prototype.charset = 0;

        /**
         * Field decimals.
         * @member {number} decimals
         * @memberof query.Field
         * @instance
         */
        Field.prototype.decimals = 0;

        /**
         * Field flags.
         * @member {number} flags
         * @memberof query.Field
         * @instance
         */
        Field.prototype.flags = 0;

        /**
         * Field column_type.
         * @member {string} column_type
         * @memberof query.Field
         * @instance
         */
        Field.prototype.column_type = "";

        /**
         * Creates a new Field instance using the specified properties.
         * @function create
         * @memberof query.Field
         * @static
         * @param {query.IField=} [properties] Properties to set
         * @returns {query.Field} Field instance
         */
        Field.create = function create(properties) {
            return new Field(properties);
        };

        /**
         * Encodes the specified Field message. Does not implicitly {@link query.Field.verify|verify} messages.
         * @function encode
         * @memberof query.Field
         * @static
         * @param {query.IField} message Field message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Field.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.table != null && Object.hasOwnProperty.call(message, "table"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.table);
            if (message.org_table != null && Object.hasOwnProperty.call(message, "org_table"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.org_table);
            if (message.database != null && Object.hasOwnProperty.call(message, "database"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.database);
            if (message.org_name != null && Object.hasOwnProperty.call(message, "org_name"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.org_name);
            if (message.column_length != null && Object.hasOwnProperty.call(message, "column_length"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.column_length);
            if (message.charset != null && Object.hasOwnProperty.call(message, "charset"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.charset);
            if (message.decimals != null && Object.hasOwnProperty.call(message, "decimals"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.decimals);
            if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.flags);
            if (message.column_type != null && Object.hasOwnProperty.call(message, "column_type"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.column_type);
            return writer;
        };

        /**
         * Encodes the specified Field message, length delimited. Does not implicitly {@link query.Field.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.Field
         * @static
         * @param {query.IField} message Field message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Field.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Field message from the specified reader or buffer.
         * @function decode
         * @memberof query.Field
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.Field} Field
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Field.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.Field();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.table = reader.string();
                    break;
                case 4:
                    message.org_table = reader.string();
                    break;
                case 5:
                    message.database = reader.string();
                    break;
                case 6:
                    message.org_name = reader.string();
                    break;
                case 7:
                    message.column_length = reader.uint32();
                    break;
                case 8:
                    message.charset = reader.uint32();
                    break;
                case 9:
                    message.decimals = reader.uint32();
                    break;
                case 10:
                    message.flags = reader.uint32();
                    break;
                case 11:
                    message.column_type = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Field message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.Field
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.Field} Field
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Field.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Field message.
         * @function verify
         * @memberof query.Field
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Field.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 257:
                case 770:
                case 259:
                case 772:
                case 261:
                case 774:
                case 263:
                case 776:
                case 265:
                case 778:
                case 1035:
                case 1036:
                case 2061:
                case 2062:
                case 2063:
                case 2064:
                case 785:
                case 18:
                case 6163:
                case 10260:
                case 6165:
                case 10262:
                case 6167:
                case 10264:
                case 2073:
                case 2074:
                case 2075:
                case 28:
                case 2077:
                case 2078:
                case 31:
                    break;
                }
            if (message.table != null && message.hasOwnProperty("table"))
                if (!$util.isString(message.table))
                    return "table: string expected";
            if (message.org_table != null && message.hasOwnProperty("org_table"))
                if (!$util.isString(message.org_table))
                    return "org_table: string expected";
            if (message.database != null && message.hasOwnProperty("database"))
                if (!$util.isString(message.database))
                    return "database: string expected";
            if (message.org_name != null && message.hasOwnProperty("org_name"))
                if (!$util.isString(message.org_name))
                    return "org_name: string expected";
            if (message.column_length != null && message.hasOwnProperty("column_length"))
                if (!$util.isInteger(message.column_length))
                    return "column_length: integer expected";
            if (message.charset != null && message.hasOwnProperty("charset"))
                if (!$util.isInteger(message.charset))
                    return "charset: integer expected";
            if (message.decimals != null && message.hasOwnProperty("decimals"))
                if (!$util.isInteger(message.decimals))
                    return "decimals: integer expected";
            if (message.flags != null && message.hasOwnProperty("flags"))
                if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
            if (message.column_type != null && message.hasOwnProperty("column_type"))
                if (!$util.isString(message.column_type))
                    return "column_type: string expected";
            return null;
        };

        /**
         * Creates a Field message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.Field
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.Field} Field
         */
        Field.fromObject = function fromObject(object) {
            if (object instanceof $root.query.Field)
                return object;
            var message = new $root.query.Field();
            if (object.name != null)
                message.name = String(object.name);
            switch (object.type) {
            case "NULL_TYPE":
            case 0:
                message.type = 0;
                break;
            case "INT8":
            case 257:
                message.type = 257;
                break;
            case "UINT8":
            case 770:
                message.type = 770;
                break;
            case "INT16":
            case 259:
                message.type = 259;
                break;
            case "UINT16":
            case 772:
                message.type = 772;
                break;
            case "INT24":
            case 261:
                message.type = 261;
                break;
            case "UINT24":
            case 774:
                message.type = 774;
                break;
            case "INT32":
            case 263:
                message.type = 263;
                break;
            case "UINT32":
            case 776:
                message.type = 776;
                break;
            case "INT64":
            case 265:
                message.type = 265;
                break;
            case "UINT64":
            case 778:
                message.type = 778;
                break;
            case "FLOAT32":
            case 1035:
                message.type = 1035;
                break;
            case "FLOAT64":
            case 1036:
                message.type = 1036;
                break;
            case "TIMESTAMP":
            case 2061:
                message.type = 2061;
                break;
            case "DATE":
            case 2062:
                message.type = 2062;
                break;
            case "TIME":
            case 2063:
                message.type = 2063;
                break;
            case "DATETIME":
            case 2064:
                message.type = 2064;
                break;
            case "YEAR":
            case 785:
                message.type = 785;
                break;
            case "DECIMAL":
            case 18:
                message.type = 18;
                break;
            case "TEXT":
            case 6163:
                message.type = 6163;
                break;
            case "BLOB":
            case 10260:
                message.type = 10260;
                break;
            case "VARCHAR":
            case 6165:
                message.type = 6165;
                break;
            case "VARBINARY":
            case 10262:
                message.type = 10262;
                break;
            case "CHAR":
            case 6167:
                message.type = 6167;
                break;
            case "BINARY":
            case 10264:
                message.type = 10264;
                break;
            case "BIT":
            case 2073:
                message.type = 2073;
                break;
            case "ENUM":
            case 2074:
                message.type = 2074;
                break;
            case "SET":
            case 2075:
                message.type = 2075;
                break;
            case "TUPLE":
            case 28:
                message.type = 28;
                break;
            case "GEOMETRY":
            case 2077:
                message.type = 2077;
                break;
            case "JSON":
            case 2078:
                message.type = 2078;
                break;
            case "EXPRESSION":
            case 31:
                message.type = 31;
                break;
            }
            if (object.table != null)
                message.table = String(object.table);
            if (object.org_table != null)
                message.org_table = String(object.org_table);
            if (object.database != null)
                message.database = String(object.database);
            if (object.org_name != null)
                message.org_name = String(object.org_name);
            if (object.column_length != null)
                message.column_length = object.column_length >>> 0;
            if (object.charset != null)
                message.charset = object.charset >>> 0;
            if (object.decimals != null)
                message.decimals = object.decimals >>> 0;
            if (object.flags != null)
                message.flags = object.flags >>> 0;
            if (object.column_type != null)
                message.column_type = String(object.column_type);
            return message;
        };

        /**
         * Creates a plain object from a Field message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.Field
         * @static
         * @param {query.Field} message Field
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Field.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.type = options.enums === String ? "NULL_TYPE" : 0;
                object.table = "";
                object.org_table = "";
                object.database = "";
                object.org_name = "";
                object.column_length = 0;
                object.charset = 0;
                object.decimals = 0;
                object.flags = 0;
                object.column_type = "";
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.query.Type[message.type] : message.type;
            if (message.table != null && message.hasOwnProperty("table"))
                object.table = message.table;
            if (message.org_table != null && message.hasOwnProperty("org_table"))
                object.org_table = message.org_table;
            if (message.database != null && message.hasOwnProperty("database"))
                object.database = message.database;
            if (message.org_name != null && message.hasOwnProperty("org_name"))
                object.org_name = message.org_name;
            if (message.column_length != null && message.hasOwnProperty("column_length"))
                object.column_length = message.column_length;
            if (message.charset != null && message.hasOwnProperty("charset"))
                object.charset = message.charset;
            if (message.decimals != null && message.hasOwnProperty("decimals"))
                object.decimals = message.decimals;
            if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
            if (message.column_type != null && message.hasOwnProperty("column_type"))
                object.column_type = message.column_type;
            return object;
        };

        /**
         * Converts this Field to JSON.
         * @function toJSON
         * @memberof query.Field
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Field.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Field;
    })();

    query.Row = (function() {

        /**
         * Properties of a Row.
         * @memberof query
         * @interface IRow
         * @property {Array.<number|Long>|null} [lengths] Row lengths
         * @property {Uint8Array|null} [values] Row values
         */

        /**
         * Constructs a new Row.
         * @memberof query
         * @classdesc Represents a Row.
         * @implements IRow
         * @constructor
         * @param {query.IRow=} [properties] Properties to set
         */
        function Row(properties) {
            this.lengths = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Row lengths.
         * @member {Array.<number|Long>} lengths
         * @memberof query.Row
         * @instance
         */
        Row.prototype.lengths = $util.emptyArray;

        /**
         * Row values.
         * @member {Uint8Array} values
         * @memberof query.Row
         * @instance
         */
        Row.prototype.values = $util.newBuffer([]);

        /**
         * Creates a new Row instance using the specified properties.
         * @function create
         * @memberof query.Row
         * @static
         * @param {query.IRow=} [properties] Properties to set
         * @returns {query.Row} Row instance
         */
        Row.create = function create(properties) {
            return new Row(properties);
        };

        /**
         * Encodes the specified Row message. Does not implicitly {@link query.Row.verify|verify} messages.
         * @function encode
         * @memberof query.Row
         * @static
         * @param {query.IRow} message Row message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Row.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.lengths != null && message.lengths.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.lengths.length; ++i)
                    writer.sint64(message.lengths[i]);
                writer.ldelim();
            }
            if (message.values != null && Object.hasOwnProperty.call(message, "values"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.values);
            return writer;
        };

        /**
         * Encodes the specified Row message, length delimited. Does not implicitly {@link query.Row.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.Row
         * @static
         * @param {query.IRow} message Row message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Row.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Row message from the specified reader or buffer.
         * @function decode
         * @memberof query.Row
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.Row} Row
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Row.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.Row();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.lengths && message.lengths.length))
                        message.lengths = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.lengths.push(reader.sint64());
                    } else
                        message.lengths.push(reader.sint64());
                    break;
                case 2:
                    message.values = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Row message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.Row
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.Row} Row
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Row.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Row message.
         * @function verify
         * @memberof query.Row
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Row.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.lengths != null && message.hasOwnProperty("lengths")) {
                if (!Array.isArray(message.lengths))
                    return "lengths: array expected";
                for (var i = 0; i < message.lengths.length; ++i)
                    if (!$util.isInteger(message.lengths[i]) && !(message.lengths[i] && $util.isInteger(message.lengths[i].low) && $util.isInteger(message.lengths[i].high)))
                        return "lengths: integer|Long[] expected";
            }
            if (message.values != null && message.hasOwnProperty("values"))
                if (!(message.values && typeof message.values.length === "number" || $util.isString(message.values)))
                    return "values: buffer expected";
            return null;
        };

        /**
         * Creates a Row message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.Row
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.Row} Row
         */
        Row.fromObject = function fromObject(object) {
            if (object instanceof $root.query.Row)
                return object;
            var message = new $root.query.Row();
            if (object.lengths) {
                if (!Array.isArray(object.lengths))
                    throw TypeError(".query.Row.lengths: array expected");
                message.lengths = [];
                for (var i = 0; i < object.lengths.length; ++i)
                    if ($util.Long)
                        (message.lengths[i] = $util.Long.fromValue(object.lengths[i])).unsigned = false;
                    else if (typeof object.lengths[i] === "string")
                        message.lengths[i] = parseInt(object.lengths[i], 10);
                    else if (typeof object.lengths[i] === "number")
                        message.lengths[i] = object.lengths[i];
                    else if (typeof object.lengths[i] === "object")
                        message.lengths[i] = new $util.LongBits(object.lengths[i].low >>> 0, object.lengths[i].high >>> 0).toNumber();
            }
            if (object.values != null)
                if (typeof object.values === "string")
                    $util.base64.decode(object.values, message.values = $util.newBuffer($util.base64.length(object.values)), 0);
                else if (object.values.length)
                    message.values = object.values;
            return message;
        };

        /**
         * Creates a plain object from a Row message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.Row
         * @static
         * @param {query.Row} message Row
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Row.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.lengths = [];
            if (options.defaults)
                if (options.bytes === String)
                    object.values = "";
                else {
                    object.values = [];
                    if (options.bytes !== Array)
                        object.values = $util.newBuffer(object.values);
                }
            if (message.lengths && message.lengths.length) {
                object.lengths = [];
                for (var j = 0; j < message.lengths.length; ++j)
                    if (typeof message.lengths[j] === "number")
                        object.lengths[j] = options.longs === String ? String(message.lengths[j]) : message.lengths[j];
                    else
                        object.lengths[j] = options.longs === String ? $util.Long.prototype.toString.call(message.lengths[j]) : options.longs === Number ? new $util.LongBits(message.lengths[j].low >>> 0, message.lengths[j].high >>> 0).toNumber() : message.lengths[j];
            }
            if (message.values != null && message.hasOwnProperty("values"))
                object.values = options.bytes === String ? $util.base64.encode(message.values, 0, message.values.length) : options.bytes === Array ? Array.prototype.slice.call(message.values) : message.values;
            return object;
        };

        /**
         * Converts this Row to JSON.
         * @function toJSON
         * @memberof query.Row
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Row.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Row;
    })();

    query.QueryResult = (function() {

        /**
         * Properties of a QueryResult.
         * @memberof query
         * @interface IQueryResult
         * @property {Array.<query.IField>|null} [fields] QueryResult fields
         * @property {number|Long|null} [rows_affected] QueryResult rows_affected
         * @property {number|Long|null} [insert_id] QueryResult insert_id
         * @property {Array.<query.IRow>|null} [rows] QueryResult rows
         */

        /**
         * Constructs a new QueryResult.
         * @memberof query
         * @classdesc Represents a QueryResult.
         * @implements IQueryResult
         * @constructor
         * @param {query.IQueryResult=} [properties] Properties to set
         */
        function QueryResult(properties) {
            this.fields = [];
            this.rows = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryResult fields.
         * @member {Array.<query.IField>} fields
         * @memberof query.QueryResult
         * @instance
         */
        QueryResult.prototype.fields = $util.emptyArray;

        /**
         * QueryResult rows_affected.
         * @member {number|Long} rows_affected
         * @memberof query.QueryResult
         * @instance
         */
        QueryResult.prototype.rows_affected = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * QueryResult insert_id.
         * @member {number|Long} insert_id
         * @memberof query.QueryResult
         * @instance
         */
        QueryResult.prototype.insert_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * QueryResult rows.
         * @member {Array.<query.IRow>} rows
         * @memberof query.QueryResult
         * @instance
         */
        QueryResult.prototype.rows = $util.emptyArray;

        /**
         * Creates a new QueryResult instance using the specified properties.
         * @function create
         * @memberof query.QueryResult
         * @static
         * @param {query.IQueryResult=} [properties] Properties to set
         * @returns {query.QueryResult} QueryResult instance
         */
        QueryResult.create = function create(properties) {
            return new QueryResult(properties);
        };

        /**
         * Encodes the specified QueryResult message. Does not implicitly {@link query.QueryResult.verify|verify} messages.
         * @function encode
         * @memberof query.QueryResult
         * @static
         * @param {query.IQueryResult} message QueryResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fields != null && message.fields.length)
                for (var i = 0; i < message.fields.length; ++i)
                    $root.query.Field.encode(message.fields[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.rows_affected != null && Object.hasOwnProperty.call(message, "rows_affected"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.rows_affected);
            if (message.insert_id != null && Object.hasOwnProperty.call(message, "insert_id"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.insert_id);
            if (message.rows != null && message.rows.length)
                for (var i = 0; i < message.rows.length; ++i)
                    $root.query.Row.encode(message.rows[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified QueryResult message, length delimited. Does not implicitly {@link query.QueryResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.QueryResult
         * @static
         * @param {query.IQueryResult} message QueryResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryResult message from the specified reader or buffer.
         * @function decode
         * @memberof query.QueryResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.QueryResult} QueryResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.QueryResult();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.fields && message.fields.length))
                        message.fields = [];
                    message.fields.push($root.query.Field.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.rows_affected = reader.uint64();
                    break;
                case 3:
                    message.insert_id = reader.uint64();
                    break;
                case 4:
                    if (!(message.rows && message.rows.length))
                        message.rows = [];
                    message.rows.push($root.query.Row.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QueryResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.QueryResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.QueryResult} QueryResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryResult message.
         * @function verify
         * @memberof query.QueryResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fields != null && message.hasOwnProperty("fields")) {
                if (!Array.isArray(message.fields))
                    return "fields: array expected";
                for (var i = 0; i < message.fields.length; ++i) {
                    var error = $root.query.Field.verify(message.fields[i]);
                    if (error)
                        return "fields." + error;
                }
            }
            if (message.rows_affected != null && message.hasOwnProperty("rows_affected"))
                if (!$util.isInteger(message.rows_affected) && !(message.rows_affected && $util.isInteger(message.rows_affected.low) && $util.isInteger(message.rows_affected.high)))
                    return "rows_affected: integer|Long expected";
            if (message.insert_id != null && message.hasOwnProperty("insert_id"))
                if (!$util.isInteger(message.insert_id) && !(message.insert_id && $util.isInteger(message.insert_id.low) && $util.isInteger(message.insert_id.high)))
                    return "insert_id: integer|Long expected";
            if (message.rows != null && message.hasOwnProperty("rows")) {
                if (!Array.isArray(message.rows))
                    return "rows: array expected";
                for (var i = 0; i < message.rows.length; ++i) {
                    var error = $root.query.Row.verify(message.rows[i]);
                    if (error)
                        return "rows." + error;
                }
            }
            return null;
        };

        /**
         * Creates a QueryResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.QueryResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.QueryResult} QueryResult
         */
        QueryResult.fromObject = function fromObject(object) {
            if (object instanceof $root.query.QueryResult)
                return object;
            var message = new $root.query.QueryResult();
            if (object.fields) {
                if (!Array.isArray(object.fields))
                    throw TypeError(".query.QueryResult.fields: array expected");
                message.fields = [];
                for (var i = 0; i < object.fields.length; ++i) {
                    if (typeof object.fields[i] !== "object")
                        throw TypeError(".query.QueryResult.fields: object expected");
                    message.fields[i] = $root.query.Field.fromObject(object.fields[i]);
                }
            }
            if (object.rows_affected != null)
                if ($util.Long)
                    (message.rows_affected = $util.Long.fromValue(object.rows_affected)).unsigned = true;
                else if (typeof object.rows_affected === "string")
                    message.rows_affected = parseInt(object.rows_affected, 10);
                else if (typeof object.rows_affected === "number")
                    message.rows_affected = object.rows_affected;
                else if (typeof object.rows_affected === "object")
                    message.rows_affected = new $util.LongBits(object.rows_affected.low >>> 0, object.rows_affected.high >>> 0).toNumber(true);
            if (object.insert_id != null)
                if ($util.Long)
                    (message.insert_id = $util.Long.fromValue(object.insert_id)).unsigned = true;
                else if (typeof object.insert_id === "string")
                    message.insert_id = parseInt(object.insert_id, 10);
                else if (typeof object.insert_id === "number")
                    message.insert_id = object.insert_id;
                else if (typeof object.insert_id === "object")
                    message.insert_id = new $util.LongBits(object.insert_id.low >>> 0, object.insert_id.high >>> 0).toNumber(true);
            if (object.rows) {
                if (!Array.isArray(object.rows))
                    throw TypeError(".query.QueryResult.rows: array expected");
                message.rows = [];
                for (var i = 0; i < object.rows.length; ++i) {
                    if (typeof object.rows[i] !== "object")
                        throw TypeError(".query.QueryResult.rows: object expected");
                    message.rows[i] = $root.query.Row.fromObject(object.rows[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a QueryResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.QueryResult
         * @static
         * @param {query.QueryResult} message QueryResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.fields = [];
                object.rows = [];
            }
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.rows_affected = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.rows_affected = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.insert_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.insert_id = options.longs === String ? "0" : 0;
            }
            if (message.fields && message.fields.length) {
                object.fields = [];
                for (var j = 0; j < message.fields.length; ++j)
                    object.fields[j] = $root.query.Field.toObject(message.fields[j], options);
            }
            if (message.rows_affected != null && message.hasOwnProperty("rows_affected"))
                if (typeof message.rows_affected === "number")
                    object.rows_affected = options.longs === String ? String(message.rows_affected) : message.rows_affected;
                else
                    object.rows_affected = options.longs === String ? $util.Long.prototype.toString.call(message.rows_affected) : options.longs === Number ? new $util.LongBits(message.rows_affected.low >>> 0, message.rows_affected.high >>> 0).toNumber(true) : message.rows_affected;
            if (message.insert_id != null && message.hasOwnProperty("insert_id"))
                if (typeof message.insert_id === "number")
                    object.insert_id = options.longs === String ? String(message.insert_id) : message.insert_id;
                else
                    object.insert_id = options.longs === String ? $util.Long.prototype.toString.call(message.insert_id) : options.longs === Number ? new $util.LongBits(message.insert_id.low >>> 0, message.insert_id.high >>> 0).toNumber(true) : message.insert_id;
            if (message.rows && message.rows.length) {
                object.rows = [];
                for (var j = 0; j < message.rows.length; ++j)
                    object.rows[j] = $root.query.Row.toObject(message.rows[j], options);
            }
            return object;
        };

        /**
         * Converts this QueryResult to JSON.
         * @function toJSON
         * @memberof query.QueryResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryResult;
    })();

    query.QueryWarning = (function() {

        /**
         * Properties of a QueryWarning.
         * @memberof query
         * @interface IQueryWarning
         * @property {number|null} [code] QueryWarning code
         * @property {string|null} [message] QueryWarning message
         */

        /**
         * Constructs a new QueryWarning.
         * @memberof query
         * @classdesc Represents a QueryWarning.
         * @implements IQueryWarning
         * @constructor
         * @param {query.IQueryWarning=} [properties] Properties to set
         */
        function QueryWarning(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryWarning code.
         * @member {number} code
         * @memberof query.QueryWarning
         * @instance
         */
        QueryWarning.prototype.code = 0;

        /**
         * QueryWarning message.
         * @member {string} message
         * @memberof query.QueryWarning
         * @instance
         */
        QueryWarning.prototype.message = "";

        /**
         * Creates a new QueryWarning instance using the specified properties.
         * @function create
         * @memberof query.QueryWarning
         * @static
         * @param {query.IQueryWarning=} [properties] Properties to set
         * @returns {query.QueryWarning} QueryWarning instance
         */
        QueryWarning.create = function create(properties) {
            return new QueryWarning(properties);
        };

        /**
         * Encodes the specified QueryWarning message. Does not implicitly {@link query.QueryWarning.verify|verify} messages.
         * @function encode
         * @memberof query.QueryWarning
         * @static
         * @param {query.IQueryWarning} message QueryWarning message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryWarning.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.code);
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
            return writer;
        };

        /**
         * Encodes the specified QueryWarning message, length delimited. Does not implicitly {@link query.QueryWarning.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.QueryWarning
         * @static
         * @param {query.IQueryWarning} message QueryWarning message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryWarning.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryWarning message from the specified reader or buffer.
         * @function decode
         * @memberof query.QueryWarning
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.QueryWarning} QueryWarning
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryWarning.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.QueryWarning();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.code = reader.uint32();
                    break;
                case 2:
                    message.message = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QueryWarning message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.QueryWarning
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.QueryWarning} QueryWarning
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryWarning.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryWarning message.
         * @function verify
         * @memberof query.QueryWarning
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryWarning.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.code != null && message.hasOwnProperty("code"))
                if (!$util.isInteger(message.code))
                    return "code: integer expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            return null;
        };

        /**
         * Creates a QueryWarning message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.QueryWarning
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.QueryWarning} QueryWarning
         */
        QueryWarning.fromObject = function fromObject(object) {
            if (object instanceof $root.query.QueryWarning)
                return object;
            var message = new $root.query.QueryWarning();
            if (object.code != null)
                message.code = object.code >>> 0;
            if (object.message != null)
                message.message = String(object.message);
            return message;
        };

        /**
         * Creates a plain object from a QueryWarning message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.QueryWarning
         * @static
         * @param {query.QueryWarning} message QueryWarning
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryWarning.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.code = 0;
                object.message = "";
            }
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = message.code;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            return object;
        };

        /**
         * Converts this QueryWarning to JSON.
         * @function toJSON
         * @memberof query.QueryWarning
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryWarning.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryWarning;
    })();

    query.StreamEvent = (function() {

        /**
         * Properties of a StreamEvent.
         * @memberof query
         * @interface IStreamEvent
         * @property {Array.<query.StreamEvent.IStatement>|null} [statements] StreamEvent statements
         * @property {query.IEventToken|null} [event_token] StreamEvent event_token
         */

        /**
         * Constructs a new StreamEvent.
         * @memberof query
         * @classdesc Represents a StreamEvent.
         * @implements IStreamEvent
         * @constructor
         * @param {query.IStreamEvent=} [properties] Properties to set
         */
        function StreamEvent(properties) {
            this.statements = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StreamEvent statements.
         * @member {Array.<query.StreamEvent.IStatement>} statements
         * @memberof query.StreamEvent
         * @instance
         */
        StreamEvent.prototype.statements = $util.emptyArray;

        /**
         * StreamEvent event_token.
         * @member {query.IEventToken|null|undefined} event_token
         * @memberof query.StreamEvent
         * @instance
         */
        StreamEvent.prototype.event_token = null;

        /**
         * Creates a new StreamEvent instance using the specified properties.
         * @function create
         * @memberof query.StreamEvent
         * @static
         * @param {query.IStreamEvent=} [properties] Properties to set
         * @returns {query.StreamEvent} StreamEvent instance
         */
        StreamEvent.create = function create(properties) {
            return new StreamEvent(properties);
        };

        /**
         * Encodes the specified StreamEvent message. Does not implicitly {@link query.StreamEvent.verify|verify} messages.
         * @function encode
         * @memberof query.StreamEvent
         * @static
         * @param {query.IStreamEvent} message StreamEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.statements != null && message.statements.length)
                for (var i = 0; i < message.statements.length; ++i)
                    $root.query.StreamEvent.Statement.encode(message.statements[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.event_token != null && Object.hasOwnProperty.call(message, "event_token"))
                $root.query.EventToken.encode(message.event_token, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified StreamEvent message, length delimited. Does not implicitly {@link query.StreamEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.StreamEvent
         * @static
         * @param {query.IStreamEvent} message StreamEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StreamEvent message from the specified reader or buffer.
         * @function decode
         * @memberof query.StreamEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.StreamEvent} StreamEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.StreamEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.statements && message.statements.length))
                        message.statements = [];
                    message.statements.push($root.query.StreamEvent.Statement.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.event_token = $root.query.EventToken.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StreamEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.StreamEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.StreamEvent} StreamEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StreamEvent message.
         * @function verify
         * @memberof query.StreamEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StreamEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.statements != null && message.hasOwnProperty("statements")) {
                if (!Array.isArray(message.statements))
                    return "statements: array expected";
                for (var i = 0; i < message.statements.length; ++i) {
                    var error = $root.query.StreamEvent.Statement.verify(message.statements[i]);
                    if (error)
                        return "statements." + error;
                }
            }
            if (message.event_token != null && message.hasOwnProperty("event_token")) {
                var error = $root.query.EventToken.verify(message.event_token);
                if (error)
                    return "event_token." + error;
            }
            return null;
        };

        /**
         * Creates a StreamEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.StreamEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.StreamEvent} StreamEvent
         */
        StreamEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.query.StreamEvent)
                return object;
            var message = new $root.query.StreamEvent();
            if (object.statements) {
                if (!Array.isArray(object.statements))
                    throw TypeError(".query.StreamEvent.statements: array expected");
                message.statements = [];
                for (var i = 0; i < object.statements.length; ++i) {
                    if (typeof object.statements[i] !== "object")
                        throw TypeError(".query.StreamEvent.statements: object expected");
                    message.statements[i] = $root.query.StreamEvent.Statement.fromObject(object.statements[i]);
                }
            }
            if (object.event_token != null) {
                if (typeof object.event_token !== "object")
                    throw TypeError(".query.StreamEvent.event_token: object expected");
                message.event_token = $root.query.EventToken.fromObject(object.event_token);
            }
            return message;
        };

        /**
         * Creates a plain object from a StreamEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.StreamEvent
         * @static
         * @param {query.StreamEvent} message StreamEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StreamEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.statements = [];
            if (options.defaults)
                object.event_token = null;
            if (message.statements && message.statements.length) {
                object.statements = [];
                for (var j = 0; j < message.statements.length; ++j)
                    object.statements[j] = $root.query.StreamEvent.Statement.toObject(message.statements[j], options);
            }
            if (message.event_token != null && message.hasOwnProperty("event_token"))
                object.event_token = $root.query.EventToken.toObject(message.event_token, options);
            return object;
        };

        /**
         * Converts this StreamEvent to JSON.
         * @function toJSON
         * @memberof query.StreamEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StreamEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        StreamEvent.Statement = (function() {

            /**
             * Properties of a Statement.
             * @memberof query.StreamEvent
             * @interface IStatement
             * @property {query.StreamEvent.Statement.Category|null} [category] Statement category
             * @property {string|null} [table_name] Statement table_name
             * @property {Array.<query.IField>|null} [primary_key_fields] Statement primary_key_fields
             * @property {Array.<query.IRow>|null} [primary_key_values] Statement primary_key_values
             * @property {Uint8Array|null} [sql] Statement sql
             */

            /**
             * Constructs a new Statement.
             * @memberof query.StreamEvent
             * @classdesc Represents a Statement.
             * @implements IStatement
             * @constructor
             * @param {query.StreamEvent.IStatement=} [properties] Properties to set
             */
            function Statement(properties) {
                this.primary_key_fields = [];
                this.primary_key_values = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Statement category.
             * @member {query.StreamEvent.Statement.Category} category
             * @memberof query.StreamEvent.Statement
             * @instance
             */
            Statement.prototype.category = 0;

            /**
             * Statement table_name.
             * @member {string} table_name
             * @memberof query.StreamEvent.Statement
             * @instance
             */
            Statement.prototype.table_name = "";

            /**
             * Statement primary_key_fields.
             * @member {Array.<query.IField>} primary_key_fields
             * @memberof query.StreamEvent.Statement
             * @instance
             */
            Statement.prototype.primary_key_fields = $util.emptyArray;

            /**
             * Statement primary_key_values.
             * @member {Array.<query.IRow>} primary_key_values
             * @memberof query.StreamEvent.Statement
             * @instance
             */
            Statement.prototype.primary_key_values = $util.emptyArray;

            /**
             * Statement sql.
             * @member {Uint8Array} sql
             * @memberof query.StreamEvent.Statement
             * @instance
             */
            Statement.prototype.sql = $util.newBuffer([]);

            /**
             * Creates a new Statement instance using the specified properties.
             * @function create
             * @memberof query.StreamEvent.Statement
             * @static
             * @param {query.StreamEvent.IStatement=} [properties] Properties to set
             * @returns {query.StreamEvent.Statement} Statement instance
             */
            Statement.create = function create(properties) {
                return new Statement(properties);
            };

            /**
             * Encodes the specified Statement message. Does not implicitly {@link query.StreamEvent.Statement.verify|verify} messages.
             * @function encode
             * @memberof query.StreamEvent.Statement
             * @static
             * @param {query.StreamEvent.IStatement} message Statement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Statement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.category != null && Object.hasOwnProperty.call(message, "category"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.category);
                if (message.table_name != null && Object.hasOwnProperty.call(message, "table_name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.table_name);
                if (message.primary_key_fields != null && message.primary_key_fields.length)
                    for (var i = 0; i < message.primary_key_fields.length; ++i)
                        $root.query.Field.encode(message.primary_key_fields[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.primary_key_values != null && message.primary_key_values.length)
                    for (var i = 0; i < message.primary_key_values.length; ++i)
                        $root.query.Row.encode(message.primary_key_values[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.sql != null && Object.hasOwnProperty.call(message, "sql"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.sql);
                return writer;
            };

            /**
             * Encodes the specified Statement message, length delimited. Does not implicitly {@link query.StreamEvent.Statement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof query.StreamEvent.Statement
             * @static
             * @param {query.StreamEvent.IStatement} message Statement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Statement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Statement message from the specified reader or buffer.
             * @function decode
             * @memberof query.StreamEvent.Statement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {query.StreamEvent.Statement} Statement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Statement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.StreamEvent.Statement();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.category = reader.int32();
                        break;
                    case 2:
                        message.table_name = reader.string();
                        break;
                    case 3:
                        if (!(message.primary_key_fields && message.primary_key_fields.length))
                            message.primary_key_fields = [];
                        message.primary_key_fields.push($root.query.Field.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.primary_key_values && message.primary_key_values.length))
                            message.primary_key_values = [];
                        message.primary_key_values.push($root.query.Row.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        message.sql = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Statement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof query.StreamEvent.Statement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {query.StreamEvent.Statement} Statement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Statement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Statement message.
             * @function verify
             * @memberof query.StreamEvent.Statement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Statement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.category != null && message.hasOwnProperty("category"))
                    switch (message.category) {
                    default:
                        return "category: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.table_name != null && message.hasOwnProperty("table_name"))
                    if (!$util.isString(message.table_name))
                        return "table_name: string expected";
                if (message.primary_key_fields != null && message.hasOwnProperty("primary_key_fields")) {
                    if (!Array.isArray(message.primary_key_fields))
                        return "primary_key_fields: array expected";
                    for (var i = 0; i < message.primary_key_fields.length; ++i) {
                        var error = $root.query.Field.verify(message.primary_key_fields[i]);
                        if (error)
                            return "primary_key_fields." + error;
                    }
                }
                if (message.primary_key_values != null && message.hasOwnProperty("primary_key_values")) {
                    if (!Array.isArray(message.primary_key_values))
                        return "primary_key_values: array expected";
                    for (var i = 0; i < message.primary_key_values.length; ++i) {
                        var error = $root.query.Row.verify(message.primary_key_values[i]);
                        if (error)
                            return "primary_key_values." + error;
                    }
                }
                if (message.sql != null && message.hasOwnProperty("sql"))
                    if (!(message.sql && typeof message.sql.length === "number" || $util.isString(message.sql)))
                        return "sql: buffer expected";
                return null;
            };

            /**
             * Creates a Statement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof query.StreamEvent.Statement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {query.StreamEvent.Statement} Statement
             */
            Statement.fromObject = function fromObject(object) {
                if (object instanceof $root.query.StreamEvent.Statement)
                    return object;
                var message = new $root.query.StreamEvent.Statement();
                switch (object.category) {
                case "Error":
                case 0:
                    message.category = 0;
                    break;
                case "DML":
                case 1:
                    message.category = 1;
                    break;
                case "DDL":
                case 2:
                    message.category = 2;
                    break;
                }
                if (object.table_name != null)
                    message.table_name = String(object.table_name);
                if (object.primary_key_fields) {
                    if (!Array.isArray(object.primary_key_fields))
                        throw TypeError(".query.StreamEvent.Statement.primary_key_fields: array expected");
                    message.primary_key_fields = [];
                    for (var i = 0; i < object.primary_key_fields.length; ++i) {
                        if (typeof object.primary_key_fields[i] !== "object")
                            throw TypeError(".query.StreamEvent.Statement.primary_key_fields: object expected");
                        message.primary_key_fields[i] = $root.query.Field.fromObject(object.primary_key_fields[i]);
                    }
                }
                if (object.primary_key_values) {
                    if (!Array.isArray(object.primary_key_values))
                        throw TypeError(".query.StreamEvent.Statement.primary_key_values: array expected");
                    message.primary_key_values = [];
                    for (var i = 0; i < object.primary_key_values.length; ++i) {
                        if (typeof object.primary_key_values[i] !== "object")
                            throw TypeError(".query.StreamEvent.Statement.primary_key_values: object expected");
                        message.primary_key_values[i] = $root.query.Row.fromObject(object.primary_key_values[i]);
                    }
                }
                if (object.sql != null)
                    if (typeof object.sql === "string")
                        $util.base64.decode(object.sql, message.sql = $util.newBuffer($util.base64.length(object.sql)), 0);
                    else if (object.sql.length)
                        message.sql = object.sql;
                return message;
            };

            /**
             * Creates a plain object from a Statement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof query.StreamEvent.Statement
             * @static
             * @param {query.StreamEvent.Statement} message Statement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Statement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.primary_key_fields = [];
                    object.primary_key_values = [];
                }
                if (options.defaults) {
                    object.category = options.enums === String ? "Error" : 0;
                    object.table_name = "";
                    if (options.bytes === String)
                        object.sql = "";
                    else {
                        object.sql = [];
                        if (options.bytes !== Array)
                            object.sql = $util.newBuffer(object.sql);
                    }
                }
                if (message.category != null && message.hasOwnProperty("category"))
                    object.category = options.enums === String ? $root.query.StreamEvent.Statement.Category[message.category] : message.category;
                if (message.table_name != null && message.hasOwnProperty("table_name"))
                    object.table_name = message.table_name;
                if (message.primary_key_fields && message.primary_key_fields.length) {
                    object.primary_key_fields = [];
                    for (var j = 0; j < message.primary_key_fields.length; ++j)
                        object.primary_key_fields[j] = $root.query.Field.toObject(message.primary_key_fields[j], options);
                }
                if (message.primary_key_values && message.primary_key_values.length) {
                    object.primary_key_values = [];
                    for (var j = 0; j < message.primary_key_values.length; ++j)
                        object.primary_key_values[j] = $root.query.Row.toObject(message.primary_key_values[j], options);
                }
                if (message.sql != null && message.hasOwnProperty("sql"))
                    object.sql = options.bytes === String ? $util.base64.encode(message.sql, 0, message.sql.length) : options.bytes === Array ? Array.prototype.slice.call(message.sql) : message.sql;
                return object;
            };

            /**
             * Converts this Statement to JSON.
             * @function toJSON
             * @memberof query.StreamEvent.Statement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Statement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Category enum.
             * @name query.StreamEvent.Statement.Category
             * @enum {number}
             * @property {number} Error=0 Error value
             * @property {number} DML=1 DML value
             * @property {number} DDL=2 DDL value
             */
            Statement.Category = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "Error"] = 0;
                values[valuesById[1] = "DML"] = 1;
                values[valuesById[2] = "DDL"] = 2;
                return values;
            })();

            return Statement;
        })();

        return StreamEvent;
    })();

    query.ExecuteRequest = (function() {

        /**
         * Properties of an ExecuteRequest.
         * @memberof query
         * @interface IExecuteRequest
         * @property {vtrpc.ICallerID|null} [effective_caller_id] ExecuteRequest effective_caller_id
         * @property {query.IVTGateCallerID|null} [immediate_caller_id] ExecuteRequest immediate_caller_id
         * @property {query.ITarget|null} [target] ExecuteRequest target
         * @property {query.IBoundQuery|null} [query] ExecuteRequest query
         * @property {number|Long|null} [transaction_id] ExecuteRequest transaction_id
         * @property {query.IExecuteOptions|null} [options] ExecuteRequest options
         * @property {number|Long|null} [reserved_id] ExecuteRequest reserved_id
         */

        /**
         * Constructs a new ExecuteRequest.
         * @memberof query
         * @classdesc Represents an ExecuteRequest.
         * @implements IExecuteRequest
         * @constructor
         * @param {query.IExecuteRequest=} [properties] Properties to set
         */
        function ExecuteRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExecuteRequest effective_caller_id.
         * @member {vtrpc.ICallerID|null|undefined} effective_caller_id
         * @memberof query.ExecuteRequest
         * @instance
         */
        ExecuteRequest.prototype.effective_caller_id = null;

        /**
         * ExecuteRequest immediate_caller_id.
         * @member {query.IVTGateCallerID|null|undefined} immediate_caller_id
         * @memberof query.ExecuteRequest
         * @instance
         */
        ExecuteRequest.prototype.immediate_caller_id = null;

        /**
         * ExecuteRequest target.
         * @member {query.ITarget|null|undefined} target
         * @memberof query.ExecuteRequest
         * @instance
         */
        ExecuteRequest.prototype.target = null;

        /**
         * ExecuteRequest query.
         * @member {query.IBoundQuery|null|undefined} query
         * @memberof query.ExecuteRequest
         * @instance
         */
        ExecuteRequest.prototype.query = null;

        /**
         * ExecuteRequest transaction_id.
         * @member {number|Long} transaction_id
         * @memberof query.ExecuteRequest
         * @instance
         */
        ExecuteRequest.prototype.transaction_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ExecuteRequest options.
         * @member {query.IExecuteOptions|null|undefined} options
         * @memberof query.ExecuteRequest
         * @instance
         */
        ExecuteRequest.prototype.options = null;

        /**
         * ExecuteRequest reserved_id.
         * @member {number|Long} reserved_id
         * @memberof query.ExecuteRequest
         * @instance
         */
        ExecuteRequest.prototype.reserved_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ExecuteRequest instance using the specified properties.
         * @function create
         * @memberof query.ExecuteRequest
         * @static
         * @param {query.IExecuteRequest=} [properties] Properties to set
         * @returns {query.ExecuteRequest} ExecuteRequest instance
         */
        ExecuteRequest.create = function create(properties) {
            return new ExecuteRequest(properties);
        };

        /**
         * Encodes the specified ExecuteRequest message. Does not implicitly {@link query.ExecuteRequest.verify|verify} messages.
         * @function encode
         * @memberof query.ExecuteRequest
         * @static
         * @param {query.IExecuteRequest} message ExecuteRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecuteRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.effective_caller_id != null && Object.hasOwnProperty.call(message, "effective_caller_id"))
                $root.vtrpc.CallerID.encode(message.effective_caller_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.immediate_caller_id != null && Object.hasOwnProperty.call(message, "immediate_caller_id"))
                $root.query.VTGateCallerID.encode(message.immediate_caller_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                $root.query.Target.encode(message.target, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                $root.query.BoundQuery.encode(message.query, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.transaction_id != null && Object.hasOwnProperty.call(message, "transaction_id"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.transaction_id);
            if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                $root.query.ExecuteOptions.encode(message.options, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.reserved_id != null && Object.hasOwnProperty.call(message, "reserved_id"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.reserved_id);
            return writer;
        };

        /**
         * Encodes the specified ExecuteRequest message, length delimited. Does not implicitly {@link query.ExecuteRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.ExecuteRequest
         * @static
         * @param {query.IExecuteRequest} message ExecuteRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecuteRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExecuteRequest message from the specified reader or buffer.
         * @function decode
         * @memberof query.ExecuteRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.ExecuteRequest} ExecuteRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecuteRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.ExecuteRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.effective_caller_id = $root.vtrpc.CallerID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.immediate_caller_id = $root.query.VTGateCallerID.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.target = $root.query.Target.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.query = $root.query.BoundQuery.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.transaction_id = reader.int64();
                    break;
                case 6:
                    message.options = $root.query.ExecuteOptions.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.reserved_id = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExecuteRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.ExecuteRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.ExecuteRequest} ExecuteRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecuteRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExecuteRequest message.
         * @function verify
         * @memberof query.ExecuteRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExecuteRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id")) {
                var error = $root.vtrpc.CallerID.verify(message.effective_caller_id);
                if (error)
                    return "effective_caller_id." + error;
            }
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id")) {
                var error = $root.query.VTGateCallerID.verify(message.immediate_caller_id);
                if (error)
                    return "immediate_caller_id." + error;
            }
            if (message.target != null && message.hasOwnProperty("target")) {
                var error = $root.query.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.query != null && message.hasOwnProperty("query")) {
                var error = $root.query.BoundQuery.verify(message.query);
                if (error)
                    return "query." + error;
            }
            if (message.transaction_id != null && message.hasOwnProperty("transaction_id"))
                if (!$util.isInteger(message.transaction_id) && !(message.transaction_id && $util.isInteger(message.transaction_id.low) && $util.isInteger(message.transaction_id.high)))
                    return "transaction_id: integer|Long expected";
            if (message.options != null && message.hasOwnProperty("options")) {
                var error = $root.query.ExecuteOptions.verify(message.options);
                if (error)
                    return "options." + error;
            }
            if (message.reserved_id != null && message.hasOwnProperty("reserved_id"))
                if (!$util.isInteger(message.reserved_id) && !(message.reserved_id && $util.isInteger(message.reserved_id.low) && $util.isInteger(message.reserved_id.high)))
                    return "reserved_id: integer|Long expected";
            return null;
        };

        /**
         * Creates an ExecuteRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.ExecuteRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.ExecuteRequest} ExecuteRequest
         */
        ExecuteRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.query.ExecuteRequest)
                return object;
            var message = new $root.query.ExecuteRequest();
            if (object.effective_caller_id != null) {
                if (typeof object.effective_caller_id !== "object")
                    throw TypeError(".query.ExecuteRequest.effective_caller_id: object expected");
                message.effective_caller_id = $root.vtrpc.CallerID.fromObject(object.effective_caller_id);
            }
            if (object.immediate_caller_id != null) {
                if (typeof object.immediate_caller_id !== "object")
                    throw TypeError(".query.ExecuteRequest.immediate_caller_id: object expected");
                message.immediate_caller_id = $root.query.VTGateCallerID.fromObject(object.immediate_caller_id);
            }
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".query.ExecuteRequest.target: object expected");
                message.target = $root.query.Target.fromObject(object.target);
            }
            if (object.query != null) {
                if (typeof object.query !== "object")
                    throw TypeError(".query.ExecuteRequest.query: object expected");
                message.query = $root.query.BoundQuery.fromObject(object.query);
            }
            if (object.transaction_id != null)
                if ($util.Long)
                    (message.transaction_id = $util.Long.fromValue(object.transaction_id)).unsigned = false;
                else if (typeof object.transaction_id === "string")
                    message.transaction_id = parseInt(object.transaction_id, 10);
                else if (typeof object.transaction_id === "number")
                    message.transaction_id = object.transaction_id;
                else if (typeof object.transaction_id === "object")
                    message.transaction_id = new $util.LongBits(object.transaction_id.low >>> 0, object.transaction_id.high >>> 0).toNumber();
            if (object.options != null) {
                if (typeof object.options !== "object")
                    throw TypeError(".query.ExecuteRequest.options: object expected");
                message.options = $root.query.ExecuteOptions.fromObject(object.options);
            }
            if (object.reserved_id != null)
                if ($util.Long)
                    (message.reserved_id = $util.Long.fromValue(object.reserved_id)).unsigned = false;
                else if (typeof object.reserved_id === "string")
                    message.reserved_id = parseInt(object.reserved_id, 10);
                else if (typeof object.reserved_id === "number")
                    message.reserved_id = object.reserved_id;
                else if (typeof object.reserved_id === "object")
                    message.reserved_id = new $util.LongBits(object.reserved_id.low >>> 0, object.reserved_id.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an ExecuteRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.ExecuteRequest
         * @static
         * @param {query.ExecuteRequest} message ExecuteRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExecuteRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.effective_caller_id = null;
                object.immediate_caller_id = null;
                object.target = null;
                object.query = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.transaction_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.transaction_id = options.longs === String ? "0" : 0;
                object.options = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.reserved_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.reserved_id = options.longs === String ? "0" : 0;
            }
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id"))
                object.effective_caller_id = $root.vtrpc.CallerID.toObject(message.effective_caller_id, options);
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id"))
                object.immediate_caller_id = $root.query.VTGateCallerID.toObject(message.immediate_caller_id, options);
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.query.Target.toObject(message.target, options);
            if (message.query != null && message.hasOwnProperty("query"))
                object.query = $root.query.BoundQuery.toObject(message.query, options);
            if (message.transaction_id != null && message.hasOwnProperty("transaction_id"))
                if (typeof message.transaction_id === "number")
                    object.transaction_id = options.longs === String ? String(message.transaction_id) : message.transaction_id;
                else
                    object.transaction_id = options.longs === String ? $util.Long.prototype.toString.call(message.transaction_id) : options.longs === Number ? new $util.LongBits(message.transaction_id.low >>> 0, message.transaction_id.high >>> 0).toNumber() : message.transaction_id;
            if (message.options != null && message.hasOwnProperty("options"))
                object.options = $root.query.ExecuteOptions.toObject(message.options, options);
            if (message.reserved_id != null && message.hasOwnProperty("reserved_id"))
                if (typeof message.reserved_id === "number")
                    object.reserved_id = options.longs === String ? String(message.reserved_id) : message.reserved_id;
                else
                    object.reserved_id = options.longs === String ? $util.Long.prototype.toString.call(message.reserved_id) : options.longs === Number ? new $util.LongBits(message.reserved_id.low >>> 0, message.reserved_id.high >>> 0).toNumber() : message.reserved_id;
            return object;
        };

        /**
         * Converts this ExecuteRequest to JSON.
         * @function toJSON
         * @memberof query.ExecuteRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExecuteRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExecuteRequest;
    })();

    query.ExecuteResponse = (function() {

        /**
         * Properties of an ExecuteResponse.
         * @memberof query
         * @interface IExecuteResponse
         * @property {query.IQueryResult|null} [result] ExecuteResponse result
         */

        /**
         * Constructs a new ExecuteResponse.
         * @memberof query
         * @classdesc Represents an ExecuteResponse.
         * @implements IExecuteResponse
         * @constructor
         * @param {query.IExecuteResponse=} [properties] Properties to set
         */
        function ExecuteResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExecuteResponse result.
         * @member {query.IQueryResult|null|undefined} result
         * @memberof query.ExecuteResponse
         * @instance
         */
        ExecuteResponse.prototype.result = null;

        /**
         * Creates a new ExecuteResponse instance using the specified properties.
         * @function create
         * @memberof query.ExecuteResponse
         * @static
         * @param {query.IExecuteResponse=} [properties] Properties to set
         * @returns {query.ExecuteResponse} ExecuteResponse instance
         */
        ExecuteResponse.create = function create(properties) {
            return new ExecuteResponse(properties);
        };

        /**
         * Encodes the specified ExecuteResponse message. Does not implicitly {@link query.ExecuteResponse.verify|verify} messages.
         * @function encode
         * @memberof query.ExecuteResponse
         * @static
         * @param {query.IExecuteResponse} message ExecuteResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecuteResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                $root.query.QueryResult.encode(message.result, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ExecuteResponse message, length delimited. Does not implicitly {@link query.ExecuteResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.ExecuteResponse
         * @static
         * @param {query.IExecuteResponse} message ExecuteResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecuteResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExecuteResponse message from the specified reader or buffer.
         * @function decode
         * @memberof query.ExecuteResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.ExecuteResponse} ExecuteResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecuteResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.ExecuteResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = $root.query.QueryResult.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExecuteResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.ExecuteResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.ExecuteResponse} ExecuteResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecuteResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExecuteResponse message.
         * @function verify
         * @memberof query.ExecuteResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExecuteResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result")) {
                var error = $root.query.QueryResult.verify(message.result);
                if (error)
                    return "result." + error;
            }
            return null;
        };

        /**
         * Creates an ExecuteResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.ExecuteResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.ExecuteResponse} ExecuteResponse
         */
        ExecuteResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.query.ExecuteResponse)
                return object;
            var message = new $root.query.ExecuteResponse();
            if (object.result != null) {
                if (typeof object.result !== "object")
                    throw TypeError(".query.ExecuteResponse.result: object expected");
                message.result = $root.query.QueryResult.fromObject(object.result);
            }
            return message;
        };

        /**
         * Creates a plain object from an ExecuteResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.ExecuteResponse
         * @static
         * @param {query.ExecuteResponse} message ExecuteResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExecuteResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = null;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = $root.query.QueryResult.toObject(message.result, options);
            return object;
        };

        /**
         * Converts this ExecuteResponse to JSON.
         * @function toJSON
         * @memberof query.ExecuteResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExecuteResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExecuteResponse;
    })();

    query.ResultWithError = (function() {

        /**
         * Properties of a ResultWithError.
         * @memberof query
         * @interface IResultWithError
         * @property {vtrpc.IRPCError|null} [error] ResultWithError error
         * @property {query.IQueryResult|null} [result] ResultWithError result
         */

        /**
         * Constructs a new ResultWithError.
         * @memberof query
         * @classdesc Represents a ResultWithError.
         * @implements IResultWithError
         * @constructor
         * @param {query.IResultWithError=} [properties] Properties to set
         */
        function ResultWithError(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResultWithError error.
         * @member {vtrpc.IRPCError|null|undefined} error
         * @memberof query.ResultWithError
         * @instance
         */
        ResultWithError.prototype.error = null;

        /**
         * ResultWithError result.
         * @member {query.IQueryResult|null|undefined} result
         * @memberof query.ResultWithError
         * @instance
         */
        ResultWithError.prototype.result = null;

        /**
         * Creates a new ResultWithError instance using the specified properties.
         * @function create
         * @memberof query.ResultWithError
         * @static
         * @param {query.IResultWithError=} [properties] Properties to set
         * @returns {query.ResultWithError} ResultWithError instance
         */
        ResultWithError.create = function create(properties) {
            return new ResultWithError(properties);
        };

        /**
         * Encodes the specified ResultWithError message. Does not implicitly {@link query.ResultWithError.verify|verify} messages.
         * @function encode
         * @memberof query.ResultWithError
         * @static
         * @param {query.IResultWithError} message ResultWithError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResultWithError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                $root.vtrpc.RPCError.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                $root.query.QueryResult.encode(message.result, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ResultWithError message, length delimited. Does not implicitly {@link query.ResultWithError.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.ResultWithError
         * @static
         * @param {query.IResultWithError} message ResultWithError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResultWithError.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResultWithError message from the specified reader or buffer.
         * @function decode
         * @memberof query.ResultWithError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.ResultWithError} ResultWithError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResultWithError.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.ResultWithError();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.error = $root.vtrpc.RPCError.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.result = $root.query.QueryResult.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResultWithError message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.ResultWithError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.ResultWithError} ResultWithError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResultWithError.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResultWithError message.
         * @function verify
         * @memberof query.ResultWithError
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResultWithError.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.error != null && message.hasOwnProperty("error")) {
                var error = $root.vtrpc.RPCError.verify(message.error);
                if (error)
                    return "error." + error;
            }
            if (message.result != null && message.hasOwnProperty("result")) {
                var error = $root.query.QueryResult.verify(message.result);
                if (error)
                    return "result." + error;
            }
            return null;
        };

        /**
         * Creates a ResultWithError message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.ResultWithError
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.ResultWithError} ResultWithError
         */
        ResultWithError.fromObject = function fromObject(object) {
            if (object instanceof $root.query.ResultWithError)
                return object;
            var message = new $root.query.ResultWithError();
            if (object.error != null) {
                if (typeof object.error !== "object")
                    throw TypeError(".query.ResultWithError.error: object expected");
                message.error = $root.vtrpc.RPCError.fromObject(object.error);
            }
            if (object.result != null) {
                if (typeof object.result !== "object")
                    throw TypeError(".query.ResultWithError.result: object expected");
                message.result = $root.query.QueryResult.fromObject(object.result);
            }
            return message;
        };

        /**
         * Creates a plain object from a ResultWithError message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.ResultWithError
         * @static
         * @param {query.ResultWithError} message ResultWithError
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResultWithError.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.error = null;
                object.result = null;
            }
            if (message.error != null && message.hasOwnProperty("error"))
                object.error = $root.vtrpc.RPCError.toObject(message.error, options);
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = $root.query.QueryResult.toObject(message.result, options);
            return object;
        };

        /**
         * Converts this ResultWithError to JSON.
         * @function toJSON
         * @memberof query.ResultWithError
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResultWithError.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResultWithError;
    })();

    query.ExecuteBatchRequest = (function() {

        /**
         * Properties of an ExecuteBatchRequest.
         * @memberof query
         * @interface IExecuteBatchRequest
         * @property {vtrpc.ICallerID|null} [effective_caller_id] ExecuteBatchRequest effective_caller_id
         * @property {query.IVTGateCallerID|null} [immediate_caller_id] ExecuteBatchRequest immediate_caller_id
         * @property {query.ITarget|null} [target] ExecuteBatchRequest target
         * @property {Array.<query.IBoundQuery>|null} [queries] ExecuteBatchRequest queries
         * @property {boolean|null} [as_transaction] ExecuteBatchRequest as_transaction
         * @property {number|Long|null} [transaction_id] ExecuteBatchRequest transaction_id
         * @property {query.IExecuteOptions|null} [options] ExecuteBatchRequest options
         */

        /**
         * Constructs a new ExecuteBatchRequest.
         * @memberof query
         * @classdesc Represents an ExecuteBatchRequest.
         * @implements IExecuteBatchRequest
         * @constructor
         * @param {query.IExecuteBatchRequest=} [properties] Properties to set
         */
        function ExecuteBatchRequest(properties) {
            this.queries = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExecuteBatchRequest effective_caller_id.
         * @member {vtrpc.ICallerID|null|undefined} effective_caller_id
         * @memberof query.ExecuteBatchRequest
         * @instance
         */
        ExecuteBatchRequest.prototype.effective_caller_id = null;

        /**
         * ExecuteBatchRequest immediate_caller_id.
         * @member {query.IVTGateCallerID|null|undefined} immediate_caller_id
         * @memberof query.ExecuteBatchRequest
         * @instance
         */
        ExecuteBatchRequest.prototype.immediate_caller_id = null;

        /**
         * ExecuteBatchRequest target.
         * @member {query.ITarget|null|undefined} target
         * @memberof query.ExecuteBatchRequest
         * @instance
         */
        ExecuteBatchRequest.prototype.target = null;

        /**
         * ExecuteBatchRequest queries.
         * @member {Array.<query.IBoundQuery>} queries
         * @memberof query.ExecuteBatchRequest
         * @instance
         */
        ExecuteBatchRequest.prototype.queries = $util.emptyArray;

        /**
         * ExecuteBatchRequest as_transaction.
         * @member {boolean} as_transaction
         * @memberof query.ExecuteBatchRequest
         * @instance
         */
        ExecuteBatchRequest.prototype.as_transaction = false;

        /**
         * ExecuteBatchRequest transaction_id.
         * @member {number|Long} transaction_id
         * @memberof query.ExecuteBatchRequest
         * @instance
         */
        ExecuteBatchRequest.prototype.transaction_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ExecuteBatchRequest options.
         * @member {query.IExecuteOptions|null|undefined} options
         * @memberof query.ExecuteBatchRequest
         * @instance
         */
        ExecuteBatchRequest.prototype.options = null;

        /**
         * Creates a new ExecuteBatchRequest instance using the specified properties.
         * @function create
         * @memberof query.ExecuteBatchRequest
         * @static
         * @param {query.IExecuteBatchRequest=} [properties] Properties to set
         * @returns {query.ExecuteBatchRequest} ExecuteBatchRequest instance
         */
        ExecuteBatchRequest.create = function create(properties) {
            return new ExecuteBatchRequest(properties);
        };

        /**
         * Encodes the specified ExecuteBatchRequest message. Does not implicitly {@link query.ExecuteBatchRequest.verify|verify} messages.
         * @function encode
         * @memberof query.ExecuteBatchRequest
         * @static
         * @param {query.IExecuteBatchRequest} message ExecuteBatchRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecuteBatchRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.effective_caller_id != null && Object.hasOwnProperty.call(message, "effective_caller_id"))
                $root.vtrpc.CallerID.encode(message.effective_caller_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.immediate_caller_id != null && Object.hasOwnProperty.call(message, "immediate_caller_id"))
                $root.query.VTGateCallerID.encode(message.immediate_caller_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                $root.query.Target.encode(message.target, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.queries != null && message.queries.length)
                for (var i = 0; i < message.queries.length; ++i)
                    $root.query.BoundQuery.encode(message.queries[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.as_transaction != null && Object.hasOwnProperty.call(message, "as_transaction"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.as_transaction);
            if (message.transaction_id != null && Object.hasOwnProperty.call(message, "transaction_id"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.transaction_id);
            if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                $root.query.ExecuteOptions.encode(message.options, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ExecuteBatchRequest message, length delimited. Does not implicitly {@link query.ExecuteBatchRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.ExecuteBatchRequest
         * @static
         * @param {query.IExecuteBatchRequest} message ExecuteBatchRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecuteBatchRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExecuteBatchRequest message from the specified reader or buffer.
         * @function decode
         * @memberof query.ExecuteBatchRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.ExecuteBatchRequest} ExecuteBatchRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecuteBatchRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.ExecuteBatchRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.effective_caller_id = $root.vtrpc.CallerID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.immediate_caller_id = $root.query.VTGateCallerID.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.target = $root.query.Target.decode(reader, reader.uint32());
                    break;
                case 4:
                    if (!(message.queries && message.queries.length))
                        message.queries = [];
                    message.queries.push($root.query.BoundQuery.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.as_transaction = reader.bool();
                    break;
                case 6:
                    message.transaction_id = reader.int64();
                    break;
                case 7:
                    message.options = $root.query.ExecuteOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExecuteBatchRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.ExecuteBatchRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.ExecuteBatchRequest} ExecuteBatchRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecuteBatchRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExecuteBatchRequest message.
         * @function verify
         * @memberof query.ExecuteBatchRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExecuteBatchRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id")) {
                var error = $root.vtrpc.CallerID.verify(message.effective_caller_id);
                if (error)
                    return "effective_caller_id." + error;
            }
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id")) {
                var error = $root.query.VTGateCallerID.verify(message.immediate_caller_id);
                if (error)
                    return "immediate_caller_id." + error;
            }
            if (message.target != null && message.hasOwnProperty("target")) {
                var error = $root.query.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.queries != null && message.hasOwnProperty("queries")) {
                if (!Array.isArray(message.queries))
                    return "queries: array expected";
                for (var i = 0; i < message.queries.length; ++i) {
                    var error = $root.query.BoundQuery.verify(message.queries[i]);
                    if (error)
                        return "queries." + error;
                }
            }
            if (message.as_transaction != null && message.hasOwnProperty("as_transaction"))
                if (typeof message.as_transaction !== "boolean")
                    return "as_transaction: boolean expected";
            if (message.transaction_id != null && message.hasOwnProperty("transaction_id"))
                if (!$util.isInteger(message.transaction_id) && !(message.transaction_id && $util.isInteger(message.transaction_id.low) && $util.isInteger(message.transaction_id.high)))
                    return "transaction_id: integer|Long expected";
            if (message.options != null && message.hasOwnProperty("options")) {
                var error = $root.query.ExecuteOptions.verify(message.options);
                if (error)
                    return "options." + error;
            }
            return null;
        };

        /**
         * Creates an ExecuteBatchRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.ExecuteBatchRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.ExecuteBatchRequest} ExecuteBatchRequest
         */
        ExecuteBatchRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.query.ExecuteBatchRequest)
                return object;
            var message = new $root.query.ExecuteBatchRequest();
            if (object.effective_caller_id != null) {
                if (typeof object.effective_caller_id !== "object")
                    throw TypeError(".query.ExecuteBatchRequest.effective_caller_id: object expected");
                message.effective_caller_id = $root.vtrpc.CallerID.fromObject(object.effective_caller_id);
            }
            if (object.immediate_caller_id != null) {
                if (typeof object.immediate_caller_id !== "object")
                    throw TypeError(".query.ExecuteBatchRequest.immediate_caller_id: object expected");
                message.immediate_caller_id = $root.query.VTGateCallerID.fromObject(object.immediate_caller_id);
            }
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".query.ExecuteBatchRequest.target: object expected");
                message.target = $root.query.Target.fromObject(object.target);
            }
            if (object.queries) {
                if (!Array.isArray(object.queries))
                    throw TypeError(".query.ExecuteBatchRequest.queries: array expected");
                message.queries = [];
                for (var i = 0; i < object.queries.length; ++i) {
                    if (typeof object.queries[i] !== "object")
                        throw TypeError(".query.ExecuteBatchRequest.queries: object expected");
                    message.queries[i] = $root.query.BoundQuery.fromObject(object.queries[i]);
                }
            }
            if (object.as_transaction != null)
                message.as_transaction = Boolean(object.as_transaction);
            if (object.transaction_id != null)
                if ($util.Long)
                    (message.transaction_id = $util.Long.fromValue(object.transaction_id)).unsigned = false;
                else if (typeof object.transaction_id === "string")
                    message.transaction_id = parseInt(object.transaction_id, 10);
                else if (typeof object.transaction_id === "number")
                    message.transaction_id = object.transaction_id;
                else if (typeof object.transaction_id === "object")
                    message.transaction_id = new $util.LongBits(object.transaction_id.low >>> 0, object.transaction_id.high >>> 0).toNumber();
            if (object.options != null) {
                if (typeof object.options !== "object")
                    throw TypeError(".query.ExecuteBatchRequest.options: object expected");
                message.options = $root.query.ExecuteOptions.fromObject(object.options);
            }
            return message;
        };

        /**
         * Creates a plain object from an ExecuteBatchRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.ExecuteBatchRequest
         * @static
         * @param {query.ExecuteBatchRequest} message ExecuteBatchRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExecuteBatchRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.queries = [];
            if (options.defaults) {
                object.effective_caller_id = null;
                object.immediate_caller_id = null;
                object.target = null;
                object.as_transaction = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.transaction_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.transaction_id = options.longs === String ? "0" : 0;
                object.options = null;
            }
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id"))
                object.effective_caller_id = $root.vtrpc.CallerID.toObject(message.effective_caller_id, options);
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id"))
                object.immediate_caller_id = $root.query.VTGateCallerID.toObject(message.immediate_caller_id, options);
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.query.Target.toObject(message.target, options);
            if (message.queries && message.queries.length) {
                object.queries = [];
                for (var j = 0; j < message.queries.length; ++j)
                    object.queries[j] = $root.query.BoundQuery.toObject(message.queries[j], options);
            }
            if (message.as_transaction != null && message.hasOwnProperty("as_transaction"))
                object.as_transaction = message.as_transaction;
            if (message.transaction_id != null && message.hasOwnProperty("transaction_id"))
                if (typeof message.transaction_id === "number")
                    object.transaction_id = options.longs === String ? String(message.transaction_id) : message.transaction_id;
                else
                    object.transaction_id = options.longs === String ? $util.Long.prototype.toString.call(message.transaction_id) : options.longs === Number ? new $util.LongBits(message.transaction_id.low >>> 0, message.transaction_id.high >>> 0).toNumber() : message.transaction_id;
            if (message.options != null && message.hasOwnProperty("options"))
                object.options = $root.query.ExecuteOptions.toObject(message.options, options);
            return object;
        };

        /**
         * Converts this ExecuteBatchRequest to JSON.
         * @function toJSON
         * @memberof query.ExecuteBatchRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExecuteBatchRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExecuteBatchRequest;
    })();

    query.ExecuteBatchResponse = (function() {

        /**
         * Properties of an ExecuteBatchResponse.
         * @memberof query
         * @interface IExecuteBatchResponse
         * @property {Array.<query.IQueryResult>|null} [results] ExecuteBatchResponse results
         */

        /**
         * Constructs a new ExecuteBatchResponse.
         * @memberof query
         * @classdesc Represents an ExecuteBatchResponse.
         * @implements IExecuteBatchResponse
         * @constructor
         * @param {query.IExecuteBatchResponse=} [properties] Properties to set
         */
        function ExecuteBatchResponse(properties) {
            this.results = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExecuteBatchResponse results.
         * @member {Array.<query.IQueryResult>} results
         * @memberof query.ExecuteBatchResponse
         * @instance
         */
        ExecuteBatchResponse.prototype.results = $util.emptyArray;

        /**
         * Creates a new ExecuteBatchResponse instance using the specified properties.
         * @function create
         * @memberof query.ExecuteBatchResponse
         * @static
         * @param {query.IExecuteBatchResponse=} [properties] Properties to set
         * @returns {query.ExecuteBatchResponse} ExecuteBatchResponse instance
         */
        ExecuteBatchResponse.create = function create(properties) {
            return new ExecuteBatchResponse(properties);
        };

        /**
         * Encodes the specified ExecuteBatchResponse message. Does not implicitly {@link query.ExecuteBatchResponse.verify|verify} messages.
         * @function encode
         * @memberof query.ExecuteBatchResponse
         * @static
         * @param {query.IExecuteBatchResponse} message ExecuteBatchResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecuteBatchResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.results != null && message.results.length)
                for (var i = 0; i < message.results.length; ++i)
                    $root.query.QueryResult.encode(message.results[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ExecuteBatchResponse message, length delimited. Does not implicitly {@link query.ExecuteBatchResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.ExecuteBatchResponse
         * @static
         * @param {query.IExecuteBatchResponse} message ExecuteBatchResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecuteBatchResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExecuteBatchResponse message from the specified reader or buffer.
         * @function decode
         * @memberof query.ExecuteBatchResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.ExecuteBatchResponse} ExecuteBatchResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecuteBatchResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.ExecuteBatchResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.results && message.results.length))
                        message.results = [];
                    message.results.push($root.query.QueryResult.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExecuteBatchResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.ExecuteBatchResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.ExecuteBatchResponse} ExecuteBatchResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecuteBatchResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExecuteBatchResponse message.
         * @function verify
         * @memberof query.ExecuteBatchResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExecuteBatchResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.results != null && message.hasOwnProperty("results")) {
                if (!Array.isArray(message.results))
                    return "results: array expected";
                for (var i = 0; i < message.results.length; ++i) {
                    var error = $root.query.QueryResult.verify(message.results[i]);
                    if (error)
                        return "results." + error;
                }
            }
            return null;
        };

        /**
         * Creates an ExecuteBatchResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.ExecuteBatchResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.ExecuteBatchResponse} ExecuteBatchResponse
         */
        ExecuteBatchResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.query.ExecuteBatchResponse)
                return object;
            var message = new $root.query.ExecuteBatchResponse();
            if (object.results) {
                if (!Array.isArray(object.results))
                    throw TypeError(".query.ExecuteBatchResponse.results: array expected");
                message.results = [];
                for (var i = 0; i < object.results.length; ++i) {
                    if (typeof object.results[i] !== "object")
                        throw TypeError(".query.ExecuteBatchResponse.results: object expected");
                    message.results[i] = $root.query.QueryResult.fromObject(object.results[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an ExecuteBatchResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.ExecuteBatchResponse
         * @static
         * @param {query.ExecuteBatchResponse} message ExecuteBatchResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExecuteBatchResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.results = [];
            if (message.results && message.results.length) {
                object.results = [];
                for (var j = 0; j < message.results.length; ++j)
                    object.results[j] = $root.query.QueryResult.toObject(message.results[j], options);
            }
            return object;
        };

        /**
         * Converts this ExecuteBatchResponse to JSON.
         * @function toJSON
         * @memberof query.ExecuteBatchResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExecuteBatchResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExecuteBatchResponse;
    })();

    query.StreamExecuteRequest = (function() {

        /**
         * Properties of a StreamExecuteRequest.
         * @memberof query
         * @interface IStreamExecuteRequest
         * @property {vtrpc.ICallerID|null} [effective_caller_id] StreamExecuteRequest effective_caller_id
         * @property {query.IVTGateCallerID|null} [immediate_caller_id] StreamExecuteRequest immediate_caller_id
         * @property {query.ITarget|null} [target] StreamExecuteRequest target
         * @property {query.IBoundQuery|null} [query] StreamExecuteRequest query
         * @property {query.IExecuteOptions|null} [options] StreamExecuteRequest options
         * @property {number|Long|null} [transaction_id] StreamExecuteRequest transaction_id
         */

        /**
         * Constructs a new StreamExecuteRequest.
         * @memberof query
         * @classdesc Represents a StreamExecuteRequest.
         * @implements IStreamExecuteRequest
         * @constructor
         * @param {query.IStreamExecuteRequest=} [properties] Properties to set
         */
        function StreamExecuteRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StreamExecuteRequest effective_caller_id.
         * @member {vtrpc.ICallerID|null|undefined} effective_caller_id
         * @memberof query.StreamExecuteRequest
         * @instance
         */
        StreamExecuteRequest.prototype.effective_caller_id = null;

        /**
         * StreamExecuteRequest immediate_caller_id.
         * @member {query.IVTGateCallerID|null|undefined} immediate_caller_id
         * @memberof query.StreamExecuteRequest
         * @instance
         */
        StreamExecuteRequest.prototype.immediate_caller_id = null;

        /**
         * StreamExecuteRequest target.
         * @member {query.ITarget|null|undefined} target
         * @memberof query.StreamExecuteRequest
         * @instance
         */
        StreamExecuteRequest.prototype.target = null;

        /**
         * StreamExecuteRequest query.
         * @member {query.IBoundQuery|null|undefined} query
         * @memberof query.StreamExecuteRequest
         * @instance
         */
        StreamExecuteRequest.prototype.query = null;

        /**
         * StreamExecuteRequest options.
         * @member {query.IExecuteOptions|null|undefined} options
         * @memberof query.StreamExecuteRequest
         * @instance
         */
        StreamExecuteRequest.prototype.options = null;

        /**
         * StreamExecuteRequest transaction_id.
         * @member {number|Long} transaction_id
         * @memberof query.StreamExecuteRequest
         * @instance
         */
        StreamExecuteRequest.prototype.transaction_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new StreamExecuteRequest instance using the specified properties.
         * @function create
         * @memberof query.StreamExecuteRequest
         * @static
         * @param {query.IStreamExecuteRequest=} [properties] Properties to set
         * @returns {query.StreamExecuteRequest} StreamExecuteRequest instance
         */
        StreamExecuteRequest.create = function create(properties) {
            return new StreamExecuteRequest(properties);
        };

        /**
         * Encodes the specified StreamExecuteRequest message. Does not implicitly {@link query.StreamExecuteRequest.verify|verify} messages.
         * @function encode
         * @memberof query.StreamExecuteRequest
         * @static
         * @param {query.IStreamExecuteRequest} message StreamExecuteRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamExecuteRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.effective_caller_id != null && Object.hasOwnProperty.call(message, "effective_caller_id"))
                $root.vtrpc.CallerID.encode(message.effective_caller_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.immediate_caller_id != null && Object.hasOwnProperty.call(message, "immediate_caller_id"))
                $root.query.VTGateCallerID.encode(message.immediate_caller_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                $root.query.Target.encode(message.target, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                $root.query.BoundQuery.encode(message.query, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                $root.query.ExecuteOptions.encode(message.options, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.transaction_id != null && Object.hasOwnProperty.call(message, "transaction_id"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.transaction_id);
            return writer;
        };

        /**
         * Encodes the specified StreamExecuteRequest message, length delimited. Does not implicitly {@link query.StreamExecuteRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.StreamExecuteRequest
         * @static
         * @param {query.IStreamExecuteRequest} message StreamExecuteRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamExecuteRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StreamExecuteRequest message from the specified reader or buffer.
         * @function decode
         * @memberof query.StreamExecuteRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.StreamExecuteRequest} StreamExecuteRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamExecuteRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.StreamExecuteRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.effective_caller_id = $root.vtrpc.CallerID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.immediate_caller_id = $root.query.VTGateCallerID.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.target = $root.query.Target.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.query = $root.query.BoundQuery.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.options = $root.query.ExecuteOptions.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.transaction_id = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StreamExecuteRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.StreamExecuteRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.StreamExecuteRequest} StreamExecuteRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamExecuteRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StreamExecuteRequest message.
         * @function verify
         * @memberof query.StreamExecuteRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StreamExecuteRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id")) {
                var error = $root.vtrpc.CallerID.verify(message.effective_caller_id);
                if (error)
                    return "effective_caller_id." + error;
            }
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id")) {
                var error = $root.query.VTGateCallerID.verify(message.immediate_caller_id);
                if (error)
                    return "immediate_caller_id." + error;
            }
            if (message.target != null && message.hasOwnProperty("target")) {
                var error = $root.query.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.query != null && message.hasOwnProperty("query")) {
                var error = $root.query.BoundQuery.verify(message.query);
                if (error)
                    return "query." + error;
            }
            if (message.options != null && message.hasOwnProperty("options")) {
                var error = $root.query.ExecuteOptions.verify(message.options);
                if (error)
                    return "options." + error;
            }
            if (message.transaction_id != null && message.hasOwnProperty("transaction_id"))
                if (!$util.isInteger(message.transaction_id) && !(message.transaction_id && $util.isInteger(message.transaction_id.low) && $util.isInteger(message.transaction_id.high)))
                    return "transaction_id: integer|Long expected";
            return null;
        };

        /**
         * Creates a StreamExecuteRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.StreamExecuteRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.StreamExecuteRequest} StreamExecuteRequest
         */
        StreamExecuteRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.query.StreamExecuteRequest)
                return object;
            var message = new $root.query.StreamExecuteRequest();
            if (object.effective_caller_id != null) {
                if (typeof object.effective_caller_id !== "object")
                    throw TypeError(".query.StreamExecuteRequest.effective_caller_id: object expected");
                message.effective_caller_id = $root.vtrpc.CallerID.fromObject(object.effective_caller_id);
            }
            if (object.immediate_caller_id != null) {
                if (typeof object.immediate_caller_id !== "object")
                    throw TypeError(".query.StreamExecuteRequest.immediate_caller_id: object expected");
                message.immediate_caller_id = $root.query.VTGateCallerID.fromObject(object.immediate_caller_id);
            }
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".query.StreamExecuteRequest.target: object expected");
                message.target = $root.query.Target.fromObject(object.target);
            }
            if (object.query != null) {
                if (typeof object.query !== "object")
                    throw TypeError(".query.StreamExecuteRequest.query: object expected");
                message.query = $root.query.BoundQuery.fromObject(object.query);
            }
            if (object.options != null) {
                if (typeof object.options !== "object")
                    throw TypeError(".query.StreamExecuteRequest.options: object expected");
                message.options = $root.query.ExecuteOptions.fromObject(object.options);
            }
            if (object.transaction_id != null)
                if ($util.Long)
                    (message.transaction_id = $util.Long.fromValue(object.transaction_id)).unsigned = false;
                else if (typeof object.transaction_id === "string")
                    message.transaction_id = parseInt(object.transaction_id, 10);
                else if (typeof object.transaction_id === "number")
                    message.transaction_id = object.transaction_id;
                else if (typeof object.transaction_id === "object")
                    message.transaction_id = new $util.LongBits(object.transaction_id.low >>> 0, object.transaction_id.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a StreamExecuteRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.StreamExecuteRequest
         * @static
         * @param {query.StreamExecuteRequest} message StreamExecuteRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StreamExecuteRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.effective_caller_id = null;
                object.immediate_caller_id = null;
                object.target = null;
                object.query = null;
                object.options = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.transaction_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.transaction_id = options.longs === String ? "0" : 0;
            }
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id"))
                object.effective_caller_id = $root.vtrpc.CallerID.toObject(message.effective_caller_id, options);
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id"))
                object.immediate_caller_id = $root.query.VTGateCallerID.toObject(message.immediate_caller_id, options);
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.query.Target.toObject(message.target, options);
            if (message.query != null && message.hasOwnProperty("query"))
                object.query = $root.query.BoundQuery.toObject(message.query, options);
            if (message.options != null && message.hasOwnProperty("options"))
                object.options = $root.query.ExecuteOptions.toObject(message.options, options);
            if (message.transaction_id != null && message.hasOwnProperty("transaction_id"))
                if (typeof message.transaction_id === "number")
                    object.transaction_id = options.longs === String ? String(message.transaction_id) : message.transaction_id;
                else
                    object.transaction_id = options.longs === String ? $util.Long.prototype.toString.call(message.transaction_id) : options.longs === Number ? new $util.LongBits(message.transaction_id.low >>> 0, message.transaction_id.high >>> 0).toNumber() : message.transaction_id;
            return object;
        };

        /**
         * Converts this StreamExecuteRequest to JSON.
         * @function toJSON
         * @memberof query.StreamExecuteRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StreamExecuteRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StreamExecuteRequest;
    })();

    query.StreamExecuteResponse = (function() {

        /**
         * Properties of a StreamExecuteResponse.
         * @memberof query
         * @interface IStreamExecuteResponse
         * @property {query.IQueryResult|null} [result] StreamExecuteResponse result
         */

        /**
         * Constructs a new StreamExecuteResponse.
         * @memberof query
         * @classdesc Represents a StreamExecuteResponse.
         * @implements IStreamExecuteResponse
         * @constructor
         * @param {query.IStreamExecuteResponse=} [properties] Properties to set
         */
        function StreamExecuteResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StreamExecuteResponse result.
         * @member {query.IQueryResult|null|undefined} result
         * @memberof query.StreamExecuteResponse
         * @instance
         */
        StreamExecuteResponse.prototype.result = null;

        /**
         * Creates a new StreamExecuteResponse instance using the specified properties.
         * @function create
         * @memberof query.StreamExecuteResponse
         * @static
         * @param {query.IStreamExecuteResponse=} [properties] Properties to set
         * @returns {query.StreamExecuteResponse} StreamExecuteResponse instance
         */
        StreamExecuteResponse.create = function create(properties) {
            return new StreamExecuteResponse(properties);
        };

        /**
         * Encodes the specified StreamExecuteResponse message. Does not implicitly {@link query.StreamExecuteResponse.verify|verify} messages.
         * @function encode
         * @memberof query.StreamExecuteResponse
         * @static
         * @param {query.IStreamExecuteResponse} message StreamExecuteResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamExecuteResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                $root.query.QueryResult.encode(message.result, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified StreamExecuteResponse message, length delimited. Does not implicitly {@link query.StreamExecuteResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.StreamExecuteResponse
         * @static
         * @param {query.IStreamExecuteResponse} message StreamExecuteResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamExecuteResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StreamExecuteResponse message from the specified reader or buffer.
         * @function decode
         * @memberof query.StreamExecuteResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.StreamExecuteResponse} StreamExecuteResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamExecuteResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.StreamExecuteResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = $root.query.QueryResult.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StreamExecuteResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.StreamExecuteResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.StreamExecuteResponse} StreamExecuteResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamExecuteResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StreamExecuteResponse message.
         * @function verify
         * @memberof query.StreamExecuteResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StreamExecuteResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result")) {
                var error = $root.query.QueryResult.verify(message.result);
                if (error)
                    return "result." + error;
            }
            return null;
        };

        /**
         * Creates a StreamExecuteResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.StreamExecuteResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.StreamExecuteResponse} StreamExecuteResponse
         */
        StreamExecuteResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.query.StreamExecuteResponse)
                return object;
            var message = new $root.query.StreamExecuteResponse();
            if (object.result != null) {
                if (typeof object.result !== "object")
                    throw TypeError(".query.StreamExecuteResponse.result: object expected");
                message.result = $root.query.QueryResult.fromObject(object.result);
            }
            return message;
        };

        /**
         * Creates a plain object from a StreamExecuteResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.StreamExecuteResponse
         * @static
         * @param {query.StreamExecuteResponse} message StreamExecuteResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StreamExecuteResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = null;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = $root.query.QueryResult.toObject(message.result, options);
            return object;
        };

        /**
         * Converts this StreamExecuteResponse to JSON.
         * @function toJSON
         * @memberof query.StreamExecuteResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StreamExecuteResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StreamExecuteResponse;
    })();

    query.BeginRequest = (function() {

        /**
         * Properties of a BeginRequest.
         * @memberof query
         * @interface IBeginRequest
         * @property {vtrpc.ICallerID|null} [effective_caller_id] BeginRequest effective_caller_id
         * @property {query.IVTGateCallerID|null} [immediate_caller_id] BeginRequest immediate_caller_id
         * @property {query.ITarget|null} [target] BeginRequest target
         * @property {query.IExecuteOptions|null} [options] BeginRequest options
         */

        /**
         * Constructs a new BeginRequest.
         * @memberof query
         * @classdesc Represents a BeginRequest.
         * @implements IBeginRequest
         * @constructor
         * @param {query.IBeginRequest=} [properties] Properties to set
         */
        function BeginRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BeginRequest effective_caller_id.
         * @member {vtrpc.ICallerID|null|undefined} effective_caller_id
         * @memberof query.BeginRequest
         * @instance
         */
        BeginRequest.prototype.effective_caller_id = null;

        /**
         * BeginRequest immediate_caller_id.
         * @member {query.IVTGateCallerID|null|undefined} immediate_caller_id
         * @memberof query.BeginRequest
         * @instance
         */
        BeginRequest.prototype.immediate_caller_id = null;

        /**
         * BeginRequest target.
         * @member {query.ITarget|null|undefined} target
         * @memberof query.BeginRequest
         * @instance
         */
        BeginRequest.prototype.target = null;

        /**
         * BeginRequest options.
         * @member {query.IExecuteOptions|null|undefined} options
         * @memberof query.BeginRequest
         * @instance
         */
        BeginRequest.prototype.options = null;

        /**
         * Creates a new BeginRequest instance using the specified properties.
         * @function create
         * @memberof query.BeginRequest
         * @static
         * @param {query.IBeginRequest=} [properties] Properties to set
         * @returns {query.BeginRequest} BeginRequest instance
         */
        BeginRequest.create = function create(properties) {
            return new BeginRequest(properties);
        };

        /**
         * Encodes the specified BeginRequest message. Does not implicitly {@link query.BeginRequest.verify|verify} messages.
         * @function encode
         * @memberof query.BeginRequest
         * @static
         * @param {query.IBeginRequest} message BeginRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BeginRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.effective_caller_id != null && Object.hasOwnProperty.call(message, "effective_caller_id"))
                $root.vtrpc.CallerID.encode(message.effective_caller_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.immediate_caller_id != null && Object.hasOwnProperty.call(message, "immediate_caller_id"))
                $root.query.VTGateCallerID.encode(message.immediate_caller_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                $root.query.Target.encode(message.target, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                $root.query.ExecuteOptions.encode(message.options, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BeginRequest message, length delimited. Does not implicitly {@link query.BeginRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.BeginRequest
         * @static
         * @param {query.IBeginRequest} message BeginRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BeginRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BeginRequest message from the specified reader or buffer.
         * @function decode
         * @memberof query.BeginRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.BeginRequest} BeginRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BeginRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.BeginRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.effective_caller_id = $root.vtrpc.CallerID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.immediate_caller_id = $root.query.VTGateCallerID.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.target = $root.query.Target.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.options = $root.query.ExecuteOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BeginRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.BeginRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.BeginRequest} BeginRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BeginRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BeginRequest message.
         * @function verify
         * @memberof query.BeginRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BeginRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id")) {
                var error = $root.vtrpc.CallerID.verify(message.effective_caller_id);
                if (error)
                    return "effective_caller_id." + error;
            }
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id")) {
                var error = $root.query.VTGateCallerID.verify(message.immediate_caller_id);
                if (error)
                    return "immediate_caller_id." + error;
            }
            if (message.target != null && message.hasOwnProperty("target")) {
                var error = $root.query.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.options != null && message.hasOwnProperty("options")) {
                var error = $root.query.ExecuteOptions.verify(message.options);
                if (error)
                    return "options." + error;
            }
            return null;
        };

        /**
         * Creates a BeginRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.BeginRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.BeginRequest} BeginRequest
         */
        BeginRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.query.BeginRequest)
                return object;
            var message = new $root.query.BeginRequest();
            if (object.effective_caller_id != null) {
                if (typeof object.effective_caller_id !== "object")
                    throw TypeError(".query.BeginRequest.effective_caller_id: object expected");
                message.effective_caller_id = $root.vtrpc.CallerID.fromObject(object.effective_caller_id);
            }
            if (object.immediate_caller_id != null) {
                if (typeof object.immediate_caller_id !== "object")
                    throw TypeError(".query.BeginRequest.immediate_caller_id: object expected");
                message.immediate_caller_id = $root.query.VTGateCallerID.fromObject(object.immediate_caller_id);
            }
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".query.BeginRequest.target: object expected");
                message.target = $root.query.Target.fromObject(object.target);
            }
            if (object.options != null) {
                if (typeof object.options !== "object")
                    throw TypeError(".query.BeginRequest.options: object expected");
                message.options = $root.query.ExecuteOptions.fromObject(object.options);
            }
            return message;
        };

        /**
         * Creates a plain object from a BeginRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.BeginRequest
         * @static
         * @param {query.BeginRequest} message BeginRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BeginRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.effective_caller_id = null;
                object.immediate_caller_id = null;
                object.target = null;
                object.options = null;
            }
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id"))
                object.effective_caller_id = $root.vtrpc.CallerID.toObject(message.effective_caller_id, options);
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id"))
                object.immediate_caller_id = $root.query.VTGateCallerID.toObject(message.immediate_caller_id, options);
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.query.Target.toObject(message.target, options);
            if (message.options != null && message.hasOwnProperty("options"))
                object.options = $root.query.ExecuteOptions.toObject(message.options, options);
            return object;
        };

        /**
         * Converts this BeginRequest to JSON.
         * @function toJSON
         * @memberof query.BeginRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BeginRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BeginRequest;
    })();

    query.BeginResponse = (function() {

        /**
         * Properties of a BeginResponse.
         * @memberof query
         * @interface IBeginResponse
         * @property {number|Long|null} [transaction_id] BeginResponse transaction_id
         * @property {topodata.ITabletAlias|null} [tablet_alias] BeginResponse tablet_alias
         */

        /**
         * Constructs a new BeginResponse.
         * @memberof query
         * @classdesc Represents a BeginResponse.
         * @implements IBeginResponse
         * @constructor
         * @param {query.IBeginResponse=} [properties] Properties to set
         */
        function BeginResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BeginResponse transaction_id.
         * @member {number|Long} transaction_id
         * @memberof query.BeginResponse
         * @instance
         */
        BeginResponse.prototype.transaction_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BeginResponse tablet_alias.
         * @member {topodata.ITabletAlias|null|undefined} tablet_alias
         * @memberof query.BeginResponse
         * @instance
         */
        BeginResponse.prototype.tablet_alias = null;

        /**
         * Creates a new BeginResponse instance using the specified properties.
         * @function create
         * @memberof query.BeginResponse
         * @static
         * @param {query.IBeginResponse=} [properties] Properties to set
         * @returns {query.BeginResponse} BeginResponse instance
         */
        BeginResponse.create = function create(properties) {
            return new BeginResponse(properties);
        };

        /**
         * Encodes the specified BeginResponse message. Does not implicitly {@link query.BeginResponse.verify|verify} messages.
         * @function encode
         * @memberof query.BeginResponse
         * @static
         * @param {query.IBeginResponse} message BeginResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BeginResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.transaction_id != null && Object.hasOwnProperty.call(message, "transaction_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.transaction_id);
            if (message.tablet_alias != null && Object.hasOwnProperty.call(message, "tablet_alias"))
                $root.topodata.TabletAlias.encode(message.tablet_alias, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BeginResponse message, length delimited. Does not implicitly {@link query.BeginResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.BeginResponse
         * @static
         * @param {query.IBeginResponse} message BeginResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BeginResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BeginResponse message from the specified reader or buffer.
         * @function decode
         * @memberof query.BeginResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.BeginResponse} BeginResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BeginResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.BeginResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.transaction_id = reader.int64();
                    break;
                case 2:
                    message.tablet_alias = $root.topodata.TabletAlias.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BeginResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.BeginResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.BeginResponse} BeginResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BeginResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BeginResponse message.
         * @function verify
         * @memberof query.BeginResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BeginResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.transaction_id != null && message.hasOwnProperty("transaction_id"))
                if (!$util.isInteger(message.transaction_id) && !(message.transaction_id && $util.isInteger(message.transaction_id.low) && $util.isInteger(message.transaction_id.high)))
                    return "transaction_id: integer|Long expected";
            if (message.tablet_alias != null && message.hasOwnProperty("tablet_alias")) {
                var error = $root.topodata.TabletAlias.verify(message.tablet_alias);
                if (error)
                    return "tablet_alias." + error;
            }
            return null;
        };

        /**
         * Creates a BeginResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.BeginResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.BeginResponse} BeginResponse
         */
        BeginResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.query.BeginResponse)
                return object;
            var message = new $root.query.BeginResponse();
            if (object.transaction_id != null)
                if ($util.Long)
                    (message.transaction_id = $util.Long.fromValue(object.transaction_id)).unsigned = false;
                else if (typeof object.transaction_id === "string")
                    message.transaction_id = parseInt(object.transaction_id, 10);
                else if (typeof object.transaction_id === "number")
                    message.transaction_id = object.transaction_id;
                else if (typeof object.transaction_id === "object")
                    message.transaction_id = new $util.LongBits(object.transaction_id.low >>> 0, object.transaction_id.high >>> 0).toNumber();
            if (object.tablet_alias != null) {
                if (typeof object.tablet_alias !== "object")
                    throw TypeError(".query.BeginResponse.tablet_alias: object expected");
                message.tablet_alias = $root.topodata.TabletAlias.fromObject(object.tablet_alias);
            }
            return message;
        };

        /**
         * Creates a plain object from a BeginResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.BeginResponse
         * @static
         * @param {query.BeginResponse} message BeginResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BeginResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.transaction_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.transaction_id = options.longs === String ? "0" : 0;
                object.tablet_alias = null;
            }
            if (message.transaction_id != null && message.hasOwnProperty("transaction_id"))
                if (typeof message.transaction_id === "number")
                    object.transaction_id = options.longs === String ? String(message.transaction_id) : message.transaction_id;
                else
                    object.transaction_id = options.longs === String ? $util.Long.prototype.toString.call(message.transaction_id) : options.longs === Number ? new $util.LongBits(message.transaction_id.low >>> 0, message.transaction_id.high >>> 0).toNumber() : message.transaction_id;
            if (message.tablet_alias != null && message.hasOwnProperty("tablet_alias"))
                object.tablet_alias = $root.topodata.TabletAlias.toObject(message.tablet_alias, options);
            return object;
        };

        /**
         * Converts this BeginResponse to JSON.
         * @function toJSON
         * @memberof query.BeginResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BeginResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BeginResponse;
    })();

    query.CommitRequest = (function() {

        /**
         * Properties of a CommitRequest.
         * @memberof query
         * @interface ICommitRequest
         * @property {vtrpc.ICallerID|null} [effective_caller_id] CommitRequest effective_caller_id
         * @property {query.IVTGateCallerID|null} [immediate_caller_id] CommitRequest immediate_caller_id
         * @property {query.ITarget|null} [target] CommitRequest target
         * @property {number|Long|null} [transaction_id] CommitRequest transaction_id
         */

        /**
         * Constructs a new CommitRequest.
         * @memberof query
         * @classdesc Represents a CommitRequest.
         * @implements ICommitRequest
         * @constructor
         * @param {query.ICommitRequest=} [properties] Properties to set
         */
        function CommitRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CommitRequest effective_caller_id.
         * @member {vtrpc.ICallerID|null|undefined} effective_caller_id
         * @memberof query.CommitRequest
         * @instance
         */
        CommitRequest.prototype.effective_caller_id = null;

        /**
         * CommitRequest immediate_caller_id.
         * @member {query.IVTGateCallerID|null|undefined} immediate_caller_id
         * @memberof query.CommitRequest
         * @instance
         */
        CommitRequest.prototype.immediate_caller_id = null;

        /**
         * CommitRequest target.
         * @member {query.ITarget|null|undefined} target
         * @memberof query.CommitRequest
         * @instance
         */
        CommitRequest.prototype.target = null;

        /**
         * CommitRequest transaction_id.
         * @member {number|Long} transaction_id
         * @memberof query.CommitRequest
         * @instance
         */
        CommitRequest.prototype.transaction_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new CommitRequest instance using the specified properties.
         * @function create
         * @memberof query.CommitRequest
         * @static
         * @param {query.ICommitRequest=} [properties] Properties to set
         * @returns {query.CommitRequest} CommitRequest instance
         */
        CommitRequest.create = function create(properties) {
            return new CommitRequest(properties);
        };

        /**
         * Encodes the specified CommitRequest message. Does not implicitly {@link query.CommitRequest.verify|verify} messages.
         * @function encode
         * @memberof query.CommitRequest
         * @static
         * @param {query.ICommitRequest} message CommitRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommitRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.effective_caller_id != null && Object.hasOwnProperty.call(message, "effective_caller_id"))
                $root.vtrpc.CallerID.encode(message.effective_caller_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.immediate_caller_id != null && Object.hasOwnProperty.call(message, "immediate_caller_id"))
                $root.query.VTGateCallerID.encode(message.immediate_caller_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                $root.query.Target.encode(message.target, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.transaction_id != null && Object.hasOwnProperty.call(message, "transaction_id"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.transaction_id);
            return writer;
        };

        /**
         * Encodes the specified CommitRequest message, length delimited. Does not implicitly {@link query.CommitRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.CommitRequest
         * @static
         * @param {query.ICommitRequest} message CommitRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommitRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CommitRequest message from the specified reader or buffer.
         * @function decode
         * @memberof query.CommitRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.CommitRequest} CommitRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommitRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.CommitRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.effective_caller_id = $root.vtrpc.CallerID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.immediate_caller_id = $root.query.VTGateCallerID.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.target = $root.query.Target.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.transaction_id = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CommitRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.CommitRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.CommitRequest} CommitRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommitRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CommitRequest message.
         * @function verify
         * @memberof query.CommitRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CommitRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id")) {
                var error = $root.vtrpc.CallerID.verify(message.effective_caller_id);
                if (error)
                    return "effective_caller_id." + error;
            }
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id")) {
                var error = $root.query.VTGateCallerID.verify(message.immediate_caller_id);
                if (error)
                    return "immediate_caller_id." + error;
            }
            if (message.target != null && message.hasOwnProperty("target")) {
                var error = $root.query.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.transaction_id != null && message.hasOwnProperty("transaction_id"))
                if (!$util.isInteger(message.transaction_id) && !(message.transaction_id && $util.isInteger(message.transaction_id.low) && $util.isInteger(message.transaction_id.high)))
                    return "transaction_id: integer|Long expected";
            return null;
        };

        /**
         * Creates a CommitRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.CommitRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.CommitRequest} CommitRequest
         */
        CommitRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.query.CommitRequest)
                return object;
            var message = new $root.query.CommitRequest();
            if (object.effective_caller_id != null) {
                if (typeof object.effective_caller_id !== "object")
                    throw TypeError(".query.CommitRequest.effective_caller_id: object expected");
                message.effective_caller_id = $root.vtrpc.CallerID.fromObject(object.effective_caller_id);
            }
            if (object.immediate_caller_id != null) {
                if (typeof object.immediate_caller_id !== "object")
                    throw TypeError(".query.CommitRequest.immediate_caller_id: object expected");
                message.immediate_caller_id = $root.query.VTGateCallerID.fromObject(object.immediate_caller_id);
            }
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".query.CommitRequest.target: object expected");
                message.target = $root.query.Target.fromObject(object.target);
            }
            if (object.transaction_id != null)
                if ($util.Long)
                    (message.transaction_id = $util.Long.fromValue(object.transaction_id)).unsigned = false;
                else if (typeof object.transaction_id === "string")
                    message.transaction_id = parseInt(object.transaction_id, 10);
                else if (typeof object.transaction_id === "number")
                    message.transaction_id = object.transaction_id;
                else if (typeof object.transaction_id === "object")
                    message.transaction_id = new $util.LongBits(object.transaction_id.low >>> 0, object.transaction_id.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a CommitRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.CommitRequest
         * @static
         * @param {query.CommitRequest} message CommitRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CommitRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.effective_caller_id = null;
                object.immediate_caller_id = null;
                object.target = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.transaction_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.transaction_id = options.longs === String ? "0" : 0;
            }
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id"))
                object.effective_caller_id = $root.vtrpc.CallerID.toObject(message.effective_caller_id, options);
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id"))
                object.immediate_caller_id = $root.query.VTGateCallerID.toObject(message.immediate_caller_id, options);
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.query.Target.toObject(message.target, options);
            if (message.transaction_id != null && message.hasOwnProperty("transaction_id"))
                if (typeof message.transaction_id === "number")
                    object.transaction_id = options.longs === String ? String(message.transaction_id) : message.transaction_id;
                else
                    object.transaction_id = options.longs === String ? $util.Long.prototype.toString.call(message.transaction_id) : options.longs === Number ? new $util.LongBits(message.transaction_id.low >>> 0, message.transaction_id.high >>> 0).toNumber() : message.transaction_id;
            return object;
        };

        /**
         * Converts this CommitRequest to JSON.
         * @function toJSON
         * @memberof query.CommitRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CommitRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CommitRequest;
    })();

    query.CommitResponse = (function() {

        /**
         * Properties of a CommitResponse.
         * @memberof query
         * @interface ICommitResponse
         * @property {number|Long|null} [reserved_id] CommitResponse reserved_id
         */

        /**
         * Constructs a new CommitResponse.
         * @memberof query
         * @classdesc Represents a CommitResponse.
         * @implements ICommitResponse
         * @constructor
         * @param {query.ICommitResponse=} [properties] Properties to set
         */
        function CommitResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CommitResponse reserved_id.
         * @member {number|Long} reserved_id
         * @memberof query.CommitResponse
         * @instance
         */
        CommitResponse.prototype.reserved_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new CommitResponse instance using the specified properties.
         * @function create
         * @memberof query.CommitResponse
         * @static
         * @param {query.ICommitResponse=} [properties] Properties to set
         * @returns {query.CommitResponse} CommitResponse instance
         */
        CommitResponse.create = function create(properties) {
            return new CommitResponse(properties);
        };

        /**
         * Encodes the specified CommitResponse message. Does not implicitly {@link query.CommitResponse.verify|verify} messages.
         * @function encode
         * @memberof query.CommitResponse
         * @static
         * @param {query.ICommitResponse} message CommitResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommitResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reserved_id != null && Object.hasOwnProperty.call(message, "reserved_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.reserved_id);
            return writer;
        };

        /**
         * Encodes the specified CommitResponse message, length delimited. Does not implicitly {@link query.CommitResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.CommitResponse
         * @static
         * @param {query.ICommitResponse} message CommitResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommitResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CommitResponse message from the specified reader or buffer.
         * @function decode
         * @memberof query.CommitResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.CommitResponse} CommitResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommitResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.CommitResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reserved_id = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CommitResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.CommitResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.CommitResponse} CommitResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommitResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CommitResponse message.
         * @function verify
         * @memberof query.CommitResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CommitResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reserved_id != null && message.hasOwnProperty("reserved_id"))
                if (!$util.isInteger(message.reserved_id) && !(message.reserved_id && $util.isInteger(message.reserved_id.low) && $util.isInteger(message.reserved_id.high)))
                    return "reserved_id: integer|Long expected";
            return null;
        };

        /**
         * Creates a CommitResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.CommitResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.CommitResponse} CommitResponse
         */
        CommitResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.query.CommitResponse)
                return object;
            var message = new $root.query.CommitResponse();
            if (object.reserved_id != null)
                if ($util.Long)
                    (message.reserved_id = $util.Long.fromValue(object.reserved_id)).unsigned = false;
                else if (typeof object.reserved_id === "string")
                    message.reserved_id = parseInt(object.reserved_id, 10);
                else if (typeof object.reserved_id === "number")
                    message.reserved_id = object.reserved_id;
                else if (typeof object.reserved_id === "object")
                    message.reserved_id = new $util.LongBits(object.reserved_id.low >>> 0, object.reserved_id.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a CommitResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.CommitResponse
         * @static
         * @param {query.CommitResponse} message CommitResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CommitResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.reserved_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.reserved_id = options.longs === String ? "0" : 0;
            if (message.reserved_id != null && message.hasOwnProperty("reserved_id"))
                if (typeof message.reserved_id === "number")
                    object.reserved_id = options.longs === String ? String(message.reserved_id) : message.reserved_id;
                else
                    object.reserved_id = options.longs === String ? $util.Long.prototype.toString.call(message.reserved_id) : options.longs === Number ? new $util.LongBits(message.reserved_id.low >>> 0, message.reserved_id.high >>> 0).toNumber() : message.reserved_id;
            return object;
        };

        /**
         * Converts this CommitResponse to JSON.
         * @function toJSON
         * @memberof query.CommitResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CommitResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CommitResponse;
    })();

    query.RollbackRequest = (function() {

        /**
         * Properties of a RollbackRequest.
         * @memberof query
         * @interface IRollbackRequest
         * @property {vtrpc.ICallerID|null} [effective_caller_id] RollbackRequest effective_caller_id
         * @property {query.IVTGateCallerID|null} [immediate_caller_id] RollbackRequest immediate_caller_id
         * @property {query.ITarget|null} [target] RollbackRequest target
         * @property {number|Long|null} [transaction_id] RollbackRequest transaction_id
         */

        /**
         * Constructs a new RollbackRequest.
         * @memberof query
         * @classdesc Represents a RollbackRequest.
         * @implements IRollbackRequest
         * @constructor
         * @param {query.IRollbackRequest=} [properties] Properties to set
         */
        function RollbackRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RollbackRequest effective_caller_id.
         * @member {vtrpc.ICallerID|null|undefined} effective_caller_id
         * @memberof query.RollbackRequest
         * @instance
         */
        RollbackRequest.prototype.effective_caller_id = null;

        /**
         * RollbackRequest immediate_caller_id.
         * @member {query.IVTGateCallerID|null|undefined} immediate_caller_id
         * @memberof query.RollbackRequest
         * @instance
         */
        RollbackRequest.prototype.immediate_caller_id = null;

        /**
         * RollbackRequest target.
         * @member {query.ITarget|null|undefined} target
         * @memberof query.RollbackRequest
         * @instance
         */
        RollbackRequest.prototype.target = null;

        /**
         * RollbackRequest transaction_id.
         * @member {number|Long} transaction_id
         * @memberof query.RollbackRequest
         * @instance
         */
        RollbackRequest.prototype.transaction_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new RollbackRequest instance using the specified properties.
         * @function create
         * @memberof query.RollbackRequest
         * @static
         * @param {query.IRollbackRequest=} [properties] Properties to set
         * @returns {query.RollbackRequest} RollbackRequest instance
         */
        RollbackRequest.create = function create(properties) {
            return new RollbackRequest(properties);
        };

        /**
         * Encodes the specified RollbackRequest message. Does not implicitly {@link query.RollbackRequest.verify|verify} messages.
         * @function encode
         * @memberof query.RollbackRequest
         * @static
         * @param {query.IRollbackRequest} message RollbackRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RollbackRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.effective_caller_id != null && Object.hasOwnProperty.call(message, "effective_caller_id"))
                $root.vtrpc.CallerID.encode(message.effective_caller_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.immediate_caller_id != null && Object.hasOwnProperty.call(message, "immediate_caller_id"))
                $root.query.VTGateCallerID.encode(message.immediate_caller_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                $root.query.Target.encode(message.target, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.transaction_id != null && Object.hasOwnProperty.call(message, "transaction_id"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.transaction_id);
            return writer;
        };

        /**
         * Encodes the specified RollbackRequest message, length delimited. Does not implicitly {@link query.RollbackRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.RollbackRequest
         * @static
         * @param {query.IRollbackRequest} message RollbackRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RollbackRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RollbackRequest message from the specified reader or buffer.
         * @function decode
         * @memberof query.RollbackRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.RollbackRequest} RollbackRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RollbackRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.RollbackRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.effective_caller_id = $root.vtrpc.CallerID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.immediate_caller_id = $root.query.VTGateCallerID.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.target = $root.query.Target.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.transaction_id = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RollbackRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.RollbackRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.RollbackRequest} RollbackRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RollbackRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RollbackRequest message.
         * @function verify
         * @memberof query.RollbackRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RollbackRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id")) {
                var error = $root.vtrpc.CallerID.verify(message.effective_caller_id);
                if (error)
                    return "effective_caller_id." + error;
            }
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id")) {
                var error = $root.query.VTGateCallerID.verify(message.immediate_caller_id);
                if (error)
                    return "immediate_caller_id." + error;
            }
            if (message.target != null && message.hasOwnProperty("target")) {
                var error = $root.query.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.transaction_id != null && message.hasOwnProperty("transaction_id"))
                if (!$util.isInteger(message.transaction_id) && !(message.transaction_id && $util.isInteger(message.transaction_id.low) && $util.isInteger(message.transaction_id.high)))
                    return "transaction_id: integer|Long expected";
            return null;
        };

        /**
         * Creates a RollbackRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.RollbackRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.RollbackRequest} RollbackRequest
         */
        RollbackRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.query.RollbackRequest)
                return object;
            var message = new $root.query.RollbackRequest();
            if (object.effective_caller_id != null) {
                if (typeof object.effective_caller_id !== "object")
                    throw TypeError(".query.RollbackRequest.effective_caller_id: object expected");
                message.effective_caller_id = $root.vtrpc.CallerID.fromObject(object.effective_caller_id);
            }
            if (object.immediate_caller_id != null) {
                if (typeof object.immediate_caller_id !== "object")
                    throw TypeError(".query.RollbackRequest.immediate_caller_id: object expected");
                message.immediate_caller_id = $root.query.VTGateCallerID.fromObject(object.immediate_caller_id);
            }
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".query.RollbackRequest.target: object expected");
                message.target = $root.query.Target.fromObject(object.target);
            }
            if (object.transaction_id != null)
                if ($util.Long)
                    (message.transaction_id = $util.Long.fromValue(object.transaction_id)).unsigned = false;
                else if (typeof object.transaction_id === "string")
                    message.transaction_id = parseInt(object.transaction_id, 10);
                else if (typeof object.transaction_id === "number")
                    message.transaction_id = object.transaction_id;
                else if (typeof object.transaction_id === "object")
                    message.transaction_id = new $util.LongBits(object.transaction_id.low >>> 0, object.transaction_id.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a RollbackRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.RollbackRequest
         * @static
         * @param {query.RollbackRequest} message RollbackRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RollbackRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.effective_caller_id = null;
                object.immediate_caller_id = null;
                object.target = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.transaction_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.transaction_id = options.longs === String ? "0" : 0;
            }
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id"))
                object.effective_caller_id = $root.vtrpc.CallerID.toObject(message.effective_caller_id, options);
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id"))
                object.immediate_caller_id = $root.query.VTGateCallerID.toObject(message.immediate_caller_id, options);
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.query.Target.toObject(message.target, options);
            if (message.transaction_id != null && message.hasOwnProperty("transaction_id"))
                if (typeof message.transaction_id === "number")
                    object.transaction_id = options.longs === String ? String(message.transaction_id) : message.transaction_id;
                else
                    object.transaction_id = options.longs === String ? $util.Long.prototype.toString.call(message.transaction_id) : options.longs === Number ? new $util.LongBits(message.transaction_id.low >>> 0, message.transaction_id.high >>> 0).toNumber() : message.transaction_id;
            return object;
        };

        /**
         * Converts this RollbackRequest to JSON.
         * @function toJSON
         * @memberof query.RollbackRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RollbackRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RollbackRequest;
    })();

    query.RollbackResponse = (function() {

        /**
         * Properties of a RollbackResponse.
         * @memberof query
         * @interface IRollbackResponse
         * @property {number|Long|null} [reserved_id] RollbackResponse reserved_id
         */

        /**
         * Constructs a new RollbackResponse.
         * @memberof query
         * @classdesc Represents a RollbackResponse.
         * @implements IRollbackResponse
         * @constructor
         * @param {query.IRollbackResponse=} [properties] Properties to set
         */
        function RollbackResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RollbackResponse reserved_id.
         * @member {number|Long} reserved_id
         * @memberof query.RollbackResponse
         * @instance
         */
        RollbackResponse.prototype.reserved_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new RollbackResponse instance using the specified properties.
         * @function create
         * @memberof query.RollbackResponse
         * @static
         * @param {query.IRollbackResponse=} [properties] Properties to set
         * @returns {query.RollbackResponse} RollbackResponse instance
         */
        RollbackResponse.create = function create(properties) {
            return new RollbackResponse(properties);
        };

        /**
         * Encodes the specified RollbackResponse message. Does not implicitly {@link query.RollbackResponse.verify|verify} messages.
         * @function encode
         * @memberof query.RollbackResponse
         * @static
         * @param {query.IRollbackResponse} message RollbackResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RollbackResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reserved_id != null && Object.hasOwnProperty.call(message, "reserved_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.reserved_id);
            return writer;
        };

        /**
         * Encodes the specified RollbackResponse message, length delimited. Does not implicitly {@link query.RollbackResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.RollbackResponse
         * @static
         * @param {query.IRollbackResponse} message RollbackResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RollbackResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RollbackResponse message from the specified reader or buffer.
         * @function decode
         * @memberof query.RollbackResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.RollbackResponse} RollbackResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RollbackResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.RollbackResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reserved_id = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RollbackResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.RollbackResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.RollbackResponse} RollbackResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RollbackResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RollbackResponse message.
         * @function verify
         * @memberof query.RollbackResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RollbackResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reserved_id != null && message.hasOwnProperty("reserved_id"))
                if (!$util.isInteger(message.reserved_id) && !(message.reserved_id && $util.isInteger(message.reserved_id.low) && $util.isInteger(message.reserved_id.high)))
                    return "reserved_id: integer|Long expected";
            return null;
        };

        /**
         * Creates a RollbackResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.RollbackResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.RollbackResponse} RollbackResponse
         */
        RollbackResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.query.RollbackResponse)
                return object;
            var message = new $root.query.RollbackResponse();
            if (object.reserved_id != null)
                if ($util.Long)
                    (message.reserved_id = $util.Long.fromValue(object.reserved_id)).unsigned = false;
                else if (typeof object.reserved_id === "string")
                    message.reserved_id = parseInt(object.reserved_id, 10);
                else if (typeof object.reserved_id === "number")
                    message.reserved_id = object.reserved_id;
                else if (typeof object.reserved_id === "object")
                    message.reserved_id = new $util.LongBits(object.reserved_id.low >>> 0, object.reserved_id.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a RollbackResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.RollbackResponse
         * @static
         * @param {query.RollbackResponse} message RollbackResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RollbackResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.reserved_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.reserved_id = options.longs === String ? "0" : 0;
            if (message.reserved_id != null && message.hasOwnProperty("reserved_id"))
                if (typeof message.reserved_id === "number")
                    object.reserved_id = options.longs === String ? String(message.reserved_id) : message.reserved_id;
                else
                    object.reserved_id = options.longs === String ? $util.Long.prototype.toString.call(message.reserved_id) : options.longs === Number ? new $util.LongBits(message.reserved_id.low >>> 0, message.reserved_id.high >>> 0).toNumber() : message.reserved_id;
            return object;
        };

        /**
         * Converts this RollbackResponse to JSON.
         * @function toJSON
         * @memberof query.RollbackResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RollbackResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RollbackResponse;
    })();

    query.PrepareRequest = (function() {

        /**
         * Properties of a PrepareRequest.
         * @memberof query
         * @interface IPrepareRequest
         * @property {vtrpc.ICallerID|null} [effective_caller_id] PrepareRequest effective_caller_id
         * @property {query.IVTGateCallerID|null} [immediate_caller_id] PrepareRequest immediate_caller_id
         * @property {query.ITarget|null} [target] PrepareRequest target
         * @property {number|Long|null} [transaction_id] PrepareRequest transaction_id
         * @property {string|null} [dtid] PrepareRequest dtid
         */

        /**
         * Constructs a new PrepareRequest.
         * @memberof query
         * @classdesc Represents a PrepareRequest.
         * @implements IPrepareRequest
         * @constructor
         * @param {query.IPrepareRequest=} [properties] Properties to set
         */
        function PrepareRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PrepareRequest effective_caller_id.
         * @member {vtrpc.ICallerID|null|undefined} effective_caller_id
         * @memberof query.PrepareRequest
         * @instance
         */
        PrepareRequest.prototype.effective_caller_id = null;

        /**
         * PrepareRequest immediate_caller_id.
         * @member {query.IVTGateCallerID|null|undefined} immediate_caller_id
         * @memberof query.PrepareRequest
         * @instance
         */
        PrepareRequest.prototype.immediate_caller_id = null;

        /**
         * PrepareRequest target.
         * @member {query.ITarget|null|undefined} target
         * @memberof query.PrepareRequest
         * @instance
         */
        PrepareRequest.prototype.target = null;

        /**
         * PrepareRequest transaction_id.
         * @member {number|Long} transaction_id
         * @memberof query.PrepareRequest
         * @instance
         */
        PrepareRequest.prototype.transaction_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PrepareRequest dtid.
         * @member {string} dtid
         * @memberof query.PrepareRequest
         * @instance
         */
        PrepareRequest.prototype.dtid = "";

        /**
         * Creates a new PrepareRequest instance using the specified properties.
         * @function create
         * @memberof query.PrepareRequest
         * @static
         * @param {query.IPrepareRequest=} [properties] Properties to set
         * @returns {query.PrepareRequest} PrepareRequest instance
         */
        PrepareRequest.create = function create(properties) {
            return new PrepareRequest(properties);
        };

        /**
         * Encodes the specified PrepareRequest message. Does not implicitly {@link query.PrepareRequest.verify|verify} messages.
         * @function encode
         * @memberof query.PrepareRequest
         * @static
         * @param {query.IPrepareRequest} message PrepareRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrepareRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.effective_caller_id != null && Object.hasOwnProperty.call(message, "effective_caller_id"))
                $root.vtrpc.CallerID.encode(message.effective_caller_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.immediate_caller_id != null && Object.hasOwnProperty.call(message, "immediate_caller_id"))
                $root.query.VTGateCallerID.encode(message.immediate_caller_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                $root.query.Target.encode(message.target, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.transaction_id != null && Object.hasOwnProperty.call(message, "transaction_id"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.transaction_id);
            if (message.dtid != null && Object.hasOwnProperty.call(message, "dtid"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.dtid);
            return writer;
        };

        /**
         * Encodes the specified PrepareRequest message, length delimited. Does not implicitly {@link query.PrepareRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.PrepareRequest
         * @static
         * @param {query.IPrepareRequest} message PrepareRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrepareRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PrepareRequest message from the specified reader or buffer.
         * @function decode
         * @memberof query.PrepareRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.PrepareRequest} PrepareRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrepareRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.PrepareRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.effective_caller_id = $root.vtrpc.CallerID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.immediate_caller_id = $root.query.VTGateCallerID.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.target = $root.query.Target.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.transaction_id = reader.int64();
                    break;
                case 5:
                    message.dtid = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PrepareRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.PrepareRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.PrepareRequest} PrepareRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrepareRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PrepareRequest message.
         * @function verify
         * @memberof query.PrepareRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PrepareRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id")) {
                var error = $root.vtrpc.CallerID.verify(message.effective_caller_id);
                if (error)
                    return "effective_caller_id." + error;
            }
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id")) {
                var error = $root.query.VTGateCallerID.verify(message.immediate_caller_id);
                if (error)
                    return "immediate_caller_id." + error;
            }
            if (message.target != null && message.hasOwnProperty("target")) {
                var error = $root.query.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.transaction_id != null && message.hasOwnProperty("transaction_id"))
                if (!$util.isInteger(message.transaction_id) && !(message.transaction_id && $util.isInteger(message.transaction_id.low) && $util.isInteger(message.transaction_id.high)))
                    return "transaction_id: integer|Long expected";
            if (message.dtid != null && message.hasOwnProperty("dtid"))
                if (!$util.isString(message.dtid))
                    return "dtid: string expected";
            return null;
        };

        /**
         * Creates a PrepareRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.PrepareRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.PrepareRequest} PrepareRequest
         */
        PrepareRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.query.PrepareRequest)
                return object;
            var message = new $root.query.PrepareRequest();
            if (object.effective_caller_id != null) {
                if (typeof object.effective_caller_id !== "object")
                    throw TypeError(".query.PrepareRequest.effective_caller_id: object expected");
                message.effective_caller_id = $root.vtrpc.CallerID.fromObject(object.effective_caller_id);
            }
            if (object.immediate_caller_id != null) {
                if (typeof object.immediate_caller_id !== "object")
                    throw TypeError(".query.PrepareRequest.immediate_caller_id: object expected");
                message.immediate_caller_id = $root.query.VTGateCallerID.fromObject(object.immediate_caller_id);
            }
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".query.PrepareRequest.target: object expected");
                message.target = $root.query.Target.fromObject(object.target);
            }
            if (object.transaction_id != null)
                if ($util.Long)
                    (message.transaction_id = $util.Long.fromValue(object.transaction_id)).unsigned = false;
                else if (typeof object.transaction_id === "string")
                    message.transaction_id = parseInt(object.transaction_id, 10);
                else if (typeof object.transaction_id === "number")
                    message.transaction_id = object.transaction_id;
                else if (typeof object.transaction_id === "object")
                    message.transaction_id = new $util.LongBits(object.transaction_id.low >>> 0, object.transaction_id.high >>> 0).toNumber();
            if (object.dtid != null)
                message.dtid = String(object.dtid);
            return message;
        };

        /**
         * Creates a plain object from a PrepareRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.PrepareRequest
         * @static
         * @param {query.PrepareRequest} message PrepareRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PrepareRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.effective_caller_id = null;
                object.immediate_caller_id = null;
                object.target = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.transaction_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.transaction_id = options.longs === String ? "0" : 0;
                object.dtid = "";
            }
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id"))
                object.effective_caller_id = $root.vtrpc.CallerID.toObject(message.effective_caller_id, options);
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id"))
                object.immediate_caller_id = $root.query.VTGateCallerID.toObject(message.immediate_caller_id, options);
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.query.Target.toObject(message.target, options);
            if (message.transaction_id != null && message.hasOwnProperty("transaction_id"))
                if (typeof message.transaction_id === "number")
                    object.transaction_id = options.longs === String ? String(message.transaction_id) : message.transaction_id;
                else
                    object.transaction_id = options.longs === String ? $util.Long.prototype.toString.call(message.transaction_id) : options.longs === Number ? new $util.LongBits(message.transaction_id.low >>> 0, message.transaction_id.high >>> 0).toNumber() : message.transaction_id;
            if (message.dtid != null && message.hasOwnProperty("dtid"))
                object.dtid = message.dtid;
            return object;
        };

        /**
         * Converts this PrepareRequest to JSON.
         * @function toJSON
         * @memberof query.PrepareRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PrepareRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PrepareRequest;
    })();

    query.PrepareResponse = (function() {

        /**
         * Properties of a PrepareResponse.
         * @memberof query
         * @interface IPrepareResponse
         */

        /**
         * Constructs a new PrepareResponse.
         * @memberof query
         * @classdesc Represents a PrepareResponse.
         * @implements IPrepareResponse
         * @constructor
         * @param {query.IPrepareResponse=} [properties] Properties to set
         */
        function PrepareResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new PrepareResponse instance using the specified properties.
         * @function create
         * @memberof query.PrepareResponse
         * @static
         * @param {query.IPrepareResponse=} [properties] Properties to set
         * @returns {query.PrepareResponse} PrepareResponse instance
         */
        PrepareResponse.create = function create(properties) {
            return new PrepareResponse(properties);
        };

        /**
         * Encodes the specified PrepareResponse message. Does not implicitly {@link query.PrepareResponse.verify|verify} messages.
         * @function encode
         * @memberof query.PrepareResponse
         * @static
         * @param {query.IPrepareResponse} message PrepareResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrepareResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified PrepareResponse message, length delimited. Does not implicitly {@link query.PrepareResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.PrepareResponse
         * @static
         * @param {query.IPrepareResponse} message PrepareResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrepareResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PrepareResponse message from the specified reader or buffer.
         * @function decode
         * @memberof query.PrepareResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.PrepareResponse} PrepareResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrepareResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.PrepareResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PrepareResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.PrepareResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.PrepareResponse} PrepareResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrepareResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PrepareResponse message.
         * @function verify
         * @memberof query.PrepareResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PrepareResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a PrepareResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.PrepareResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.PrepareResponse} PrepareResponse
         */
        PrepareResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.query.PrepareResponse)
                return object;
            return new $root.query.PrepareResponse();
        };

        /**
         * Creates a plain object from a PrepareResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.PrepareResponse
         * @static
         * @param {query.PrepareResponse} message PrepareResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PrepareResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this PrepareResponse to JSON.
         * @function toJSON
         * @memberof query.PrepareResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PrepareResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PrepareResponse;
    })();

    query.CommitPreparedRequest = (function() {

        /**
         * Properties of a CommitPreparedRequest.
         * @memberof query
         * @interface ICommitPreparedRequest
         * @property {vtrpc.ICallerID|null} [effective_caller_id] CommitPreparedRequest effective_caller_id
         * @property {query.IVTGateCallerID|null} [immediate_caller_id] CommitPreparedRequest immediate_caller_id
         * @property {query.ITarget|null} [target] CommitPreparedRequest target
         * @property {string|null} [dtid] CommitPreparedRequest dtid
         */

        /**
         * Constructs a new CommitPreparedRequest.
         * @memberof query
         * @classdesc Represents a CommitPreparedRequest.
         * @implements ICommitPreparedRequest
         * @constructor
         * @param {query.ICommitPreparedRequest=} [properties] Properties to set
         */
        function CommitPreparedRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CommitPreparedRequest effective_caller_id.
         * @member {vtrpc.ICallerID|null|undefined} effective_caller_id
         * @memberof query.CommitPreparedRequest
         * @instance
         */
        CommitPreparedRequest.prototype.effective_caller_id = null;

        /**
         * CommitPreparedRequest immediate_caller_id.
         * @member {query.IVTGateCallerID|null|undefined} immediate_caller_id
         * @memberof query.CommitPreparedRequest
         * @instance
         */
        CommitPreparedRequest.prototype.immediate_caller_id = null;

        /**
         * CommitPreparedRequest target.
         * @member {query.ITarget|null|undefined} target
         * @memberof query.CommitPreparedRequest
         * @instance
         */
        CommitPreparedRequest.prototype.target = null;

        /**
         * CommitPreparedRequest dtid.
         * @member {string} dtid
         * @memberof query.CommitPreparedRequest
         * @instance
         */
        CommitPreparedRequest.prototype.dtid = "";

        /**
         * Creates a new CommitPreparedRequest instance using the specified properties.
         * @function create
         * @memberof query.CommitPreparedRequest
         * @static
         * @param {query.ICommitPreparedRequest=} [properties] Properties to set
         * @returns {query.CommitPreparedRequest} CommitPreparedRequest instance
         */
        CommitPreparedRequest.create = function create(properties) {
            return new CommitPreparedRequest(properties);
        };

        /**
         * Encodes the specified CommitPreparedRequest message. Does not implicitly {@link query.CommitPreparedRequest.verify|verify} messages.
         * @function encode
         * @memberof query.CommitPreparedRequest
         * @static
         * @param {query.ICommitPreparedRequest} message CommitPreparedRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommitPreparedRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.effective_caller_id != null && Object.hasOwnProperty.call(message, "effective_caller_id"))
                $root.vtrpc.CallerID.encode(message.effective_caller_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.immediate_caller_id != null && Object.hasOwnProperty.call(message, "immediate_caller_id"))
                $root.query.VTGateCallerID.encode(message.immediate_caller_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                $root.query.Target.encode(message.target, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.dtid != null && Object.hasOwnProperty.call(message, "dtid"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.dtid);
            return writer;
        };

        /**
         * Encodes the specified CommitPreparedRequest message, length delimited. Does not implicitly {@link query.CommitPreparedRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.CommitPreparedRequest
         * @static
         * @param {query.ICommitPreparedRequest} message CommitPreparedRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommitPreparedRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CommitPreparedRequest message from the specified reader or buffer.
         * @function decode
         * @memberof query.CommitPreparedRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.CommitPreparedRequest} CommitPreparedRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommitPreparedRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.CommitPreparedRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.effective_caller_id = $root.vtrpc.CallerID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.immediate_caller_id = $root.query.VTGateCallerID.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.target = $root.query.Target.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.dtid = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CommitPreparedRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.CommitPreparedRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.CommitPreparedRequest} CommitPreparedRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommitPreparedRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CommitPreparedRequest message.
         * @function verify
         * @memberof query.CommitPreparedRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CommitPreparedRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id")) {
                var error = $root.vtrpc.CallerID.verify(message.effective_caller_id);
                if (error)
                    return "effective_caller_id." + error;
            }
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id")) {
                var error = $root.query.VTGateCallerID.verify(message.immediate_caller_id);
                if (error)
                    return "immediate_caller_id." + error;
            }
            if (message.target != null && message.hasOwnProperty("target")) {
                var error = $root.query.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.dtid != null && message.hasOwnProperty("dtid"))
                if (!$util.isString(message.dtid))
                    return "dtid: string expected";
            return null;
        };

        /**
         * Creates a CommitPreparedRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.CommitPreparedRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.CommitPreparedRequest} CommitPreparedRequest
         */
        CommitPreparedRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.query.CommitPreparedRequest)
                return object;
            var message = new $root.query.CommitPreparedRequest();
            if (object.effective_caller_id != null) {
                if (typeof object.effective_caller_id !== "object")
                    throw TypeError(".query.CommitPreparedRequest.effective_caller_id: object expected");
                message.effective_caller_id = $root.vtrpc.CallerID.fromObject(object.effective_caller_id);
            }
            if (object.immediate_caller_id != null) {
                if (typeof object.immediate_caller_id !== "object")
                    throw TypeError(".query.CommitPreparedRequest.immediate_caller_id: object expected");
                message.immediate_caller_id = $root.query.VTGateCallerID.fromObject(object.immediate_caller_id);
            }
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".query.CommitPreparedRequest.target: object expected");
                message.target = $root.query.Target.fromObject(object.target);
            }
            if (object.dtid != null)
                message.dtid = String(object.dtid);
            return message;
        };

        /**
         * Creates a plain object from a CommitPreparedRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.CommitPreparedRequest
         * @static
         * @param {query.CommitPreparedRequest} message CommitPreparedRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CommitPreparedRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.effective_caller_id = null;
                object.immediate_caller_id = null;
                object.target = null;
                object.dtid = "";
            }
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id"))
                object.effective_caller_id = $root.vtrpc.CallerID.toObject(message.effective_caller_id, options);
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id"))
                object.immediate_caller_id = $root.query.VTGateCallerID.toObject(message.immediate_caller_id, options);
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.query.Target.toObject(message.target, options);
            if (message.dtid != null && message.hasOwnProperty("dtid"))
                object.dtid = message.dtid;
            return object;
        };

        /**
         * Converts this CommitPreparedRequest to JSON.
         * @function toJSON
         * @memberof query.CommitPreparedRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CommitPreparedRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CommitPreparedRequest;
    })();

    query.CommitPreparedResponse = (function() {

        /**
         * Properties of a CommitPreparedResponse.
         * @memberof query
         * @interface ICommitPreparedResponse
         */

        /**
         * Constructs a new CommitPreparedResponse.
         * @memberof query
         * @classdesc Represents a CommitPreparedResponse.
         * @implements ICommitPreparedResponse
         * @constructor
         * @param {query.ICommitPreparedResponse=} [properties] Properties to set
         */
        function CommitPreparedResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new CommitPreparedResponse instance using the specified properties.
         * @function create
         * @memberof query.CommitPreparedResponse
         * @static
         * @param {query.ICommitPreparedResponse=} [properties] Properties to set
         * @returns {query.CommitPreparedResponse} CommitPreparedResponse instance
         */
        CommitPreparedResponse.create = function create(properties) {
            return new CommitPreparedResponse(properties);
        };

        /**
         * Encodes the specified CommitPreparedResponse message. Does not implicitly {@link query.CommitPreparedResponse.verify|verify} messages.
         * @function encode
         * @memberof query.CommitPreparedResponse
         * @static
         * @param {query.ICommitPreparedResponse} message CommitPreparedResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommitPreparedResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified CommitPreparedResponse message, length delimited. Does not implicitly {@link query.CommitPreparedResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.CommitPreparedResponse
         * @static
         * @param {query.ICommitPreparedResponse} message CommitPreparedResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommitPreparedResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CommitPreparedResponse message from the specified reader or buffer.
         * @function decode
         * @memberof query.CommitPreparedResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.CommitPreparedResponse} CommitPreparedResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommitPreparedResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.CommitPreparedResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CommitPreparedResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.CommitPreparedResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.CommitPreparedResponse} CommitPreparedResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommitPreparedResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CommitPreparedResponse message.
         * @function verify
         * @memberof query.CommitPreparedResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CommitPreparedResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a CommitPreparedResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.CommitPreparedResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.CommitPreparedResponse} CommitPreparedResponse
         */
        CommitPreparedResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.query.CommitPreparedResponse)
                return object;
            return new $root.query.CommitPreparedResponse();
        };

        /**
         * Creates a plain object from a CommitPreparedResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.CommitPreparedResponse
         * @static
         * @param {query.CommitPreparedResponse} message CommitPreparedResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CommitPreparedResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this CommitPreparedResponse to JSON.
         * @function toJSON
         * @memberof query.CommitPreparedResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CommitPreparedResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CommitPreparedResponse;
    })();

    query.RollbackPreparedRequest = (function() {

        /**
         * Properties of a RollbackPreparedRequest.
         * @memberof query
         * @interface IRollbackPreparedRequest
         * @property {vtrpc.ICallerID|null} [effective_caller_id] RollbackPreparedRequest effective_caller_id
         * @property {query.IVTGateCallerID|null} [immediate_caller_id] RollbackPreparedRequest immediate_caller_id
         * @property {query.ITarget|null} [target] RollbackPreparedRequest target
         * @property {number|Long|null} [transaction_id] RollbackPreparedRequest transaction_id
         * @property {string|null} [dtid] RollbackPreparedRequest dtid
         */

        /**
         * Constructs a new RollbackPreparedRequest.
         * @memberof query
         * @classdesc Represents a RollbackPreparedRequest.
         * @implements IRollbackPreparedRequest
         * @constructor
         * @param {query.IRollbackPreparedRequest=} [properties] Properties to set
         */
        function RollbackPreparedRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RollbackPreparedRequest effective_caller_id.
         * @member {vtrpc.ICallerID|null|undefined} effective_caller_id
         * @memberof query.RollbackPreparedRequest
         * @instance
         */
        RollbackPreparedRequest.prototype.effective_caller_id = null;

        /**
         * RollbackPreparedRequest immediate_caller_id.
         * @member {query.IVTGateCallerID|null|undefined} immediate_caller_id
         * @memberof query.RollbackPreparedRequest
         * @instance
         */
        RollbackPreparedRequest.prototype.immediate_caller_id = null;

        /**
         * RollbackPreparedRequest target.
         * @member {query.ITarget|null|undefined} target
         * @memberof query.RollbackPreparedRequest
         * @instance
         */
        RollbackPreparedRequest.prototype.target = null;

        /**
         * RollbackPreparedRequest transaction_id.
         * @member {number|Long} transaction_id
         * @memberof query.RollbackPreparedRequest
         * @instance
         */
        RollbackPreparedRequest.prototype.transaction_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RollbackPreparedRequest dtid.
         * @member {string} dtid
         * @memberof query.RollbackPreparedRequest
         * @instance
         */
        RollbackPreparedRequest.prototype.dtid = "";

        /**
         * Creates a new RollbackPreparedRequest instance using the specified properties.
         * @function create
         * @memberof query.RollbackPreparedRequest
         * @static
         * @param {query.IRollbackPreparedRequest=} [properties] Properties to set
         * @returns {query.RollbackPreparedRequest} RollbackPreparedRequest instance
         */
        RollbackPreparedRequest.create = function create(properties) {
            return new RollbackPreparedRequest(properties);
        };

        /**
         * Encodes the specified RollbackPreparedRequest message. Does not implicitly {@link query.RollbackPreparedRequest.verify|verify} messages.
         * @function encode
         * @memberof query.RollbackPreparedRequest
         * @static
         * @param {query.IRollbackPreparedRequest} message RollbackPreparedRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RollbackPreparedRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.effective_caller_id != null && Object.hasOwnProperty.call(message, "effective_caller_id"))
                $root.vtrpc.CallerID.encode(message.effective_caller_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.immediate_caller_id != null && Object.hasOwnProperty.call(message, "immediate_caller_id"))
                $root.query.VTGateCallerID.encode(message.immediate_caller_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                $root.query.Target.encode(message.target, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.transaction_id != null && Object.hasOwnProperty.call(message, "transaction_id"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.transaction_id);
            if (message.dtid != null && Object.hasOwnProperty.call(message, "dtid"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.dtid);
            return writer;
        };

        /**
         * Encodes the specified RollbackPreparedRequest message, length delimited. Does not implicitly {@link query.RollbackPreparedRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.RollbackPreparedRequest
         * @static
         * @param {query.IRollbackPreparedRequest} message RollbackPreparedRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RollbackPreparedRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RollbackPreparedRequest message from the specified reader or buffer.
         * @function decode
         * @memberof query.RollbackPreparedRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.RollbackPreparedRequest} RollbackPreparedRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RollbackPreparedRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.RollbackPreparedRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.effective_caller_id = $root.vtrpc.CallerID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.immediate_caller_id = $root.query.VTGateCallerID.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.target = $root.query.Target.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.transaction_id = reader.int64();
                    break;
                case 5:
                    message.dtid = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RollbackPreparedRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.RollbackPreparedRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.RollbackPreparedRequest} RollbackPreparedRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RollbackPreparedRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RollbackPreparedRequest message.
         * @function verify
         * @memberof query.RollbackPreparedRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RollbackPreparedRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id")) {
                var error = $root.vtrpc.CallerID.verify(message.effective_caller_id);
                if (error)
                    return "effective_caller_id." + error;
            }
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id")) {
                var error = $root.query.VTGateCallerID.verify(message.immediate_caller_id);
                if (error)
                    return "immediate_caller_id." + error;
            }
            if (message.target != null && message.hasOwnProperty("target")) {
                var error = $root.query.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.transaction_id != null && message.hasOwnProperty("transaction_id"))
                if (!$util.isInteger(message.transaction_id) && !(message.transaction_id && $util.isInteger(message.transaction_id.low) && $util.isInteger(message.transaction_id.high)))
                    return "transaction_id: integer|Long expected";
            if (message.dtid != null && message.hasOwnProperty("dtid"))
                if (!$util.isString(message.dtid))
                    return "dtid: string expected";
            return null;
        };

        /**
         * Creates a RollbackPreparedRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.RollbackPreparedRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.RollbackPreparedRequest} RollbackPreparedRequest
         */
        RollbackPreparedRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.query.RollbackPreparedRequest)
                return object;
            var message = new $root.query.RollbackPreparedRequest();
            if (object.effective_caller_id != null) {
                if (typeof object.effective_caller_id !== "object")
                    throw TypeError(".query.RollbackPreparedRequest.effective_caller_id: object expected");
                message.effective_caller_id = $root.vtrpc.CallerID.fromObject(object.effective_caller_id);
            }
            if (object.immediate_caller_id != null) {
                if (typeof object.immediate_caller_id !== "object")
                    throw TypeError(".query.RollbackPreparedRequest.immediate_caller_id: object expected");
                message.immediate_caller_id = $root.query.VTGateCallerID.fromObject(object.immediate_caller_id);
            }
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".query.RollbackPreparedRequest.target: object expected");
                message.target = $root.query.Target.fromObject(object.target);
            }
            if (object.transaction_id != null)
                if ($util.Long)
                    (message.transaction_id = $util.Long.fromValue(object.transaction_id)).unsigned = false;
                else if (typeof object.transaction_id === "string")
                    message.transaction_id = parseInt(object.transaction_id, 10);
                else if (typeof object.transaction_id === "number")
                    message.transaction_id = object.transaction_id;
                else if (typeof object.transaction_id === "object")
                    message.transaction_id = new $util.LongBits(object.transaction_id.low >>> 0, object.transaction_id.high >>> 0).toNumber();
            if (object.dtid != null)
                message.dtid = String(object.dtid);
            return message;
        };

        /**
         * Creates a plain object from a RollbackPreparedRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.RollbackPreparedRequest
         * @static
         * @param {query.RollbackPreparedRequest} message RollbackPreparedRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RollbackPreparedRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.effective_caller_id = null;
                object.immediate_caller_id = null;
                object.target = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.transaction_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.transaction_id = options.longs === String ? "0" : 0;
                object.dtid = "";
            }
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id"))
                object.effective_caller_id = $root.vtrpc.CallerID.toObject(message.effective_caller_id, options);
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id"))
                object.immediate_caller_id = $root.query.VTGateCallerID.toObject(message.immediate_caller_id, options);
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.query.Target.toObject(message.target, options);
            if (message.transaction_id != null && message.hasOwnProperty("transaction_id"))
                if (typeof message.transaction_id === "number")
                    object.transaction_id = options.longs === String ? String(message.transaction_id) : message.transaction_id;
                else
                    object.transaction_id = options.longs === String ? $util.Long.prototype.toString.call(message.transaction_id) : options.longs === Number ? new $util.LongBits(message.transaction_id.low >>> 0, message.transaction_id.high >>> 0).toNumber() : message.transaction_id;
            if (message.dtid != null && message.hasOwnProperty("dtid"))
                object.dtid = message.dtid;
            return object;
        };

        /**
         * Converts this RollbackPreparedRequest to JSON.
         * @function toJSON
         * @memberof query.RollbackPreparedRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RollbackPreparedRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RollbackPreparedRequest;
    })();

    query.RollbackPreparedResponse = (function() {

        /**
         * Properties of a RollbackPreparedResponse.
         * @memberof query
         * @interface IRollbackPreparedResponse
         */

        /**
         * Constructs a new RollbackPreparedResponse.
         * @memberof query
         * @classdesc Represents a RollbackPreparedResponse.
         * @implements IRollbackPreparedResponse
         * @constructor
         * @param {query.IRollbackPreparedResponse=} [properties] Properties to set
         */
        function RollbackPreparedResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new RollbackPreparedResponse instance using the specified properties.
         * @function create
         * @memberof query.RollbackPreparedResponse
         * @static
         * @param {query.IRollbackPreparedResponse=} [properties] Properties to set
         * @returns {query.RollbackPreparedResponse} RollbackPreparedResponse instance
         */
        RollbackPreparedResponse.create = function create(properties) {
            return new RollbackPreparedResponse(properties);
        };

        /**
         * Encodes the specified RollbackPreparedResponse message. Does not implicitly {@link query.RollbackPreparedResponse.verify|verify} messages.
         * @function encode
         * @memberof query.RollbackPreparedResponse
         * @static
         * @param {query.IRollbackPreparedResponse} message RollbackPreparedResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RollbackPreparedResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified RollbackPreparedResponse message, length delimited. Does not implicitly {@link query.RollbackPreparedResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.RollbackPreparedResponse
         * @static
         * @param {query.IRollbackPreparedResponse} message RollbackPreparedResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RollbackPreparedResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RollbackPreparedResponse message from the specified reader or buffer.
         * @function decode
         * @memberof query.RollbackPreparedResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.RollbackPreparedResponse} RollbackPreparedResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RollbackPreparedResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.RollbackPreparedResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RollbackPreparedResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.RollbackPreparedResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.RollbackPreparedResponse} RollbackPreparedResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RollbackPreparedResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RollbackPreparedResponse message.
         * @function verify
         * @memberof query.RollbackPreparedResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RollbackPreparedResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a RollbackPreparedResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.RollbackPreparedResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.RollbackPreparedResponse} RollbackPreparedResponse
         */
        RollbackPreparedResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.query.RollbackPreparedResponse)
                return object;
            return new $root.query.RollbackPreparedResponse();
        };

        /**
         * Creates a plain object from a RollbackPreparedResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.RollbackPreparedResponse
         * @static
         * @param {query.RollbackPreparedResponse} message RollbackPreparedResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RollbackPreparedResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this RollbackPreparedResponse to JSON.
         * @function toJSON
         * @memberof query.RollbackPreparedResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RollbackPreparedResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RollbackPreparedResponse;
    })();

    query.CreateTransactionRequest = (function() {

        /**
         * Properties of a CreateTransactionRequest.
         * @memberof query
         * @interface ICreateTransactionRequest
         * @property {vtrpc.ICallerID|null} [effective_caller_id] CreateTransactionRequest effective_caller_id
         * @property {query.IVTGateCallerID|null} [immediate_caller_id] CreateTransactionRequest immediate_caller_id
         * @property {query.ITarget|null} [target] CreateTransactionRequest target
         * @property {string|null} [dtid] CreateTransactionRequest dtid
         * @property {Array.<query.ITarget>|null} [participants] CreateTransactionRequest participants
         */

        /**
         * Constructs a new CreateTransactionRequest.
         * @memberof query
         * @classdesc Represents a CreateTransactionRequest.
         * @implements ICreateTransactionRequest
         * @constructor
         * @param {query.ICreateTransactionRequest=} [properties] Properties to set
         */
        function CreateTransactionRequest(properties) {
            this.participants = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateTransactionRequest effective_caller_id.
         * @member {vtrpc.ICallerID|null|undefined} effective_caller_id
         * @memberof query.CreateTransactionRequest
         * @instance
         */
        CreateTransactionRequest.prototype.effective_caller_id = null;

        /**
         * CreateTransactionRequest immediate_caller_id.
         * @member {query.IVTGateCallerID|null|undefined} immediate_caller_id
         * @memberof query.CreateTransactionRequest
         * @instance
         */
        CreateTransactionRequest.prototype.immediate_caller_id = null;

        /**
         * CreateTransactionRequest target.
         * @member {query.ITarget|null|undefined} target
         * @memberof query.CreateTransactionRequest
         * @instance
         */
        CreateTransactionRequest.prototype.target = null;

        /**
         * CreateTransactionRequest dtid.
         * @member {string} dtid
         * @memberof query.CreateTransactionRequest
         * @instance
         */
        CreateTransactionRequest.prototype.dtid = "";

        /**
         * CreateTransactionRequest participants.
         * @member {Array.<query.ITarget>} participants
         * @memberof query.CreateTransactionRequest
         * @instance
         */
        CreateTransactionRequest.prototype.participants = $util.emptyArray;

        /**
         * Creates a new CreateTransactionRequest instance using the specified properties.
         * @function create
         * @memberof query.CreateTransactionRequest
         * @static
         * @param {query.ICreateTransactionRequest=} [properties] Properties to set
         * @returns {query.CreateTransactionRequest} CreateTransactionRequest instance
         */
        CreateTransactionRequest.create = function create(properties) {
            return new CreateTransactionRequest(properties);
        };

        /**
         * Encodes the specified CreateTransactionRequest message. Does not implicitly {@link query.CreateTransactionRequest.verify|verify} messages.
         * @function encode
         * @memberof query.CreateTransactionRequest
         * @static
         * @param {query.ICreateTransactionRequest} message CreateTransactionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateTransactionRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.effective_caller_id != null && Object.hasOwnProperty.call(message, "effective_caller_id"))
                $root.vtrpc.CallerID.encode(message.effective_caller_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.immediate_caller_id != null && Object.hasOwnProperty.call(message, "immediate_caller_id"))
                $root.query.VTGateCallerID.encode(message.immediate_caller_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                $root.query.Target.encode(message.target, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.dtid != null && Object.hasOwnProperty.call(message, "dtid"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.dtid);
            if (message.participants != null && message.participants.length)
                for (var i = 0; i < message.participants.length; ++i)
                    $root.query.Target.encode(message.participants[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CreateTransactionRequest message, length delimited. Does not implicitly {@link query.CreateTransactionRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.CreateTransactionRequest
         * @static
         * @param {query.ICreateTransactionRequest} message CreateTransactionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateTransactionRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateTransactionRequest message from the specified reader or buffer.
         * @function decode
         * @memberof query.CreateTransactionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.CreateTransactionRequest} CreateTransactionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateTransactionRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.CreateTransactionRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.effective_caller_id = $root.vtrpc.CallerID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.immediate_caller_id = $root.query.VTGateCallerID.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.target = $root.query.Target.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.dtid = reader.string();
                    break;
                case 5:
                    if (!(message.participants && message.participants.length))
                        message.participants = [];
                    message.participants.push($root.query.Target.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateTransactionRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.CreateTransactionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.CreateTransactionRequest} CreateTransactionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateTransactionRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateTransactionRequest message.
         * @function verify
         * @memberof query.CreateTransactionRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateTransactionRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id")) {
                var error = $root.vtrpc.CallerID.verify(message.effective_caller_id);
                if (error)
                    return "effective_caller_id." + error;
            }
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id")) {
                var error = $root.query.VTGateCallerID.verify(message.immediate_caller_id);
                if (error)
                    return "immediate_caller_id." + error;
            }
            if (message.target != null && message.hasOwnProperty("target")) {
                var error = $root.query.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.dtid != null && message.hasOwnProperty("dtid"))
                if (!$util.isString(message.dtid))
                    return "dtid: string expected";
            if (message.participants != null && message.hasOwnProperty("participants")) {
                if (!Array.isArray(message.participants))
                    return "participants: array expected";
                for (var i = 0; i < message.participants.length; ++i) {
                    var error = $root.query.Target.verify(message.participants[i]);
                    if (error)
                        return "participants." + error;
                }
            }
            return null;
        };

        /**
         * Creates a CreateTransactionRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.CreateTransactionRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.CreateTransactionRequest} CreateTransactionRequest
         */
        CreateTransactionRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.query.CreateTransactionRequest)
                return object;
            var message = new $root.query.CreateTransactionRequest();
            if (object.effective_caller_id != null) {
                if (typeof object.effective_caller_id !== "object")
                    throw TypeError(".query.CreateTransactionRequest.effective_caller_id: object expected");
                message.effective_caller_id = $root.vtrpc.CallerID.fromObject(object.effective_caller_id);
            }
            if (object.immediate_caller_id != null) {
                if (typeof object.immediate_caller_id !== "object")
                    throw TypeError(".query.CreateTransactionRequest.immediate_caller_id: object expected");
                message.immediate_caller_id = $root.query.VTGateCallerID.fromObject(object.immediate_caller_id);
            }
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".query.CreateTransactionRequest.target: object expected");
                message.target = $root.query.Target.fromObject(object.target);
            }
            if (object.dtid != null)
                message.dtid = String(object.dtid);
            if (object.participants) {
                if (!Array.isArray(object.participants))
                    throw TypeError(".query.CreateTransactionRequest.participants: array expected");
                message.participants = [];
                for (var i = 0; i < object.participants.length; ++i) {
                    if (typeof object.participants[i] !== "object")
                        throw TypeError(".query.CreateTransactionRequest.participants: object expected");
                    message.participants[i] = $root.query.Target.fromObject(object.participants[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a CreateTransactionRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.CreateTransactionRequest
         * @static
         * @param {query.CreateTransactionRequest} message CreateTransactionRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateTransactionRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.participants = [];
            if (options.defaults) {
                object.effective_caller_id = null;
                object.immediate_caller_id = null;
                object.target = null;
                object.dtid = "";
            }
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id"))
                object.effective_caller_id = $root.vtrpc.CallerID.toObject(message.effective_caller_id, options);
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id"))
                object.immediate_caller_id = $root.query.VTGateCallerID.toObject(message.immediate_caller_id, options);
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.query.Target.toObject(message.target, options);
            if (message.dtid != null && message.hasOwnProperty("dtid"))
                object.dtid = message.dtid;
            if (message.participants && message.participants.length) {
                object.participants = [];
                for (var j = 0; j < message.participants.length; ++j)
                    object.participants[j] = $root.query.Target.toObject(message.participants[j], options);
            }
            return object;
        };

        /**
         * Converts this CreateTransactionRequest to JSON.
         * @function toJSON
         * @memberof query.CreateTransactionRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateTransactionRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateTransactionRequest;
    })();

    query.CreateTransactionResponse = (function() {

        /**
         * Properties of a CreateTransactionResponse.
         * @memberof query
         * @interface ICreateTransactionResponse
         */

        /**
         * Constructs a new CreateTransactionResponse.
         * @memberof query
         * @classdesc Represents a CreateTransactionResponse.
         * @implements ICreateTransactionResponse
         * @constructor
         * @param {query.ICreateTransactionResponse=} [properties] Properties to set
         */
        function CreateTransactionResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new CreateTransactionResponse instance using the specified properties.
         * @function create
         * @memberof query.CreateTransactionResponse
         * @static
         * @param {query.ICreateTransactionResponse=} [properties] Properties to set
         * @returns {query.CreateTransactionResponse} CreateTransactionResponse instance
         */
        CreateTransactionResponse.create = function create(properties) {
            return new CreateTransactionResponse(properties);
        };

        /**
         * Encodes the specified CreateTransactionResponse message. Does not implicitly {@link query.CreateTransactionResponse.verify|verify} messages.
         * @function encode
         * @memberof query.CreateTransactionResponse
         * @static
         * @param {query.ICreateTransactionResponse} message CreateTransactionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateTransactionResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified CreateTransactionResponse message, length delimited. Does not implicitly {@link query.CreateTransactionResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.CreateTransactionResponse
         * @static
         * @param {query.ICreateTransactionResponse} message CreateTransactionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateTransactionResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateTransactionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof query.CreateTransactionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.CreateTransactionResponse} CreateTransactionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateTransactionResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.CreateTransactionResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateTransactionResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.CreateTransactionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.CreateTransactionResponse} CreateTransactionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateTransactionResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateTransactionResponse message.
         * @function verify
         * @memberof query.CreateTransactionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateTransactionResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a CreateTransactionResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.CreateTransactionResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.CreateTransactionResponse} CreateTransactionResponse
         */
        CreateTransactionResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.query.CreateTransactionResponse)
                return object;
            return new $root.query.CreateTransactionResponse();
        };

        /**
         * Creates a plain object from a CreateTransactionResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.CreateTransactionResponse
         * @static
         * @param {query.CreateTransactionResponse} message CreateTransactionResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateTransactionResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this CreateTransactionResponse to JSON.
         * @function toJSON
         * @memberof query.CreateTransactionResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateTransactionResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateTransactionResponse;
    })();

    query.StartCommitRequest = (function() {

        /**
         * Properties of a StartCommitRequest.
         * @memberof query
         * @interface IStartCommitRequest
         * @property {vtrpc.ICallerID|null} [effective_caller_id] StartCommitRequest effective_caller_id
         * @property {query.IVTGateCallerID|null} [immediate_caller_id] StartCommitRequest immediate_caller_id
         * @property {query.ITarget|null} [target] StartCommitRequest target
         * @property {number|Long|null} [transaction_id] StartCommitRequest transaction_id
         * @property {string|null} [dtid] StartCommitRequest dtid
         */

        /**
         * Constructs a new StartCommitRequest.
         * @memberof query
         * @classdesc Represents a StartCommitRequest.
         * @implements IStartCommitRequest
         * @constructor
         * @param {query.IStartCommitRequest=} [properties] Properties to set
         */
        function StartCommitRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StartCommitRequest effective_caller_id.
         * @member {vtrpc.ICallerID|null|undefined} effective_caller_id
         * @memberof query.StartCommitRequest
         * @instance
         */
        StartCommitRequest.prototype.effective_caller_id = null;

        /**
         * StartCommitRequest immediate_caller_id.
         * @member {query.IVTGateCallerID|null|undefined} immediate_caller_id
         * @memberof query.StartCommitRequest
         * @instance
         */
        StartCommitRequest.prototype.immediate_caller_id = null;

        /**
         * StartCommitRequest target.
         * @member {query.ITarget|null|undefined} target
         * @memberof query.StartCommitRequest
         * @instance
         */
        StartCommitRequest.prototype.target = null;

        /**
         * StartCommitRequest transaction_id.
         * @member {number|Long} transaction_id
         * @memberof query.StartCommitRequest
         * @instance
         */
        StartCommitRequest.prototype.transaction_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * StartCommitRequest dtid.
         * @member {string} dtid
         * @memberof query.StartCommitRequest
         * @instance
         */
        StartCommitRequest.prototype.dtid = "";

        /**
         * Creates a new StartCommitRequest instance using the specified properties.
         * @function create
         * @memberof query.StartCommitRequest
         * @static
         * @param {query.IStartCommitRequest=} [properties] Properties to set
         * @returns {query.StartCommitRequest} StartCommitRequest instance
         */
        StartCommitRequest.create = function create(properties) {
            return new StartCommitRequest(properties);
        };

        /**
         * Encodes the specified StartCommitRequest message. Does not implicitly {@link query.StartCommitRequest.verify|verify} messages.
         * @function encode
         * @memberof query.StartCommitRequest
         * @static
         * @param {query.IStartCommitRequest} message StartCommitRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartCommitRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.effective_caller_id != null && Object.hasOwnProperty.call(message, "effective_caller_id"))
                $root.vtrpc.CallerID.encode(message.effective_caller_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.immediate_caller_id != null && Object.hasOwnProperty.call(message, "immediate_caller_id"))
                $root.query.VTGateCallerID.encode(message.immediate_caller_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                $root.query.Target.encode(message.target, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.transaction_id != null && Object.hasOwnProperty.call(message, "transaction_id"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.transaction_id);
            if (message.dtid != null && Object.hasOwnProperty.call(message, "dtid"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.dtid);
            return writer;
        };

        /**
         * Encodes the specified StartCommitRequest message, length delimited. Does not implicitly {@link query.StartCommitRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.StartCommitRequest
         * @static
         * @param {query.IStartCommitRequest} message StartCommitRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartCommitRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StartCommitRequest message from the specified reader or buffer.
         * @function decode
         * @memberof query.StartCommitRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.StartCommitRequest} StartCommitRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartCommitRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.StartCommitRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.effective_caller_id = $root.vtrpc.CallerID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.immediate_caller_id = $root.query.VTGateCallerID.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.target = $root.query.Target.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.transaction_id = reader.int64();
                    break;
                case 5:
                    message.dtid = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StartCommitRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.StartCommitRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.StartCommitRequest} StartCommitRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartCommitRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StartCommitRequest message.
         * @function verify
         * @memberof query.StartCommitRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StartCommitRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id")) {
                var error = $root.vtrpc.CallerID.verify(message.effective_caller_id);
                if (error)
                    return "effective_caller_id." + error;
            }
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id")) {
                var error = $root.query.VTGateCallerID.verify(message.immediate_caller_id);
                if (error)
                    return "immediate_caller_id." + error;
            }
            if (message.target != null && message.hasOwnProperty("target")) {
                var error = $root.query.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.transaction_id != null && message.hasOwnProperty("transaction_id"))
                if (!$util.isInteger(message.transaction_id) && !(message.transaction_id && $util.isInteger(message.transaction_id.low) && $util.isInteger(message.transaction_id.high)))
                    return "transaction_id: integer|Long expected";
            if (message.dtid != null && message.hasOwnProperty("dtid"))
                if (!$util.isString(message.dtid))
                    return "dtid: string expected";
            return null;
        };

        /**
         * Creates a StartCommitRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.StartCommitRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.StartCommitRequest} StartCommitRequest
         */
        StartCommitRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.query.StartCommitRequest)
                return object;
            var message = new $root.query.StartCommitRequest();
            if (object.effective_caller_id != null) {
                if (typeof object.effective_caller_id !== "object")
                    throw TypeError(".query.StartCommitRequest.effective_caller_id: object expected");
                message.effective_caller_id = $root.vtrpc.CallerID.fromObject(object.effective_caller_id);
            }
            if (object.immediate_caller_id != null) {
                if (typeof object.immediate_caller_id !== "object")
                    throw TypeError(".query.StartCommitRequest.immediate_caller_id: object expected");
                message.immediate_caller_id = $root.query.VTGateCallerID.fromObject(object.immediate_caller_id);
            }
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".query.StartCommitRequest.target: object expected");
                message.target = $root.query.Target.fromObject(object.target);
            }
            if (object.transaction_id != null)
                if ($util.Long)
                    (message.transaction_id = $util.Long.fromValue(object.transaction_id)).unsigned = false;
                else if (typeof object.transaction_id === "string")
                    message.transaction_id = parseInt(object.transaction_id, 10);
                else if (typeof object.transaction_id === "number")
                    message.transaction_id = object.transaction_id;
                else if (typeof object.transaction_id === "object")
                    message.transaction_id = new $util.LongBits(object.transaction_id.low >>> 0, object.transaction_id.high >>> 0).toNumber();
            if (object.dtid != null)
                message.dtid = String(object.dtid);
            return message;
        };

        /**
         * Creates a plain object from a StartCommitRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.StartCommitRequest
         * @static
         * @param {query.StartCommitRequest} message StartCommitRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StartCommitRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.effective_caller_id = null;
                object.immediate_caller_id = null;
                object.target = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.transaction_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.transaction_id = options.longs === String ? "0" : 0;
                object.dtid = "";
            }
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id"))
                object.effective_caller_id = $root.vtrpc.CallerID.toObject(message.effective_caller_id, options);
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id"))
                object.immediate_caller_id = $root.query.VTGateCallerID.toObject(message.immediate_caller_id, options);
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.query.Target.toObject(message.target, options);
            if (message.transaction_id != null && message.hasOwnProperty("transaction_id"))
                if (typeof message.transaction_id === "number")
                    object.transaction_id = options.longs === String ? String(message.transaction_id) : message.transaction_id;
                else
                    object.transaction_id = options.longs === String ? $util.Long.prototype.toString.call(message.transaction_id) : options.longs === Number ? new $util.LongBits(message.transaction_id.low >>> 0, message.transaction_id.high >>> 0).toNumber() : message.transaction_id;
            if (message.dtid != null && message.hasOwnProperty("dtid"))
                object.dtid = message.dtid;
            return object;
        };

        /**
         * Converts this StartCommitRequest to JSON.
         * @function toJSON
         * @memberof query.StartCommitRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StartCommitRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StartCommitRequest;
    })();

    query.StartCommitResponse = (function() {

        /**
         * Properties of a StartCommitResponse.
         * @memberof query
         * @interface IStartCommitResponse
         */

        /**
         * Constructs a new StartCommitResponse.
         * @memberof query
         * @classdesc Represents a StartCommitResponse.
         * @implements IStartCommitResponse
         * @constructor
         * @param {query.IStartCommitResponse=} [properties] Properties to set
         */
        function StartCommitResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new StartCommitResponse instance using the specified properties.
         * @function create
         * @memberof query.StartCommitResponse
         * @static
         * @param {query.IStartCommitResponse=} [properties] Properties to set
         * @returns {query.StartCommitResponse} StartCommitResponse instance
         */
        StartCommitResponse.create = function create(properties) {
            return new StartCommitResponse(properties);
        };

        /**
         * Encodes the specified StartCommitResponse message. Does not implicitly {@link query.StartCommitResponse.verify|verify} messages.
         * @function encode
         * @memberof query.StartCommitResponse
         * @static
         * @param {query.IStartCommitResponse} message StartCommitResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartCommitResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified StartCommitResponse message, length delimited. Does not implicitly {@link query.StartCommitResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.StartCommitResponse
         * @static
         * @param {query.IStartCommitResponse} message StartCommitResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartCommitResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StartCommitResponse message from the specified reader or buffer.
         * @function decode
         * @memberof query.StartCommitResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.StartCommitResponse} StartCommitResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartCommitResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.StartCommitResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StartCommitResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.StartCommitResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.StartCommitResponse} StartCommitResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartCommitResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StartCommitResponse message.
         * @function verify
         * @memberof query.StartCommitResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StartCommitResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a StartCommitResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.StartCommitResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.StartCommitResponse} StartCommitResponse
         */
        StartCommitResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.query.StartCommitResponse)
                return object;
            return new $root.query.StartCommitResponse();
        };

        /**
         * Creates a plain object from a StartCommitResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.StartCommitResponse
         * @static
         * @param {query.StartCommitResponse} message StartCommitResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StartCommitResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this StartCommitResponse to JSON.
         * @function toJSON
         * @memberof query.StartCommitResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StartCommitResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StartCommitResponse;
    })();

    query.SetRollbackRequest = (function() {

        /**
         * Properties of a SetRollbackRequest.
         * @memberof query
         * @interface ISetRollbackRequest
         * @property {vtrpc.ICallerID|null} [effective_caller_id] SetRollbackRequest effective_caller_id
         * @property {query.IVTGateCallerID|null} [immediate_caller_id] SetRollbackRequest immediate_caller_id
         * @property {query.ITarget|null} [target] SetRollbackRequest target
         * @property {number|Long|null} [transaction_id] SetRollbackRequest transaction_id
         * @property {string|null} [dtid] SetRollbackRequest dtid
         */

        /**
         * Constructs a new SetRollbackRequest.
         * @memberof query
         * @classdesc Represents a SetRollbackRequest.
         * @implements ISetRollbackRequest
         * @constructor
         * @param {query.ISetRollbackRequest=} [properties] Properties to set
         */
        function SetRollbackRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetRollbackRequest effective_caller_id.
         * @member {vtrpc.ICallerID|null|undefined} effective_caller_id
         * @memberof query.SetRollbackRequest
         * @instance
         */
        SetRollbackRequest.prototype.effective_caller_id = null;

        /**
         * SetRollbackRequest immediate_caller_id.
         * @member {query.IVTGateCallerID|null|undefined} immediate_caller_id
         * @memberof query.SetRollbackRequest
         * @instance
         */
        SetRollbackRequest.prototype.immediate_caller_id = null;

        /**
         * SetRollbackRequest target.
         * @member {query.ITarget|null|undefined} target
         * @memberof query.SetRollbackRequest
         * @instance
         */
        SetRollbackRequest.prototype.target = null;

        /**
         * SetRollbackRequest transaction_id.
         * @member {number|Long} transaction_id
         * @memberof query.SetRollbackRequest
         * @instance
         */
        SetRollbackRequest.prototype.transaction_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SetRollbackRequest dtid.
         * @member {string} dtid
         * @memberof query.SetRollbackRequest
         * @instance
         */
        SetRollbackRequest.prototype.dtid = "";

        /**
         * Creates a new SetRollbackRequest instance using the specified properties.
         * @function create
         * @memberof query.SetRollbackRequest
         * @static
         * @param {query.ISetRollbackRequest=} [properties] Properties to set
         * @returns {query.SetRollbackRequest} SetRollbackRequest instance
         */
        SetRollbackRequest.create = function create(properties) {
            return new SetRollbackRequest(properties);
        };

        /**
         * Encodes the specified SetRollbackRequest message. Does not implicitly {@link query.SetRollbackRequest.verify|verify} messages.
         * @function encode
         * @memberof query.SetRollbackRequest
         * @static
         * @param {query.ISetRollbackRequest} message SetRollbackRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetRollbackRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.effective_caller_id != null && Object.hasOwnProperty.call(message, "effective_caller_id"))
                $root.vtrpc.CallerID.encode(message.effective_caller_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.immediate_caller_id != null && Object.hasOwnProperty.call(message, "immediate_caller_id"))
                $root.query.VTGateCallerID.encode(message.immediate_caller_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                $root.query.Target.encode(message.target, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.transaction_id != null && Object.hasOwnProperty.call(message, "transaction_id"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.transaction_id);
            if (message.dtid != null && Object.hasOwnProperty.call(message, "dtid"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.dtid);
            return writer;
        };

        /**
         * Encodes the specified SetRollbackRequest message, length delimited. Does not implicitly {@link query.SetRollbackRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.SetRollbackRequest
         * @static
         * @param {query.ISetRollbackRequest} message SetRollbackRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetRollbackRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetRollbackRequest message from the specified reader or buffer.
         * @function decode
         * @memberof query.SetRollbackRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.SetRollbackRequest} SetRollbackRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetRollbackRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.SetRollbackRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.effective_caller_id = $root.vtrpc.CallerID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.immediate_caller_id = $root.query.VTGateCallerID.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.target = $root.query.Target.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.transaction_id = reader.int64();
                    break;
                case 5:
                    message.dtid = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetRollbackRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.SetRollbackRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.SetRollbackRequest} SetRollbackRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetRollbackRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetRollbackRequest message.
         * @function verify
         * @memberof query.SetRollbackRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetRollbackRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id")) {
                var error = $root.vtrpc.CallerID.verify(message.effective_caller_id);
                if (error)
                    return "effective_caller_id." + error;
            }
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id")) {
                var error = $root.query.VTGateCallerID.verify(message.immediate_caller_id);
                if (error)
                    return "immediate_caller_id." + error;
            }
            if (message.target != null && message.hasOwnProperty("target")) {
                var error = $root.query.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.transaction_id != null && message.hasOwnProperty("transaction_id"))
                if (!$util.isInteger(message.transaction_id) && !(message.transaction_id && $util.isInteger(message.transaction_id.low) && $util.isInteger(message.transaction_id.high)))
                    return "transaction_id: integer|Long expected";
            if (message.dtid != null && message.hasOwnProperty("dtid"))
                if (!$util.isString(message.dtid))
                    return "dtid: string expected";
            return null;
        };

        /**
         * Creates a SetRollbackRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.SetRollbackRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.SetRollbackRequest} SetRollbackRequest
         */
        SetRollbackRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.query.SetRollbackRequest)
                return object;
            var message = new $root.query.SetRollbackRequest();
            if (object.effective_caller_id != null) {
                if (typeof object.effective_caller_id !== "object")
                    throw TypeError(".query.SetRollbackRequest.effective_caller_id: object expected");
                message.effective_caller_id = $root.vtrpc.CallerID.fromObject(object.effective_caller_id);
            }
            if (object.immediate_caller_id != null) {
                if (typeof object.immediate_caller_id !== "object")
                    throw TypeError(".query.SetRollbackRequest.immediate_caller_id: object expected");
                message.immediate_caller_id = $root.query.VTGateCallerID.fromObject(object.immediate_caller_id);
            }
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".query.SetRollbackRequest.target: object expected");
                message.target = $root.query.Target.fromObject(object.target);
            }
            if (object.transaction_id != null)
                if ($util.Long)
                    (message.transaction_id = $util.Long.fromValue(object.transaction_id)).unsigned = false;
                else if (typeof object.transaction_id === "string")
                    message.transaction_id = parseInt(object.transaction_id, 10);
                else if (typeof object.transaction_id === "number")
                    message.transaction_id = object.transaction_id;
                else if (typeof object.transaction_id === "object")
                    message.transaction_id = new $util.LongBits(object.transaction_id.low >>> 0, object.transaction_id.high >>> 0).toNumber();
            if (object.dtid != null)
                message.dtid = String(object.dtid);
            return message;
        };

        /**
         * Creates a plain object from a SetRollbackRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.SetRollbackRequest
         * @static
         * @param {query.SetRollbackRequest} message SetRollbackRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetRollbackRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.effective_caller_id = null;
                object.immediate_caller_id = null;
                object.target = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.transaction_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.transaction_id = options.longs === String ? "0" : 0;
                object.dtid = "";
            }
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id"))
                object.effective_caller_id = $root.vtrpc.CallerID.toObject(message.effective_caller_id, options);
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id"))
                object.immediate_caller_id = $root.query.VTGateCallerID.toObject(message.immediate_caller_id, options);
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.query.Target.toObject(message.target, options);
            if (message.transaction_id != null && message.hasOwnProperty("transaction_id"))
                if (typeof message.transaction_id === "number")
                    object.transaction_id = options.longs === String ? String(message.transaction_id) : message.transaction_id;
                else
                    object.transaction_id = options.longs === String ? $util.Long.prototype.toString.call(message.transaction_id) : options.longs === Number ? new $util.LongBits(message.transaction_id.low >>> 0, message.transaction_id.high >>> 0).toNumber() : message.transaction_id;
            if (message.dtid != null && message.hasOwnProperty("dtid"))
                object.dtid = message.dtid;
            return object;
        };

        /**
         * Converts this SetRollbackRequest to JSON.
         * @function toJSON
         * @memberof query.SetRollbackRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetRollbackRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SetRollbackRequest;
    })();

    query.SetRollbackResponse = (function() {

        /**
         * Properties of a SetRollbackResponse.
         * @memberof query
         * @interface ISetRollbackResponse
         */

        /**
         * Constructs a new SetRollbackResponse.
         * @memberof query
         * @classdesc Represents a SetRollbackResponse.
         * @implements ISetRollbackResponse
         * @constructor
         * @param {query.ISetRollbackResponse=} [properties] Properties to set
         */
        function SetRollbackResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new SetRollbackResponse instance using the specified properties.
         * @function create
         * @memberof query.SetRollbackResponse
         * @static
         * @param {query.ISetRollbackResponse=} [properties] Properties to set
         * @returns {query.SetRollbackResponse} SetRollbackResponse instance
         */
        SetRollbackResponse.create = function create(properties) {
            return new SetRollbackResponse(properties);
        };

        /**
         * Encodes the specified SetRollbackResponse message. Does not implicitly {@link query.SetRollbackResponse.verify|verify} messages.
         * @function encode
         * @memberof query.SetRollbackResponse
         * @static
         * @param {query.ISetRollbackResponse} message SetRollbackResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetRollbackResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified SetRollbackResponse message, length delimited. Does not implicitly {@link query.SetRollbackResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.SetRollbackResponse
         * @static
         * @param {query.ISetRollbackResponse} message SetRollbackResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetRollbackResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetRollbackResponse message from the specified reader or buffer.
         * @function decode
         * @memberof query.SetRollbackResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.SetRollbackResponse} SetRollbackResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetRollbackResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.SetRollbackResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetRollbackResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.SetRollbackResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.SetRollbackResponse} SetRollbackResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetRollbackResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetRollbackResponse message.
         * @function verify
         * @memberof query.SetRollbackResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetRollbackResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a SetRollbackResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.SetRollbackResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.SetRollbackResponse} SetRollbackResponse
         */
        SetRollbackResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.query.SetRollbackResponse)
                return object;
            return new $root.query.SetRollbackResponse();
        };

        /**
         * Creates a plain object from a SetRollbackResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.SetRollbackResponse
         * @static
         * @param {query.SetRollbackResponse} message SetRollbackResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetRollbackResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this SetRollbackResponse to JSON.
         * @function toJSON
         * @memberof query.SetRollbackResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetRollbackResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SetRollbackResponse;
    })();

    query.ConcludeTransactionRequest = (function() {

        /**
         * Properties of a ConcludeTransactionRequest.
         * @memberof query
         * @interface IConcludeTransactionRequest
         * @property {vtrpc.ICallerID|null} [effective_caller_id] ConcludeTransactionRequest effective_caller_id
         * @property {query.IVTGateCallerID|null} [immediate_caller_id] ConcludeTransactionRequest immediate_caller_id
         * @property {query.ITarget|null} [target] ConcludeTransactionRequest target
         * @property {string|null} [dtid] ConcludeTransactionRequest dtid
         */

        /**
         * Constructs a new ConcludeTransactionRequest.
         * @memberof query
         * @classdesc Represents a ConcludeTransactionRequest.
         * @implements IConcludeTransactionRequest
         * @constructor
         * @param {query.IConcludeTransactionRequest=} [properties] Properties to set
         */
        function ConcludeTransactionRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ConcludeTransactionRequest effective_caller_id.
         * @member {vtrpc.ICallerID|null|undefined} effective_caller_id
         * @memberof query.ConcludeTransactionRequest
         * @instance
         */
        ConcludeTransactionRequest.prototype.effective_caller_id = null;

        /**
         * ConcludeTransactionRequest immediate_caller_id.
         * @member {query.IVTGateCallerID|null|undefined} immediate_caller_id
         * @memberof query.ConcludeTransactionRequest
         * @instance
         */
        ConcludeTransactionRequest.prototype.immediate_caller_id = null;

        /**
         * ConcludeTransactionRequest target.
         * @member {query.ITarget|null|undefined} target
         * @memberof query.ConcludeTransactionRequest
         * @instance
         */
        ConcludeTransactionRequest.prototype.target = null;

        /**
         * ConcludeTransactionRequest dtid.
         * @member {string} dtid
         * @memberof query.ConcludeTransactionRequest
         * @instance
         */
        ConcludeTransactionRequest.prototype.dtid = "";

        /**
         * Creates a new ConcludeTransactionRequest instance using the specified properties.
         * @function create
         * @memberof query.ConcludeTransactionRequest
         * @static
         * @param {query.IConcludeTransactionRequest=} [properties] Properties to set
         * @returns {query.ConcludeTransactionRequest} ConcludeTransactionRequest instance
         */
        ConcludeTransactionRequest.create = function create(properties) {
            return new ConcludeTransactionRequest(properties);
        };

        /**
         * Encodes the specified ConcludeTransactionRequest message. Does not implicitly {@link query.ConcludeTransactionRequest.verify|verify} messages.
         * @function encode
         * @memberof query.ConcludeTransactionRequest
         * @static
         * @param {query.IConcludeTransactionRequest} message ConcludeTransactionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConcludeTransactionRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.effective_caller_id != null && Object.hasOwnProperty.call(message, "effective_caller_id"))
                $root.vtrpc.CallerID.encode(message.effective_caller_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.immediate_caller_id != null && Object.hasOwnProperty.call(message, "immediate_caller_id"))
                $root.query.VTGateCallerID.encode(message.immediate_caller_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                $root.query.Target.encode(message.target, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.dtid != null && Object.hasOwnProperty.call(message, "dtid"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.dtid);
            return writer;
        };

        /**
         * Encodes the specified ConcludeTransactionRequest message, length delimited. Does not implicitly {@link query.ConcludeTransactionRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.ConcludeTransactionRequest
         * @static
         * @param {query.IConcludeTransactionRequest} message ConcludeTransactionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConcludeTransactionRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ConcludeTransactionRequest message from the specified reader or buffer.
         * @function decode
         * @memberof query.ConcludeTransactionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.ConcludeTransactionRequest} ConcludeTransactionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConcludeTransactionRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.ConcludeTransactionRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.effective_caller_id = $root.vtrpc.CallerID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.immediate_caller_id = $root.query.VTGateCallerID.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.target = $root.query.Target.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.dtid = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ConcludeTransactionRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.ConcludeTransactionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.ConcludeTransactionRequest} ConcludeTransactionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConcludeTransactionRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ConcludeTransactionRequest message.
         * @function verify
         * @memberof query.ConcludeTransactionRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ConcludeTransactionRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id")) {
                var error = $root.vtrpc.CallerID.verify(message.effective_caller_id);
                if (error)
                    return "effective_caller_id." + error;
            }
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id")) {
                var error = $root.query.VTGateCallerID.verify(message.immediate_caller_id);
                if (error)
                    return "immediate_caller_id." + error;
            }
            if (message.target != null && message.hasOwnProperty("target")) {
                var error = $root.query.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.dtid != null && message.hasOwnProperty("dtid"))
                if (!$util.isString(message.dtid))
                    return "dtid: string expected";
            return null;
        };

        /**
         * Creates a ConcludeTransactionRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.ConcludeTransactionRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.ConcludeTransactionRequest} ConcludeTransactionRequest
         */
        ConcludeTransactionRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.query.ConcludeTransactionRequest)
                return object;
            var message = new $root.query.ConcludeTransactionRequest();
            if (object.effective_caller_id != null) {
                if (typeof object.effective_caller_id !== "object")
                    throw TypeError(".query.ConcludeTransactionRequest.effective_caller_id: object expected");
                message.effective_caller_id = $root.vtrpc.CallerID.fromObject(object.effective_caller_id);
            }
            if (object.immediate_caller_id != null) {
                if (typeof object.immediate_caller_id !== "object")
                    throw TypeError(".query.ConcludeTransactionRequest.immediate_caller_id: object expected");
                message.immediate_caller_id = $root.query.VTGateCallerID.fromObject(object.immediate_caller_id);
            }
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".query.ConcludeTransactionRequest.target: object expected");
                message.target = $root.query.Target.fromObject(object.target);
            }
            if (object.dtid != null)
                message.dtid = String(object.dtid);
            return message;
        };

        /**
         * Creates a plain object from a ConcludeTransactionRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.ConcludeTransactionRequest
         * @static
         * @param {query.ConcludeTransactionRequest} message ConcludeTransactionRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ConcludeTransactionRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.effective_caller_id = null;
                object.immediate_caller_id = null;
                object.target = null;
                object.dtid = "";
            }
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id"))
                object.effective_caller_id = $root.vtrpc.CallerID.toObject(message.effective_caller_id, options);
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id"))
                object.immediate_caller_id = $root.query.VTGateCallerID.toObject(message.immediate_caller_id, options);
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.query.Target.toObject(message.target, options);
            if (message.dtid != null && message.hasOwnProperty("dtid"))
                object.dtid = message.dtid;
            return object;
        };

        /**
         * Converts this ConcludeTransactionRequest to JSON.
         * @function toJSON
         * @memberof query.ConcludeTransactionRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ConcludeTransactionRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ConcludeTransactionRequest;
    })();

    query.ConcludeTransactionResponse = (function() {

        /**
         * Properties of a ConcludeTransactionResponse.
         * @memberof query
         * @interface IConcludeTransactionResponse
         */

        /**
         * Constructs a new ConcludeTransactionResponse.
         * @memberof query
         * @classdesc Represents a ConcludeTransactionResponse.
         * @implements IConcludeTransactionResponse
         * @constructor
         * @param {query.IConcludeTransactionResponse=} [properties] Properties to set
         */
        function ConcludeTransactionResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ConcludeTransactionResponse instance using the specified properties.
         * @function create
         * @memberof query.ConcludeTransactionResponse
         * @static
         * @param {query.IConcludeTransactionResponse=} [properties] Properties to set
         * @returns {query.ConcludeTransactionResponse} ConcludeTransactionResponse instance
         */
        ConcludeTransactionResponse.create = function create(properties) {
            return new ConcludeTransactionResponse(properties);
        };

        /**
         * Encodes the specified ConcludeTransactionResponse message. Does not implicitly {@link query.ConcludeTransactionResponse.verify|verify} messages.
         * @function encode
         * @memberof query.ConcludeTransactionResponse
         * @static
         * @param {query.IConcludeTransactionResponse} message ConcludeTransactionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConcludeTransactionResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ConcludeTransactionResponse message, length delimited. Does not implicitly {@link query.ConcludeTransactionResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.ConcludeTransactionResponse
         * @static
         * @param {query.IConcludeTransactionResponse} message ConcludeTransactionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConcludeTransactionResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ConcludeTransactionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof query.ConcludeTransactionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.ConcludeTransactionResponse} ConcludeTransactionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConcludeTransactionResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.ConcludeTransactionResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ConcludeTransactionResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.ConcludeTransactionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.ConcludeTransactionResponse} ConcludeTransactionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConcludeTransactionResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ConcludeTransactionResponse message.
         * @function verify
         * @memberof query.ConcludeTransactionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ConcludeTransactionResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ConcludeTransactionResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.ConcludeTransactionResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.ConcludeTransactionResponse} ConcludeTransactionResponse
         */
        ConcludeTransactionResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.query.ConcludeTransactionResponse)
                return object;
            return new $root.query.ConcludeTransactionResponse();
        };

        /**
         * Creates a plain object from a ConcludeTransactionResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.ConcludeTransactionResponse
         * @static
         * @param {query.ConcludeTransactionResponse} message ConcludeTransactionResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ConcludeTransactionResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ConcludeTransactionResponse to JSON.
         * @function toJSON
         * @memberof query.ConcludeTransactionResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ConcludeTransactionResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ConcludeTransactionResponse;
    })();

    query.ReadTransactionRequest = (function() {

        /**
         * Properties of a ReadTransactionRequest.
         * @memberof query
         * @interface IReadTransactionRequest
         * @property {vtrpc.ICallerID|null} [effective_caller_id] ReadTransactionRequest effective_caller_id
         * @property {query.IVTGateCallerID|null} [immediate_caller_id] ReadTransactionRequest immediate_caller_id
         * @property {query.ITarget|null} [target] ReadTransactionRequest target
         * @property {string|null} [dtid] ReadTransactionRequest dtid
         */

        /**
         * Constructs a new ReadTransactionRequest.
         * @memberof query
         * @classdesc Represents a ReadTransactionRequest.
         * @implements IReadTransactionRequest
         * @constructor
         * @param {query.IReadTransactionRequest=} [properties] Properties to set
         */
        function ReadTransactionRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReadTransactionRequest effective_caller_id.
         * @member {vtrpc.ICallerID|null|undefined} effective_caller_id
         * @memberof query.ReadTransactionRequest
         * @instance
         */
        ReadTransactionRequest.prototype.effective_caller_id = null;

        /**
         * ReadTransactionRequest immediate_caller_id.
         * @member {query.IVTGateCallerID|null|undefined} immediate_caller_id
         * @memberof query.ReadTransactionRequest
         * @instance
         */
        ReadTransactionRequest.prototype.immediate_caller_id = null;

        /**
         * ReadTransactionRequest target.
         * @member {query.ITarget|null|undefined} target
         * @memberof query.ReadTransactionRequest
         * @instance
         */
        ReadTransactionRequest.prototype.target = null;

        /**
         * ReadTransactionRequest dtid.
         * @member {string} dtid
         * @memberof query.ReadTransactionRequest
         * @instance
         */
        ReadTransactionRequest.prototype.dtid = "";

        /**
         * Creates a new ReadTransactionRequest instance using the specified properties.
         * @function create
         * @memberof query.ReadTransactionRequest
         * @static
         * @param {query.IReadTransactionRequest=} [properties] Properties to set
         * @returns {query.ReadTransactionRequest} ReadTransactionRequest instance
         */
        ReadTransactionRequest.create = function create(properties) {
            return new ReadTransactionRequest(properties);
        };

        /**
         * Encodes the specified ReadTransactionRequest message. Does not implicitly {@link query.ReadTransactionRequest.verify|verify} messages.
         * @function encode
         * @memberof query.ReadTransactionRequest
         * @static
         * @param {query.IReadTransactionRequest} message ReadTransactionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReadTransactionRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.effective_caller_id != null && Object.hasOwnProperty.call(message, "effective_caller_id"))
                $root.vtrpc.CallerID.encode(message.effective_caller_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.immediate_caller_id != null && Object.hasOwnProperty.call(message, "immediate_caller_id"))
                $root.query.VTGateCallerID.encode(message.immediate_caller_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                $root.query.Target.encode(message.target, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.dtid != null && Object.hasOwnProperty.call(message, "dtid"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.dtid);
            return writer;
        };

        /**
         * Encodes the specified ReadTransactionRequest message, length delimited. Does not implicitly {@link query.ReadTransactionRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.ReadTransactionRequest
         * @static
         * @param {query.IReadTransactionRequest} message ReadTransactionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReadTransactionRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReadTransactionRequest message from the specified reader or buffer.
         * @function decode
         * @memberof query.ReadTransactionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.ReadTransactionRequest} ReadTransactionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReadTransactionRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.ReadTransactionRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.effective_caller_id = $root.vtrpc.CallerID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.immediate_caller_id = $root.query.VTGateCallerID.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.target = $root.query.Target.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.dtid = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReadTransactionRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.ReadTransactionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.ReadTransactionRequest} ReadTransactionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReadTransactionRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReadTransactionRequest message.
         * @function verify
         * @memberof query.ReadTransactionRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReadTransactionRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id")) {
                var error = $root.vtrpc.CallerID.verify(message.effective_caller_id);
                if (error)
                    return "effective_caller_id." + error;
            }
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id")) {
                var error = $root.query.VTGateCallerID.verify(message.immediate_caller_id);
                if (error)
                    return "immediate_caller_id." + error;
            }
            if (message.target != null && message.hasOwnProperty("target")) {
                var error = $root.query.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.dtid != null && message.hasOwnProperty("dtid"))
                if (!$util.isString(message.dtid))
                    return "dtid: string expected";
            return null;
        };

        /**
         * Creates a ReadTransactionRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.ReadTransactionRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.ReadTransactionRequest} ReadTransactionRequest
         */
        ReadTransactionRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.query.ReadTransactionRequest)
                return object;
            var message = new $root.query.ReadTransactionRequest();
            if (object.effective_caller_id != null) {
                if (typeof object.effective_caller_id !== "object")
                    throw TypeError(".query.ReadTransactionRequest.effective_caller_id: object expected");
                message.effective_caller_id = $root.vtrpc.CallerID.fromObject(object.effective_caller_id);
            }
            if (object.immediate_caller_id != null) {
                if (typeof object.immediate_caller_id !== "object")
                    throw TypeError(".query.ReadTransactionRequest.immediate_caller_id: object expected");
                message.immediate_caller_id = $root.query.VTGateCallerID.fromObject(object.immediate_caller_id);
            }
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".query.ReadTransactionRequest.target: object expected");
                message.target = $root.query.Target.fromObject(object.target);
            }
            if (object.dtid != null)
                message.dtid = String(object.dtid);
            return message;
        };

        /**
         * Creates a plain object from a ReadTransactionRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.ReadTransactionRequest
         * @static
         * @param {query.ReadTransactionRequest} message ReadTransactionRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReadTransactionRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.effective_caller_id = null;
                object.immediate_caller_id = null;
                object.target = null;
                object.dtid = "";
            }
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id"))
                object.effective_caller_id = $root.vtrpc.CallerID.toObject(message.effective_caller_id, options);
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id"))
                object.immediate_caller_id = $root.query.VTGateCallerID.toObject(message.immediate_caller_id, options);
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.query.Target.toObject(message.target, options);
            if (message.dtid != null && message.hasOwnProperty("dtid"))
                object.dtid = message.dtid;
            return object;
        };

        /**
         * Converts this ReadTransactionRequest to JSON.
         * @function toJSON
         * @memberof query.ReadTransactionRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReadTransactionRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ReadTransactionRequest;
    })();

    query.ReadTransactionResponse = (function() {

        /**
         * Properties of a ReadTransactionResponse.
         * @memberof query
         * @interface IReadTransactionResponse
         * @property {query.ITransactionMetadata|null} [metadata] ReadTransactionResponse metadata
         */

        /**
         * Constructs a new ReadTransactionResponse.
         * @memberof query
         * @classdesc Represents a ReadTransactionResponse.
         * @implements IReadTransactionResponse
         * @constructor
         * @param {query.IReadTransactionResponse=} [properties] Properties to set
         */
        function ReadTransactionResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReadTransactionResponse metadata.
         * @member {query.ITransactionMetadata|null|undefined} metadata
         * @memberof query.ReadTransactionResponse
         * @instance
         */
        ReadTransactionResponse.prototype.metadata = null;

        /**
         * Creates a new ReadTransactionResponse instance using the specified properties.
         * @function create
         * @memberof query.ReadTransactionResponse
         * @static
         * @param {query.IReadTransactionResponse=} [properties] Properties to set
         * @returns {query.ReadTransactionResponse} ReadTransactionResponse instance
         */
        ReadTransactionResponse.create = function create(properties) {
            return new ReadTransactionResponse(properties);
        };

        /**
         * Encodes the specified ReadTransactionResponse message. Does not implicitly {@link query.ReadTransactionResponse.verify|verify} messages.
         * @function encode
         * @memberof query.ReadTransactionResponse
         * @static
         * @param {query.IReadTransactionResponse} message ReadTransactionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReadTransactionResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                $root.query.TransactionMetadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ReadTransactionResponse message, length delimited. Does not implicitly {@link query.ReadTransactionResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.ReadTransactionResponse
         * @static
         * @param {query.IReadTransactionResponse} message ReadTransactionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReadTransactionResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReadTransactionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof query.ReadTransactionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.ReadTransactionResponse} ReadTransactionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReadTransactionResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.ReadTransactionResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.query.TransactionMetadata.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReadTransactionResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.ReadTransactionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.ReadTransactionResponse} ReadTransactionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReadTransactionResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReadTransactionResponse message.
         * @function verify
         * @memberof query.ReadTransactionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReadTransactionResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.query.TransactionMetadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            return null;
        };

        /**
         * Creates a ReadTransactionResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.ReadTransactionResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.ReadTransactionResponse} ReadTransactionResponse
         */
        ReadTransactionResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.query.ReadTransactionResponse)
                return object;
            var message = new $root.query.ReadTransactionResponse();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".query.ReadTransactionResponse.metadata: object expected");
                message.metadata = $root.query.TransactionMetadata.fromObject(object.metadata);
            }
            return message;
        };

        /**
         * Creates a plain object from a ReadTransactionResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.ReadTransactionResponse
         * @static
         * @param {query.ReadTransactionResponse} message ReadTransactionResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReadTransactionResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.metadata = null;
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.query.TransactionMetadata.toObject(message.metadata, options);
            return object;
        };

        /**
         * Converts this ReadTransactionResponse to JSON.
         * @function toJSON
         * @memberof query.ReadTransactionResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReadTransactionResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ReadTransactionResponse;
    })();

    query.BeginExecuteRequest = (function() {

        /**
         * Properties of a BeginExecuteRequest.
         * @memberof query
         * @interface IBeginExecuteRequest
         * @property {vtrpc.ICallerID|null} [effective_caller_id] BeginExecuteRequest effective_caller_id
         * @property {query.IVTGateCallerID|null} [immediate_caller_id] BeginExecuteRequest immediate_caller_id
         * @property {query.ITarget|null} [target] BeginExecuteRequest target
         * @property {query.IBoundQuery|null} [query] BeginExecuteRequest query
         * @property {query.IExecuteOptions|null} [options] BeginExecuteRequest options
         * @property {number|Long|null} [reserved_id] BeginExecuteRequest reserved_id
         * @property {Array.<string>|null} [pre_queries] BeginExecuteRequest pre_queries
         */

        /**
         * Constructs a new BeginExecuteRequest.
         * @memberof query
         * @classdesc Represents a BeginExecuteRequest.
         * @implements IBeginExecuteRequest
         * @constructor
         * @param {query.IBeginExecuteRequest=} [properties] Properties to set
         */
        function BeginExecuteRequest(properties) {
            this.pre_queries = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BeginExecuteRequest effective_caller_id.
         * @member {vtrpc.ICallerID|null|undefined} effective_caller_id
         * @memberof query.BeginExecuteRequest
         * @instance
         */
        BeginExecuteRequest.prototype.effective_caller_id = null;

        /**
         * BeginExecuteRequest immediate_caller_id.
         * @member {query.IVTGateCallerID|null|undefined} immediate_caller_id
         * @memberof query.BeginExecuteRequest
         * @instance
         */
        BeginExecuteRequest.prototype.immediate_caller_id = null;

        /**
         * BeginExecuteRequest target.
         * @member {query.ITarget|null|undefined} target
         * @memberof query.BeginExecuteRequest
         * @instance
         */
        BeginExecuteRequest.prototype.target = null;

        /**
         * BeginExecuteRequest query.
         * @member {query.IBoundQuery|null|undefined} query
         * @memberof query.BeginExecuteRequest
         * @instance
         */
        BeginExecuteRequest.prototype.query = null;

        /**
         * BeginExecuteRequest options.
         * @member {query.IExecuteOptions|null|undefined} options
         * @memberof query.BeginExecuteRequest
         * @instance
         */
        BeginExecuteRequest.prototype.options = null;

        /**
         * BeginExecuteRequest reserved_id.
         * @member {number|Long} reserved_id
         * @memberof query.BeginExecuteRequest
         * @instance
         */
        BeginExecuteRequest.prototype.reserved_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BeginExecuteRequest pre_queries.
         * @member {Array.<string>} pre_queries
         * @memberof query.BeginExecuteRequest
         * @instance
         */
        BeginExecuteRequest.prototype.pre_queries = $util.emptyArray;

        /**
         * Creates a new BeginExecuteRequest instance using the specified properties.
         * @function create
         * @memberof query.BeginExecuteRequest
         * @static
         * @param {query.IBeginExecuteRequest=} [properties] Properties to set
         * @returns {query.BeginExecuteRequest} BeginExecuteRequest instance
         */
        BeginExecuteRequest.create = function create(properties) {
            return new BeginExecuteRequest(properties);
        };

        /**
         * Encodes the specified BeginExecuteRequest message. Does not implicitly {@link query.BeginExecuteRequest.verify|verify} messages.
         * @function encode
         * @memberof query.BeginExecuteRequest
         * @static
         * @param {query.IBeginExecuteRequest} message BeginExecuteRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BeginExecuteRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.effective_caller_id != null && Object.hasOwnProperty.call(message, "effective_caller_id"))
                $root.vtrpc.CallerID.encode(message.effective_caller_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.immediate_caller_id != null && Object.hasOwnProperty.call(message, "immediate_caller_id"))
                $root.query.VTGateCallerID.encode(message.immediate_caller_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                $root.query.Target.encode(message.target, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                $root.query.BoundQuery.encode(message.query, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                $root.query.ExecuteOptions.encode(message.options, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.reserved_id != null && Object.hasOwnProperty.call(message, "reserved_id"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.reserved_id);
            if (message.pre_queries != null && message.pre_queries.length)
                for (var i = 0; i < message.pre_queries.length; ++i)
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.pre_queries[i]);
            return writer;
        };

        /**
         * Encodes the specified BeginExecuteRequest message, length delimited. Does not implicitly {@link query.BeginExecuteRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.BeginExecuteRequest
         * @static
         * @param {query.IBeginExecuteRequest} message BeginExecuteRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BeginExecuteRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BeginExecuteRequest message from the specified reader or buffer.
         * @function decode
         * @memberof query.BeginExecuteRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.BeginExecuteRequest} BeginExecuteRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BeginExecuteRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.BeginExecuteRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.effective_caller_id = $root.vtrpc.CallerID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.immediate_caller_id = $root.query.VTGateCallerID.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.target = $root.query.Target.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.query = $root.query.BoundQuery.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.options = $root.query.ExecuteOptions.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.reserved_id = reader.int64();
                    break;
                case 7:
                    if (!(message.pre_queries && message.pre_queries.length))
                        message.pre_queries = [];
                    message.pre_queries.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BeginExecuteRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.BeginExecuteRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.BeginExecuteRequest} BeginExecuteRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BeginExecuteRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BeginExecuteRequest message.
         * @function verify
         * @memberof query.BeginExecuteRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BeginExecuteRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id")) {
                var error = $root.vtrpc.CallerID.verify(message.effective_caller_id);
                if (error)
                    return "effective_caller_id." + error;
            }
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id")) {
                var error = $root.query.VTGateCallerID.verify(message.immediate_caller_id);
                if (error)
                    return "immediate_caller_id." + error;
            }
            if (message.target != null && message.hasOwnProperty("target")) {
                var error = $root.query.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.query != null && message.hasOwnProperty("query")) {
                var error = $root.query.BoundQuery.verify(message.query);
                if (error)
                    return "query." + error;
            }
            if (message.options != null && message.hasOwnProperty("options")) {
                var error = $root.query.ExecuteOptions.verify(message.options);
                if (error)
                    return "options." + error;
            }
            if (message.reserved_id != null && message.hasOwnProperty("reserved_id"))
                if (!$util.isInteger(message.reserved_id) && !(message.reserved_id && $util.isInteger(message.reserved_id.low) && $util.isInteger(message.reserved_id.high)))
                    return "reserved_id: integer|Long expected";
            if (message.pre_queries != null && message.hasOwnProperty("pre_queries")) {
                if (!Array.isArray(message.pre_queries))
                    return "pre_queries: array expected";
                for (var i = 0; i < message.pre_queries.length; ++i)
                    if (!$util.isString(message.pre_queries[i]))
                        return "pre_queries: string[] expected";
            }
            return null;
        };

        /**
         * Creates a BeginExecuteRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.BeginExecuteRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.BeginExecuteRequest} BeginExecuteRequest
         */
        BeginExecuteRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.query.BeginExecuteRequest)
                return object;
            var message = new $root.query.BeginExecuteRequest();
            if (object.effective_caller_id != null) {
                if (typeof object.effective_caller_id !== "object")
                    throw TypeError(".query.BeginExecuteRequest.effective_caller_id: object expected");
                message.effective_caller_id = $root.vtrpc.CallerID.fromObject(object.effective_caller_id);
            }
            if (object.immediate_caller_id != null) {
                if (typeof object.immediate_caller_id !== "object")
                    throw TypeError(".query.BeginExecuteRequest.immediate_caller_id: object expected");
                message.immediate_caller_id = $root.query.VTGateCallerID.fromObject(object.immediate_caller_id);
            }
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".query.BeginExecuteRequest.target: object expected");
                message.target = $root.query.Target.fromObject(object.target);
            }
            if (object.query != null) {
                if (typeof object.query !== "object")
                    throw TypeError(".query.BeginExecuteRequest.query: object expected");
                message.query = $root.query.BoundQuery.fromObject(object.query);
            }
            if (object.options != null) {
                if (typeof object.options !== "object")
                    throw TypeError(".query.BeginExecuteRequest.options: object expected");
                message.options = $root.query.ExecuteOptions.fromObject(object.options);
            }
            if (object.reserved_id != null)
                if ($util.Long)
                    (message.reserved_id = $util.Long.fromValue(object.reserved_id)).unsigned = false;
                else if (typeof object.reserved_id === "string")
                    message.reserved_id = parseInt(object.reserved_id, 10);
                else if (typeof object.reserved_id === "number")
                    message.reserved_id = object.reserved_id;
                else if (typeof object.reserved_id === "object")
                    message.reserved_id = new $util.LongBits(object.reserved_id.low >>> 0, object.reserved_id.high >>> 0).toNumber();
            if (object.pre_queries) {
                if (!Array.isArray(object.pre_queries))
                    throw TypeError(".query.BeginExecuteRequest.pre_queries: array expected");
                message.pre_queries = [];
                for (var i = 0; i < object.pre_queries.length; ++i)
                    message.pre_queries[i] = String(object.pre_queries[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a BeginExecuteRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.BeginExecuteRequest
         * @static
         * @param {query.BeginExecuteRequest} message BeginExecuteRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BeginExecuteRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.pre_queries = [];
            if (options.defaults) {
                object.effective_caller_id = null;
                object.immediate_caller_id = null;
                object.target = null;
                object.query = null;
                object.options = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.reserved_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.reserved_id = options.longs === String ? "0" : 0;
            }
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id"))
                object.effective_caller_id = $root.vtrpc.CallerID.toObject(message.effective_caller_id, options);
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id"))
                object.immediate_caller_id = $root.query.VTGateCallerID.toObject(message.immediate_caller_id, options);
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.query.Target.toObject(message.target, options);
            if (message.query != null && message.hasOwnProperty("query"))
                object.query = $root.query.BoundQuery.toObject(message.query, options);
            if (message.options != null && message.hasOwnProperty("options"))
                object.options = $root.query.ExecuteOptions.toObject(message.options, options);
            if (message.reserved_id != null && message.hasOwnProperty("reserved_id"))
                if (typeof message.reserved_id === "number")
                    object.reserved_id = options.longs === String ? String(message.reserved_id) : message.reserved_id;
                else
                    object.reserved_id = options.longs === String ? $util.Long.prototype.toString.call(message.reserved_id) : options.longs === Number ? new $util.LongBits(message.reserved_id.low >>> 0, message.reserved_id.high >>> 0).toNumber() : message.reserved_id;
            if (message.pre_queries && message.pre_queries.length) {
                object.pre_queries = [];
                for (var j = 0; j < message.pre_queries.length; ++j)
                    object.pre_queries[j] = message.pre_queries[j];
            }
            return object;
        };

        /**
         * Converts this BeginExecuteRequest to JSON.
         * @function toJSON
         * @memberof query.BeginExecuteRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BeginExecuteRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BeginExecuteRequest;
    })();

    query.BeginExecuteResponse = (function() {

        /**
         * Properties of a BeginExecuteResponse.
         * @memberof query
         * @interface IBeginExecuteResponse
         * @property {vtrpc.IRPCError|null} [error] BeginExecuteResponse error
         * @property {query.IQueryResult|null} [result] BeginExecuteResponse result
         * @property {number|Long|null} [transaction_id] BeginExecuteResponse transaction_id
         * @property {topodata.ITabletAlias|null} [tablet_alias] BeginExecuteResponse tablet_alias
         */

        /**
         * Constructs a new BeginExecuteResponse.
         * @memberof query
         * @classdesc Represents a BeginExecuteResponse.
         * @implements IBeginExecuteResponse
         * @constructor
         * @param {query.IBeginExecuteResponse=} [properties] Properties to set
         */
        function BeginExecuteResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BeginExecuteResponse error.
         * @member {vtrpc.IRPCError|null|undefined} error
         * @memberof query.BeginExecuteResponse
         * @instance
         */
        BeginExecuteResponse.prototype.error = null;

        /**
         * BeginExecuteResponse result.
         * @member {query.IQueryResult|null|undefined} result
         * @memberof query.BeginExecuteResponse
         * @instance
         */
        BeginExecuteResponse.prototype.result = null;

        /**
         * BeginExecuteResponse transaction_id.
         * @member {number|Long} transaction_id
         * @memberof query.BeginExecuteResponse
         * @instance
         */
        BeginExecuteResponse.prototype.transaction_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BeginExecuteResponse tablet_alias.
         * @member {topodata.ITabletAlias|null|undefined} tablet_alias
         * @memberof query.BeginExecuteResponse
         * @instance
         */
        BeginExecuteResponse.prototype.tablet_alias = null;

        /**
         * Creates a new BeginExecuteResponse instance using the specified properties.
         * @function create
         * @memberof query.BeginExecuteResponse
         * @static
         * @param {query.IBeginExecuteResponse=} [properties] Properties to set
         * @returns {query.BeginExecuteResponse} BeginExecuteResponse instance
         */
        BeginExecuteResponse.create = function create(properties) {
            return new BeginExecuteResponse(properties);
        };

        /**
         * Encodes the specified BeginExecuteResponse message. Does not implicitly {@link query.BeginExecuteResponse.verify|verify} messages.
         * @function encode
         * @memberof query.BeginExecuteResponse
         * @static
         * @param {query.IBeginExecuteResponse} message BeginExecuteResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BeginExecuteResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                $root.vtrpc.RPCError.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                $root.query.QueryResult.encode(message.result, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.transaction_id != null && Object.hasOwnProperty.call(message, "transaction_id"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.transaction_id);
            if (message.tablet_alias != null && Object.hasOwnProperty.call(message, "tablet_alias"))
                $root.topodata.TabletAlias.encode(message.tablet_alias, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BeginExecuteResponse message, length delimited. Does not implicitly {@link query.BeginExecuteResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.BeginExecuteResponse
         * @static
         * @param {query.IBeginExecuteResponse} message BeginExecuteResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BeginExecuteResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BeginExecuteResponse message from the specified reader or buffer.
         * @function decode
         * @memberof query.BeginExecuteResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.BeginExecuteResponse} BeginExecuteResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BeginExecuteResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.BeginExecuteResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.error = $root.vtrpc.RPCError.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.result = $root.query.QueryResult.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.transaction_id = reader.int64();
                    break;
                case 4:
                    message.tablet_alias = $root.topodata.TabletAlias.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BeginExecuteResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.BeginExecuteResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.BeginExecuteResponse} BeginExecuteResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BeginExecuteResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BeginExecuteResponse message.
         * @function verify
         * @memberof query.BeginExecuteResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BeginExecuteResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.error != null && message.hasOwnProperty("error")) {
                var error = $root.vtrpc.RPCError.verify(message.error);
                if (error)
                    return "error." + error;
            }
            if (message.result != null && message.hasOwnProperty("result")) {
                var error = $root.query.QueryResult.verify(message.result);
                if (error)
                    return "result." + error;
            }
            if (message.transaction_id != null && message.hasOwnProperty("transaction_id"))
                if (!$util.isInteger(message.transaction_id) && !(message.transaction_id && $util.isInteger(message.transaction_id.low) && $util.isInteger(message.transaction_id.high)))
                    return "transaction_id: integer|Long expected";
            if (message.tablet_alias != null && message.hasOwnProperty("tablet_alias")) {
                var error = $root.topodata.TabletAlias.verify(message.tablet_alias);
                if (error)
                    return "tablet_alias." + error;
            }
            return null;
        };

        /**
         * Creates a BeginExecuteResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.BeginExecuteResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.BeginExecuteResponse} BeginExecuteResponse
         */
        BeginExecuteResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.query.BeginExecuteResponse)
                return object;
            var message = new $root.query.BeginExecuteResponse();
            if (object.error != null) {
                if (typeof object.error !== "object")
                    throw TypeError(".query.BeginExecuteResponse.error: object expected");
                message.error = $root.vtrpc.RPCError.fromObject(object.error);
            }
            if (object.result != null) {
                if (typeof object.result !== "object")
                    throw TypeError(".query.BeginExecuteResponse.result: object expected");
                message.result = $root.query.QueryResult.fromObject(object.result);
            }
            if (object.transaction_id != null)
                if ($util.Long)
                    (message.transaction_id = $util.Long.fromValue(object.transaction_id)).unsigned = false;
                else if (typeof object.transaction_id === "string")
                    message.transaction_id = parseInt(object.transaction_id, 10);
                else if (typeof object.transaction_id === "number")
                    message.transaction_id = object.transaction_id;
                else if (typeof object.transaction_id === "object")
                    message.transaction_id = new $util.LongBits(object.transaction_id.low >>> 0, object.transaction_id.high >>> 0).toNumber();
            if (object.tablet_alias != null) {
                if (typeof object.tablet_alias !== "object")
                    throw TypeError(".query.BeginExecuteResponse.tablet_alias: object expected");
                message.tablet_alias = $root.topodata.TabletAlias.fromObject(object.tablet_alias);
            }
            return message;
        };

        /**
         * Creates a plain object from a BeginExecuteResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.BeginExecuteResponse
         * @static
         * @param {query.BeginExecuteResponse} message BeginExecuteResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BeginExecuteResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.error = null;
                object.result = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.transaction_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.transaction_id = options.longs === String ? "0" : 0;
                object.tablet_alias = null;
            }
            if (message.error != null && message.hasOwnProperty("error"))
                object.error = $root.vtrpc.RPCError.toObject(message.error, options);
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = $root.query.QueryResult.toObject(message.result, options);
            if (message.transaction_id != null && message.hasOwnProperty("transaction_id"))
                if (typeof message.transaction_id === "number")
                    object.transaction_id = options.longs === String ? String(message.transaction_id) : message.transaction_id;
                else
                    object.transaction_id = options.longs === String ? $util.Long.prototype.toString.call(message.transaction_id) : options.longs === Number ? new $util.LongBits(message.transaction_id.low >>> 0, message.transaction_id.high >>> 0).toNumber() : message.transaction_id;
            if (message.tablet_alias != null && message.hasOwnProperty("tablet_alias"))
                object.tablet_alias = $root.topodata.TabletAlias.toObject(message.tablet_alias, options);
            return object;
        };

        /**
         * Converts this BeginExecuteResponse to JSON.
         * @function toJSON
         * @memberof query.BeginExecuteResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BeginExecuteResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BeginExecuteResponse;
    })();

    query.BeginExecuteBatchRequest = (function() {

        /**
         * Properties of a BeginExecuteBatchRequest.
         * @memberof query
         * @interface IBeginExecuteBatchRequest
         * @property {vtrpc.ICallerID|null} [effective_caller_id] BeginExecuteBatchRequest effective_caller_id
         * @property {query.IVTGateCallerID|null} [immediate_caller_id] BeginExecuteBatchRequest immediate_caller_id
         * @property {query.ITarget|null} [target] BeginExecuteBatchRequest target
         * @property {Array.<query.IBoundQuery>|null} [queries] BeginExecuteBatchRequest queries
         * @property {boolean|null} [as_transaction] BeginExecuteBatchRequest as_transaction
         * @property {query.IExecuteOptions|null} [options] BeginExecuteBatchRequest options
         */

        /**
         * Constructs a new BeginExecuteBatchRequest.
         * @memberof query
         * @classdesc Represents a BeginExecuteBatchRequest.
         * @implements IBeginExecuteBatchRequest
         * @constructor
         * @param {query.IBeginExecuteBatchRequest=} [properties] Properties to set
         */
        function BeginExecuteBatchRequest(properties) {
            this.queries = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BeginExecuteBatchRequest effective_caller_id.
         * @member {vtrpc.ICallerID|null|undefined} effective_caller_id
         * @memberof query.BeginExecuteBatchRequest
         * @instance
         */
        BeginExecuteBatchRequest.prototype.effective_caller_id = null;

        /**
         * BeginExecuteBatchRequest immediate_caller_id.
         * @member {query.IVTGateCallerID|null|undefined} immediate_caller_id
         * @memberof query.BeginExecuteBatchRequest
         * @instance
         */
        BeginExecuteBatchRequest.prototype.immediate_caller_id = null;

        /**
         * BeginExecuteBatchRequest target.
         * @member {query.ITarget|null|undefined} target
         * @memberof query.BeginExecuteBatchRequest
         * @instance
         */
        BeginExecuteBatchRequest.prototype.target = null;

        /**
         * BeginExecuteBatchRequest queries.
         * @member {Array.<query.IBoundQuery>} queries
         * @memberof query.BeginExecuteBatchRequest
         * @instance
         */
        BeginExecuteBatchRequest.prototype.queries = $util.emptyArray;

        /**
         * BeginExecuteBatchRequest as_transaction.
         * @member {boolean} as_transaction
         * @memberof query.BeginExecuteBatchRequest
         * @instance
         */
        BeginExecuteBatchRequest.prototype.as_transaction = false;

        /**
         * BeginExecuteBatchRequest options.
         * @member {query.IExecuteOptions|null|undefined} options
         * @memberof query.BeginExecuteBatchRequest
         * @instance
         */
        BeginExecuteBatchRequest.prototype.options = null;

        /**
         * Creates a new BeginExecuteBatchRequest instance using the specified properties.
         * @function create
         * @memberof query.BeginExecuteBatchRequest
         * @static
         * @param {query.IBeginExecuteBatchRequest=} [properties] Properties to set
         * @returns {query.BeginExecuteBatchRequest} BeginExecuteBatchRequest instance
         */
        BeginExecuteBatchRequest.create = function create(properties) {
            return new BeginExecuteBatchRequest(properties);
        };

        /**
         * Encodes the specified BeginExecuteBatchRequest message. Does not implicitly {@link query.BeginExecuteBatchRequest.verify|verify} messages.
         * @function encode
         * @memberof query.BeginExecuteBatchRequest
         * @static
         * @param {query.IBeginExecuteBatchRequest} message BeginExecuteBatchRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BeginExecuteBatchRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.effective_caller_id != null && Object.hasOwnProperty.call(message, "effective_caller_id"))
                $root.vtrpc.CallerID.encode(message.effective_caller_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.immediate_caller_id != null && Object.hasOwnProperty.call(message, "immediate_caller_id"))
                $root.query.VTGateCallerID.encode(message.immediate_caller_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                $root.query.Target.encode(message.target, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.queries != null && message.queries.length)
                for (var i = 0; i < message.queries.length; ++i)
                    $root.query.BoundQuery.encode(message.queries[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.as_transaction != null && Object.hasOwnProperty.call(message, "as_transaction"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.as_transaction);
            if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                $root.query.ExecuteOptions.encode(message.options, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BeginExecuteBatchRequest message, length delimited. Does not implicitly {@link query.BeginExecuteBatchRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.BeginExecuteBatchRequest
         * @static
         * @param {query.IBeginExecuteBatchRequest} message BeginExecuteBatchRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BeginExecuteBatchRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BeginExecuteBatchRequest message from the specified reader or buffer.
         * @function decode
         * @memberof query.BeginExecuteBatchRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.BeginExecuteBatchRequest} BeginExecuteBatchRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BeginExecuteBatchRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.BeginExecuteBatchRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.effective_caller_id = $root.vtrpc.CallerID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.immediate_caller_id = $root.query.VTGateCallerID.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.target = $root.query.Target.decode(reader, reader.uint32());
                    break;
                case 4:
                    if (!(message.queries && message.queries.length))
                        message.queries = [];
                    message.queries.push($root.query.BoundQuery.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.as_transaction = reader.bool();
                    break;
                case 6:
                    message.options = $root.query.ExecuteOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BeginExecuteBatchRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.BeginExecuteBatchRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.BeginExecuteBatchRequest} BeginExecuteBatchRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BeginExecuteBatchRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BeginExecuteBatchRequest message.
         * @function verify
         * @memberof query.BeginExecuteBatchRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BeginExecuteBatchRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id")) {
                var error = $root.vtrpc.CallerID.verify(message.effective_caller_id);
                if (error)
                    return "effective_caller_id." + error;
            }
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id")) {
                var error = $root.query.VTGateCallerID.verify(message.immediate_caller_id);
                if (error)
                    return "immediate_caller_id." + error;
            }
            if (message.target != null && message.hasOwnProperty("target")) {
                var error = $root.query.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.queries != null && message.hasOwnProperty("queries")) {
                if (!Array.isArray(message.queries))
                    return "queries: array expected";
                for (var i = 0; i < message.queries.length; ++i) {
                    var error = $root.query.BoundQuery.verify(message.queries[i]);
                    if (error)
                        return "queries." + error;
                }
            }
            if (message.as_transaction != null && message.hasOwnProperty("as_transaction"))
                if (typeof message.as_transaction !== "boolean")
                    return "as_transaction: boolean expected";
            if (message.options != null && message.hasOwnProperty("options")) {
                var error = $root.query.ExecuteOptions.verify(message.options);
                if (error)
                    return "options." + error;
            }
            return null;
        };

        /**
         * Creates a BeginExecuteBatchRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.BeginExecuteBatchRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.BeginExecuteBatchRequest} BeginExecuteBatchRequest
         */
        BeginExecuteBatchRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.query.BeginExecuteBatchRequest)
                return object;
            var message = new $root.query.BeginExecuteBatchRequest();
            if (object.effective_caller_id != null) {
                if (typeof object.effective_caller_id !== "object")
                    throw TypeError(".query.BeginExecuteBatchRequest.effective_caller_id: object expected");
                message.effective_caller_id = $root.vtrpc.CallerID.fromObject(object.effective_caller_id);
            }
            if (object.immediate_caller_id != null) {
                if (typeof object.immediate_caller_id !== "object")
                    throw TypeError(".query.BeginExecuteBatchRequest.immediate_caller_id: object expected");
                message.immediate_caller_id = $root.query.VTGateCallerID.fromObject(object.immediate_caller_id);
            }
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".query.BeginExecuteBatchRequest.target: object expected");
                message.target = $root.query.Target.fromObject(object.target);
            }
            if (object.queries) {
                if (!Array.isArray(object.queries))
                    throw TypeError(".query.BeginExecuteBatchRequest.queries: array expected");
                message.queries = [];
                for (var i = 0; i < object.queries.length; ++i) {
                    if (typeof object.queries[i] !== "object")
                        throw TypeError(".query.BeginExecuteBatchRequest.queries: object expected");
                    message.queries[i] = $root.query.BoundQuery.fromObject(object.queries[i]);
                }
            }
            if (object.as_transaction != null)
                message.as_transaction = Boolean(object.as_transaction);
            if (object.options != null) {
                if (typeof object.options !== "object")
                    throw TypeError(".query.BeginExecuteBatchRequest.options: object expected");
                message.options = $root.query.ExecuteOptions.fromObject(object.options);
            }
            return message;
        };

        /**
         * Creates a plain object from a BeginExecuteBatchRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.BeginExecuteBatchRequest
         * @static
         * @param {query.BeginExecuteBatchRequest} message BeginExecuteBatchRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BeginExecuteBatchRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.queries = [];
            if (options.defaults) {
                object.effective_caller_id = null;
                object.immediate_caller_id = null;
                object.target = null;
                object.as_transaction = false;
                object.options = null;
            }
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id"))
                object.effective_caller_id = $root.vtrpc.CallerID.toObject(message.effective_caller_id, options);
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id"))
                object.immediate_caller_id = $root.query.VTGateCallerID.toObject(message.immediate_caller_id, options);
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.query.Target.toObject(message.target, options);
            if (message.queries && message.queries.length) {
                object.queries = [];
                for (var j = 0; j < message.queries.length; ++j)
                    object.queries[j] = $root.query.BoundQuery.toObject(message.queries[j], options);
            }
            if (message.as_transaction != null && message.hasOwnProperty("as_transaction"))
                object.as_transaction = message.as_transaction;
            if (message.options != null && message.hasOwnProperty("options"))
                object.options = $root.query.ExecuteOptions.toObject(message.options, options);
            return object;
        };

        /**
         * Converts this BeginExecuteBatchRequest to JSON.
         * @function toJSON
         * @memberof query.BeginExecuteBatchRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BeginExecuteBatchRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BeginExecuteBatchRequest;
    })();

    query.BeginExecuteBatchResponse = (function() {

        /**
         * Properties of a BeginExecuteBatchResponse.
         * @memberof query
         * @interface IBeginExecuteBatchResponse
         * @property {vtrpc.IRPCError|null} [error] BeginExecuteBatchResponse error
         * @property {Array.<query.IQueryResult>|null} [results] BeginExecuteBatchResponse results
         * @property {number|Long|null} [transaction_id] BeginExecuteBatchResponse transaction_id
         * @property {topodata.ITabletAlias|null} [tablet_alias] BeginExecuteBatchResponse tablet_alias
         */

        /**
         * Constructs a new BeginExecuteBatchResponse.
         * @memberof query
         * @classdesc Represents a BeginExecuteBatchResponse.
         * @implements IBeginExecuteBatchResponse
         * @constructor
         * @param {query.IBeginExecuteBatchResponse=} [properties] Properties to set
         */
        function BeginExecuteBatchResponse(properties) {
            this.results = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BeginExecuteBatchResponse error.
         * @member {vtrpc.IRPCError|null|undefined} error
         * @memberof query.BeginExecuteBatchResponse
         * @instance
         */
        BeginExecuteBatchResponse.prototype.error = null;

        /**
         * BeginExecuteBatchResponse results.
         * @member {Array.<query.IQueryResult>} results
         * @memberof query.BeginExecuteBatchResponse
         * @instance
         */
        BeginExecuteBatchResponse.prototype.results = $util.emptyArray;

        /**
         * BeginExecuteBatchResponse transaction_id.
         * @member {number|Long} transaction_id
         * @memberof query.BeginExecuteBatchResponse
         * @instance
         */
        BeginExecuteBatchResponse.prototype.transaction_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BeginExecuteBatchResponse tablet_alias.
         * @member {topodata.ITabletAlias|null|undefined} tablet_alias
         * @memberof query.BeginExecuteBatchResponse
         * @instance
         */
        BeginExecuteBatchResponse.prototype.tablet_alias = null;

        /**
         * Creates a new BeginExecuteBatchResponse instance using the specified properties.
         * @function create
         * @memberof query.BeginExecuteBatchResponse
         * @static
         * @param {query.IBeginExecuteBatchResponse=} [properties] Properties to set
         * @returns {query.BeginExecuteBatchResponse} BeginExecuteBatchResponse instance
         */
        BeginExecuteBatchResponse.create = function create(properties) {
            return new BeginExecuteBatchResponse(properties);
        };

        /**
         * Encodes the specified BeginExecuteBatchResponse message. Does not implicitly {@link query.BeginExecuteBatchResponse.verify|verify} messages.
         * @function encode
         * @memberof query.BeginExecuteBatchResponse
         * @static
         * @param {query.IBeginExecuteBatchResponse} message BeginExecuteBatchResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BeginExecuteBatchResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                $root.vtrpc.RPCError.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.results != null && message.results.length)
                for (var i = 0; i < message.results.length; ++i)
                    $root.query.QueryResult.encode(message.results[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.transaction_id != null && Object.hasOwnProperty.call(message, "transaction_id"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.transaction_id);
            if (message.tablet_alias != null && Object.hasOwnProperty.call(message, "tablet_alias"))
                $root.topodata.TabletAlias.encode(message.tablet_alias, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BeginExecuteBatchResponse message, length delimited. Does not implicitly {@link query.BeginExecuteBatchResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.BeginExecuteBatchResponse
         * @static
         * @param {query.IBeginExecuteBatchResponse} message BeginExecuteBatchResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BeginExecuteBatchResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BeginExecuteBatchResponse message from the specified reader or buffer.
         * @function decode
         * @memberof query.BeginExecuteBatchResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.BeginExecuteBatchResponse} BeginExecuteBatchResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BeginExecuteBatchResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.BeginExecuteBatchResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.error = $root.vtrpc.RPCError.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.results && message.results.length))
                        message.results = [];
                    message.results.push($root.query.QueryResult.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.transaction_id = reader.int64();
                    break;
                case 4:
                    message.tablet_alias = $root.topodata.TabletAlias.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BeginExecuteBatchResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.BeginExecuteBatchResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.BeginExecuteBatchResponse} BeginExecuteBatchResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BeginExecuteBatchResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BeginExecuteBatchResponse message.
         * @function verify
         * @memberof query.BeginExecuteBatchResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BeginExecuteBatchResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.error != null && message.hasOwnProperty("error")) {
                var error = $root.vtrpc.RPCError.verify(message.error);
                if (error)
                    return "error." + error;
            }
            if (message.results != null && message.hasOwnProperty("results")) {
                if (!Array.isArray(message.results))
                    return "results: array expected";
                for (var i = 0; i < message.results.length; ++i) {
                    var error = $root.query.QueryResult.verify(message.results[i]);
                    if (error)
                        return "results." + error;
                }
            }
            if (message.transaction_id != null && message.hasOwnProperty("transaction_id"))
                if (!$util.isInteger(message.transaction_id) && !(message.transaction_id && $util.isInteger(message.transaction_id.low) && $util.isInteger(message.transaction_id.high)))
                    return "transaction_id: integer|Long expected";
            if (message.tablet_alias != null && message.hasOwnProperty("tablet_alias")) {
                var error = $root.topodata.TabletAlias.verify(message.tablet_alias);
                if (error)
                    return "tablet_alias." + error;
            }
            return null;
        };

        /**
         * Creates a BeginExecuteBatchResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.BeginExecuteBatchResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.BeginExecuteBatchResponse} BeginExecuteBatchResponse
         */
        BeginExecuteBatchResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.query.BeginExecuteBatchResponse)
                return object;
            var message = new $root.query.BeginExecuteBatchResponse();
            if (object.error != null) {
                if (typeof object.error !== "object")
                    throw TypeError(".query.BeginExecuteBatchResponse.error: object expected");
                message.error = $root.vtrpc.RPCError.fromObject(object.error);
            }
            if (object.results) {
                if (!Array.isArray(object.results))
                    throw TypeError(".query.BeginExecuteBatchResponse.results: array expected");
                message.results = [];
                for (var i = 0; i < object.results.length; ++i) {
                    if (typeof object.results[i] !== "object")
                        throw TypeError(".query.BeginExecuteBatchResponse.results: object expected");
                    message.results[i] = $root.query.QueryResult.fromObject(object.results[i]);
                }
            }
            if (object.transaction_id != null)
                if ($util.Long)
                    (message.transaction_id = $util.Long.fromValue(object.transaction_id)).unsigned = false;
                else if (typeof object.transaction_id === "string")
                    message.transaction_id = parseInt(object.transaction_id, 10);
                else if (typeof object.transaction_id === "number")
                    message.transaction_id = object.transaction_id;
                else if (typeof object.transaction_id === "object")
                    message.transaction_id = new $util.LongBits(object.transaction_id.low >>> 0, object.transaction_id.high >>> 0).toNumber();
            if (object.tablet_alias != null) {
                if (typeof object.tablet_alias !== "object")
                    throw TypeError(".query.BeginExecuteBatchResponse.tablet_alias: object expected");
                message.tablet_alias = $root.topodata.TabletAlias.fromObject(object.tablet_alias);
            }
            return message;
        };

        /**
         * Creates a plain object from a BeginExecuteBatchResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.BeginExecuteBatchResponse
         * @static
         * @param {query.BeginExecuteBatchResponse} message BeginExecuteBatchResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BeginExecuteBatchResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.results = [];
            if (options.defaults) {
                object.error = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.transaction_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.transaction_id = options.longs === String ? "0" : 0;
                object.tablet_alias = null;
            }
            if (message.error != null && message.hasOwnProperty("error"))
                object.error = $root.vtrpc.RPCError.toObject(message.error, options);
            if (message.results && message.results.length) {
                object.results = [];
                for (var j = 0; j < message.results.length; ++j)
                    object.results[j] = $root.query.QueryResult.toObject(message.results[j], options);
            }
            if (message.transaction_id != null && message.hasOwnProperty("transaction_id"))
                if (typeof message.transaction_id === "number")
                    object.transaction_id = options.longs === String ? String(message.transaction_id) : message.transaction_id;
                else
                    object.transaction_id = options.longs === String ? $util.Long.prototype.toString.call(message.transaction_id) : options.longs === Number ? new $util.LongBits(message.transaction_id.low >>> 0, message.transaction_id.high >>> 0).toNumber() : message.transaction_id;
            if (message.tablet_alias != null && message.hasOwnProperty("tablet_alias"))
                object.tablet_alias = $root.topodata.TabletAlias.toObject(message.tablet_alias, options);
            return object;
        };

        /**
         * Converts this BeginExecuteBatchResponse to JSON.
         * @function toJSON
         * @memberof query.BeginExecuteBatchResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BeginExecuteBatchResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BeginExecuteBatchResponse;
    })();

    query.MessageStreamRequest = (function() {

        /**
         * Properties of a MessageStreamRequest.
         * @memberof query
         * @interface IMessageStreamRequest
         * @property {vtrpc.ICallerID|null} [effective_caller_id] MessageStreamRequest effective_caller_id
         * @property {query.IVTGateCallerID|null} [immediate_caller_id] MessageStreamRequest immediate_caller_id
         * @property {query.ITarget|null} [target] MessageStreamRequest target
         * @property {string|null} [name] MessageStreamRequest name
         */

        /**
         * Constructs a new MessageStreamRequest.
         * @memberof query
         * @classdesc Represents a MessageStreamRequest.
         * @implements IMessageStreamRequest
         * @constructor
         * @param {query.IMessageStreamRequest=} [properties] Properties to set
         */
        function MessageStreamRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MessageStreamRequest effective_caller_id.
         * @member {vtrpc.ICallerID|null|undefined} effective_caller_id
         * @memberof query.MessageStreamRequest
         * @instance
         */
        MessageStreamRequest.prototype.effective_caller_id = null;

        /**
         * MessageStreamRequest immediate_caller_id.
         * @member {query.IVTGateCallerID|null|undefined} immediate_caller_id
         * @memberof query.MessageStreamRequest
         * @instance
         */
        MessageStreamRequest.prototype.immediate_caller_id = null;

        /**
         * MessageStreamRequest target.
         * @member {query.ITarget|null|undefined} target
         * @memberof query.MessageStreamRequest
         * @instance
         */
        MessageStreamRequest.prototype.target = null;

        /**
         * MessageStreamRequest name.
         * @member {string} name
         * @memberof query.MessageStreamRequest
         * @instance
         */
        MessageStreamRequest.prototype.name = "";

        /**
         * Creates a new MessageStreamRequest instance using the specified properties.
         * @function create
         * @memberof query.MessageStreamRequest
         * @static
         * @param {query.IMessageStreamRequest=} [properties] Properties to set
         * @returns {query.MessageStreamRequest} MessageStreamRequest instance
         */
        MessageStreamRequest.create = function create(properties) {
            return new MessageStreamRequest(properties);
        };

        /**
         * Encodes the specified MessageStreamRequest message. Does not implicitly {@link query.MessageStreamRequest.verify|verify} messages.
         * @function encode
         * @memberof query.MessageStreamRequest
         * @static
         * @param {query.IMessageStreamRequest} message MessageStreamRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MessageStreamRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.effective_caller_id != null && Object.hasOwnProperty.call(message, "effective_caller_id"))
                $root.vtrpc.CallerID.encode(message.effective_caller_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.immediate_caller_id != null && Object.hasOwnProperty.call(message, "immediate_caller_id"))
                $root.query.VTGateCallerID.encode(message.immediate_caller_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                $root.query.Target.encode(message.target, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified MessageStreamRequest message, length delimited. Does not implicitly {@link query.MessageStreamRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.MessageStreamRequest
         * @static
         * @param {query.IMessageStreamRequest} message MessageStreamRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MessageStreamRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MessageStreamRequest message from the specified reader or buffer.
         * @function decode
         * @memberof query.MessageStreamRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.MessageStreamRequest} MessageStreamRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MessageStreamRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.MessageStreamRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.effective_caller_id = $root.vtrpc.CallerID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.immediate_caller_id = $root.query.VTGateCallerID.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.target = $root.query.Target.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MessageStreamRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.MessageStreamRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.MessageStreamRequest} MessageStreamRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MessageStreamRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MessageStreamRequest message.
         * @function verify
         * @memberof query.MessageStreamRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MessageStreamRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id")) {
                var error = $root.vtrpc.CallerID.verify(message.effective_caller_id);
                if (error)
                    return "effective_caller_id." + error;
            }
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id")) {
                var error = $root.query.VTGateCallerID.verify(message.immediate_caller_id);
                if (error)
                    return "immediate_caller_id." + error;
            }
            if (message.target != null && message.hasOwnProperty("target")) {
                var error = $root.query.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates a MessageStreamRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.MessageStreamRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.MessageStreamRequest} MessageStreamRequest
         */
        MessageStreamRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.query.MessageStreamRequest)
                return object;
            var message = new $root.query.MessageStreamRequest();
            if (object.effective_caller_id != null) {
                if (typeof object.effective_caller_id !== "object")
                    throw TypeError(".query.MessageStreamRequest.effective_caller_id: object expected");
                message.effective_caller_id = $root.vtrpc.CallerID.fromObject(object.effective_caller_id);
            }
            if (object.immediate_caller_id != null) {
                if (typeof object.immediate_caller_id !== "object")
                    throw TypeError(".query.MessageStreamRequest.immediate_caller_id: object expected");
                message.immediate_caller_id = $root.query.VTGateCallerID.fromObject(object.immediate_caller_id);
            }
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".query.MessageStreamRequest.target: object expected");
                message.target = $root.query.Target.fromObject(object.target);
            }
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a MessageStreamRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.MessageStreamRequest
         * @static
         * @param {query.MessageStreamRequest} message MessageStreamRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MessageStreamRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.effective_caller_id = null;
                object.immediate_caller_id = null;
                object.target = null;
                object.name = "";
            }
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id"))
                object.effective_caller_id = $root.vtrpc.CallerID.toObject(message.effective_caller_id, options);
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id"))
                object.immediate_caller_id = $root.query.VTGateCallerID.toObject(message.immediate_caller_id, options);
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.query.Target.toObject(message.target, options);
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this MessageStreamRequest to JSON.
         * @function toJSON
         * @memberof query.MessageStreamRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MessageStreamRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MessageStreamRequest;
    })();

    query.MessageStreamResponse = (function() {

        /**
         * Properties of a MessageStreamResponse.
         * @memberof query
         * @interface IMessageStreamResponse
         * @property {query.IQueryResult|null} [result] MessageStreamResponse result
         */

        /**
         * Constructs a new MessageStreamResponse.
         * @memberof query
         * @classdesc Represents a MessageStreamResponse.
         * @implements IMessageStreamResponse
         * @constructor
         * @param {query.IMessageStreamResponse=} [properties] Properties to set
         */
        function MessageStreamResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MessageStreamResponse result.
         * @member {query.IQueryResult|null|undefined} result
         * @memberof query.MessageStreamResponse
         * @instance
         */
        MessageStreamResponse.prototype.result = null;

        /**
         * Creates a new MessageStreamResponse instance using the specified properties.
         * @function create
         * @memberof query.MessageStreamResponse
         * @static
         * @param {query.IMessageStreamResponse=} [properties] Properties to set
         * @returns {query.MessageStreamResponse} MessageStreamResponse instance
         */
        MessageStreamResponse.create = function create(properties) {
            return new MessageStreamResponse(properties);
        };

        /**
         * Encodes the specified MessageStreamResponse message. Does not implicitly {@link query.MessageStreamResponse.verify|verify} messages.
         * @function encode
         * @memberof query.MessageStreamResponse
         * @static
         * @param {query.IMessageStreamResponse} message MessageStreamResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MessageStreamResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                $root.query.QueryResult.encode(message.result, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MessageStreamResponse message, length delimited. Does not implicitly {@link query.MessageStreamResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.MessageStreamResponse
         * @static
         * @param {query.IMessageStreamResponse} message MessageStreamResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MessageStreamResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MessageStreamResponse message from the specified reader or buffer.
         * @function decode
         * @memberof query.MessageStreamResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.MessageStreamResponse} MessageStreamResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MessageStreamResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.MessageStreamResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = $root.query.QueryResult.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MessageStreamResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.MessageStreamResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.MessageStreamResponse} MessageStreamResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MessageStreamResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MessageStreamResponse message.
         * @function verify
         * @memberof query.MessageStreamResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MessageStreamResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result")) {
                var error = $root.query.QueryResult.verify(message.result);
                if (error)
                    return "result." + error;
            }
            return null;
        };

        /**
         * Creates a MessageStreamResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.MessageStreamResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.MessageStreamResponse} MessageStreamResponse
         */
        MessageStreamResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.query.MessageStreamResponse)
                return object;
            var message = new $root.query.MessageStreamResponse();
            if (object.result != null) {
                if (typeof object.result !== "object")
                    throw TypeError(".query.MessageStreamResponse.result: object expected");
                message.result = $root.query.QueryResult.fromObject(object.result);
            }
            return message;
        };

        /**
         * Creates a plain object from a MessageStreamResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.MessageStreamResponse
         * @static
         * @param {query.MessageStreamResponse} message MessageStreamResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MessageStreamResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = null;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = $root.query.QueryResult.toObject(message.result, options);
            return object;
        };

        /**
         * Converts this MessageStreamResponse to JSON.
         * @function toJSON
         * @memberof query.MessageStreamResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MessageStreamResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MessageStreamResponse;
    })();

    query.MessageAckRequest = (function() {

        /**
         * Properties of a MessageAckRequest.
         * @memberof query
         * @interface IMessageAckRequest
         * @property {vtrpc.ICallerID|null} [effective_caller_id] MessageAckRequest effective_caller_id
         * @property {query.IVTGateCallerID|null} [immediate_caller_id] MessageAckRequest immediate_caller_id
         * @property {query.ITarget|null} [target] MessageAckRequest target
         * @property {string|null} [name] MessageAckRequest name
         * @property {Array.<query.IValue>|null} [ids] MessageAckRequest ids
         */

        /**
         * Constructs a new MessageAckRequest.
         * @memberof query
         * @classdesc Represents a MessageAckRequest.
         * @implements IMessageAckRequest
         * @constructor
         * @param {query.IMessageAckRequest=} [properties] Properties to set
         */
        function MessageAckRequest(properties) {
            this.ids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MessageAckRequest effective_caller_id.
         * @member {vtrpc.ICallerID|null|undefined} effective_caller_id
         * @memberof query.MessageAckRequest
         * @instance
         */
        MessageAckRequest.prototype.effective_caller_id = null;

        /**
         * MessageAckRequest immediate_caller_id.
         * @member {query.IVTGateCallerID|null|undefined} immediate_caller_id
         * @memberof query.MessageAckRequest
         * @instance
         */
        MessageAckRequest.prototype.immediate_caller_id = null;

        /**
         * MessageAckRequest target.
         * @member {query.ITarget|null|undefined} target
         * @memberof query.MessageAckRequest
         * @instance
         */
        MessageAckRequest.prototype.target = null;

        /**
         * MessageAckRequest name.
         * @member {string} name
         * @memberof query.MessageAckRequest
         * @instance
         */
        MessageAckRequest.prototype.name = "";

        /**
         * MessageAckRequest ids.
         * @member {Array.<query.IValue>} ids
         * @memberof query.MessageAckRequest
         * @instance
         */
        MessageAckRequest.prototype.ids = $util.emptyArray;

        /**
         * Creates a new MessageAckRequest instance using the specified properties.
         * @function create
         * @memberof query.MessageAckRequest
         * @static
         * @param {query.IMessageAckRequest=} [properties] Properties to set
         * @returns {query.MessageAckRequest} MessageAckRequest instance
         */
        MessageAckRequest.create = function create(properties) {
            return new MessageAckRequest(properties);
        };

        /**
         * Encodes the specified MessageAckRequest message. Does not implicitly {@link query.MessageAckRequest.verify|verify} messages.
         * @function encode
         * @memberof query.MessageAckRequest
         * @static
         * @param {query.IMessageAckRequest} message MessageAckRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MessageAckRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.effective_caller_id != null && Object.hasOwnProperty.call(message, "effective_caller_id"))
                $root.vtrpc.CallerID.encode(message.effective_caller_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.immediate_caller_id != null && Object.hasOwnProperty.call(message, "immediate_caller_id"))
                $root.query.VTGateCallerID.encode(message.immediate_caller_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                $root.query.Target.encode(message.target, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.name);
            if (message.ids != null && message.ids.length)
                for (var i = 0; i < message.ids.length; ++i)
                    $root.query.Value.encode(message.ids[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MessageAckRequest message, length delimited. Does not implicitly {@link query.MessageAckRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.MessageAckRequest
         * @static
         * @param {query.IMessageAckRequest} message MessageAckRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MessageAckRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MessageAckRequest message from the specified reader or buffer.
         * @function decode
         * @memberof query.MessageAckRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.MessageAckRequest} MessageAckRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MessageAckRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.MessageAckRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.effective_caller_id = $root.vtrpc.CallerID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.immediate_caller_id = $root.query.VTGateCallerID.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.target = $root.query.Target.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.name = reader.string();
                    break;
                case 5:
                    if (!(message.ids && message.ids.length))
                        message.ids = [];
                    message.ids.push($root.query.Value.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MessageAckRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.MessageAckRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.MessageAckRequest} MessageAckRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MessageAckRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MessageAckRequest message.
         * @function verify
         * @memberof query.MessageAckRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MessageAckRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id")) {
                var error = $root.vtrpc.CallerID.verify(message.effective_caller_id);
                if (error)
                    return "effective_caller_id." + error;
            }
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id")) {
                var error = $root.query.VTGateCallerID.verify(message.immediate_caller_id);
                if (error)
                    return "immediate_caller_id." + error;
            }
            if (message.target != null && message.hasOwnProperty("target")) {
                var error = $root.query.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.ids != null && message.hasOwnProperty("ids")) {
                if (!Array.isArray(message.ids))
                    return "ids: array expected";
                for (var i = 0; i < message.ids.length; ++i) {
                    var error = $root.query.Value.verify(message.ids[i]);
                    if (error)
                        return "ids." + error;
                }
            }
            return null;
        };

        /**
         * Creates a MessageAckRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.MessageAckRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.MessageAckRequest} MessageAckRequest
         */
        MessageAckRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.query.MessageAckRequest)
                return object;
            var message = new $root.query.MessageAckRequest();
            if (object.effective_caller_id != null) {
                if (typeof object.effective_caller_id !== "object")
                    throw TypeError(".query.MessageAckRequest.effective_caller_id: object expected");
                message.effective_caller_id = $root.vtrpc.CallerID.fromObject(object.effective_caller_id);
            }
            if (object.immediate_caller_id != null) {
                if (typeof object.immediate_caller_id !== "object")
                    throw TypeError(".query.MessageAckRequest.immediate_caller_id: object expected");
                message.immediate_caller_id = $root.query.VTGateCallerID.fromObject(object.immediate_caller_id);
            }
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".query.MessageAckRequest.target: object expected");
                message.target = $root.query.Target.fromObject(object.target);
            }
            if (object.name != null)
                message.name = String(object.name);
            if (object.ids) {
                if (!Array.isArray(object.ids))
                    throw TypeError(".query.MessageAckRequest.ids: array expected");
                message.ids = [];
                for (var i = 0; i < object.ids.length; ++i) {
                    if (typeof object.ids[i] !== "object")
                        throw TypeError(".query.MessageAckRequest.ids: object expected");
                    message.ids[i] = $root.query.Value.fromObject(object.ids[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a MessageAckRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.MessageAckRequest
         * @static
         * @param {query.MessageAckRequest} message MessageAckRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MessageAckRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.ids = [];
            if (options.defaults) {
                object.effective_caller_id = null;
                object.immediate_caller_id = null;
                object.target = null;
                object.name = "";
            }
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id"))
                object.effective_caller_id = $root.vtrpc.CallerID.toObject(message.effective_caller_id, options);
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id"))
                object.immediate_caller_id = $root.query.VTGateCallerID.toObject(message.immediate_caller_id, options);
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.query.Target.toObject(message.target, options);
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.ids && message.ids.length) {
                object.ids = [];
                for (var j = 0; j < message.ids.length; ++j)
                    object.ids[j] = $root.query.Value.toObject(message.ids[j], options);
            }
            return object;
        };

        /**
         * Converts this MessageAckRequest to JSON.
         * @function toJSON
         * @memberof query.MessageAckRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MessageAckRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MessageAckRequest;
    })();

    query.MessageAckResponse = (function() {

        /**
         * Properties of a MessageAckResponse.
         * @memberof query
         * @interface IMessageAckResponse
         * @property {query.IQueryResult|null} [result] MessageAckResponse result
         */

        /**
         * Constructs a new MessageAckResponse.
         * @memberof query
         * @classdesc Represents a MessageAckResponse.
         * @implements IMessageAckResponse
         * @constructor
         * @param {query.IMessageAckResponse=} [properties] Properties to set
         */
        function MessageAckResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MessageAckResponse result.
         * @member {query.IQueryResult|null|undefined} result
         * @memberof query.MessageAckResponse
         * @instance
         */
        MessageAckResponse.prototype.result = null;

        /**
         * Creates a new MessageAckResponse instance using the specified properties.
         * @function create
         * @memberof query.MessageAckResponse
         * @static
         * @param {query.IMessageAckResponse=} [properties] Properties to set
         * @returns {query.MessageAckResponse} MessageAckResponse instance
         */
        MessageAckResponse.create = function create(properties) {
            return new MessageAckResponse(properties);
        };

        /**
         * Encodes the specified MessageAckResponse message. Does not implicitly {@link query.MessageAckResponse.verify|verify} messages.
         * @function encode
         * @memberof query.MessageAckResponse
         * @static
         * @param {query.IMessageAckResponse} message MessageAckResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MessageAckResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                $root.query.QueryResult.encode(message.result, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MessageAckResponse message, length delimited. Does not implicitly {@link query.MessageAckResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.MessageAckResponse
         * @static
         * @param {query.IMessageAckResponse} message MessageAckResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MessageAckResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MessageAckResponse message from the specified reader or buffer.
         * @function decode
         * @memberof query.MessageAckResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.MessageAckResponse} MessageAckResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MessageAckResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.MessageAckResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = $root.query.QueryResult.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MessageAckResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.MessageAckResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.MessageAckResponse} MessageAckResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MessageAckResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MessageAckResponse message.
         * @function verify
         * @memberof query.MessageAckResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MessageAckResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result")) {
                var error = $root.query.QueryResult.verify(message.result);
                if (error)
                    return "result." + error;
            }
            return null;
        };

        /**
         * Creates a MessageAckResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.MessageAckResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.MessageAckResponse} MessageAckResponse
         */
        MessageAckResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.query.MessageAckResponse)
                return object;
            var message = new $root.query.MessageAckResponse();
            if (object.result != null) {
                if (typeof object.result !== "object")
                    throw TypeError(".query.MessageAckResponse.result: object expected");
                message.result = $root.query.QueryResult.fromObject(object.result);
            }
            return message;
        };

        /**
         * Creates a plain object from a MessageAckResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.MessageAckResponse
         * @static
         * @param {query.MessageAckResponse} message MessageAckResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MessageAckResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = null;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = $root.query.QueryResult.toObject(message.result, options);
            return object;
        };

        /**
         * Converts this MessageAckResponse to JSON.
         * @function toJSON
         * @memberof query.MessageAckResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MessageAckResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MessageAckResponse;
    })();

    query.ReserveExecuteRequest = (function() {

        /**
         * Properties of a ReserveExecuteRequest.
         * @memberof query
         * @interface IReserveExecuteRequest
         * @property {vtrpc.ICallerID|null} [effective_caller_id] ReserveExecuteRequest effective_caller_id
         * @property {query.IVTGateCallerID|null} [immediate_caller_id] ReserveExecuteRequest immediate_caller_id
         * @property {query.ITarget|null} [target] ReserveExecuteRequest target
         * @property {query.IBoundQuery|null} [query] ReserveExecuteRequest query
         * @property {number|Long|null} [transaction_id] ReserveExecuteRequest transaction_id
         * @property {query.IExecuteOptions|null} [options] ReserveExecuteRequest options
         * @property {Array.<string>|null} [pre_queries] ReserveExecuteRequest pre_queries
         */

        /**
         * Constructs a new ReserveExecuteRequest.
         * @memberof query
         * @classdesc Represents a ReserveExecuteRequest.
         * @implements IReserveExecuteRequest
         * @constructor
         * @param {query.IReserveExecuteRequest=} [properties] Properties to set
         */
        function ReserveExecuteRequest(properties) {
            this.pre_queries = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReserveExecuteRequest effective_caller_id.
         * @member {vtrpc.ICallerID|null|undefined} effective_caller_id
         * @memberof query.ReserveExecuteRequest
         * @instance
         */
        ReserveExecuteRequest.prototype.effective_caller_id = null;

        /**
         * ReserveExecuteRequest immediate_caller_id.
         * @member {query.IVTGateCallerID|null|undefined} immediate_caller_id
         * @memberof query.ReserveExecuteRequest
         * @instance
         */
        ReserveExecuteRequest.prototype.immediate_caller_id = null;

        /**
         * ReserveExecuteRequest target.
         * @member {query.ITarget|null|undefined} target
         * @memberof query.ReserveExecuteRequest
         * @instance
         */
        ReserveExecuteRequest.prototype.target = null;

        /**
         * ReserveExecuteRequest query.
         * @member {query.IBoundQuery|null|undefined} query
         * @memberof query.ReserveExecuteRequest
         * @instance
         */
        ReserveExecuteRequest.prototype.query = null;

        /**
         * ReserveExecuteRequest transaction_id.
         * @member {number|Long} transaction_id
         * @memberof query.ReserveExecuteRequest
         * @instance
         */
        ReserveExecuteRequest.prototype.transaction_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ReserveExecuteRequest options.
         * @member {query.IExecuteOptions|null|undefined} options
         * @memberof query.ReserveExecuteRequest
         * @instance
         */
        ReserveExecuteRequest.prototype.options = null;

        /**
         * ReserveExecuteRequest pre_queries.
         * @member {Array.<string>} pre_queries
         * @memberof query.ReserveExecuteRequest
         * @instance
         */
        ReserveExecuteRequest.prototype.pre_queries = $util.emptyArray;

        /**
         * Creates a new ReserveExecuteRequest instance using the specified properties.
         * @function create
         * @memberof query.ReserveExecuteRequest
         * @static
         * @param {query.IReserveExecuteRequest=} [properties] Properties to set
         * @returns {query.ReserveExecuteRequest} ReserveExecuteRequest instance
         */
        ReserveExecuteRequest.create = function create(properties) {
            return new ReserveExecuteRequest(properties);
        };

        /**
         * Encodes the specified ReserveExecuteRequest message. Does not implicitly {@link query.ReserveExecuteRequest.verify|verify} messages.
         * @function encode
         * @memberof query.ReserveExecuteRequest
         * @static
         * @param {query.IReserveExecuteRequest} message ReserveExecuteRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReserveExecuteRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.effective_caller_id != null && Object.hasOwnProperty.call(message, "effective_caller_id"))
                $root.vtrpc.CallerID.encode(message.effective_caller_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.immediate_caller_id != null && Object.hasOwnProperty.call(message, "immediate_caller_id"))
                $root.query.VTGateCallerID.encode(message.immediate_caller_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                $root.query.Target.encode(message.target, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                $root.query.BoundQuery.encode(message.query, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.transaction_id != null && Object.hasOwnProperty.call(message, "transaction_id"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.transaction_id);
            if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                $root.query.ExecuteOptions.encode(message.options, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.pre_queries != null && message.pre_queries.length)
                for (var i = 0; i < message.pre_queries.length; ++i)
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.pre_queries[i]);
            return writer;
        };

        /**
         * Encodes the specified ReserveExecuteRequest message, length delimited. Does not implicitly {@link query.ReserveExecuteRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.ReserveExecuteRequest
         * @static
         * @param {query.IReserveExecuteRequest} message ReserveExecuteRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReserveExecuteRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReserveExecuteRequest message from the specified reader or buffer.
         * @function decode
         * @memberof query.ReserveExecuteRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.ReserveExecuteRequest} ReserveExecuteRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReserveExecuteRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.ReserveExecuteRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.effective_caller_id = $root.vtrpc.CallerID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.immediate_caller_id = $root.query.VTGateCallerID.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.target = $root.query.Target.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.query = $root.query.BoundQuery.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.transaction_id = reader.int64();
                    break;
                case 6:
                    message.options = $root.query.ExecuteOptions.decode(reader, reader.uint32());
                    break;
                case 7:
                    if (!(message.pre_queries && message.pre_queries.length))
                        message.pre_queries = [];
                    message.pre_queries.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReserveExecuteRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.ReserveExecuteRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.ReserveExecuteRequest} ReserveExecuteRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReserveExecuteRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReserveExecuteRequest message.
         * @function verify
         * @memberof query.ReserveExecuteRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReserveExecuteRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id")) {
                var error = $root.vtrpc.CallerID.verify(message.effective_caller_id);
                if (error)
                    return "effective_caller_id." + error;
            }
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id")) {
                var error = $root.query.VTGateCallerID.verify(message.immediate_caller_id);
                if (error)
                    return "immediate_caller_id." + error;
            }
            if (message.target != null && message.hasOwnProperty("target")) {
                var error = $root.query.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.query != null && message.hasOwnProperty("query")) {
                var error = $root.query.BoundQuery.verify(message.query);
                if (error)
                    return "query." + error;
            }
            if (message.transaction_id != null && message.hasOwnProperty("transaction_id"))
                if (!$util.isInteger(message.transaction_id) && !(message.transaction_id && $util.isInteger(message.transaction_id.low) && $util.isInteger(message.transaction_id.high)))
                    return "transaction_id: integer|Long expected";
            if (message.options != null && message.hasOwnProperty("options")) {
                var error = $root.query.ExecuteOptions.verify(message.options);
                if (error)
                    return "options." + error;
            }
            if (message.pre_queries != null && message.hasOwnProperty("pre_queries")) {
                if (!Array.isArray(message.pre_queries))
                    return "pre_queries: array expected";
                for (var i = 0; i < message.pre_queries.length; ++i)
                    if (!$util.isString(message.pre_queries[i]))
                        return "pre_queries: string[] expected";
            }
            return null;
        };

        /**
         * Creates a ReserveExecuteRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.ReserveExecuteRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.ReserveExecuteRequest} ReserveExecuteRequest
         */
        ReserveExecuteRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.query.ReserveExecuteRequest)
                return object;
            var message = new $root.query.ReserveExecuteRequest();
            if (object.effective_caller_id != null) {
                if (typeof object.effective_caller_id !== "object")
                    throw TypeError(".query.ReserveExecuteRequest.effective_caller_id: object expected");
                message.effective_caller_id = $root.vtrpc.CallerID.fromObject(object.effective_caller_id);
            }
            if (object.immediate_caller_id != null) {
                if (typeof object.immediate_caller_id !== "object")
                    throw TypeError(".query.ReserveExecuteRequest.immediate_caller_id: object expected");
                message.immediate_caller_id = $root.query.VTGateCallerID.fromObject(object.immediate_caller_id);
            }
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".query.ReserveExecuteRequest.target: object expected");
                message.target = $root.query.Target.fromObject(object.target);
            }
            if (object.query != null) {
                if (typeof object.query !== "object")
                    throw TypeError(".query.ReserveExecuteRequest.query: object expected");
                message.query = $root.query.BoundQuery.fromObject(object.query);
            }
            if (object.transaction_id != null)
                if ($util.Long)
                    (message.transaction_id = $util.Long.fromValue(object.transaction_id)).unsigned = false;
                else if (typeof object.transaction_id === "string")
                    message.transaction_id = parseInt(object.transaction_id, 10);
                else if (typeof object.transaction_id === "number")
                    message.transaction_id = object.transaction_id;
                else if (typeof object.transaction_id === "object")
                    message.transaction_id = new $util.LongBits(object.transaction_id.low >>> 0, object.transaction_id.high >>> 0).toNumber();
            if (object.options != null) {
                if (typeof object.options !== "object")
                    throw TypeError(".query.ReserveExecuteRequest.options: object expected");
                message.options = $root.query.ExecuteOptions.fromObject(object.options);
            }
            if (object.pre_queries) {
                if (!Array.isArray(object.pre_queries))
                    throw TypeError(".query.ReserveExecuteRequest.pre_queries: array expected");
                message.pre_queries = [];
                for (var i = 0; i < object.pre_queries.length; ++i)
                    message.pre_queries[i] = String(object.pre_queries[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a ReserveExecuteRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.ReserveExecuteRequest
         * @static
         * @param {query.ReserveExecuteRequest} message ReserveExecuteRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReserveExecuteRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.pre_queries = [];
            if (options.defaults) {
                object.effective_caller_id = null;
                object.immediate_caller_id = null;
                object.target = null;
                object.query = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.transaction_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.transaction_id = options.longs === String ? "0" : 0;
                object.options = null;
            }
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id"))
                object.effective_caller_id = $root.vtrpc.CallerID.toObject(message.effective_caller_id, options);
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id"))
                object.immediate_caller_id = $root.query.VTGateCallerID.toObject(message.immediate_caller_id, options);
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.query.Target.toObject(message.target, options);
            if (message.query != null && message.hasOwnProperty("query"))
                object.query = $root.query.BoundQuery.toObject(message.query, options);
            if (message.transaction_id != null && message.hasOwnProperty("transaction_id"))
                if (typeof message.transaction_id === "number")
                    object.transaction_id = options.longs === String ? String(message.transaction_id) : message.transaction_id;
                else
                    object.transaction_id = options.longs === String ? $util.Long.prototype.toString.call(message.transaction_id) : options.longs === Number ? new $util.LongBits(message.transaction_id.low >>> 0, message.transaction_id.high >>> 0).toNumber() : message.transaction_id;
            if (message.options != null && message.hasOwnProperty("options"))
                object.options = $root.query.ExecuteOptions.toObject(message.options, options);
            if (message.pre_queries && message.pre_queries.length) {
                object.pre_queries = [];
                for (var j = 0; j < message.pre_queries.length; ++j)
                    object.pre_queries[j] = message.pre_queries[j];
            }
            return object;
        };

        /**
         * Converts this ReserveExecuteRequest to JSON.
         * @function toJSON
         * @memberof query.ReserveExecuteRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReserveExecuteRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ReserveExecuteRequest;
    })();

    query.ReserveExecuteResponse = (function() {

        /**
         * Properties of a ReserveExecuteResponse.
         * @memberof query
         * @interface IReserveExecuteResponse
         * @property {vtrpc.IRPCError|null} [error] ReserveExecuteResponse error
         * @property {query.IQueryResult|null} [result] ReserveExecuteResponse result
         * @property {number|Long|null} [reserved_id] ReserveExecuteResponse reserved_id
         * @property {topodata.ITabletAlias|null} [tablet_alias] ReserveExecuteResponse tablet_alias
         */

        /**
         * Constructs a new ReserveExecuteResponse.
         * @memberof query
         * @classdesc Represents a ReserveExecuteResponse.
         * @implements IReserveExecuteResponse
         * @constructor
         * @param {query.IReserveExecuteResponse=} [properties] Properties to set
         */
        function ReserveExecuteResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReserveExecuteResponse error.
         * @member {vtrpc.IRPCError|null|undefined} error
         * @memberof query.ReserveExecuteResponse
         * @instance
         */
        ReserveExecuteResponse.prototype.error = null;

        /**
         * ReserveExecuteResponse result.
         * @member {query.IQueryResult|null|undefined} result
         * @memberof query.ReserveExecuteResponse
         * @instance
         */
        ReserveExecuteResponse.prototype.result = null;

        /**
         * ReserveExecuteResponse reserved_id.
         * @member {number|Long} reserved_id
         * @memberof query.ReserveExecuteResponse
         * @instance
         */
        ReserveExecuteResponse.prototype.reserved_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ReserveExecuteResponse tablet_alias.
         * @member {topodata.ITabletAlias|null|undefined} tablet_alias
         * @memberof query.ReserveExecuteResponse
         * @instance
         */
        ReserveExecuteResponse.prototype.tablet_alias = null;

        /**
         * Creates a new ReserveExecuteResponse instance using the specified properties.
         * @function create
         * @memberof query.ReserveExecuteResponse
         * @static
         * @param {query.IReserveExecuteResponse=} [properties] Properties to set
         * @returns {query.ReserveExecuteResponse} ReserveExecuteResponse instance
         */
        ReserveExecuteResponse.create = function create(properties) {
            return new ReserveExecuteResponse(properties);
        };

        /**
         * Encodes the specified ReserveExecuteResponse message. Does not implicitly {@link query.ReserveExecuteResponse.verify|verify} messages.
         * @function encode
         * @memberof query.ReserveExecuteResponse
         * @static
         * @param {query.IReserveExecuteResponse} message ReserveExecuteResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReserveExecuteResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                $root.vtrpc.RPCError.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                $root.query.QueryResult.encode(message.result, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.reserved_id != null && Object.hasOwnProperty.call(message, "reserved_id"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.reserved_id);
            if (message.tablet_alias != null && Object.hasOwnProperty.call(message, "tablet_alias"))
                $root.topodata.TabletAlias.encode(message.tablet_alias, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ReserveExecuteResponse message, length delimited. Does not implicitly {@link query.ReserveExecuteResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.ReserveExecuteResponse
         * @static
         * @param {query.IReserveExecuteResponse} message ReserveExecuteResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReserveExecuteResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReserveExecuteResponse message from the specified reader or buffer.
         * @function decode
         * @memberof query.ReserveExecuteResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.ReserveExecuteResponse} ReserveExecuteResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReserveExecuteResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.ReserveExecuteResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.error = $root.vtrpc.RPCError.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.result = $root.query.QueryResult.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.reserved_id = reader.int64();
                    break;
                case 4:
                    message.tablet_alias = $root.topodata.TabletAlias.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReserveExecuteResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.ReserveExecuteResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.ReserveExecuteResponse} ReserveExecuteResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReserveExecuteResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReserveExecuteResponse message.
         * @function verify
         * @memberof query.ReserveExecuteResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReserveExecuteResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.error != null && message.hasOwnProperty("error")) {
                var error = $root.vtrpc.RPCError.verify(message.error);
                if (error)
                    return "error." + error;
            }
            if (message.result != null && message.hasOwnProperty("result")) {
                var error = $root.query.QueryResult.verify(message.result);
                if (error)
                    return "result." + error;
            }
            if (message.reserved_id != null && message.hasOwnProperty("reserved_id"))
                if (!$util.isInteger(message.reserved_id) && !(message.reserved_id && $util.isInteger(message.reserved_id.low) && $util.isInteger(message.reserved_id.high)))
                    return "reserved_id: integer|Long expected";
            if (message.tablet_alias != null && message.hasOwnProperty("tablet_alias")) {
                var error = $root.topodata.TabletAlias.verify(message.tablet_alias);
                if (error)
                    return "tablet_alias." + error;
            }
            return null;
        };

        /**
         * Creates a ReserveExecuteResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.ReserveExecuteResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.ReserveExecuteResponse} ReserveExecuteResponse
         */
        ReserveExecuteResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.query.ReserveExecuteResponse)
                return object;
            var message = new $root.query.ReserveExecuteResponse();
            if (object.error != null) {
                if (typeof object.error !== "object")
                    throw TypeError(".query.ReserveExecuteResponse.error: object expected");
                message.error = $root.vtrpc.RPCError.fromObject(object.error);
            }
            if (object.result != null) {
                if (typeof object.result !== "object")
                    throw TypeError(".query.ReserveExecuteResponse.result: object expected");
                message.result = $root.query.QueryResult.fromObject(object.result);
            }
            if (object.reserved_id != null)
                if ($util.Long)
                    (message.reserved_id = $util.Long.fromValue(object.reserved_id)).unsigned = false;
                else if (typeof object.reserved_id === "string")
                    message.reserved_id = parseInt(object.reserved_id, 10);
                else if (typeof object.reserved_id === "number")
                    message.reserved_id = object.reserved_id;
                else if (typeof object.reserved_id === "object")
                    message.reserved_id = new $util.LongBits(object.reserved_id.low >>> 0, object.reserved_id.high >>> 0).toNumber();
            if (object.tablet_alias != null) {
                if (typeof object.tablet_alias !== "object")
                    throw TypeError(".query.ReserveExecuteResponse.tablet_alias: object expected");
                message.tablet_alias = $root.topodata.TabletAlias.fromObject(object.tablet_alias);
            }
            return message;
        };

        /**
         * Creates a plain object from a ReserveExecuteResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.ReserveExecuteResponse
         * @static
         * @param {query.ReserveExecuteResponse} message ReserveExecuteResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReserveExecuteResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.error = null;
                object.result = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.reserved_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.reserved_id = options.longs === String ? "0" : 0;
                object.tablet_alias = null;
            }
            if (message.error != null && message.hasOwnProperty("error"))
                object.error = $root.vtrpc.RPCError.toObject(message.error, options);
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = $root.query.QueryResult.toObject(message.result, options);
            if (message.reserved_id != null && message.hasOwnProperty("reserved_id"))
                if (typeof message.reserved_id === "number")
                    object.reserved_id = options.longs === String ? String(message.reserved_id) : message.reserved_id;
                else
                    object.reserved_id = options.longs === String ? $util.Long.prototype.toString.call(message.reserved_id) : options.longs === Number ? new $util.LongBits(message.reserved_id.low >>> 0, message.reserved_id.high >>> 0).toNumber() : message.reserved_id;
            if (message.tablet_alias != null && message.hasOwnProperty("tablet_alias"))
                object.tablet_alias = $root.topodata.TabletAlias.toObject(message.tablet_alias, options);
            return object;
        };

        /**
         * Converts this ReserveExecuteResponse to JSON.
         * @function toJSON
         * @memberof query.ReserveExecuteResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReserveExecuteResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ReserveExecuteResponse;
    })();

    query.ReserveBeginExecuteRequest = (function() {

        /**
         * Properties of a ReserveBeginExecuteRequest.
         * @memberof query
         * @interface IReserveBeginExecuteRequest
         * @property {vtrpc.ICallerID|null} [effective_caller_id] ReserveBeginExecuteRequest effective_caller_id
         * @property {query.IVTGateCallerID|null} [immediate_caller_id] ReserveBeginExecuteRequest immediate_caller_id
         * @property {query.ITarget|null} [target] ReserveBeginExecuteRequest target
         * @property {query.IBoundQuery|null} [query] ReserveBeginExecuteRequest query
         * @property {query.IExecuteOptions|null} [options] ReserveBeginExecuteRequest options
         * @property {Array.<string>|null} [pre_queries] ReserveBeginExecuteRequest pre_queries
         */

        /**
         * Constructs a new ReserveBeginExecuteRequest.
         * @memberof query
         * @classdesc Represents a ReserveBeginExecuteRequest.
         * @implements IReserveBeginExecuteRequest
         * @constructor
         * @param {query.IReserveBeginExecuteRequest=} [properties] Properties to set
         */
        function ReserveBeginExecuteRequest(properties) {
            this.pre_queries = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReserveBeginExecuteRequest effective_caller_id.
         * @member {vtrpc.ICallerID|null|undefined} effective_caller_id
         * @memberof query.ReserveBeginExecuteRequest
         * @instance
         */
        ReserveBeginExecuteRequest.prototype.effective_caller_id = null;

        /**
         * ReserveBeginExecuteRequest immediate_caller_id.
         * @member {query.IVTGateCallerID|null|undefined} immediate_caller_id
         * @memberof query.ReserveBeginExecuteRequest
         * @instance
         */
        ReserveBeginExecuteRequest.prototype.immediate_caller_id = null;

        /**
         * ReserveBeginExecuteRequest target.
         * @member {query.ITarget|null|undefined} target
         * @memberof query.ReserveBeginExecuteRequest
         * @instance
         */
        ReserveBeginExecuteRequest.prototype.target = null;

        /**
         * ReserveBeginExecuteRequest query.
         * @member {query.IBoundQuery|null|undefined} query
         * @memberof query.ReserveBeginExecuteRequest
         * @instance
         */
        ReserveBeginExecuteRequest.prototype.query = null;

        /**
         * ReserveBeginExecuteRequest options.
         * @member {query.IExecuteOptions|null|undefined} options
         * @memberof query.ReserveBeginExecuteRequest
         * @instance
         */
        ReserveBeginExecuteRequest.prototype.options = null;

        /**
         * ReserveBeginExecuteRequest pre_queries.
         * @member {Array.<string>} pre_queries
         * @memberof query.ReserveBeginExecuteRequest
         * @instance
         */
        ReserveBeginExecuteRequest.prototype.pre_queries = $util.emptyArray;

        /**
         * Creates a new ReserveBeginExecuteRequest instance using the specified properties.
         * @function create
         * @memberof query.ReserveBeginExecuteRequest
         * @static
         * @param {query.IReserveBeginExecuteRequest=} [properties] Properties to set
         * @returns {query.ReserveBeginExecuteRequest} ReserveBeginExecuteRequest instance
         */
        ReserveBeginExecuteRequest.create = function create(properties) {
            return new ReserveBeginExecuteRequest(properties);
        };

        /**
         * Encodes the specified ReserveBeginExecuteRequest message. Does not implicitly {@link query.ReserveBeginExecuteRequest.verify|verify} messages.
         * @function encode
         * @memberof query.ReserveBeginExecuteRequest
         * @static
         * @param {query.IReserveBeginExecuteRequest} message ReserveBeginExecuteRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReserveBeginExecuteRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.effective_caller_id != null && Object.hasOwnProperty.call(message, "effective_caller_id"))
                $root.vtrpc.CallerID.encode(message.effective_caller_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.immediate_caller_id != null && Object.hasOwnProperty.call(message, "immediate_caller_id"))
                $root.query.VTGateCallerID.encode(message.immediate_caller_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                $root.query.Target.encode(message.target, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                $root.query.BoundQuery.encode(message.query, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                $root.query.ExecuteOptions.encode(message.options, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.pre_queries != null && message.pre_queries.length)
                for (var i = 0; i < message.pre_queries.length; ++i)
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.pre_queries[i]);
            return writer;
        };

        /**
         * Encodes the specified ReserveBeginExecuteRequest message, length delimited. Does not implicitly {@link query.ReserveBeginExecuteRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.ReserveBeginExecuteRequest
         * @static
         * @param {query.IReserveBeginExecuteRequest} message ReserveBeginExecuteRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReserveBeginExecuteRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReserveBeginExecuteRequest message from the specified reader or buffer.
         * @function decode
         * @memberof query.ReserveBeginExecuteRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.ReserveBeginExecuteRequest} ReserveBeginExecuteRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReserveBeginExecuteRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.ReserveBeginExecuteRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.effective_caller_id = $root.vtrpc.CallerID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.immediate_caller_id = $root.query.VTGateCallerID.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.target = $root.query.Target.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.query = $root.query.BoundQuery.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.options = $root.query.ExecuteOptions.decode(reader, reader.uint32());
                    break;
                case 6:
                    if (!(message.pre_queries && message.pre_queries.length))
                        message.pre_queries = [];
                    message.pre_queries.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReserveBeginExecuteRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.ReserveBeginExecuteRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.ReserveBeginExecuteRequest} ReserveBeginExecuteRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReserveBeginExecuteRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReserveBeginExecuteRequest message.
         * @function verify
         * @memberof query.ReserveBeginExecuteRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReserveBeginExecuteRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id")) {
                var error = $root.vtrpc.CallerID.verify(message.effective_caller_id);
                if (error)
                    return "effective_caller_id." + error;
            }
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id")) {
                var error = $root.query.VTGateCallerID.verify(message.immediate_caller_id);
                if (error)
                    return "immediate_caller_id." + error;
            }
            if (message.target != null && message.hasOwnProperty("target")) {
                var error = $root.query.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.query != null && message.hasOwnProperty("query")) {
                var error = $root.query.BoundQuery.verify(message.query);
                if (error)
                    return "query." + error;
            }
            if (message.options != null && message.hasOwnProperty("options")) {
                var error = $root.query.ExecuteOptions.verify(message.options);
                if (error)
                    return "options." + error;
            }
            if (message.pre_queries != null && message.hasOwnProperty("pre_queries")) {
                if (!Array.isArray(message.pre_queries))
                    return "pre_queries: array expected";
                for (var i = 0; i < message.pre_queries.length; ++i)
                    if (!$util.isString(message.pre_queries[i]))
                        return "pre_queries: string[] expected";
            }
            return null;
        };

        /**
         * Creates a ReserveBeginExecuteRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.ReserveBeginExecuteRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.ReserveBeginExecuteRequest} ReserveBeginExecuteRequest
         */
        ReserveBeginExecuteRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.query.ReserveBeginExecuteRequest)
                return object;
            var message = new $root.query.ReserveBeginExecuteRequest();
            if (object.effective_caller_id != null) {
                if (typeof object.effective_caller_id !== "object")
                    throw TypeError(".query.ReserveBeginExecuteRequest.effective_caller_id: object expected");
                message.effective_caller_id = $root.vtrpc.CallerID.fromObject(object.effective_caller_id);
            }
            if (object.immediate_caller_id != null) {
                if (typeof object.immediate_caller_id !== "object")
                    throw TypeError(".query.ReserveBeginExecuteRequest.immediate_caller_id: object expected");
                message.immediate_caller_id = $root.query.VTGateCallerID.fromObject(object.immediate_caller_id);
            }
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".query.ReserveBeginExecuteRequest.target: object expected");
                message.target = $root.query.Target.fromObject(object.target);
            }
            if (object.query != null) {
                if (typeof object.query !== "object")
                    throw TypeError(".query.ReserveBeginExecuteRequest.query: object expected");
                message.query = $root.query.BoundQuery.fromObject(object.query);
            }
            if (object.options != null) {
                if (typeof object.options !== "object")
                    throw TypeError(".query.ReserveBeginExecuteRequest.options: object expected");
                message.options = $root.query.ExecuteOptions.fromObject(object.options);
            }
            if (object.pre_queries) {
                if (!Array.isArray(object.pre_queries))
                    throw TypeError(".query.ReserveBeginExecuteRequest.pre_queries: array expected");
                message.pre_queries = [];
                for (var i = 0; i < object.pre_queries.length; ++i)
                    message.pre_queries[i] = String(object.pre_queries[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a ReserveBeginExecuteRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.ReserveBeginExecuteRequest
         * @static
         * @param {query.ReserveBeginExecuteRequest} message ReserveBeginExecuteRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReserveBeginExecuteRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.pre_queries = [];
            if (options.defaults) {
                object.effective_caller_id = null;
                object.immediate_caller_id = null;
                object.target = null;
                object.query = null;
                object.options = null;
            }
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id"))
                object.effective_caller_id = $root.vtrpc.CallerID.toObject(message.effective_caller_id, options);
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id"))
                object.immediate_caller_id = $root.query.VTGateCallerID.toObject(message.immediate_caller_id, options);
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.query.Target.toObject(message.target, options);
            if (message.query != null && message.hasOwnProperty("query"))
                object.query = $root.query.BoundQuery.toObject(message.query, options);
            if (message.options != null && message.hasOwnProperty("options"))
                object.options = $root.query.ExecuteOptions.toObject(message.options, options);
            if (message.pre_queries && message.pre_queries.length) {
                object.pre_queries = [];
                for (var j = 0; j < message.pre_queries.length; ++j)
                    object.pre_queries[j] = message.pre_queries[j];
            }
            return object;
        };

        /**
         * Converts this ReserveBeginExecuteRequest to JSON.
         * @function toJSON
         * @memberof query.ReserveBeginExecuteRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReserveBeginExecuteRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ReserveBeginExecuteRequest;
    })();

    query.ReserveBeginExecuteResponse = (function() {

        /**
         * Properties of a ReserveBeginExecuteResponse.
         * @memberof query
         * @interface IReserveBeginExecuteResponse
         * @property {vtrpc.IRPCError|null} [error] ReserveBeginExecuteResponse error
         * @property {query.IQueryResult|null} [result] ReserveBeginExecuteResponse result
         * @property {number|Long|null} [transaction_id] ReserveBeginExecuteResponse transaction_id
         * @property {number|Long|null} [reserved_id] ReserveBeginExecuteResponse reserved_id
         * @property {topodata.ITabletAlias|null} [tablet_alias] ReserveBeginExecuteResponse tablet_alias
         */

        /**
         * Constructs a new ReserveBeginExecuteResponse.
         * @memberof query
         * @classdesc Represents a ReserveBeginExecuteResponse.
         * @implements IReserveBeginExecuteResponse
         * @constructor
         * @param {query.IReserveBeginExecuteResponse=} [properties] Properties to set
         */
        function ReserveBeginExecuteResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReserveBeginExecuteResponse error.
         * @member {vtrpc.IRPCError|null|undefined} error
         * @memberof query.ReserveBeginExecuteResponse
         * @instance
         */
        ReserveBeginExecuteResponse.prototype.error = null;

        /**
         * ReserveBeginExecuteResponse result.
         * @member {query.IQueryResult|null|undefined} result
         * @memberof query.ReserveBeginExecuteResponse
         * @instance
         */
        ReserveBeginExecuteResponse.prototype.result = null;

        /**
         * ReserveBeginExecuteResponse transaction_id.
         * @member {number|Long} transaction_id
         * @memberof query.ReserveBeginExecuteResponse
         * @instance
         */
        ReserveBeginExecuteResponse.prototype.transaction_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ReserveBeginExecuteResponse reserved_id.
         * @member {number|Long} reserved_id
         * @memberof query.ReserveBeginExecuteResponse
         * @instance
         */
        ReserveBeginExecuteResponse.prototype.reserved_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ReserveBeginExecuteResponse tablet_alias.
         * @member {topodata.ITabletAlias|null|undefined} tablet_alias
         * @memberof query.ReserveBeginExecuteResponse
         * @instance
         */
        ReserveBeginExecuteResponse.prototype.tablet_alias = null;

        /**
         * Creates a new ReserveBeginExecuteResponse instance using the specified properties.
         * @function create
         * @memberof query.ReserveBeginExecuteResponse
         * @static
         * @param {query.IReserveBeginExecuteResponse=} [properties] Properties to set
         * @returns {query.ReserveBeginExecuteResponse} ReserveBeginExecuteResponse instance
         */
        ReserveBeginExecuteResponse.create = function create(properties) {
            return new ReserveBeginExecuteResponse(properties);
        };

        /**
         * Encodes the specified ReserveBeginExecuteResponse message. Does not implicitly {@link query.ReserveBeginExecuteResponse.verify|verify} messages.
         * @function encode
         * @memberof query.ReserveBeginExecuteResponse
         * @static
         * @param {query.IReserveBeginExecuteResponse} message ReserveBeginExecuteResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReserveBeginExecuteResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                $root.vtrpc.RPCError.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                $root.query.QueryResult.encode(message.result, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.transaction_id != null && Object.hasOwnProperty.call(message, "transaction_id"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.transaction_id);
            if (message.reserved_id != null && Object.hasOwnProperty.call(message, "reserved_id"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.reserved_id);
            if (message.tablet_alias != null && Object.hasOwnProperty.call(message, "tablet_alias"))
                $root.topodata.TabletAlias.encode(message.tablet_alias, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ReserveBeginExecuteResponse message, length delimited. Does not implicitly {@link query.ReserveBeginExecuteResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.ReserveBeginExecuteResponse
         * @static
         * @param {query.IReserveBeginExecuteResponse} message ReserveBeginExecuteResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReserveBeginExecuteResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReserveBeginExecuteResponse message from the specified reader or buffer.
         * @function decode
         * @memberof query.ReserveBeginExecuteResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.ReserveBeginExecuteResponse} ReserveBeginExecuteResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReserveBeginExecuteResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.ReserveBeginExecuteResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.error = $root.vtrpc.RPCError.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.result = $root.query.QueryResult.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.transaction_id = reader.int64();
                    break;
                case 4:
                    message.reserved_id = reader.int64();
                    break;
                case 5:
                    message.tablet_alias = $root.topodata.TabletAlias.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReserveBeginExecuteResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.ReserveBeginExecuteResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.ReserveBeginExecuteResponse} ReserveBeginExecuteResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReserveBeginExecuteResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReserveBeginExecuteResponse message.
         * @function verify
         * @memberof query.ReserveBeginExecuteResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReserveBeginExecuteResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.error != null && message.hasOwnProperty("error")) {
                var error = $root.vtrpc.RPCError.verify(message.error);
                if (error)
                    return "error." + error;
            }
            if (message.result != null && message.hasOwnProperty("result")) {
                var error = $root.query.QueryResult.verify(message.result);
                if (error)
                    return "result." + error;
            }
            if (message.transaction_id != null && message.hasOwnProperty("transaction_id"))
                if (!$util.isInteger(message.transaction_id) && !(message.transaction_id && $util.isInteger(message.transaction_id.low) && $util.isInteger(message.transaction_id.high)))
                    return "transaction_id: integer|Long expected";
            if (message.reserved_id != null && message.hasOwnProperty("reserved_id"))
                if (!$util.isInteger(message.reserved_id) && !(message.reserved_id && $util.isInteger(message.reserved_id.low) && $util.isInteger(message.reserved_id.high)))
                    return "reserved_id: integer|Long expected";
            if (message.tablet_alias != null && message.hasOwnProperty("tablet_alias")) {
                var error = $root.topodata.TabletAlias.verify(message.tablet_alias);
                if (error)
                    return "tablet_alias." + error;
            }
            return null;
        };

        /**
         * Creates a ReserveBeginExecuteResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.ReserveBeginExecuteResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.ReserveBeginExecuteResponse} ReserveBeginExecuteResponse
         */
        ReserveBeginExecuteResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.query.ReserveBeginExecuteResponse)
                return object;
            var message = new $root.query.ReserveBeginExecuteResponse();
            if (object.error != null) {
                if (typeof object.error !== "object")
                    throw TypeError(".query.ReserveBeginExecuteResponse.error: object expected");
                message.error = $root.vtrpc.RPCError.fromObject(object.error);
            }
            if (object.result != null) {
                if (typeof object.result !== "object")
                    throw TypeError(".query.ReserveBeginExecuteResponse.result: object expected");
                message.result = $root.query.QueryResult.fromObject(object.result);
            }
            if (object.transaction_id != null)
                if ($util.Long)
                    (message.transaction_id = $util.Long.fromValue(object.transaction_id)).unsigned = false;
                else if (typeof object.transaction_id === "string")
                    message.transaction_id = parseInt(object.transaction_id, 10);
                else if (typeof object.transaction_id === "number")
                    message.transaction_id = object.transaction_id;
                else if (typeof object.transaction_id === "object")
                    message.transaction_id = new $util.LongBits(object.transaction_id.low >>> 0, object.transaction_id.high >>> 0).toNumber();
            if (object.reserved_id != null)
                if ($util.Long)
                    (message.reserved_id = $util.Long.fromValue(object.reserved_id)).unsigned = false;
                else if (typeof object.reserved_id === "string")
                    message.reserved_id = parseInt(object.reserved_id, 10);
                else if (typeof object.reserved_id === "number")
                    message.reserved_id = object.reserved_id;
                else if (typeof object.reserved_id === "object")
                    message.reserved_id = new $util.LongBits(object.reserved_id.low >>> 0, object.reserved_id.high >>> 0).toNumber();
            if (object.tablet_alias != null) {
                if (typeof object.tablet_alias !== "object")
                    throw TypeError(".query.ReserveBeginExecuteResponse.tablet_alias: object expected");
                message.tablet_alias = $root.topodata.TabletAlias.fromObject(object.tablet_alias);
            }
            return message;
        };

        /**
         * Creates a plain object from a ReserveBeginExecuteResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.ReserveBeginExecuteResponse
         * @static
         * @param {query.ReserveBeginExecuteResponse} message ReserveBeginExecuteResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReserveBeginExecuteResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.error = null;
                object.result = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.transaction_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.transaction_id = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.reserved_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.reserved_id = options.longs === String ? "0" : 0;
                object.tablet_alias = null;
            }
            if (message.error != null && message.hasOwnProperty("error"))
                object.error = $root.vtrpc.RPCError.toObject(message.error, options);
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = $root.query.QueryResult.toObject(message.result, options);
            if (message.transaction_id != null && message.hasOwnProperty("transaction_id"))
                if (typeof message.transaction_id === "number")
                    object.transaction_id = options.longs === String ? String(message.transaction_id) : message.transaction_id;
                else
                    object.transaction_id = options.longs === String ? $util.Long.prototype.toString.call(message.transaction_id) : options.longs === Number ? new $util.LongBits(message.transaction_id.low >>> 0, message.transaction_id.high >>> 0).toNumber() : message.transaction_id;
            if (message.reserved_id != null && message.hasOwnProperty("reserved_id"))
                if (typeof message.reserved_id === "number")
                    object.reserved_id = options.longs === String ? String(message.reserved_id) : message.reserved_id;
                else
                    object.reserved_id = options.longs === String ? $util.Long.prototype.toString.call(message.reserved_id) : options.longs === Number ? new $util.LongBits(message.reserved_id.low >>> 0, message.reserved_id.high >>> 0).toNumber() : message.reserved_id;
            if (message.tablet_alias != null && message.hasOwnProperty("tablet_alias"))
                object.tablet_alias = $root.topodata.TabletAlias.toObject(message.tablet_alias, options);
            return object;
        };

        /**
         * Converts this ReserveBeginExecuteResponse to JSON.
         * @function toJSON
         * @memberof query.ReserveBeginExecuteResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReserveBeginExecuteResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ReserveBeginExecuteResponse;
    })();

    query.ReleaseRequest = (function() {

        /**
         * Properties of a ReleaseRequest.
         * @memberof query
         * @interface IReleaseRequest
         * @property {vtrpc.ICallerID|null} [effective_caller_id] ReleaseRequest effective_caller_id
         * @property {query.IVTGateCallerID|null} [immediate_caller_id] ReleaseRequest immediate_caller_id
         * @property {query.ITarget|null} [target] ReleaseRequest target
         * @property {number|Long|null} [transaction_id] ReleaseRequest transaction_id
         * @property {number|Long|null} [reserved_id] ReleaseRequest reserved_id
         */

        /**
         * Constructs a new ReleaseRequest.
         * @memberof query
         * @classdesc Represents a ReleaseRequest.
         * @implements IReleaseRequest
         * @constructor
         * @param {query.IReleaseRequest=} [properties] Properties to set
         */
        function ReleaseRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReleaseRequest effective_caller_id.
         * @member {vtrpc.ICallerID|null|undefined} effective_caller_id
         * @memberof query.ReleaseRequest
         * @instance
         */
        ReleaseRequest.prototype.effective_caller_id = null;

        /**
         * ReleaseRequest immediate_caller_id.
         * @member {query.IVTGateCallerID|null|undefined} immediate_caller_id
         * @memberof query.ReleaseRequest
         * @instance
         */
        ReleaseRequest.prototype.immediate_caller_id = null;

        /**
         * ReleaseRequest target.
         * @member {query.ITarget|null|undefined} target
         * @memberof query.ReleaseRequest
         * @instance
         */
        ReleaseRequest.prototype.target = null;

        /**
         * ReleaseRequest transaction_id.
         * @member {number|Long} transaction_id
         * @memberof query.ReleaseRequest
         * @instance
         */
        ReleaseRequest.prototype.transaction_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ReleaseRequest reserved_id.
         * @member {number|Long} reserved_id
         * @memberof query.ReleaseRequest
         * @instance
         */
        ReleaseRequest.prototype.reserved_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ReleaseRequest instance using the specified properties.
         * @function create
         * @memberof query.ReleaseRequest
         * @static
         * @param {query.IReleaseRequest=} [properties] Properties to set
         * @returns {query.ReleaseRequest} ReleaseRequest instance
         */
        ReleaseRequest.create = function create(properties) {
            return new ReleaseRequest(properties);
        };

        /**
         * Encodes the specified ReleaseRequest message. Does not implicitly {@link query.ReleaseRequest.verify|verify} messages.
         * @function encode
         * @memberof query.ReleaseRequest
         * @static
         * @param {query.IReleaseRequest} message ReleaseRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReleaseRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.effective_caller_id != null && Object.hasOwnProperty.call(message, "effective_caller_id"))
                $root.vtrpc.CallerID.encode(message.effective_caller_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.immediate_caller_id != null && Object.hasOwnProperty.call(message, "immediate_caller_id"))
                $root.query.VTGateCallerID.encode(message.immediate_caller_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                $root.query.Target.encode(message.target, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.transaction_id != null && Object.hasOwnProperty.call(message, "transaction_id"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.transaction_id);
            if (message.reserved_id != null && Object.hasOwnProperty.call(message, "reserved_id"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.reserved_id);
            return writer;
        };

        /**
         * Encodes the specified ReleaseRequest message, length delimited. Does not implicitly {@link query.ReleaseRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.ReleaseRequest
         * @static
         * @param {query.IReleaseRequest} message ReleaseRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReleaseRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReleaseRequest message from the specified reader or buffer.
         * @function decode
         * @memberof query.ReleaseRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.ReleaseRequest} ReleaseRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReleaseRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.ReleaseRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.effective_caller_id = $root.vtrpc.CallerID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.immediate_caller_id = $root.query.VTGateCallerID.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.target = $root.query.Target.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.transaction_id = reader.int64();
                    break;
                case 5:
                    message.reserved_id = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReleaseRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.ReleaseRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.ReleaseRequest} ReleaseRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReleaseRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReleaseRequest message.
         * @function verify
         * @memberof query.ReleaseRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReleaseRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id")) {
                var error = $root.vtrpc.CallerID.verify(message.effective_caller_id);
                if (error)
                    return "effective_caller_id." + error;
            }
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id")) {
                var error = $root.query.VTGateCallerID.verify(message.immediate_caller_id);
                if (error)
                    return "immediate_caller_id." + error;
            }
            if (message.target != null && message.hasOwnProperty("target")) {
                var error = $root.query.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.transaction_id != null && message.hasOwnProperty("transaction_id"))
                if (!$util.isInteger(message.transaction_id) && !(message.transaction_id && $util.isInteger(message.transaction_id.low) && $util.isInteger(message.transaction_id.high)))
                    return "transaction_id: integer|Long expected";
            if (message.reserved_id != null && message.hasOwnProperty("reserved_id"))
                if (!$util.isInteger(message.reserved_id) && !(message.reserved_id && $util.isInteger(message.reserved_id.low) && $util.isInteger(message.reserved_id.high)))
                    return "reserved_id: integer|Long expected";
            return null;
        };

        /**
         * Creates a ReleaseRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.ReleaseRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.ReleaseRequest} ReleaseRequest
         */
        ReleaseRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.query.ReleaseRequest)
                return object;
            var message = new $root.query.ReleaseRequest();
            if (object.effective_caller_id != null) {
                if (typeof object.effective_caller_id !== "object")
                    throw TypeError(".query.ReleaseRequest.effective_caller_id: object expected");
                message.effective_caller_id = $root.vtrpc.CallerID.fromObject(object.effective_caller_id);
            }
            if (object.immediate_caller_id != null) {
                if (typeof object.immediate_caller_id !== "object")
                    throw TypeError(".query.ReleaseRequest.immediate_caller_id: object expected");
                message.immediate_caller_id = $root.query.VTGateCallerID.fromObject(object.immediate_caller_id);
            }
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".query.ReleaseRequest.target: object expected");
                message.target = $root.query.Target.fromObject(object.target);
            }
            if (object.transaction_id != null)
                if ($util.Long)
                    (message.transaction_id = $util.Long.fromValue(object.transaction_id)).unsigned = false;
                else if (typeof object.transaction_id === "string")
                    message.transaction_id = parseInt(object.transaction_id, 10);
                else if (typeof object.transaction_id === "number")
                    message.transaction_id = object.transaction_id;
                else if (typeof object.transaction_id === "object")
                    message.transaction_id = new $util.LongBits(object.transaction_id.low >>> 0, object.transaction_id.high >>> 0).toNumber();
            if (object.reserved_id != null)
                if ($util.Long)
                    (message.reserved_id = $util.Long.fromValue(object.reserved_id)).unsigned = false;
                else if (typeof object.reserved_id === "string")
                    message.reserved_id = parseInt(object.reserved_id, 10);
                else if (typeof object.reserved_id === "number")
                    message.reserved_id = object.reserved_id;
                else if (typeof object.reserved_id === "object")
                    message.reserved_id = new $util.LongBits(object.reserved_id.low >>> 0, object.reserved_id.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a ReleaseRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.ReleaseRequest
         * @static
         * @param {query.ReleaseRequest} message ReleaseRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReleaseRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.effective_caller_id = null;
                object.immediate_caller_id = null;
                object.target = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.transaction_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.transaction_id = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.reserved_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.reserved_id = options.longs === String ? "0" : 0;
            }
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id"))
                object.effective_caller_id = $root.vtrpc.CallerID.toObject(message.effective_caller_id, options);
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id"))
                object.immediate_caller_id = $root.query.VTGateCallerID.toObject(message.immediate_caller_id, options);
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.query.Target.toObject(message.target, options);
            if (message.transaction_id != null && message.hasOwnProperty("transaction_id"))
                if (typeof message.transaction_id === "number")
                    object.transaction_id = options.longs === String ? String(message.transaction_id) : message.transaction_id;
                else
                    object.transaction_id = options.longs === String ? $util.Long.prototype.toString.call(message.transaction_id) : options.longs === Number ? new $util.LongBits(message.transaction_id.low >>> 0, message.transaction_id.high >>> 0).toNumber() : message.transaction_id;
            if (message.reserved_id != null && message.hasOwnProperty("reserved_id"))
                if (typeof message.reserved_id === "number")
                    object.reserved_id = options.longs === String ? String(message.reserved_id) : message.reserved_id;
                else
                    object.reserved_id = options.longs === String ? $util.Long.prototype.toString.call(message.reserved_id) : options.longs === Number ? new $util.LongBits(message.reserved_id.low >>> 0, message.reserved_id.high >>> 0).toNumber() : message.reserved_id;
            return object;
        };

        /**
         * Converts this ReleaseRequest to JSON.
         * @function toJSON
         * @memberof query.ReleaseRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReleaseRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ReleaseRequest;
    })();

    query.ReleaseResponse = (function() {

        /**
         * Properties of a ReleaseResponse.
         * @memberof query
         * @interface IReleaseResponse
         */

        /**
         * Constructs a new ReleaseResponse.
         * @memberof query
         * @classdesc Represents a ReleaseResponse.
         * @implements IReleaseResponse
         * @constructor
         * @param {query.IReleaseResponse=} [properties] Properties to set
         */
        function ReleaseResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ReleaseResponse instance using the specified properties.
         * @function create
         * @memberof query.ReleaseResponse
         * @static
         * @param {query.IReleaseResponse=} [properties] Properties to set
         * @returns {query.ReleaseResponse} ReleaseResponse instance
         */
        ReleaseResponse.create = function create(properties) {
            return new ReleaseResponse(properties);
        };

        /**
         * Encodes the specified ReleaseResponse message. Does not implicitly {@link query.ReleaseResponse.verify|verify} messages.
         * @function encode
         * @memberof query.ReleaseResponse
         * @static
         * @param {query.IReleaseResponse} message ReleaseResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReleaseResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ReleaseResponse message, length delimited. Does not implicitly {@link query.ReleaseResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.ReleaseResponse
         * @static
         * @param {query.IReleaseResponse} message ReleaseResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReleaseResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReleaseResponse message from the specified reader or buffer.
         * @function decode
         * @memberof query.ReleaseResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.ReleaseResponse} ReleaseResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReleaseResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.ReleaseResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReleaseResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.ReleaseResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.ReleaseResponse} ReleaseResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReleaseResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReleaseResponse message.
         * @function verify
         * @memberof query.ReleaseResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReleaseResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ReleaseResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.ReleaseResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.ReleaseResponse} ReleaseResponse
         */
        ReleaseResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.query.ReleaseResponse)
                return object;
            return new $root.query.ReleaseResponse();
        };

        /**
         * Creates a plain object from a ReleaseResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.ReleaseResponse
         * @static
         * @param {query.ReleaseResponse} message ReleaseResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReleaseResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ReleaseResponse to JSON.
         * @function toJSON
         * @memberof query.ReleaseResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReleaseResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ReleaseResponse;
    })();

    query.StreamHealthRequest = (function() {

        /**
         * Properties of a StreamHealthRequest.
         * @memberof query
         * @interface IStreamHealthRequest
         */

        /**
         * Constructs a new StreamHealthRequest.
         * @memberof query
         * @classdesc Represents a StreamHealthRequest.
         * @implements IStreamHealthRequest
         * @constructor
         * @param {query.IStreamHealthRequest=} [properties] Properties to set
         */
        function StreamHealthRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new StreamHealthRequest instance using the specified properties.
         * @function create
         * @memberof query.StreamHealthRequest
         * @static
         * @param {query.IStreamHealthRequest=} [properties] Properties to set
         * @returns {query.StreamHealthRequest} StreamHealthRequest instance
         */
        StreamHealthRequest.create = function create(properties) {
            return new StreamHealthRequest(properties);
        };

        /**
         * Encodes the specified StreamHealthRequest message. Does not implicitly {@link query.StreamHealthRequest.verify|verify} messages.
         * @function encode
         * @memberof query.StreamHealthRequest
         * @static
         * @param {query.IStreamHealthRequest} message StreamHealthRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamHealthRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified StreamHealthRequest message, length delimited. Does not implicitly {@link query.StreamHealthRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.StreamHealthRequest
         * @static
         * @param {query.IStreamHealthRequest} message StreamHealthRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamHealthRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StreamHealthRequest message from the specified reader or buffer.
         * @function decode
         * @memberof query.StreamHealthRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.StreamHealthRequest} StreamHealthRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamHealthRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.StreamHealthRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StreamHealthRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.StreamHealthRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.StreamHealthRequest} StreamHealthRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamHealthRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StreamHealthRequest message.
         * @function verify
         * @memberof query.StreamHealthRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StreamHealthRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a StreamHealthRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.StreamHealthRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.StreamHealthRequest} StreamHealthRequest
         */
        StreamHealthRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.query.StreamHealthRequest)
                return object;
            return new $root.query.StreamHealthRequest();
        };

        /**
         * Creates a plain object from a StreamHealthRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.StreamHealthRequest
         * @static
         * @param {query.StreamHealthRequest} message StreamHealthRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StreamHealthRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this StreamHealthRequest to JSON.
         * @function toJSON
         * @memberof query.StreamHealthRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StreamHealthRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StreamHealthRequest;
    })();

    query.RealtimeStats = (function() {

        /**
         * Properties of a RealtimeStats.
         * @memberof query
         * @interface IRealtimeStats
         * @property {string|null} [health_error] RealtimeStats health_error
         * @property {number|null} [seconds_behind_master] RealtimeStats seconds_behind_master
         * @property {number|null} [binlog_players_count] RealtimeStats binlog_players_count
         * @property {number|Long|null} [seconds_behind_master_filtered_replication] RealtimeStats seconds_behind_master_filtered_replication
         * @property {number|null} [cpu_usage] RealtimeStats cpu_usage
         * @property {number|null} [qps] RealtimeStats qps
         */

        /**
         * Constructs a new RealtimeStats.
         * @memberof query
         * @classdesc Represents a RealtimeStats.
         * @implements IRealtimeStats
         * @constructor
         * @param {query.IRealtimeStats=} [properties] Properties to set
         */
        function RealtimeStats(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RealtimeStats health_error.
         * @member {string} health_error
         * @memberof query.RealtimeStats
         * @instance
         */
        RealtimeStats.prototype.health_error = "";

        /**
         * RealtimeStats seconds_behind_master.
         * @member {number} seconds_behind_master
         * @memberof query.RealtimeStats
         * @instance
         */
        RealtimeStats.prototype.seconds_behind_master = 0;

        /**
         * RealtimeStats binlog_players_count.
         * @member {number} binlog_players_count
         * @memberof query.RealtimeStats
         * @instance
         */
        RealtimeStats.prototype.binlog_players_count = 0;

        /**
         * RealtimeStats seconds_behind_master_filtered_replication.
         * @member {number|Long} seconds_behind_master_filtered_replication
         * @memberof query.RealtimeStats
         * @instance
         */
        RealtimeStats.prototype.seconds_behind_master_filtered_replication = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RealtimeStats cpu_usage.
         * @member {number} cpu_usage
         * @memberof query.RealtimeStats
         * @instance
         */
        RealtimeStats.prototype.cpu_usage = 0;

        /**
         * RealtimeStats qps.
         * @member {number} qps
         * @memberof query.RealtimeStats
         * @instance
         */
        RealtimeStats.prototype.qps = 0;

        /**
         * Creates a new RealtimeStats instance using the specified properties.
         * @function create
         * @memberof query.RealtimeStats
         * @static
         * @param {query.IRealtimeStats=} [properties] Properties to set
         * @returns {query.RealtimeStats} RealtimeStats instance
         */
        RealtimeStats.create = function create(properties) {
            return new RealtimeStats(properties);
        };

        /**
         * Encodes the specified RealtimeStats message. Does not implicitly {@link query.RealtimeStats.verify|verify} messages.
         * @function encode
         * @memberof query.RealtimeStats
         * @static
         * @param {query.IRealtimeStats} message RealtimeStats message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RealtimeStats.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.health_error != null && Object.hasOwnProperty.call(message, "health_error"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.health_error);
            if (message.seconds_behind_master != null && Object.hasOwnProperty.call(message, "seconds_behind_master"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.seconds_behind_master);
            if (message.binlog_players_count != null && Object.hasOwnProperty.call(message, "binlog_players_count"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.binlog_players_count);
            if (message.seconds_behind_master_filtered_replication != null && Object.hasOwnProperty.call(message, "seconds_behind_master_filtered_replication"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.seconds_behind_master_filtered_replication);
            if (message.cpu_usage != null && Object.hasOwnProperty.call(message, "cpu_usage"))
                writer.uint32(/* id 5, wireType 1 =*/41).double(message.cpu_usage);
            if (message.qps != null && Object.hasOwnProperty.call(message, "qps"))
                writer.uint32(/* id 6, wireType 1 =*/49).double(message.qps);
            return writer;
        };

        /**
         * Encodes the specified RealtimeStats message, length delimited. Does not implicitly {@link query.RealtimeStats.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.RealtimeStats
         * @static
         * @param {query.IRealtimeStats} message RealtimeStats message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RealtimeStats.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RealtimeStats message from the specified reader or buffer.
         * @function decode
         * @memberof query.RealtimeStats
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.RealtimeStats} RealtimeStats
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RealtimeStats.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.RealtimeStats();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.health_error = reader.string();
                    break;
                case 2:
                    message.seconds_behind_master = reader.uint32();
                    break;
                case 3:
                    message.binlog_players_count = reader.int32();
                    break;
                case 4:
                    message.seconds_behind_master_filtered_replication = reader.int64();
                    break;
                case 5:
                    message.cpu_usage = reader.double();
                    break;
                case 6:
                    message.qps = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RealtimeStats message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.RealtimeStats
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.RealtimeStats} RealtimeStats
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RealtimeStats.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RealtimeStats message.
         * @function verify
         * @memberof query.RealtimeStats
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RealtimeStats.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.health_error != null && message.hasOwnProperty("health_error"))
                if (!$util.isString(message.health_error))
                    return "health_error: string expected";
            if (message.seconds_behind_master != null && message.hasOwnProperty("seconds_behind_master"))
                if (!$util.isInteger(message.seconds_behind_master))
                    return "seconds_behind_master: integer expected";
            if (message.binlog_players_count != null && message.hasOwnProperty("binlog_players_count"))
                if (!$util.isInteger(message.binlog_players_count))
                    return "binlog_players_count: integer expected";
            if (message.seconds_behind_master_filtered_replication != null && message.hasOwnProperty("seconds_behind_master_filtered_replication"))
                if (!$util.isInteger(message.seconds_behind_master_filtered_replication) && !(message.seconds_behind_master_filtered_replication && $util.isInteger(message.seconds_behind_master_filtered_replication.low) && $util.isInteger(message.seconds_behind_master_filtered_replication.high)))
                    return "seconds_behind_master_filtered_replication: integer|Long expected";
            if (message.cpu_usage != null && message.hasOwnProperty("cpu_usage"))
                if (typeof message.cpu_usage !== "number")
                    return "cpu_usage: number expected";
            if (message.qps != null && message.hasOwnProperty("qps"))
                if (typeof message.qps !== "number")
                    return "qps: number expected";
            return null;
        };

        /**
         * Creates a RealtimeStats message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.RealtimeStats
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.RealtimeStats} RealtimeStats
         */
        RealtimeStats.fromObject = function fromObject(object) {
            if (object instanceof $root.query.RealtimeStats)
                return object;
            var message = new $root.query.RealtimeStats();
            if (object.health_error != null)
                message.health_error = String(object.health_error);
            if (object.seconds_behind_master != null)
                message.seconds_behind_master = object.seconds_behind_master >>> 0;
            if (object.binlog_players_count != null)
                message.binlog_players_count = object.binlog_players_count | 0;
            if (object.seconds_behind_master_filtered_replication != null)
                if ($util.Long)
                    (message.seconds_behind_master_filtered_replication = $util.Long.fromValue(object.seconds_behind_master_filtered_replication)).unsigned = false;
                else if (typeof object.seconds_behind_master_filtered_replication === "string")
                    message.seconds_behind_master_filtered_replication = parseInt(object.seconds_behind_master_filtered_replication, 10);
                else if (typeof object.seconds_behind_master_filtered_replication === "number")
                    message.seconds_behind_master_filtered_replication = object.seconds_behind_master_filtered_replication;
                else if (typeof object.seconds_behind_master_filtered_replication === "object")
                    message.seconds_behind_master_filtered_replication = new $util.LongBits(object.seconds_behind_master_filtered_replication.low >>> 0, object.seconds_behind_master_filtered_replication.high >>> 0).toNumber();
            if (object.cpu_usage != null)
                message.cpu_usage = Number(object.cpu_usage);
            if (object.qps != null)
                message.qps = Number(object.qps);
            return message;
        };

        /**
         * Creates a plain object from a RealtimeStats message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.RealtimeStats
         * @static
         * @param {query.RealtimeStats} message RealtimeStats
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RealtimeStats.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.health_error = "";
                object.seconds_behind_master = 0;
                object.binlog_players_count = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.seconds_behind_master_filtered_replication = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.seconds_behind_master_filtered_replication = options.longs === String ? "0" : 0;
                object.cpu_usage = 0;
                object.qps = 0;
            }
            if (message.health_error != null && message.hasOwnProperty("health_error"))
                object.health_error = message.health_error;
            if (message.seconds_behind_master != null && message.hasOwnProperty("seconds_behind_master"))
                object.seconds_behind_master = message.seconds_behind_master;
            if (message.binlog_players_count != null && message.hasOwnProperty("binlog_players_count"))
                object.binlog_players_count = message.binlog_players_count;
            if (message.seconds_behind_master_filtered_replication != null && message.hasOwnProperty("seconds_behind_master_filtered_replication"))
                if (typeof message.seconds_behind_master_filtered_replication === "number")
                    object.seconds_behind_master_filtered_replication = options.longs === String ? String(message.seconds_behind_master_filtered_replication) : message.seconds_behind_master_filtered_replication;
                else
                    object.seconds_behind_master_filtered_replication = options.longs === String ? $util.Long.prototype.toString.call(message.seconds_behind_master_filtered_replication) : options.longs === Number ? new $util.LongBits(message.seconds_behind_master_filtered_replication.low >>> 0, message.seconds_behind_master_filtered_replication.high >>> 0).toNumber() : message.seconds_behind_master_filtered_replication;
            if (message.cpu_usage != null && message.hasOwnProperty("cpu_usage"))
                object.cpu_usage = options.json && !isFinite(message.cpu_usage) ? String(message.cpu_usage) : message.cpu_usage;
            if (message.qps != null && message.hasOwnProperty("qps"))
                object.qps = options.json && !isFinite(message.qps) ? String(message.qps) : message.qps;
            return object;
        };

        /**
         * Converts this RealtimeStats to JSON.
         * @function toJSON
         * @memberof query.RealtimeStats
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RealtimeStats.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RealtimeStats;
    })();

    query.AggregateStats = (function() {

        /**
         * Properties of an AggregateStats.
         * @memberof query
         * @interface IAggregateStats
         * @property {number|null} [healthy_tablet_count] AggregateStats healthy_tablet_count
         * @property {number|null} [unhealthy_tablet_count] AggregateStats unhealthy_tablet_count
         * @property {number|null} [seconds_behind_master_min] AggregateStats seconds_behind_master_min
         * @property {number|null} [seconds_behind_master_max] AggregateStats seconds_behind_master_max
         */

        /**
         * Constructs a new AggregateStats.
         * @memberof query
         * @classdesc Represents an AggregateStats.
         * @implements IAggregateStats
         * @constructor
         * @param {query.IAggregateStats=} [properties] Properties to set
         */
        function AggregateStats(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AggregateStats healthy_tablet_count.
         * @member {number} healthy_tablet_count
         * @memberof query.AggregateStats
         * @instance
         */
        AggregateStats.prototype.healthy_tablet_count = 0;

        /**
         * AggregateStats unhealthy_tablet_count.
         * @member {number} unhealthy_tablet_count
         * @memberof query.AggregateStats
         * @instance
         */
        AggregateStats.prototype.unhealthy_tablet_count = 0;

        /**
         * AggregateStats seconds_behind_master_min.
         * @member {number} seconds_behind_master_min
         * @memberof query.AggregateStats
         * @instance
         */
        AggregateStats.prototype.seconds_behind_master_min = 0;

        /**
         * AggregateStats seconds_behind_master_max.
         * @member {number} seconds_behind_master_max
         * @memberof query.AggregateStats
         * @instance
         */
        AggregateStats.prototype.seconds_behind_master_max = 0;

        /**
         * Creates a new AggregateStats instance using the specified properties.
         * @function create
         * @memberof query.AggregateStats
         * @static
         * @param {query.IAggregateStats=} [properties] Properties to set
         * @returns {query.AggregateStats} AggregateStats instance
         */
        AggregateStats.create = function create(properties) {
            return new AggregateStats(properties);
        };

        /**
         * Encodes the specified AggregateStats message. Does not implicitly {@link query.AggregateStats.verify|verify} messages.
         * @function encode
         * @memberof query.AggregateStats
         * @static
         * @param {query.IAggregateStats} message AggregateStats message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AggregateStats.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.healthy_tablet_count != null && Object.hasOwnProperty.call(message, "healthy_tablet_count"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.healthy_tablet_count);
            if (message.unhealthy_tablet_count != null && Object.hasOwnProperty.call(message, "unhealthy_tablet_count"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.unhealthy_tablet_count);
            if (message.seconds_behind_master_min != null && Object.hasOwnProperty.call(message, "seconds_behind_master_min"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.seconds_behind_master_min);
            if (message.seconds_behind_master_max != null && Object.hasOwnProperty.call(message, "seconds_behind_master_max"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.seconds_behind_master_max);
            return writer;
        };

        /**
         * Encodes the specified AggregateStats message, length delimited. Does not implicitly {@link query.AggregateStats.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.AggregateStats
         * @static
         * @param {query.IAggregateStats} message AggregateStats message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AggregateStats.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AggregateStats message from the specified reader or buffer.
         * @function decode
         * @memberof query.AggregateStats
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.AggregateStats} AggregateStats
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AggregateStats.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.AggregateStats();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.healthy_tablet_count = reader.int32();
                    break;
                case 2:
                    message.unhealthy_tablet_count = reader.int32();
                    break;
                case 3:
                    message.seconds_behind_master_min = reader.uint32();
                    break;
                case 4:
                    message.seconds_behind_master_max = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AggregateStats message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.AggregateStats
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.AggregateStats} AggregateStats
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AggregateStats.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AggregateStats message.
         * @function verify
         * @memberof query.AggregateStats
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AggregateStats.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.healthy_tablet_count != null && message.hasOwnProperty("healthy_tablet_count"))
                if (!$util.isInteger(message.healthy_tablet_count))
                    return "healthy_tablet_count: integer expected";
            if (message.unhealthy_tablet_count != null && message.hasOwnProperty("unhealthy_tablet_count"))
                if (!$util.isInteger(message.unhealthy_tablet_count))
                    return "unhealthy_tablet_count: integer expected";
            if (message.seconds_behind_master_min != null && message.hasOwnProperty("seconds_behind_master_min"))
                if (!$util.isInteger(message.seconds_behind_master_min))
                    return "seconds_behind_master_min: integer expected";
            if (message.seconds_behind_master_max != null && message.hasOwnProperty("seconds_behind_master_max"))
                if (!$util.isInteger(message.seconds_behind_master_max))
                    return "seconds_behind_master_max: integer expected";
            return null;
        };

        /**
         * Creates an AggregateStats message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.AggregateStats
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.AggregateStats} AggregateStats
         */
        AggregateStats.fromObject = function fromObject(object) {
            if (object instanceof $root.query.AggregateStats)
                return object;
            var message = new $root.query.AggregateStats();
            if (object.healthy_tablet_count != null)
                message.healthy_tablet_count = object.healthy_tablet_count | 0;
            if (object.unhealthy_tablet_count != null)
                message.unhealthy_tablet_count = object.unhealthy_tablet_count | 0;
            if (object.seconds_behind_master_min != null)
                message.seconds_behind_master_min = object.seconds_behind_master_min >>> 0;
            if (object.seconds_behind_master_max != null)
                message.seconds_behind_master_max = object.seconds_behind_master_max >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an AggregateStats message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.AggregateStats
         * @static
         * @param {query.AggregateStats} message AggregateStats
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AggregateStats.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.healthy_tablet_count = 0;
                object.unhealthy_tablet_count = 0;
                object.seconds_behind_master_min = 0;
                object.seconds_behind_master_max = 0;
            }
            if (message.healthy_tablet_count != null && message.hasOwnProperty("healthy_tablet_count"))
                object.healthy_tablet_count = message.healthy_tablet_count;
            if (message.unhealthy_tablet_count != null && message.hasOwnProperty("unhealthy_tablet_count"))
                object.unhealthy_tablet_count = message.unhealthy_tablet_count;
            if (message.seconds_behind_master_min != null && message.hasOwnProperty("seconds_behind_master_min"))
                object.seconds_behind_master_min = message.seconds_behind_master_min;
            if (message.seconds_behind_master_max != null && message.hasOwnProperty("seconds_behind_master_max"))
                object.seconds_behind_master_max = message.seconds_behind_master_max;
            return object;
        };

        /**
         * Converts this AggregateStats to JSON.
         * @function toJSON
         * @memberof query.AggregateStats
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AggregateStats.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AggregateStats;
    })();

    query.StreamHealthResponse = (function() {

        /**
         * Properties of a StreamHealthResponse.
         * @memberof query
         * @interface IStreamHealthResponse
         * @property {query.ITarget|null} [target] StreamHealthResponse target
         * @property {boolean|null} [serving] StreamHealthResponse serving
         * @property {number|Long|null} [tablet_externally_reparented_timestamp] StreamHealthResponse tablet_externally_reparented_timestamp
         * @property {query.IRealtimeStats|null} [realtime_stats] StreamHealthResponse realtime_stats
         * @property {topodata.ITabletAlias|null} [tablet_alias] StreamHealthResponse tablet_alias
         */

        /**
         * Constructs a new StreamHealthResponse.
         * @memberof query
         * @classdesc Represents a StreamHealthResponse.
         * @implements IStreamHealthResponse
         * @constructor
         * @param {query.IStreamHealthResponse=} [properties] Properties to set
         */
        function StreamHealthResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StreamHealthResponse target.
         * @member {query.ITarget|null|undefined} target
         * @memberof query.StreamHealthResponse
         * @instance
         */
        StreamHealthResponse.prototype.target = null;

        /**
         * StreamHealthResponse serving.
         * @member {boolean} serving
         * @memberof query.StreamHealthResponse
         * @instance
         */
        StreamHealthResponse.prototype.serving = false;

        /**
         * StreamHealthResponse tablet_externally_reparented_timestamp.
         * @member {number|Long} tablet_externally_reparented_timestamp
         * @memberof query.StreamHealthResponse
         * @instance
         */
        StreamHealthResponse.prototype.tablet_externally_reparented_timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * StreamHealthResponse realtime_stats.
         * @member {query.IRealtimeStats|null|undefined} realtime_stats
         * @memberof query.StreamHealthResponse
         * @instance
         */
        StreamHealthResponse.prototype.realtime_stats = null;

        /**
         * StreamHealthResponse tablet_alias.
         * @member {topodata.ITabletAlias|null|undefined} tablet_alias
         * @memberof query.StreamHealthResponse
         * @instance
         */
        StreamHealthResponse.prototype.tablet_alias = null;

        /**
         * Creates a new StreamHealthResponse instance using the specified properties.
         * @function create
         * @memberof query.StreamHealthResponse
         * @static
         * @param {query.IStreamHealthResponse=} [properties] Properties to set
         * @returns {query.StreamHealthResponse} StreamHealthResponse instance
         */
        StreamHealthResponse.create = function create(properties) {
            return new StreamHealthResponse(properties);
        };

        /**
         * Encodes the specified StreamHealthResponse message. Does not implicitly {@link query.StreamHealthResponse.verify|verify} messages.
         * @function encode
         * @memberof query.StreamHealthResponse
         * @static
         * @param {query.IStreamHealthResponse} message StreamHealthResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamHealthResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                $root.query.Target.encode(message.target, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.serving != null && Object.hasOwnProperty.call(message, "serving"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.serving);
            if (message.tablet_externally_reparented_timestamp != null && Object.hasOwnProperty.call(message, "tablet_externally_reparented_timestamp"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.tablet_externally_reparented_timestamp);
            if (message.realtime_stats != null && Object.hasOwnProperty.call(message, "realtime_stats"))
                $root.query.RealtimeStats.encode(message.realtime_stats, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.tablet_alias != null && Object.hasOwnProperty.call(message, "tablet_alias"))
                $root.topodata.TabletAlias.encode(message.tablet_alias, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified StreamHealthResponse message, length delimited. Does not implicitly {@link query.StreamHealthResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.StreamHealthResponse
         * @static
         * @param {query.IStreamHealthResponse} message StreamHealthResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamHealthResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StreamHealthResponse message from the specified reader or buffer.
         * @function decode
         * @memberof query.StreamHealthResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.StreamHealthResponse} StreamHealthResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamHealthResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.StreamHealthResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.target = $root.query.Target.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.serving = reader.bool();
                    break;
                case 3:
                    message.tablet_externally_reparented_timestamp = reader.int64();
                    break;
                case 4:
                    message.realtime_stats = $root.query.RealtimeStats.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.tablet_alias = $root.topodata.TabletAlias.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StreamHealthResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.StreamHealthResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.StreamHealthResponse} StreamHealthResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamHealthResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StreamHealthResponse message.
         * @function verify
         * @memberof query.StreamHealthResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StreamHealthResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.target != null && message.hasOwnProperty("target")) {
                var error = $root.query.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.serving != null && message.hasOwnProperty("serving"))
                if (typeof message.serving !== "boolean")
                    return "serving: boolean expected";
            if (message.tablet_externally_reparented_timestamp != null && message.hasOwnProperty("tablet_externally_reparented_timestamp"))
                if (!$util.isInteger(message.tablet_externally_reparented_timestamp) && !(message.tablet_externally_reparented_timestamp && $util.isInteger(message.tablet_externally_reparented_timestamp.low) && $util.isInteger(message.tablet_externally_reparented_timestamp.high)))
                    return "tablet_externally_reparented_timestamp: integer|Long expected";
            if (message.realtime_stats != null && message.hasOwnProperty("realtime_stats")) {
                var error = $root.query.RealtimeStats.verify(message.realtime_stats);
                if (error)
                    return "realtime_stats." + error;
            }
            if (message.tablet_alias != null && message.hasOwnProperty("tablet_alias")) {
                var error = $root.topodata.TabletAlias.verify(message.tablet_alias);
                if (error)
                    return "tablet_alias." + error;
            }
            return null;
        };

        /**
         * Creates a StreamHealthResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.StreamHealthResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.StreamHealthResponse} StreamHealthResponse
         */
        StreamHealthResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.query.StreamHealthResponse)
                return object;
            var message = new $root.query.StreamHealthResponse();
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".query.StreamHealthResponse.target: object expected");
                message.target = $root.query.Target.fromObject(object.target);
            }
            if (object.serving != null)
                message.serving = Boolean(object.serving);
            if (object.tablet_externally_reparented_timestamp != null)
                if ($util.Long)
                    (message.tablet_externally_reparented_timestamp = $util.Long.fromValue(object.tablet_externally_reparented_timestamp)).unsigned = false;
                else if (typeof object.tablet_externally_reparented_timestamp === "string")
                    message.tablet_externally_reparented_timestamp = parseInt(object.tablet_externally_reparented_timestamp, 10);
                else if (typeof object.tablet_externally_reparented_timestamp === "number")
                    message.tablet_externally_reparented_timestamp = object.tablet_externally_reparented_timestamp;
                else if (typeof object.tablet_externally_reparented_timestamp === "object")
                    message.tablet_externally_reparented_timestamp = new $util.LongBits(object.tablet_externally_reparented_timestamp.low >>> 0, object.tablet_externally_reparented_timestamp.high >>> 0).toNumber();
            if (object.realtime_stats != null) {
                if (typeof object.realtime_stats !== "object")
                    throw TypeError(".query.StreamHealthResponse.realtime_stats: object expected");
                message.realtime_stats = $root.query.RealtimeStats.fromObject(object.realtime_stats);
            }
            if (object.tablet_alias != null) {
                if (typeof object.tablet_alias !== "object")
                    throw TypeError(".query.StreamHealthResponse.tablet_alias: object expected");
                message.tablet_alias = $root.topodata.TabletAlias.fromObject(object.tablet_alias);
            }
            return message;
        };

        /**
         * Creates a plain object from a StreamHealthResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.StreamHealthResponse
         * @static
         * @param {query.StreamHealthResponse} message StreamHealthResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StreamHealthResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.target = null;
                object.serving = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.tablet_externally_reparented_timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.tablet_externally_reparented_timestamp = options.longs === String ? "0" : 0;
                object.realtime_stats = null;
                object.tablet_alias = null;
            }
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.query.Target.toObject(message.target, options);
            if (message.serving != null && message.hasOwnProperty("serving"))
                object.serving = message.serving;
            if (message.tablet_externally_reparented_timestamp != null && message.hasOwnProperty("tablet_externally_reparented_timestamp"))
                if (typeof message.tablet_externally_reparented_timestamp === "number")
                    object.tablet_externally_reparented_timestamp = options.longs === String ? String(message.tablet_externally_reparented_timestamp) : message.tablet_externally_reparented_timestamp;
                else
                    object.tablet_externally_reparented_timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.tablet_externally_reparented_timestamp) : options.longs === Number ? new $util.LongBits(message.tablet_externally_reparented_timestamp.low >>> 0, message.tablet_externally_reparented_timestamp.high >>> 0).toNumber() : message.tablet_externally_reparented_timestamp;
            if (message.realtime_stats != null && message.hasOwnProperty("realtime_stats"))
                object.realtime_stats = $root.query.RealtimeStats.toObject(message.realtime_stats, options);
            if (message.tablet_alias != null && message.hasOwnProperty("tablet_alias"))
                object.tablet_alias = $root.topodata.TabletAlias.toObject(message.tablet_alias, options);
            return object;
        };

        /**
         * Converts this StreamHealthResponse to JSON.
         * @function toJSON
         * @memberof query.StreamHealthResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StreamHealthResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StreamHealthResponse;
    })();

    /**
     * TransactionState enum.
     * @name query.TransactionState
     * @enum {number}
     * @property {number} UNKNOWN=0 UNKNOWN value
     * @property {number} PREPARE=1 PREPARE value
     * @property {number} COMMIT=2 COMMIT value
     * @property {number} ROLLBACK=3 ROLLBACK value
     */
    query.TransactionState = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKNOWN"] = 0;
        values[valuesById[1] = "PREPARE"] = 1;
        values[valuesById[2] = "COMMIT"] = 2;
        values[valuesById[3] = "ROLLBACK"] = 3;
        return values;
    })();

    query.TransactionMetadata = (function() {

        /**
         * Properties of a TransactionMetadata.
         * @memberof query
         * @interface ITransactionMetadata
         * @property {string|null} [dtid] TransactionMetadata dtid
         * @property {query.TransactionState|null} [state] TransactionMetadata state
         * @property {number|Long|null} [time_created] TransactionMetadata time_created
         * @property {Array.<query.ITarget>|null} [participants] TransactionMetadata participants
         */

        /**
         * Constructs a new TransactionMetadata.
         * @memberof query
         * @classdesc Represents a TransactionMetadata.
         * @implements ITransactionMetadata
         * @constructor
         * @param {query.ITransactionMetadata=} [properties] Properties to set
         */
        function TransactionMetadata(properties) {
            this.participants = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TransactionMetadata dtid.
         * @member {string} dtid
         * @memberof query.TransactionMetadata
         * @instance
         */
        TransactionMetadata.prototype.dtid = "";

        /**
         * TransactionMetadata state.
         * @member {query.TransactionState} state
         * @memberof query.TransactionMetadata
         * @instance
         */
        TransactionMetadata.prototype.state = 0;

        /**
         * TransactionMetadata time_created.
         * @member {number|Long} time_created
         * @memberof query.TransactionMetadata
         * @instance
         */
        TransactionMetadata.prototype.time_created = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TransactionMetadata participants.
         * @member {Array.<query.ITarget>} participants
         * @memberof query.TransactionMetadata
         * @instance
         */
        TransactionMetadata.prototype.participants = $util.emptyArray;

        /**
         * Creates a new TransactionMetadata instance using the specified properties.
         * @function create
         * @memberof query.TransactionMetadata
         * @static
         * @param {query.ITransactionMetadata=} [properties] Properties to set
         * @returns {query.TransactionMetadata} TransactionMetadata instance
         */
        TransactionMetadata.create = function create(properties) {
            return new TransactionMetadata(properties);
        };

        /**
         * Encodes the specified TransactionMetadata message. Does not implicitly {@link query.TransactionMetadata.verify|verify} messages.
         * @function encode
         * @memberof query.TransactionMetadata
         * @static
         * @param {query.ITransactionMetadata} message TransactionMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionMetadata.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dtid != null && Object.hasOwnProperty.call(message, "dtid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.dtid);
            if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.state);
            if (message.time_created != null && Object.hasOwnProperty.call(message, "time_created"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.time_created);
            if (message.participants != null && message.participants.length)
                for (var i = 0; i < message.participants.length; ++i)
                    $root.query.Target.encode(message.participants[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TransactionMetadata message, length delimited. Does not implicitly {@link query.TransactionMetadata.verify|verify} messages.
         * @function encodeDelimited
         * @memberof query.TransactionMetadata
         * @static
         * @param {query.ITransactionMetadata} message TransactionMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionMetadata.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TransactionMetadata message from the specified reader or buffer.
         * @function decode
         * @memberof query.TransactionMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {query.TransactionMetadata} TransactionMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionMetadata.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.query.TransactionMetadata();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.dtid = reader.string();
                    break;
                case 2:
                    message.state = reader.int32();
                    break;
                case 3:
                    message.time_created = reader.int64();
                    break;
                case 4:
                    if (!(message.participants && message.participants.length))
                        message.participants = [];
                    message.participants.push($root.query.Target.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TransactionMetadata message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof query.TransactionMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {query.TransactionMetadata} TransactionMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionMetadata.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TransactionMetadata message.
         * @function verify
         * @memberof query.TransactionMetadata
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TransactionMetadata.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dtid != null && message.hasOwnProperty("dtid"))
                if (!$util.isString(message.dtid))
                    return "dtid: string expected";
            if (message.state != null && message.hasOwnProperty("state"))
                switch (message.state) {
                default:
                    return "state: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.time_created != null && message.hasOwnProperty("time_created"))
                if (!$util.isInteger(message.time_created) && !(message.time_created && $util.isInteger(message.time_created.low) && $util.isInteger(message.time_created.high)))
                    return "time_created: integer|Long expected";
            if (message.participants != null && message.hasOwnProperty("participants")) {
                if (!Array.isArray(message.participants))
                    return "participants: array expected";
                for (var i = 0; i < message.participants.length; ++i) {
                    var error = $root.query.Target.verify(message.participants[i]);
                    if (error)
                        return "participants." + error;
                }
            }
            return null;
        };

        /**
         * Creates a TransactionMetadata message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof query.TransactionMetadata
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {query.TransactionMetadata} TransactionMetadata
         */
        TransactionMetadata.fromObject = function fromObject(object) {
            if (object instanceof $root.query.TransactionMetadata)
                return object;
            var message = new $root.query.TransactionMetadata();
            if (object.dtid != null)
                message.dtid = String(object.dtid);
            switch (object.state) {
            case "UNKNOWN":
            case 0:
                message.state = 0;
                break;
            case "PREPARE":
            case 1:
                message.state = 1;
                break;
            case "COMMIT":
            case 2:
                message.state = 2;
                break;
            case "ROLLBACK":
            case 3:
                message.state = 3;
                break;
            }
            if (object.time_created != null)
                if ($util.Long)
                    (message.time_created = $util.Long.fromValue(object.time_created)).unsigned = false;
                else if (typeof object.time_created === "string")
                    message.time_created = parseInt(object.time_created, 10);
                else if (typeof object.time_created === "number")
                    message.time_created = object.time_created;
                else if (typeof object.time_created === "object")
                    message.time_created = new $util.LongBits(object.time_created.low >>> 0, object.time_created.high >>> 0).toNumber();
            if (object.participants) {
                if (!Array.isArray(object.participants))
                    throw TypeError(".query.TransactionMetadata.participants: array expected");
                message.participants = [];
                for (var i = 0; i < object.participants.length; ++i) {
                    if (typeof object.participants[i] !== "object")
                        throw TypeError(".query.TransactionMetadata.participants: object expected");
                    message.participants[i] = $root.query.Target.fromObject(object.participants[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a TransactionMetadata message. Also converts values to other types if specified.
         * @function toObject
         * @memberof query.TransactionMetadata
         * @static
         * @param {query.TransactionMetadata} message TransactionMetadata
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TransactionMetadata.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.participants = [];
            if (options.defaults) {
                object.dtid = "";
                object.state = options.enums === String ? "UNKNOWN" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.time_created = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.time_created = options.longs === String ? "0" : 0;
            }
            if (message.dtid != null && message.hasOwnProperty("dtid"))
                object.dtid = message.dtid;
            if (message.state != null && message.hasOwnProperty("state"))
                object.state = options.enums === String ? $root.query.TransactionState[message.state] : message.state;
            if (message.time_created != null && message.hasOwnProperty("time_created"))
                if (typeof message.time_created === "number")
                    object.time_created = options.longs === String ? String(message.time_created) : message.time_created;
                else
                    object.time_created = options.longs === String ? $util.Long.prototype.toString.call(message.time_created) : options.longs === Number ? new $util.LongBits(message.time_created.low >>> 0, message.time_created.high >>> 0).toNumber() : message.time_created;
            if (message.participants && message.participants.length) {
                object.participants = [];
                for (var j = 0; j < message.participants.length; ++j)
                    object.participants[j] = $root.query.Target.toObject(message.participants[j], options);
            }
            return object;
        };

        /**
         * Converts this TransactionMetadata to JSON.
         * @function toJSON
         * @memberof query.TransactionMetadata
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TransactionMetadata.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TransactionMetadata;
    })();

    return query;
})();

$root.topodata = (function() {

    /**
     * Namespace topodata.
     * @exports topodata
     * @namespace
     */
    var topodata = {};

    topodata.KeyRange = (function() {

        /**
         * Properties of a KeyRange.
         * @memberof topodata
         * @interface IKeyRange
         * @property {Uint8Array|null} [start] KeyRange start
         * @property {Uint8Array|null} [end] KeyRange end
         */

        /**
         * Constructs a new KeyRange.
         * @memberof topodata
         * @classdesc Represents a KeyRange.
         * @implements IKeyRange
         * @constructor
         * @param {topodata.IKeyRange=} [properties] Properties to set
         */
        function KeyRange(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * KeyRange start.
         * @member {Uint8Array} start
         * @memberof topodata.KeyRange
         * @instance
         */
        KeyRange.prototype.start = $util.newBuffer([]);

        /**
         * KeyRange end.
         * @member {Uint8Array} end
         * @memberof topodata.KeyRange
         * @instance
         */
        KeyRange.prototype.end = $util.newBuffer([]);

        /**
         * Creates a new KeyRange instance using the specified properties.
         * @function create
         * @memberof topodata.KeyRange
         * @static
         * @param {topodata.IKeyRange=} [properties] Properties to set
         * @returns {topodata.KeyRange} KeyRange instance
         */
        KeyRange.create = function create(properties) {
            return new KeyRange(properties);
        };

        /**
         * Encodes the specified KeyRange message. Does not implicitly {@link topodata.KeyRange.verify|verify} messages.
         * @function encode
         * @memberof topodata.KeyRange
         * @static
         * @param {topodata.IKeyRange} message KeyRange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeyRange.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.start);
            if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.end);
            return writer;
        };

        /**
         * Encodes the specified KeyRange message, length delimited. Does not implicitly {@link topodata.KeyRange.verify|verify} messages.
         * @function encodeDelimited
         * @memberof topodata.KeyRange
         * @static
         * @param {topodata.IKeyRange} message KeyRange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeyRange.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a KeyRange message from the specified reader or buffer.
         * @function decode
         * @memberof topodata.KeyRange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {topodata.KeyRange} KeyRange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyRange.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.topodata.KeyRange();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.start = reader.bytes();
                    break;
                case 2:
                    message.end = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a KeyRange message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof topodata.KeyRange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {topodata.KeyRange} KeyRange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyRange.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a KeyRange message.
         * @function verify
         * @memberof topodata.KeyRange
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        KeyRange.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.start != null && message.hasOwnProperty("start"))
                if (!(message.start && typeof message.start.length === "number" || $util.isString(message.start)))
                    return "start: buffer expected";
            if (message.end != null && message.hasOwnProperty("end"))
                if (!(message.end && typeof message.end.length === "number" || $util.isString(message.end)))
                    return "end: buffer expected";
            return null;
        };

        /**
         * Creates a KeyRange message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof topodata.KeyRange
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {topodata.KeyRange} KeyRange
         */
        KeyRange.fromObject = function fromObject(object) {
            if (object instanceof $root.topodata.KeyRange)
                return object;
            var message = new $root.topodata.KeyRange();
            if (object.start != null)
                if (typeof object.start === "string")
                    $util.base64.decode(object.start, message.start = $util.newBuffer($util.base64.length(object.start)), 0);
                else if (object.start.length)
                    message.start = object.start;
            if (object.end != null)
                if (typeof object.end === "string")
                    $util.base64.decode(object.end, message.end = $util.newBuffer($util.base64.length(object.end)), 0);
                else if (object.end.length)
                    message.end = object.end;
            return message;
        };

        /**
         * Creates a plain object from a KeyRange message. Also converts values to other types if specified.
         * @function toObject
         * @memberof topodata.KeyRange
         * @static
         * @param {topodata.KeyRange} message KeyRange
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        KeyRange.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.start = "";
                else {
                    object.start = [];
                    if (options.bytes !== Array)
                        object.start = $util.newBuffer(object.start);
                }
                if (options.bytes === String)
                    object.end = "";
                else {
                    object.end = [];
                    if (options.bytes !== Array)
                        object.end = $util.newBuffer(object.end);
                }
            }
            if (message.start != null && message.hasOwnProperty("start"))
                object.start = options.bytes === String ? $util.base64.encode(message.start, 0, message.start.length) : options.bytes === Array ? Array.prototype.slice.call(message.start) : message.start;
            if (message.end != null && message.hasOwnProperty("end"))
                object.end = options.bytes === String ? $util.base64.encode(message.end, 0, message.end.length) : options.bytes === Array ? Array.prototype.slice.call(message.end) : message.end;
            return object;
        };

        /**
         * Converts this KeyRange to JSON.
         * @function toJSON
         * @memberof topodata.KeyRange
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        KeyRange.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return KeyRange;
    })();

    /**
     * KeyspaceType enum.
     * @name topodata.KeyspaceType
     * @enum {number}
     * @property {number} NORMAL=0 NORMAL value
     * @property {number} SNAPSHOT=1 SNAPSHOT value
     */
    topodata.KeyspaceType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NORMAL"] = 0;
        values[valuesById[1] = "SNAPSHOT"] = 1;
        return values;
    })();

    /**
     * KeyspaceIdType enum.
     * @name topodata.KeyspaceIdType
     * @enum {number}
     * @property {number} UNSET=0 UNSET value
     * @property {number} UINT64=1 UINT64 value
     * @property {number} BYTES=2 BYTES value
     */
    topodata.KeyspaceIdType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNSET"] = 0;
        values[valuesById[1] = "UINT64"] = 1;
        values[valuesById[2] = "BYTES"] = 2;
        return values;
    })();

    topodata.TabletAlias = (function() {

        /**
         * Properties of a TabletAlias.
         * @memberof topodata
         * @interface ITabletAlias
         * @property {string|null} [cell] TabletAlias cell
         * @property {number|null} [uid] TabletAlias uid
         */

        /**
         * Constructs a new TabletAlias.
         * @memberof topodata
         * @classdesc Represents a TabletAlias.
         * @implements ITabletAlias
         * @constructor
         * @param {topodata.ITabletAlias=} [properties] Properties to set
         */
        function TabletAlias(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TabletAlias cell.
         * @member {string} cell
         * @memberof topodata.TabletAlias
         * @instance
         */
        TabletAlias.prototype.cell = "";

        /**
         * TabletAlias uid.
         * @member {number} uid
         * @memberof topodata.TabletAlias
         * @instance
         */
        TabletAlias.prototype.uid = 0;

        /**
         * Creates a new TabletAlias instance using the specified properties.
         * @function create
         * @memberof topodata.TabletAlias
         * @static
         * @param {topodata.ITabletAlias=} [properties] Properties to set
         * @returns {topodata.TabletAlias} TabletAlias instance
         */
        TabletAlias.create = function create(properties) {
            return new TabletAlias(properties);
        };

        /**
         * Encodes the specified TabletAlias message. Does not implicitly {@link topodata.TabletAlias.verify|verify} messages.
         * @function encode
         * @memberof topodata.TabletAlias
         * @static
         * @param {topodata.ITabletAlias} message TabletAlias message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TabletAlias.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cell != null && Object.hasOwnProperty.call(message, "cell"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.cell);
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.uid);
            return writer;
        };

        /**
         * Encodes the specified TabletAlias message, length delimited. Does not implicitly {@link topodata.TabletAlias.verify|verify} messages.
         * @function encodeDelimited
         * @memberof topodata.TabletAlias
         * @static
         * @param {topodata.ITabletAlias} message TabletAlias message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TabletAlias.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TabletAlias message from the specified reader or buffer.
         * @function decode
         * @memberof topodata.TabletAlias
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {topodata.TabletAlias} TabletAlias
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TabletAlias.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.topodata.TabletAlias();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.cell = reader.string();
                    break;
                case 2:
                    message.uid = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TabletAlias message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof topodata.TabletAlias
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {topodata.TabletAlias} TabletAlias
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TabletAlias.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TabletAlias message.
         * @function verify
         * @memberof topodata.TabletAlias
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TabletAlias.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cell != null && message.hasOwnProperty("cell"))
                if (!$util.isString(message.cell))
                    return "cell: string expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid))
                    return "uid: integer expected";
            return null;
        };

        /**
         * Creates a TabletAlias message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof topodata.TabletAlias
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {topodata.TabletAlias} TabletAlias
         */
        TabletAlias.fromObject = function fromObject(object) {
            if (object instanceof $root.topodata.TabletAlias)
                return object;
            var message = new $root.topodata.TabletAlias();
            if (object.cell != null)
                message.cell = String(object.cell);
            if (object.uid != null)
                message.uid = object.uid >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a TabletAlias message. Also converts values to other types if specified.
         * @function toObject
         * @memberof topodata.TabletAlias
         * @static
         * @param {topodata.TabletAlias} message TabletAlias
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TabletAlias.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.cell = "";
                object.uid = 0;
            }
            if (message.cell != null && message.hasOwnProperty("cell"))
                object.cell = message.cell;
            if (message.uid != null && message.hasOwnProperty("uid"))
                object.uid = message.uid;
            return object;
        };

        /**
         * Converts this TabletAlias to JSON.
         * @function toJSON
         * @memberof topodata.TabletAlias
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TabletAlias.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TabletAlias;
    })();

    /**
     * TabletType enum.
     * @name topodata.TabletType
     * @enum {number}
     * @property {number} UNKNOWN=0 UNKNOWN value
     * @property {number} MASTER=1 MASTER value
     * @property {number} REPLICA=2 REPLICA value
     * @property {number} RDONLY=3 RDONLY value
     * @property {number} BATCH=3 BATCH value
     * @property {number} SPARE=4 SPARE value
     * @property {number} EXPERIMENTAL=5 EXPERIMENTAL value
     * @property {number} BACKUP=6 BACKUP value
     * @property {number} RESTORE=7 RESTORE value
     * @property {number} DRAINED=8 DRAINED value
     */
    topodata.TabletType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKNOWN"] = 0;
        values[valuesById[1] = "MASTER"] = 1;
        values[valuesById[2] = "REPLICA"] = 2;
        values[valuesById[3] = "RDONLY"] = 3;
        values["BATCH"] = 3;
        values[valuesById[4] = "SPARE"] = 4;
        values[valuesById[5] = "EXPERIMENTAL"] = 5;
        values[valuesById[6] = "BACKUP"] = 6;
        values[valuesById[7] = "RESTORE"] = 7;
        values[valuesById[8] = "DRAINED"] = 8;
        return values;
    })();

    topodata.Tablet = (function() {

        /**
         * Properties of a Tablet.
         * @memberof topodata
         * @interface ITablet
         * @property {topodata.ITabletAlias|null} [alias] Tablet alias
         * @property {string|null} [hostname] Tablet hostname
         * @property {Object.<string,number>|null} [port_map] Tablet port_map
         * @property {string|null} [keyspace] Tablet keyspace
         * @property {string|null} [shard] Tablet shard
         * @property {topodata.IKeyRange|null} [key_range] Tablet key_range
         * @property {topodata.TabletType|null} [type] Tablet type
         * @property {string|null} [db_name_override] Tablet db_name_override
         * @property {Object.<string,string>|null} [tags] Tablet tags
         * @property {string|null} [mysql_hostname] Tablet mysql_hostname
         * @property {number|null} [mysql_port] Tablet mysql_port
         * @property {vttime.ITime|null} [master_term_start_time] Tablet master_term_start_time
         */

        /**
         * Constructs a new Tablet.
         * @memberof topodata
         * @classdesc Represents a Tablet.
         * @implements ITablet
         * @constructor
         * @param {topodata.ITablet=} [properties] Properties to set
         */
        function Tablet(properties) {
            this.port_map = {};
            this.tags = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Tablet alias.
         * @member {topodata.ITabletAlias|null|undefined} alias
         * @memberof topodata.Tablet
         * @instance
         */
        Tablet.prototype.alias = null;

        /**
         * Tablet hostname.
         * @member {string} hostname
         * @memberof topodata.Tablet
         * @instance
         */
        Tablet.prototype.hostname = "";

        /**
         * Tablet port_map.
         * @member {Object.<string,number>} port_map
         * @memberof topodata.Tablet
         * @instance
         */
        Tablet.prototype.port_map = $util.emptyObject;

        /**
         * Tablet keyspace.
         * @member {string} keyspace
         * @memberof topodata.Tablet
         * @instance
         */
        Tablet.prototype.keyspace = "";

        /**
         * Tablet shard.
         * @member {string} shard
         * @memberof topodata.Tablet
         * @instance
         */
        Tablet.prototype.shard = "";

        /**
         * Tablet key_range.
         * @member {topodata.IKeyRange|null|undefined} key_range
         * @memberof topodata.Tablet
         * @instance
         */
        Tablet.prototype.key_range = null;

        /**
         * Tablet type.
         * @member {topodata.TabletType} type
         * @memberof topodata.Tablet
         * @instance
         */
        Tablet.prototype.type = 0;

        /**
         * Tablet db_name_override.
         * @member {string} db_name_override
         * @memberof topodata.Tablet
         * @instance
         */
        Tablet.prototype.db_name_override = "";

        /**
         * Tablet tags.
         * @member {Object.<string,string>} tags
         * @memberof topodata.Tablet
         * @instance
         */
        Tablet.prototype.tags = $util.emptyObject;

        /**
         * Tablet mysql_hostname.
         * @member {string} mysql_hostname
         * @memberof topodata.Tablet
         * @instance
         */
        Tablet.prototype.mysql_hostname = "";

        /**
         * Tablet mysql_port.
         * @member {number} mysql_port
         * @memberof topodata.Tablet
         * @instance
         */
        Tablet.prototype.mysql_port = 0;

        /**
         * Tablet master_term_start_time.
         * @member {vttime.ITime|null|undefined} master_term_start_time
         * @memberof topodata.Tablet
         * @instance
         */
        Tablet.prototype.master_term_start_time = null;

        /**
         * Creates a new Tablet instance using the specified properties.
         * @function create
         * @memberof topodata.Tablet
         * @static
         * @param {topodata.ITablet=} [properties] Properties to set
         * @returns {topodata.Tablet} Tablet instance
         */
        Tablet.create = function create(properties) {
            return new Tablet(properties);
        };

        /**
         * Encodes the specified Tablet message. Does not implicitly {@link topodata.Tablet.verify|verify} messages.
         * @function encode
         * @memberof topodata.Tablet
         * @static
         * @param {topodata.ITablet} message Tablet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Tablet.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.alias != null && Object.hasOwnProperty.call(message, "alias"))
                $root.topodata.TabletAlias.encode(message.alias, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.hostname != null && Object.hasOwnProperty.call(message, "hostname"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.hostname);
            if (message.port_map != null && Object.hasOwnProperty.call(message, "port_map"))
                for (var keys = Object.keys(message.port_map), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).int32(message.port_map[keys[i]]).ldelim();
            if (message.keyspace != null && Object.hasOwnProperty.call(message, "keyspace"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.keyspace);
            if (message.shard != null && Object.hasOwnProperty.call(message, "shard"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.shard);
            if (message.key_range != null && Object.hasOwnProperty.call(message, "key_range"))
                $root.topodata.KeyRange.encode(message.key_range, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.type);
            if (message.db_name_override != null && Object.hasOwnProperty.call(message, "db_name_override"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.db_name_override);
            if (message.tags != null && Object.hasOwnProperty.call(message, "tags"))
                for (var keys = Object.keys(message.tags), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 10, wireType 2 =*/82).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.tags[keys[i]]).ldelim();
            if (message.mysql_hostname != null && Object.hasOwnProperty.call(message, "mysql_hostname"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.mysql_hostname);
            if (message.mysql_port != null && Object.hasOwnProperty.call(message, "mysql_port"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.mysql_port);
            if (message.master_term_start_time != null && Object.hasOwnProperty.call(message, "master_term_start_time"))
                $root.vttime.Time.encode(message.master_term_start_time, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Tablet message, length delimited. Does not implicitly {@link topodata.Tablet.verify|verify} messages.
         * @function encodeDelimited
         * @memberof topodata.Tablet
         * @static
         * @param {topodata.ITablet} message Tablet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Tablet.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Tablet message from the specified reader or buffer.
         * @function decode
         * @memberof topodata.Tablet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {topodata.Tablet} Tablet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Tablet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.topodata.Tablet(), key, value;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.alias = $root.topodata.TabletAlias.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.hostname = reader.string();
                    break;
                case 4:
                    if (message.port_map === $util.emptyObject)
                        message.port_map = {};
                    var end2 = reader.uint32() + reader.pos;
                    key = "";
                    value = 0;
                    while (reader.pos < end2) {
                        var tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.string();
                            break;
                        case 2:
                            value = reader.int32();
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.port_map[key] = value;
                    break;
                case 5:
                    message.keyspace = reader.string();
                    break;
                case 6:
                    message.shard = reader.string();
                    break;
                case 7:
                    message.key_range = $root.topodata.KeyRange.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.type = reader.int32();
                    break;
                case 9:
                    message.db_name_override = reader.string();
                    break;
                case 10:
                    if (message.tags === $util.emptyObject)
                        message.tags = {};
                    var end2 = reader.uint32() + reader.pos;
                    key = "";
                    value = "";
                    while (reader.pos < end2) {
                        var tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.string();
                            break;
                        case 2:
                            value = reader.string();
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.tags[key] = value;
                    break;
                case 12:
                    message.mysql_hostname = reader.string();
                    break;
                case 13:
                    message.mysql_port = reader.int32();
                    break;
                case 14:
                    message.master_term_start_time = $root.vttime.Time.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Tablet message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof topodata.Tablet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {topodata.Tablet} Tablet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Tablet.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Tablet message.
         * @function verify
         * @memberof topodata.Tablet
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Tablet.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.alias != null && message.hasOwnProperty("alias")) {
                var error = $root.topodata.TabletAlias.verify(message.alias);
                if (error)
                    return "alias." + error;
            }
            if (message.hostname != null && message.hasOwnProperty("hostname"))
                if (!$util.isString(message.hostname))
                    return "hostname: string expected";
            if (message.port_map != null && message.hasOwnProperty("port_map")) {
                if (!$util.isObject(message.port_map))
                    return "port_map: object expected";
                var key = Object.keys(message.port_map);
                for (var i = 0; i < key.length; ++i)
                    if (!$util.isInteger(message.port_map[key[i]]))
                        return "port_map: integer{k:string} expected";
            }
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                if (!$util.isString(message.keyspace))
                    return "keyspace: string expected";
            if (message.shard != null && message.hasOwnProperty("shard"))
                if (!$util.isString(message.shard))
                    return "shard: string expected";
            if (message.key_range != null && message.hasOwnProperty("key_range")) {
                var error = $root.topodata.KeyRange.verify(message.key_range);
                if (error)
                    return "key_range." + error;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                    break;
                }
            if (message.db_name_override != null && message.hasOwnProperty("db_name_override"))
                if (!$util.isString(message.db_name_override))
                    return "db_name_override: string expected";
            if (message.tags != null && message.hasOwnProperty("tags")) {
                if (!$util.isObject(message.tags))
                    return "tags: object expected";
                var key = Object.keys(message.tags);
                for (var i = 0; i < key.length; ++i)
                    if (!$util.isString(message.tags[key[i]]))
                        return "tags: string{k:string} expected";
            }
            if (message.mysql_hostname != null && message.hasOwnProperty("mysql_hostname"))
                if (!$util.isString(message.mysql_hostname))
                    return "mysql_hostname: string expected";
            if (message.mysql_port != null && message.hasOwnProperty("mysql_port"))
                if (!$util.isInteger(message.mysql_port))
                    return "mysql_port: integer expected";
            if (message.master_term_start_time != null && message.hasOwnProperty("master_term_start_time")) {
                var error = $root.vttime.Time.verify(message.master_term_start_time);
                if (error)
                    return "master_term_start_time." + error;
            }
            return null;
        };

        /**
         * Creates a Tablet message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof topodata.Tablet
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {topodata.Tablet} Tablet
         */
        Tablet.fromObject = function fromObject(object) {
            if (object instanceof $root.topodata.Tablet)
                return object;
            var message = new $root.topodata.Tablet();
            if (object.alias != null) {
                if (typeof object.alias !== "object")
                    throw TypeError(".topodata.Tablet.alias: object expected");
                message.alias = $root.topodata.TabletAlias.fromObject(object.alias);
            }
            if (object.hostname != null)
                message.hostname = String(object.hostname);
            if (object.port_map) {
                if (typeof object.port_map !== "object")
                    throw TypeError(".topodata.Tablet.port_map: object expected");
                message.port_map = {};
                for (var keys = Object.keys(object.port_map), i = 0; i < keys.length; ++i)
                    message.port_map[keys[i]] = object.port_map[keys[i]] | 0;
            }
            if (object.keyspace != null)
                message.keyspace = String(object.keyspace);
            if (object.shard != null)
                message.shard = String(object.shard);
            if (object.key_range != null) {
                if (typeof object.key_range !== "object")
                    throw TypeError(".topodata.Tablet.key_range: object expected");
                message.key_range = $root.topodata.KeyRange.fromObject(object.key_range);
            }
            switch (object.type) {
            case "UNKNOWN":
            case 0:
                message.type = 0;
                break;
            case "MASTER":
            case 1:
                message.type = 1;
                break;
            case "REPLICA":
            case 2:
                message.type = 2;
                break;
            case "RDONLY":
            case 3:
                message.type = 3;
                break;
            case "BATCH":
            case 3:
                message.type = 3;
                break;
            case "SPARE":
            case 4:
                message.type = 4;
                break;
            case "EXPERIMENTAL":
            case 5:
                message.type = 5;
                break;
            case "BACKUP":
            case 6:
                message.type = 6;
                break;
            case "RESTORE":
            case 7:
                message.type = 7;
                break;
            case "DRAINED":
            case 8:
                message.type = 8;
                break;
            }
            if (object.db_name_override != null)
                message.db_name_override = String(object.db_name_override);
            if (object.tags) {
                if (typeof object.tags !== "object")
                    throw TypeError(".topodata.Tablet.tags: object expected");
                message.tags = {};
                for (var keys = Object.keys(object.tags), i = 0; i < keys.length; ++i)
                    message.tags[keys[i]] = String(object.tags[keys[i]]);
            }
            if (object.mysql_hostname != null)
                message.mysql_hostname = String(object.mysql_hostname);
            if (object.mysql_port != null)
                message.mysql_port = object.mysql_port | 0;
            if (object.master_term_start_time != null) {
                if (typeof object.master_term_start_time !== "object")
                    throw TypeError(".topodata.Tablet.master_term_start_time: object expected");
                message.master_term_start_time = $root.vttime.Time.fromObject(object.master_term_start_time);
            }
            return message;
        };

        /**
         * Creates a plain object from a Tablet message. Also converts values to other types if specified.
         * @function toObject
         * @memberof topodata.Tablet
         * @static
         * @param {topodata.Tablet} message Tablet
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Tablet.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults) {
                object.port_map = {};
                object.tags = {};
            }
            if (options.defaults) {
                object.alias = null;
                object.hostname = "";
                object.keyspace = "";
                object.shard = "";
                object.key_range = null;
                object.type = options.enums === String ? "UNKNOWN" : 0;
                object.db_name_override = "";
                object.mysql_hostname = "";
                object.mysql_port = 0;
                object.master_term_start_time = null;
            }
            if (message.alias != null && message.hasOwnProperty("alias"))
                object.alias = $root.topodata.TabletAlias.toObject(message.alias, options);
            if (message.hostname != null && message.hasOwnProperty("hostname"))
                object.hostname = message.hostname;
            var keys2;
            if (message.port_map && (keys2 = Object.keys(message.port_map)).length) {
                object.port_map = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.port_map[keys2[j]] = message.port_map[keys2[j]];
            }
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                object.keyspace = message.keyspace;
            if (message.shard != null && message.hasOwnProperty("shard"))
                object.shard = message.shard;
            if (message.key_range != null && message.hasOwnProperty("key_range"))
                object.key_range = $root.topodata.KeyRange.toObject(message.key_range, options);
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.topodata.TabletType[message.type] : message.type;
            if (message.db_name_override != null && message.hasOwnProperty("db_name_override"))
                object.db_name_override = message.db_name_override;
            if (message.tags && (keys2 = Object.keys(message.tags)).length) {
                object.tags = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.tags[keys2[j]] = message.tags[keys2[j]];
            }
            if (message.mysql_hostname != null && message.hasOwnProperty("mysql_hostname"))
                object.mysql_hostname = message.mysql_hostname;
            if (message.mysql_port != null && message.hasOwnProperty("mysql_port"))
                object.mysql_port = message.mysql_port;
            if (message.master_term_start_time != null && message.hasOwnProperty("master_term_start_time"))
                object.master_term_start_time = $root.vttime.Time.toObject(message.master_term_start_time, options);
            return object;
        };

        /**
         * Converts this Tablet to JSON.
         * @function toJSON
         * @memberof topodata.Tablet
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Tablet.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Tablet;
    })();

    topodata.Shard = (function() {

        /**
         * Properties of a Shard.
         * @memberof topodata
         * @interface IShard
         * @property {topodata.ITabletAlias|null} [master_alias] Shard master_alias
         * @property {vttime.ITime|null} [master_term_start_time] Shard master_term_start_time
         * @property {topodata.IKeyRange|null} [key_range] Shard key_range
         * @property {Array.<topodata.Shard.IServedType>|null} [served_types] Shard served_types
         * @property {Array.<topodata.Shard.ISourceShard>|null} [source_shards] Shard source_shards
         * @property {Array.<topodata.Shard.ITabletControl>|null} [tablet_controls] Shard tablet_controls
         * @property {boolean|null} [is_master_serving] Shard is_master_serving
         */

        /**
         * Constructs a new Shard.
         * @memberof topodata
         * @classdesc Represents a Shard.
         * @implements IShard
         * @constructor
         * @param {topodata.IShard=} [properties] Properties to set
         */
        function Shard(properties) {
            this.served_types = [];
            this.source_shards = [];
            this.tablet_controls = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Shard master_alias.
         * @member {topodata.ITabletAlias|null|undefined} master_alias
         * @memberof topodata.Shard
         * @instance
         */
        Shard.prototype.master_alias = null;

        /**
         * Shard master_term_start_time.
         * @member {vttime.ITime|null|undefined} master_term_start_time
         * @memberof topodata.Shard
         * @instance
         */
        Shard.prototype.master_term_start_time = null;

        /**
         * Shard key_range.
         * @member {topodata.IKeyRange|null|undefined} key_range
         * @memberof topodata.Shard
         * @instance
         */
        Shard.prototype.key_range = null;

        /**
         * Shard served_types.
         * @member {Array.<topodata.Shard.IServedType>} served_types
         * @memberof topodata.Shard
         * @instance
         */
        Shard.prototype.served_types = $util.emptyArray;

        /**
         * Shard source_shards.
         * @member {Array.<topodata.Shard.ISourceShard>} source_shards
         * @memberof topodata.Shard
         * @instance
         */
        Shard.prototype.source_shards = $util.emptyArray;

        /**
         * Shard tablet_controls.
         * @member {Array.<topodata.Shard.ITabletControl>} tablet_controls
         * @memberof topodata.Shard
         * @instance
         */
        Shard.prototype.tablet_controls = $util.emptyArray;

        /**
         * Shard is_master_serving.
         * @member {boolean} is_master_serving
         * @memberof topodata.Shard
         * @instance
         */
        Shard.prototype.is_master_serving = false;

        /**
         * Creates a new Shard instance using the specified properties.
         * @function create
         * @memberof topodata.Shard
         * @static
         * @param {topodata.IShard=} [properties] Properties to set
         * @returns {topodata.Shard} Shard instance
         */
        Shard.create = function create(properties) {
            return new Shard(properties);
        };

        /**
         * Encodes the specified Shard message. Does not implicitly {@link topodata.Shard.verify|verify} messages.
         * @function encode
         * @memberof topodata.Shard
         * @static
         * @param {topodata.IShard} message Shard message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Shard.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.master_alias != null && Object.hasOwnProperty.call(message, "master_alias"))
                $root.topodata.TabletAlias.encode(message.master_alias, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.key_range != null && Object.hasOwnProperty.call(message, "key_range"))
                $root.topodata.KeyRange.encode(message.key_range, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.served_types != null && message.served_types.length)
                for (var i = 0; i < message.served_types.length; ++i)
                    $root.topodata.Shard.ServedType.encode(message.served_types[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.source_shards != null && message.source_shards.length)
                for (var i = 0; i < message.source_shards.length; ++i)
                    $root.topodata.Shard.SourceShard.encode(message.source_shards[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.tablet_controls != null && message.tablet_controls.length)
                for (var i = 0; i < message.tablet_controls.length; ++i)
                    $root.topodata.Shard.TabletControl.encode(message.tablet_controls[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.is_master_serving != null && Object.hasOwnProperty.call(message, "is_master_serving"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.is_master_serving);
            if (message.master_term_start_time != null && Object.hasOwnProperty.call(message, "master_term_start_time"))
                $root.vttime.Time.encode(message.master_term_start_time, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Shard message, length delimited. Does not implicitly {@link topodata.Shard.verify|verify} messages.
         * @function encodeDelimited
         * @memberof topodata.Shard
         * @static
         * @param {topodata.IShard} message Shard message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Shard.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Shard message from the specified reader or buffer.
         * @function decode
         * @memberof topodata.Shard
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {topodata.Shard} Shard
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Shard.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.topodata.Shard();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.master_alias = $root.topodata.TabletAlias.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.master_term_start_time = $root.vttime.Time.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.key_range = $root.topodata.KeyRange.decode(reader, reader.uint32());
                    break;
                case 3:
                    if (!(message.served_types && message.served_types.length))
                        message.served_types = [];
                    message.served_types.push($root.topodata.Shard.ServedType.decode(reader, reader.uint32()));
                    break;
                case 4:
                    if (!(message.source_shards && message.source_shards.length))
                        message.source_shards = [];
                    message.source_shards.push($root.topodata.Shard.SourceShard.decode(reader, reader.uint32()));
                    break;
                case 6:
                    if (!(message.tablet_controls && message.tablet_controls.length))
                        message.tablet_controls = [];
                    message.tablet_controls.push($root.topodata.Shard.TabletControl.decode(reader, reader.uint32()));
                    break;
                case 7:
                    message.is_master_serving = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Shard message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof topodata.Shard
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {topodata.Shard} Shard
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Shard.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Shard message.
         * @function verify
         * @memberof topodata.Shard
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Shard.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.master_alias != null && message.hasOwnProperty("master_alias")) {
                var error = $root.topodata.TabletAlias.verify(message.master_alias);
                if (error)
                    return "master_alias." + error;
            }
            if (message.master_term_start_time != null && message.hasOwnProperty("master_term_start_time")) {
                var error = $root.vttime.Time.verify(message.master_term_start_time);
                if (error)
                    return "master_term_start_time." + error;
            }
            if (message.key_range != null && message.hasOwnProperty("key_range")) {
                var error = $root.topodata.KeyRange.verify(message.key_range);
                if (error)
                    return "key_range." + error;
            }
            if (message.served_types != null && message.hasOwnProperty("served_types")) {
                if (!Array.isArray(message.served_types))
                    return "served_types: array expected";
                for (var i = 0; i < message.served_types.length; ++i) {
                    var error = $root.topodata.Shard.ServedType.verify(message.served_types[i]);
                    if (error)
                        return "served_types." + error;
                }
            }
            if (message.source_shards != null && message.hasOwnProperty("source_shards")) {
                if (!Array.isArray(message.source_shards))
                    return "source_shards: array expected";
                for (var i = 0; i < message.source_shards.length; ++i) {
                    var error = $root.topodata.Shard.SourceShard.verify(message.source_shards[i]);
                    if (error)
                        return "source_shards." + error;
                }
            }
            if (message.tablet_controls != null && message.hasOwnProperty("tablet_controls")) {
                if (!Array.isArray(message.tablet_controls))
                    return "tablet_controls: array expected";
                for (var i = 0; i < message.tablet_controls.length; ++i) {
                    var error = $root.topodata.Shard.TabletControl.verify(message.tablet_controls[i]);
                    if (error)
                        return "tablet_controls." + error;
                }
            }
            if (message.is_master_serving != null && message.hasOwnProperty("is_master_serving"))
                if (typeof message.is_master_serving !== "boolean")
                    return "is_master_serving: boolean expected";
            return null;
        };

        /**
         * Creates a Shard message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof topodata.Shard
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {topodata.Shard} Shard
         */
        Shard.fromObject = function fromObject(object) {
            if (object instanceof $root.topodata.Shard)
                return object;
            var message = new $root.topodata.Shard();
            if (object.master_alias != null) {
                if (typeof object.master_alias !== "object")
                    throw TypeError(".topodata.Shard.master_alias: object expected");
                message.master_alias = $root.topodata.TabletAlias.fromObject(object.master_alias);
            }
            if (object.master_term_start_time != null) {
                if (typeof object.master_term_start_time !== "object")
                    throw TypeError(".topodata.Shard.master_term_start_time: object expected");
                message.master_term_start_time = $root.vttime.Time.fromObject(object.master_term_start_time);
            }
            if (object.key_range != null) {
                if (typeof object.key_range !== "object")
                    throw TypeError(".topodata.Shard.key_range: object expected");
                message.key_range = $root.topodata.KeyRange.fromObject(object.key_range);
            }
            if (object.served_types) {
                if (!Array.isArray(object.served_types))
                    throw TypeError(".topodata.Shard.served_types: array expected");
                message.served_types = [];
                for (var i = 0; i < object.served_types.length; ++i) {
                    if (typeof object.served_types[i] !== "object")
                        throw TypeError(".topodata.Shard.served_types: object expected");
                    message.served_types[i] = $root.topodata.Shard.ServedType.fromObject(object.served_types[i]);
                }
            }
            if (object.source_shards) {
                if (!Array.isArray(object.source_shards))
                    throw TypeError(".topodata.Shard.source_shards: array expected");
                message.source_shards = [];
                for (var i = 0; i < object.source_shards.length; ++i) {
                    if (typeof object.source_shards[i] !== "object")
                        throw TypeError(".topodata.Shard.source_shards: object expected");
                    message.source_shards[i] = $root.topodata.Shard.SourceShard.fromObject(object.source_shards[i]);
                }
            }
            if (object.tablet_controls) {
                if (!Array.isArray(object.tablet_controls))
                    throw TypeError(".topodata.Shard.tablet_controls: array expected");
                message.tablet_controls = [];
                for (var i = 0; i < object.tablet_controls.length; ++i) {
                    if (typeof object.tablet_controls[i] !== "object")
                        throw TypeError(".topodata.Shard.tablet_controls: object expected");
                    message.tablet_controls[i] = $root.topodata.Shard.TabletControl.fromObject(object.tablet_controls[i]);
                }
            }
            if (object.is_master_serving != null)
                message.is_master_serving = Boolean(object.is_master_serving);
            return message;
        };

        /**
         * Creates a plain object from a Shard message. Also converts values to other types if specified.
         * @function toObject
         * @memberof topodata.Shard
         * @static
         * @param {topodata.Shard} message Shard
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Shard.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.served_types = [];
                object.source_shards = [];
                object.tablet_controls = [];
            }
            if (options.defaults) {
                object.master_alias = null;
                object.key_range = null;
                object.is_master_serving = false;
                object.master_term_start_time = null;
            }
            if (message.master_alias != null && message.hasOwnProperty("master_alias"))
                object.master_alias = $root.topodata.TabletAlias.toObject(message.master_alias, options);
            if (message.key_range != null && message.hasOwnProperty("key_range"))
                object.key_range = $root.topodata.KeyRange.toObject(message.key_range, options);
            if (message.served_types && message.served_types.length) {
                object.served_types = [];
                for (var j = 0; j < message.served_types.length; ++j)
                    object.served_types[j] = $root.topodata.Shard.ServedType.toObject(message.served_types[j], options);
            }
            if (message.source_shards && message.source_shards.length) {
                object.source_shards = [];
                for (var j = 0; j < message.source_shards.length; ++j)
                    object.source_shards[j] = $root.topodata.Shard.SourceShard.toObject(message.source_shards[j], options);
            }
            if (message.tablet_controls && message.tablet_controls.length) {
                object.tablet_controls = [];
                for (var j = 0; j < message.tablet_controls.length; ++j)
                    object.tablet_controls[j] = $root.topodata.Shard.TabletControl.toObject(message.tablet_controls[j], options);
            }
            if (message.is_master_serving != null && message.hasOwnProperty("is_master_serving"))
                object.is_master_serving = message.is_master_serving;
            if (message.master_term_start_time != null && message.hasOwnProperty("master_term_start_time"))
                object.master_term_start_time = $root.vttime.Time.toObject(message.master_term_start_time, options);
            return object;
        };

        /**
         * Converts this Shard to JSON.
         * @function toJSON
         * @memberof topodata.Shard
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Shard.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        Shard.ServedType = (function() {

            /**
             * Properties of a ServedType.
             * @memberof topodata.Shard
             * @interface IServedType
             * @property {topodata.TabletType|null} [tablet_type] ServedType tablet_type
             * @property {Array.<string>|null} [cells] ServedType cells
             */

            /**
             * Constructs a new ServedType.
             * @memberof topodata.Shard
             * @classdesc Represents a ServedType.
             * @implements IServedType
             * @constructor
             * @param {topodata.Shard.IServedType=} [properties] Properties to set
             */
            function ServedType(properties) {
                this.cells = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServedType tablet_type.
             * @member {topodata.TabletType} tablet_type
             * @memberof topodata.Shard.ServedType
             * @instance
             */
            ServedType.prototype.tablet_type = 0;

            /**
             * ServedType cells.
             * @member {Array.<string>} cells
             * @memberof topodata.Shard.ServedType
             * @instance
             */
            ServedType.prototype.cells = $util.emptyArray;

            /**
             * Creates a new ServedType instance using the specified properties.
             * @function create
             * @memberof topodata.Shard.ServedType
             * @static
             * @param {topodata.Shard.IServedType=} [properties] Properties to set
             * @returns {topodata.Shard.ServedType} ServedType instance
             */
            ServedType.create = function create(properties) {
                return new ServedType(properties);
            };

            /**
             * Encodes the specified ServedType message. Does not implicitly {@link topodata.Shard.ServedType.verify|verify} messages.
             * @function encode
             * @memberof topodata.Shard.ServedType
             * @static
             * @param {topodata.Shard.IServedType} message ServedType message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServedType.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tablet_type != null && Object.hasOwnProperty.call(message, "tablet_type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tablet_type);
                if (message.cells != null && message.cells.length)
                    for (var i = 0; i < message.cells.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.cells[i]);
                return writer;
            };

            /**
             * Encodes the specified ServedType message, length delimited. Does not implicitly {@link topodata.Shard.ServedType.verify|verify} messages.
             * @function encodeDelimited
             * @memberof topodata.Shard.ServedType
             * @static
             * @param {topodata.Shard.IServedType} message ServedType message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServedType.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ServedType message from the specified reader or buffer.
             * @function decode
             * @memberof topodata.Shard.ServedType
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {topodata.Shard.ServedType} ServedType
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServedType.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.topodata.Shard.ServedType();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tablet_type = reader.int32();
                        break;
                    case 2:
                        if (!(message.cells && message.cells.length))
                            message.cells = [];
                        message.cells.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ServedType message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof topodata.Shard.ServedType
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {topodata.Shard.ServedType} ServedType
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServedType.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ServedType message.
             * @function verify
             * @memberof topodata.Shard.ServedType
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ServedType.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tablet_type != null && message.hasOwnProperty("tablet_type"))
                    switch (message.tablet_type) {
                    default:
                        return "tablet_type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                        break;
                    }
                if (message.cells != null && message.hasOwnProperty("cells")) {
                    if (!Array.isArray(message.cells))
                        return "cells: array expected";
                    for (var i = 0; i < message.cells.length; ++i)
                        if (!$util.isString(message.cells[i]))
                            return "cells: string[] expected";
                }
                return null;
            };

            /**
             * Creates a ServedType message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof topodata.Shard.ServedType
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {topodata.Shard.ServedType} ServedType
             */
            ServedType.fromObject = function fromObject(object) {
                if (object instanceof $root.topodata.Shard.ServedType)
                    return object;
                var message = new $root.topodata.Shard.ServedType();
                switch (object.tablet_type) {
                case "UNKNOWN":
                case 0:
                    message.tablet_type = 0;
                    break;
                case "MASTER":
                case 1:
                    message.tablet_type = 1;
                    break;
                case "REPLICA":
                case 2:
                    message.tablet_type = 2;
                    break;
                case "RDONLY":
                case 3:
                    message.tablet_type = 3;
                    break;
                case "BATCH":
                case 3:
                    message.tablet_type = 3;
                    break;
                case "SPARE":
                case 4:
                    message.tablet_type = 4;
                    break;
                case "EXPERIMENTAL":
                case 5:
                    message.tablet_type = 5;
                    break;
                case "BACKUP":
                case 6:
                    message.tablet_type = 6;
                    break;
                case "RESTORE":
                case 7:
                    message.tablet_type = 7;
                    break;
                case "DRAINED":
                case 8:
                    message.tablet_type = 8;
                    break;
                }
                if (object.cells) {
                    if (!Array.isArray(object.cells))
                        throw TypeError(".topodata.Shard.ServedType.cells: array expected");
                    message.cells = [];
                    for (var i = 0; i < object.cells.length; ++i)
                        message.cells[i] = String(object.cells[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a ServedType message. Also converts values to other types if specified.
             * @function toObject
             * @memberof topodata.Shard.ServedType
             * @static
             * @param {topodata.Shard.ServedType} message ServedType
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServedType.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.cells = [];
                if (options.defaults)
                    object.tablet_type = options.enums === String ? "UNKNOWN" : 0;
                if (message.tablet_type != null && message.hasOwnProperty("tablet_type"))
                    object.tablet_type = options.enums === String ? $root.topodata.TabletType[message.tablet_type] : message.tablet_type;
                if (message.cells && message.cells.length) {
                    object.cells = [];
                    for (var j = 0; j < message.cells.length; ++j)
                        object.cells[j] = message.cells[j];
                }
                return object;
            };

            /**
             * Converts this ServedType to JSON.
             * @function toJSON
             * @memberof topodata.Shard.ServedType
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ServedType.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ServedType;
        })();

        Shard.SourceShard = (function() {

            /**
             * Properties of a SourceShard.
             * @memberof topodata.Shard
             * @interface ISourceShard
             * @property {number|null} [uid] SourceShard uid
             * @property {string|null} [keyspace] SourceShard keyspace
             * @property {string|null} [shard] SourceShard shard
             * @property {topodata.IKeyRange|null} [key_range] SourceShard key_range
             * @property {Array.<string>|null} [tables] SourceShard tables
             */

            /**
             * Constructs a new SourceShard.
             * @memberof topodata.Shard
             * @classdesc Represents a SourceShard.
             * @implements ISourceShard
             * @constructor
             * @param {topodata.Shard.ISourceShard=} [properties] Properties to set
             */
            function SourceShard(properties) {
                this.tables = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SourceShard uid.
             * @member {number} uid
             * @memberof topodata.Shard.SourceShard
             * @instance
             */
            SourceShard.prototype.uid = 0;

            /**
             * SourceShard keyspace.
             * @member {string} keyspace
             * @memberof topodata.Shard.SourceShard
             * @instance
             */
            SourceShard.prototype.keyspace = "";

            /**
             * SourceShard shard.
             * @member {string} shard
             * @memberof topodata.Shard.SourceShard
             * @instance
             */
            SourceShard.prototype.shard = "";

            /**
             * SourceShard key_range.
             * @member {topodata.IKeyRange|null|undefined} key_range
             * @memberof topodata.Shard.SourceShard
             * @instance
             */
            SourceShard.prototype.key_range = null;

            /**
             * SourceShard tables.
             * @member {Array.<string>} tables
             * @memberof topodata.Shard.SourceShard
             * @instance
             */
            SourceShard.prototype.tables = $util.emptyArray;

            /**
             * Creates a new SourceShard instance using the specified properties.
             * @function create
             * @memberof topodata.Shard.SourceShard
             * @static
             * @param {topodata.Shard.ISourceShard=} [properties] Properties to set
             * @returns {topodata.Shard.SourceShard} SourceShard instance
             */
            SourceShard.create = function create(properties) {
                return new SourceShard(properties);
            };

            /**
             * Encodes the specified SourceShard message. Does not implicitly {@link topodata.Shard.SourceShard.verify|verify} messages.
             * @function encode
             * @memberof topodata.Shard.SourceShard
             * @static
             * @param {topodata.Shard.ISourceShard} message SourceShard message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SourceShard.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.uid);
                if (message.keyspace != null && Object.hasOwnProperty.call(message, "keyspace"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.keyspace);
                if (message.shard != null && Object.hasOwnProperty.call(message, "shard"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.shard);
                if (message.key_range != null && Object.hasOwnProperty.call(message, "key_range"))
                    $root.topodata.KeyRange.encode(message.key_range, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.tables != null && message.tables.length)
                    for (var i = 0; i < message.tables.length; ++i)
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.tables[i]);
                return writer;
            };

            /**
             * Encodes the specified SourceShard message, length delimited. Does not implicitly {@link topodata.Shard.SourceShard.verify|verify} messages.
             * @function encodeDelimited
             * @memberof topodata.Shard.SourceShard
             * @static
             * @param {topodata.Shard.ISourceShard} message SourceShard message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SourceShard.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SourceShard message from the specified reader or buffer.
             * @function decode
             * @memberof topodata.Shard.SourceShard
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {topodata.Shard.SourceShard} SourceShard
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SourceShard.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.topodata.Shard.SourceShard();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.uid = reader.uint32();
                        break;
                    case 2:
                        message.keyspace = reader.string();
                        break;
                    case 3:
                        message.shard = reader.string();
                        break;
                    case 4:
                        message.key_range = $root.topodata.KeyRange.decode(reader, reader.uint32());
                        break;
                    case 5:
                        if (!(message.tables && message.tables.length))
                            message.tables = [];
                        message.tables.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SourceShard message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof topodata.Shard.SourceShard
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {topodata.Shard.SourceShard} SourceShard
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SourceShard.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SourceShard message.
             * @function verify
             * @memberof topodata.Shard.SourceShard
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SourceShard.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uid != null && message.hasOwnProperty("uid"))
                    if (!$util.isInteger(message.uid))
                        return "uid: integer expected";
                if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                    if (!$util.isString(message.keyspace))
                        return "keyspace: string expected";
                if (message.shard != null && message.hasOwnProperty("shard"))
                    if (!$util.isString(message.shard))
                        return "shard: string expected";
                if (message.key_range != null && message.hasOwnProperty("key_range")) {
                    var error = $root.topodata.KeyRange.verify(message.key_range);
                    if (error)
                        return "key_range." + error;
                }
                if (message.tables != null && message.hasOwnProperty("tables")) {
                    if (!Array.isArray(message.tables))
                        return "tables: array expected";
                    for (var i = 0; i < message.tables.length; ++i)
                        if (!$util.isString(message.tables[i]))
                            return "tables: string[] expected";
                }
                return null;
            };

            /**
             * Creates a SourceShard message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof topodata.Shard.SourceShard
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {topodata.Shard.SourceShard} SourceShard
             */
            SourceShard.fromObject = function fromObject(object) {
                if (object instanceof $root.topodata.Shard.SourceShard)
                    return object;
                var message = new $root.topodata.Shard.SourceShard();
                if (object.uid != null)
                    message.uid = object.uid >>> 0;
                if (object.keyspace != null)
                    message.keyspace = String(object.keyspace);
                if (object.shard != null)
                    message.shard = String(object.shard);
                if (object.key_range != null) {
                    if (typeof object.key_range !== "object")
                        throw TypeError(".topodata.Shard.SourceShard.key_range: object expected");
                    message.key_range = $root.topodata.KeyRange.fromObject(object.key_range);
                }
                if (object.tables) {
                    if (!Array.isArray(object.tables))
                        throw TypeError(".topodata.Shard.SourceShard.tables: array expected");
                    message.tables = [];
                    for (var i = 0; i < object.tables.length; ++i)
                        message.tables[i] = String(object.tables[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a SourceShard message. Also converts values to other types if specified.
             * @function toObject
             * @memberof topodata.Shard.SourceShard
             * @static
             * @param {topodata.Shard.SourceShard} message SourceShard
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SourceShard.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.tables = [];
                if (options.defaults) {
                    object.uid = 0;
                    object.keyspace = "";
                    object.shard = "";
                    object.key_range = null;
                }
                if (message.uid != null && message.hasOwnProperty("uid"))
                    object.uid = message.uid;
                if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                    object.keyspace = message.keyspace;
                if (message.shard != null && message.hasOwnProperty("shard"))
                    object.shard = message.shard;
                if (message.key_range != null && message.hasOwnProperty("key_range"))
                    object.key_range = $root.topodata.KeyRange.toObject(message.key_range, options);
                if (message.tables && message.tables.length) {
                    object.tables = [];
                    for (var j = 0; j < message.tables.length; ++j)
                        object.tables[j] = message.tables[j];
                }
                return object;
            };

            /**
             * Converts this SourceShard to JSON.
             * @function toJSON
             * @memberof topodata.Shard.SourceShard
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SourceShard.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SourceShard;
        })();

        Shard.TabletControl = (function() {

            /**
             * Properties of a TabletControl.
             * @memberof topodata.Shard
             * @interface ITabletControl
             * @property {topodata.TabletType|null} [tablet_type] TabletControl tablet_type
             * @property {Array.<string>|null} [cells] TabletControl cells
             * @property {Array.<string>|null} [blacklisted_tables] TabletControl blacklisted_tables
             * @property {boolean|null} [frozen] TabletControl frozen
             */

            /**
             * Constructs a new TabletControl.
             * @memberof topodata.Shard
             * @classdesc Represents a TabletControl.
             * @implements ITabletControl
             * @constructor
             * @param {topodata.Shard.ITabletControl=} [properties] Properties to set
             */
            function TabletControl(properties) {
                this.cells = [];
                this.blacklisted_tables = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TabletControl tablet_type.
             * @member {topodata.TabletType} tablet_type
             * @memberof topodata.Shard.TabletControl
             * @instance
             */
            TabletControl.prototype.tablet_type = 0;

            /**
             * TabletControl cells.
             * @member {Array.<string>} cells
             * @memberof topodata.Shard.TabletControl
             * @instance
             */
            TabletControl.prototype.cells = $util.emptyArray;

            /**
             * TabletControl blacklisted_tables.
             * @member {Array.<string>} blacklisted_tables
             * @memberof topodata.Shard.TabletControl
             * @instance
             */
            TabletControl.prototype.blacklisted_tables = $util.emptyArray;

            /**
             * TabletControl frozen.
             * @member {boolean} frozen
             * @memberof topodata.Shard.TabletControl
             * @instance
             */
            TabletControl.prototype.frozen = false;

            /**
             * Creates a new TabletControl instance using the specified properties.
             * @function create
             * @memberof topodata.Shard.TabletControl
             * @static
             * @param {topodata.Shard.ITabletControl=} [properties] Properties to set
             * @returns {topodata.Shard.TabletControl} TabletControl instance
             */
            TabletControl.create = function create(properties) {
                return new TabletControl(properties);
            };

            /**
             * Encodes the specified TabletControl message. Does not implicitly {@link topodata.Shard.TabletControl.verify|verify} messages.
             * @function encode
             * @memberof topodata.Shard.TabletControl
             * @static
             * @param {topodata.Shard.ITabletControl} message TabletControl message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TabletControl.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tablet_type != null && Object.hasOwnProperty.call(message, "tablet_type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tablet_type);
                if (message.cells != null && message.cells.length)
                    for (var i = 0; i < message.cells.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.cells[i]);
                if (message.blacklisted_tables != null && message.blacklisted_tables.length)
                    for (var i = 0; i < message.blacklisted_tables.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.blacklisted_tables[i]);
                if (message.frozen != null && Object.hasOwnProperty.call(message, "frozen"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.frozen);
                return writer;
            };

            /**
             * Encodes the specified TabletControl message, length delimited. Does not implicitly {@link topodata.Shard.TabletControl.verify|verify} messages.
             * @function encodeDelimited
             * @memberof topodata.Shard.TabletControl
             * @static
             * @param {topodata.Shard.ITabletControl} message TabletControl message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TabletControl.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TabletControl message from the specified reader or buffer.
             * @function decode
             * @memberof topodata.Shard.TabletControl
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {topodata.Shard.TabletControl} TabletControl
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TabletControl.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.topodata.Shard.TabletControl();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tablet_type = reader.int32();
                        break;
                    case 2:
                        if (!(message.cells && message.cells.length))
                            message.cells = [];
                        message.cells.push(reader.string());
                        break;
                    case 4:
                        if (!(message.blacklisted_tables && message.blacklisted_tables.length))
                            message.blacklisted_tables = [];
                        message.blacklisted_tables.push(reader.string());
                        break;
                    case 5:
                        message.frozen = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TabletControl message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof topodata.Shard.TabletControl
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {topodata.Shard.TabletControl} TabletControl
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TabletControl.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TabletControl message.
             * @function verify
             * @memberof topodata.Shard.TabletControl
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TabletControl.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tablet_type != null && message.hasOwnProperty("tablet_type"))
                    switch (message.tablet_type) {
                    default:
                        return "tablet_type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                        break;
                    }
                if (message.cells != null && message.hasOwnProperty("cells")) {
                    if (!Array.isArray(message.cells))
                        return "cells: array expected";
                    for (var i = 0; i < message.cells.length; ++i)
                        if (!$util.isString(message.cells[i]))
                            return "cells: string[] expected";
                }
                if (message.blacklisted_tables != null && message.hasOwnProperty("blacklisted_tables")) {
                    if (!Array.isArray(message.blacklisted_tables))
                        return "blacklisted_tables: array expected";
                    for (var i = 0; i < message.blacklisted_tables.length; ++i)
                        if (!$util.isString(message.blacklisted_tables[i]))
                            return "blacklisted_tables: string[] expected";
                }
                if (message.frozen != null && message.hasOwnProperty("frozen"))
                    if (typeof message.frozen !== "boolean")
                        return "frozen: boolean expected";
                return null;
            };

            /**
             * Creates a TabletControl message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof topodata.Shard.TabletControl
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {topodata.Shard.TabletControl} TabletControl
             */
            TabletControl.fromObject = function fromObject(object) {
                if (object instanceof $root.topodata.Shard.TabletControl)
                    return object;
                var message = new $root.topodata.Shard.TabletControl();
                switch (object.tablet_type) {
                case "UNKNOWN":
                case 0:
                    message.tablet_type = 0;
                    break;
                case "MASTER":
                case 1:
                    message.tablet_type = 1;
                    break;
                case "REPLICA":
                case 2:
                    message.tablet_type = 2;
                    break;
                case "RDONLY":
                case 3:
                    message.tablet_type = 3;
                    break;
                case "BATCH":
                case 3:
                    message.tablet_type = 3;
                    break;
                case "SPARE":
                case 4:
                    message.tablet_type = 4;
                    break;
                case "EXPERIMENTAL":
                case 5:
                    message.tablet_type = 5;
                    break;
                case "BACKUP":
                case 6:
                    message.tablet_type = 6;
                    break;
                case "RESTORE":
                case 7:
                    message.tablet_type = 7;
                    break;
                case "DRAINED":
                case 8:
                    message.tablet_type = 8;
                    break;
                }
                if (object.cells) {
                    if (!Array.isArray(object.cells))
                        throw TypeError(".topodata.Shard.TabletControl.cells: array expected");
                    message.cells = [];
                    for (var i = 0; i < object.cells.length; ++i)
                        message.cells[i] = String(object.cells[i]);
                }
                if (object.blacklisted_tables) {
                    if (!Array.isArray(object.blacklisted_tables))
                        throw TypeError(".topodata.Shard.TabletControl.blacklisted_tables: array expected");
                    message.blacklisted_tables = [];
                    for (var i = 0; i < object.blacklisted_tables.length; ++i)
                        message.blacklisted_tables[i] = String(object.blacklisted_tables[i]);
                }
                if (object.frozen != null)
                    message.frozen = Boolean(object.frozen);
                return message;
            };

            /**
             * Creates a plain object from a TabletControl message. Also converts values to other types if specified.
             * @function toObject
             * @memberof topodata.Shard.TabletControl
             * @static
             * @param {topodata.Shard.TabletControl} message TabletControl
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TabletControl.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.cells = [];
                    object.blacklisted_tables = [];
                }
                if (options.defaults) {
                    object.tablet_type = options.enums === String ? "UNKNOWN" : 0;
                    object.frozen = false;
                }
                if (message.tablet_type != null && message.hasOwnProperty("tablet_type"))
                    object.tablet_type = options.enums === String ? $root.topodata.TabletType[message.tablet_type] : message.tablet_type;
                if (message.cells && message.cells.length) {
                    object.cells = [];
                    for (var j = 0; j < message.cells.length; ++j)
                        object.cells[j] = message.cells[j];
                }
                if (message.blacklisted_tables && message.blacklisted_tables.length) {
                    object.blacklisted_tables = [];
                    for (var j = 0; j < message.blacklisted_tables.length; ++j)
                        object.blacklisted_tables[j] = message.blacklisted_tables[j];
                }
                if (message.frozen != null && message.hasOwnProperty("frozen"))
                    object.frozen = message.frozen;
                return object;
            };

            /**
             * Converts this TabletControl to JSON.
             * @function toJSON
             * @memberof topodata.Shard.TabletControl
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TabletControl.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TabletControl;
        })();

        return Shard;
    })();

    topodata.Keyspace = (function() {

        /**
         * Properties of a Keyspace.
         * @memberof topodata
         * @interface IKeyspace
         * @property {string|null} [sharding_column_name] Keyspace sharding_column_name
         * @property {topodata.KeyspaceIdType|null} [sharding_column_type] Keyspace sharding_column_type
         * @property {Array.<topodata.Keyspace.IServedFrom>|null} [served_froms] Keyspace served_froms
         * @property {topodata.KeyspaceType|null} [keyspace_type] Keyspace keyspace_type
         * @property {string|null} [base_keyspace] Keyspace base_keyspace
         * @property {vttime.ITime|null} [snapshot_time] Keyspace snapshot_time
         */

        /**
         * Constructs a new Keyspace.
         * @memberof topodata
         * @classdesc Represents a Keyspace.
         * @implements IKeyspace
         * @constructor
         * @param {topodata.IKeyspace=} [properties] Properties to set
         */
        function Keyspace(properties) {
            this.served_froms = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Keyspace sharding_column_name.
         * @member {string} sharding_column_name
         * @memberof topodata.Keyspace
         * @instance
         */
        Keyspace.prototype.sharding_column_name = "";

        /**
         * Keyspace sharding_column_type.
         * @member {topodata.KeyspaceIdType} sharding_column_type
         * @memberof topodata.Keyspace
         * @instance
         */
        Keyspace.prototype.sharding_column_type = 0;

        /**
         * Keyspace served_froms.
         * @member {Array.<topodata.Keyspace.IServedFrom>} served_froms
         * @memberof topodata.Keyspace
         * @instance
         */
        Keyspace.prototype.served_froms = $util.emptyArray;

        /**
         * Keyspace keyspace_type.
         * @member {topodata.KeyspaceType} keyspace_type
         * @memberof topodata.Keyspace
         * @instance
         */
        Keyspace.prototype.keyspace_type = 0;

        /**
         * Keyspace base_keyspace.
         * @member {string} base_keyspace
         * @memberof topodata.Keyspace
         * @instance
         */
        Keyspace.prototype.base_keyspace = "";

        /**
         * Keyspace snapshot_time.
         * @member {vttime.ITime|null|undefined} snapshot_time
         * @memberof topodata.Keyspace
         * @instance
         */
        Keyspace.prototype.snapshot_time = null;

        /**
         * Creates a new Keyspace instance using the specified properties.
         * @function create
         * @memberof topodata.Keyspace
         * @static
         * @param {topodata.IKeyspace=} [properties] Properties to set
         * @returns {topodata.Keyspace} Keyspace instance
         */
        Keyspace.create = function create(properties) {
            return new Keyspace(properties);
        };

        /**
         * Encodes the specified Keyspace message. Does not implicitly {@link topodata.Keyspace.verify|verify} messages.
         * @function encode
         * @memberof topodata.Keyspace
         * @static
         * @param {topodata.IKeyspace} message Keyspace message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Keyspace.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sharding_column_name != null && Object.hasOwnProperty.call(message, "sharding_column_name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.sharding_column_name);
            if (message.sharding_column_type != null && Object.hasOwnProperty.call(message, "sharding_column_type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.sharding_column_type);
            if (message.served_froms != null && message.served_froms.length)
                for (var i = 0; i < message.served_froms.length; ++i)
                    $root.topodata.Keyspace.ServedFrom.encode(message.served_froms[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.keyspace_type != null && Object.hasOwnProperty.call(message, "keyspace_type"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.keyspace_type);
            if (message.base_keyspace != null && Object.hasOwnProperty.call(message, "base_keyspace"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.base_keyspace);
            if (message.snapshot_time != null && Object.hasOwnProperty.call(message, "snapshot_time"))
                $root.vttime.Time.encode(message.snapshot_time, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Keyspace message, length delimited. Does not implicitly {@link topodata.Keyspace.verify|verify} messages.
         * @function encodeDelimited
         * @memberof topodata.Keyspace
         * @static
         * @param {topodata.IKeyspace} message Keyspace message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Keyspace.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Keyspace message from the specified reader or buffer.
         * @function decode
         * @memberof topodata.Keyspace
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {topodata.Keyspace} Keyspace
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Keyspace.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.topodata.Keyspace();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sharding_column_name = reader.string();
                    break;
                case 2:
                    message.sharding_column_type = reader.int32();
                    break;
                case 4:
                    if (!(message.served_froms && message.served_froms.length))
                        message.served_froms = [];
                    message.served_froms.push($root.topodata.Keyspace.ServedFrom.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.keyspace_type = reader.int32();
                    break;
                case 6:
                    message.base_keyspace = reader.string();
                    break;
                case 7:
                    message.snapshot_time = $root.vttime.Time.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Keyspace message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof topodata.Keyspace
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {topodata.Keyspace} Keyspace
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Keyspace.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Keyspace message.
         * @function verify
         * @memberof topodata.Keyspace
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Keyspace.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sharding_column_name != null && message.hasOwnProperty("sharding_column_name"))
                if (!$util.isString(message.sharding_column_name))
                    return "sharding_column_name: string expected";
            if (message.sharding_column_type != null && message.hasOwnProperty("sharding_column_type"))
                switch (message.sharding_column_type) {
                default:
                    return "sharding_column_type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.served_froms != null && message.hasOwnProperty("served_froms")) {
                if (!Array.isArray(message.served_froms))
                    return "served_froms: array expected";
                for (var i = 0; i < message.served_froms.length; ++i) {
                    var error = $root.topodata.Keyspace.ServedFrom.verify(message.served_froms[i]);
                    if (error)
                        return "served_froms." + error;
                }
            }
            if (message.keyspace_type != null && message.hasOwnProperty("keyspace_type"))
                switch (message.keyspace_type) {
                default:
                    return "keyspace_type: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.base_keyspace != null && message.hasOwnProperty("base_keyspace"))
                if (!$util.isString(message.base_keyspace))
                    return "base_keyspace: string expected";
            if (message.snapshot_time != null && message.hasOwnProperty("snapshot_time")) {
                var error = $root.vttime.Time.verify(message.snapshot_time);
                if (error)
                    return "snapshot_time." + error;
            }
            return null;
        };

        /**
         * Creates a Keyspace message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof topodata.Keyspace
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {topodata.Keyspace} Keyspace
         */
        Keyspace.fromObject = function fromObject(object) {
            if (object instanceof $root.topodata.Keyspace)
                return object;
            var message = new $root.topodata.Keyspace();
            if (object.sharding_column_name != null)
                message.sharding_column_name = String(object.sharding_column_name);
            switch (object.sharding_column_type) {
            case "UNSET":
            case 0:
                message.sharding_column_type = 0;
                break;
            case "UINT64":
            case 1:
                message.sharding_column_type = 1;
                break;
            case "BYTES":
            case 2:
                message.sharding_column_type = 2;
                break;
            }
            if (object.served_froms) {
                if (!Array.isArray(object.served_froms))
                    throw TypeError(".topodata.Keyspace.served_froms: array expected");
                message.served_froms = [];
                for (var i = 0; i < object.served_froms.length; ++i) {
                    if (typeof object.served_froms[i] !== "object")
                        throw TypeError(".topodata.Keyspace.served_froms: object expected");
                    message.served_froms[i] = $root.topodata.Keyspace.ServedFrom.fromObject(object.served_froms[i]);
                }
            }
            switch (object.keyspace_type) {
            case "NORMAL":
            case 0:
                message.keyspace_type = 0;
                break;
            case "SNAPSHOT":
            case 1:
                message.keyspace_type = 1;
                break;
            }
            if (object.base_keyspace != null)
                message.base_keyspace = String(object.base_keyspace);
            if (object.snapshot_time != null) {
                if (typeof object.snapshot_time !== "object")
                    throw TypeError(".topodata.Keyspace.snapshot_time: object expected");
                message.snapshot_time = $root.vttime.Time.fromObject(object.snapshot_time);
            }
            return message;
        };

        /**
         * Creates a plain object from a Keyspace message. Also converts values to other types if specified.
         * @function toObject
         * @memberof topodata.Keyspace
         * @static
         * @param {topodata.Keyspace} message Keyspace
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Keyspace.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.served_froms = [];
            if (options.defaults) {
                object.sharding_column_name = "";
                object.sharding_column_type = options.enums === String ? "UNSET" : 0;
                object.keyspace_type = options.enums === String ? "NORMAL" : 0;
                object.base_keyspace = "";
                object.snapshot_time = null;
            }
            if (message.sharding_column_name != null && message.hasOwnProperty("sharding_column_name"))
                object.sharding_column_name = message.sharding_column_name;
            if (message.sharding_column_type != null && message.hasOwnProperty("sharding_column_type"))
                object.sharding_column_type = options.enums === String ? $root.topodata.KeyspaceIdType[message.sharding_column_type] : message.sharding_column_type;
            if (message.served_froms && message.served_froms.length) {
                object.served_froms = [];
                for (var j = 0; j < message.served_froms.length; ++j)
                    object.served_froms[j] = $root.topodata.Keyspace.ServedFrom.toObject(message.served_froms[j], options);
            }
            if (message.keyspace_type != null && message.hasOwnProperty("keyspace_type"))
                object.keyspace_type = options.enums === String ? $root.topodata.KeyspaceType[message.keyspace_type] : message.keyspace_type;
            if (message.base_keyspace != null && message.hasOwnProperty("base_keyspace"))
                object.base_keyspace = message.base_keyspace;
            if (message.snapshot_time != null && message.hasOwnProperty("snapshot_time"))
                object.snapshot_time = $root.vttime.Time.toObject(message.snapshot_time, options);
            return object;
        };

        /**
         * Converts this Keyspace to JSON.
         * @function toJSON
         * @memberof topodata.Keyspace
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Keyspace.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        Keyspace.ServedFrom = (function() {

            /**
             * Properties of a ServedFrom.
             * @memberof topodata.Keyspace
             * @interface IServedFrom
             * @property {topodata.TabletType|null} [tablet_type] ServedFrom tablet_type
             * @property {Array.<string>|null} [cells] ServedFrom cells
             * @property {string|null} [keyspace] ServedFrom keyspace
             */

            /**
             * Constructs a new ServedFrom.
             * @memberof topodata.Keyspace
             * @classdesc Represents a ServedFrom.
             * @implements IServedFrom
             * @constructor
             * @param {topodata.Keyspace.IServedFrom=} [properties] Properties to set
             */
            function ServedFrom(properties) {
                this.cells = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServedFrom tablet_type.
             * @member {topodata.TabletType} tablet_type
             * @memberof topodata.Keyspace.ServedFrom
             * @instance
             */
            ServedFrom.prototype.tablet_type = 0;

            /**
             * ServedFrom cells.
             * @member {Array.<string>} cells
             * @memberof topodata.Keyspace.ServedFrom
             * @instance
             */
            ServedFrom.prototype.cells = $util.emptyArray;

            /**
             * ServedFrom keyspace.
             * @member {string} keyspace
             * @memberof topodata.Keyspace.ServedFrom
             * @instance
             */
            ServedFrom.prototype.keyspace = "";

            /**
             * Creates a new ServedFrom instance using the specified properties.
             * @function create
             * @memberof topodata.Keyspace.ServedFrom
             * @static
             * @param {topodata.Keyspace.IServedFrom=} [properties] Properties to set
             * @returns {topodata.Keyspace.ServedFrom} ServedFrom instance
             */
            ServedFrom.create = function create(properties) {
                return new ServedFrom(properties);
            };

            /**
             * Encodes the specified ServedFrom message. Does not implicitly {@link topodata.Keyspace.ServedFrom.verify|verify} messages.
             * @function encode
             * @memberof topodata.Keyspace.ServedFrom
             * @static
             * @param {topodata.Keyspace.IServedFrom} message ServedFrom message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServedFrom.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tablet_type != null && Object.hasOwnProperty.call(message, "tablet_type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tablet_type);
                if (message.cells != null && message.cells.length)
                    for (var i = 0; i < message.cells.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.cells[i]);
                if (message.keyspace != null && Object.hasOwnProperty.call(message, "keyspace"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.keyspace);
                return writer;
            };

            /**
             * Encodes the specified ServedFrom message, length delimited. Does not implicitly {@link topodata.Keyspace.ServedFrom.verify|verify} messages.
             * @function encodeDelimited
             * @memberof topodata.Keyspace.ServedFrom
             * @static
             * @param {topodata.Keyspace.IServedFrom} message ServedFrom message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServedFrom.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ServedFrom message from the specified reader or buffer.
             * @function decode
             * @memberof topodata.Keyspace.ServedFrom
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {topodata.Keyspace.ServedFrom} ServedFrom
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServedFrom.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.topodata.Keyspace.ServedFrom();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tablet_type = reader.int32();
                        break;
                    case 2:
                        if (!(message.cells && message.cells.length))
                            message.cells = [];
                        message.cells.push(reader.string());
                        break;
                    case 3:
                        message.keyspace = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ServedFrom message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof topodata.Keyspace.ServedFrom
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {topodata.Keyspace.ServedFrom} ServedFrom
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServedFrom.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ServedFrom message.
             * @function verify
             * @memberof topodata.Keyspace.ServedFrom
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ServedFrom.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tablet_type != null && message.hasOwnProperty("tablet_type"))
                    switch (message.tablet_type) {
                    default:
                        return "tablet_type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                        break;
                    }
                if (message.cells != null && message.hasOwnProperty("cells")) {
                    if (!Array.isArray(message.cells))
                        return "cells: array expected";
                    for (var i = 0; i < message.cells.length; ++i)
                        if (!$util.isString(message.cells[i]))
                            return "cells: string[] expected";
                }
                if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                    if (!$util.isString(message.keyspace))
                        return "keyspace: string expected";
                return null;
            };

            /**
             * Creates a ServedFrom message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof topodata.Keyspace.ServedFrom
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {topodata.Keyspace.ServedFrom} ServedFrom
             */
            ServedFrom.fromObject = function fromObject(object) {
                if (object instanceof $root.topodata.Keyspace.ServedFrom)
                    return object;
                var message = new $root.topodata.Keyspace.ServedFrom();
                switch (object.tablet_type) {
                case "UNKNOWN":
                case 0:
                    message.tablet_type = 0;
                    break;
                case "MASTER":
                case 1:
                    message.tablet_type = 1;
                    break;
                case "REPLICA":
                case 2:
                    message.tablet_type = 2;
                    break;
                case "RDONLY":
                case 3:
                    message.tablet_type = 3;
                    break;
                case "BATCH":
                case 3:
                    message.tablet_type = 3;
                    break;
                case "SPARE":
                case 4:
                    message.tablet_type = 4;
                    break;
                case "EXPERIMENTAL":
                case 5:
                    message.tablet_type = 5;
                    break;
                case "BACKUP":
                case 6:
                    message.tablet_type = 6;
                    break;
                case "RESTORE":
                case 7:
                    message.tablet_type = 7;
                    break;
                case "DRAINED":
                case 8:
                    message.tablet_type = 8;
                    break;
                }
                if (object.cells) {
                    if (!Array.isArray(object.cells))
                        throw TypeError(".topodata.Keyspace.ServedFrom.cells: array expected");
                    message.cells = [];
                    for (var i = 0; i < object.cells.length; ++i)
                        message.cells[i] = String(object.cells[i]);
                }
                if (object.keyspace != null)
                    message.keyspace = String(object.keyspace);
                return message;
            };

            /**
             * Creates a plain object from a ServedFrom message. Also converts values to other types if specified.
             * @function toObject
             * @memberof topodata.Keyspace.ServedFrom
             * @static
             * @param {topodata.Keyspace.ServedFrom} message ServedFrom
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServedFrom.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.cells = [];
                if (options.defaults) {
                    object.tablet_type = options.enums === String ? "UNKNOWN" : 0;
                    object.keyspace = "";
                }
                if (message.tablet_type != null && message.hasOwnProperty("tablet_type"))
                    object.tablet_type = options.enums === String ? $root.topodata.TabletType[message.tablet_type] : message.tablet_type;
                if (message.cells && message.cells.length) {
                    object.cells = [];
                    for (var j = 0; j < message.cells.length; ++j)
                        object.cells[j] = message.cells[j];
                }
                if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                    object.keyspace = message.keyspace;
                return object;
            };

            /**
             * Converts this ServedFrom to JSON.
             * @function toJSON
             * @memberof topodata.Keyspace.ServedFrom
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ServedFrom.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ServedFrom;
        })();

        return Keyspace;
    })();

    topodata.ShardReplication = (function() {

        /**
         * Properties of a ShardReplication.
         * @memberof topodata
         * @interface IShardReplication
         * @property {Array.<topodata.ShardReplication.INode>|null} [nodes] ShardReplication nodes
         */

        /**
         * Constructs a new ShardReplication.
         * @memberof topodata
         * @classdesc Represents a ShardReplication.
         * @implements IShardReplication
         * @constructor
         * @param {topodata.IShardReplication=} [properties] Properties to set
         */
        function ShardReplication(properties) {
            this.nodes = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ShardReplication nodes.
         * @member {Array.<topodata.ShardReplication.INode>} nodes
         * @memberof topodata.ShardReplication
         * @instance
         */
        ShardReplication.prototype.nodes = $util.emptyArray;

        /**
         * Creates a new ShardReplication instance using the specified properties.
         * @function create
         * @memberof topodata.ShardReplication
         * @static
         * @param {topodata.IShardReplication=} [properties] Properties to set
         * @returns {topodata.ShardReplication} ShardReplication instance
         */
        ShardReplication.create = function create(properties) {
            return new ShardReplication(properties);
        };

        /**
         * Encodes the specified ShardReplication message. Does not implicitly {@link topodata.ShardReplication.verify|verify} messages.
         * @function encode
         * @memberof topodata.ShardReplication
         * @static
         * @param {topodata.IShardReplication} message ShardReplication message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShardReplication.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nodes != null && message.nodes.length)
                for (var i = 0; i < message.nodes.length; ++i)
                    $root.topodata.ShardReplication.Node.encode(message.nodes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ShardReplication message, length delimited. Does not implicitly {@link topodata.ShardReplication.verify|verify} messages.
         * @function encodeDelimited
         * @memberof topodata.ShardReplication
         * @static
         * @param {topodata.IShardReplication} message ShardReplication message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShardReplication.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ShardReplication message from the specified reader or buffer.
         * @function decode
         * @memberof topodata.ShardReplication
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {topodata.ShardReplication} ShardReplication
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShardReplication.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.topodata.ShardReplication();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.nodes && message.nodes.length))
                        message.nodes = [];
                    message.nodes.push($root.topodata.ShardReplication.Node.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ShardReplication message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof topodata.ShardReplication
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {topodata.ShardReplication} ShardReplication
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShardReplication.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ShardReplication message.
         * @function verify
         * @memberof topodata.ShardReplication
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ShardReplication.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nodes != null && message.hasOwnProperty("nodes")) {
                if (!Array.isArray(message.nodes))
                    return "nodes: array expected";
                for (var i = 0; i < message.nodes.length; ++i) {
                    var error = $root.topodata.ShardReplication.Node.verify(message.nodes[i]);
                    if (error)
                        return "nodes." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ShardReplication message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof topodata.ShardReplication
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {topodata.ShardReplication} ShardReplication
         */
        ShardReplication.fromObject = function fromObject(object) {
            if (object instanceof $root.topodata.ShardReplication)
                return object;
            var message = new $root.topodata.ShardReplication();
            if (object.nodes) {
                if (!Array.isArray(object.nodes))
                    throw TypeError(".topodata.ShardReplication.nodes: array expected");
                message.nodes = [];
                for (var i = 0; i < object.nodes.length; ++i) {
                    if (typeof object.nodes[i] !== "object")
                        throw TypeError(".topodata.ShardReplication.nodes: object expected");
                    message.nodes[i] = $root.topodata.ShardReplication.Node.fromObject(object.nodes[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ShardReplication message. Also converts values to other types if specified.
         * @function toObject
         * @memberof topodata.ShardReplication
         * @static
         * @param {topodata.ShardReplication} message ShardReplication
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ShardReplication.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.nodes = [];
            if (message.nodes && message.nodes.length) {
                object.nodes = [];
                for (var j = 0; j < message.nodes.length; ++j)
                    object.nodes[j] = $root.topodata.ShardReplication.Node.toObject(message.nodes[j], options);
            }
            return object;
        };

        /**
         * Converts this ShardReplication to JSON.
         * @function toJSON
         * @memberof topodata.ShardReplication
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ShardReplication.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        ShardReplication.Node = (function() {

            /**
             * Properties of a Node.
             * @memberof topodata.ShardReplication
             * @interface INode
             * @property {topodata.ITabletAlias|null} [tablet_alias] Node tablet_alias
             */

            /**
             * Constructs a new Node.
             * @memberof topodata.ShardReplication
             * @classdesc Represents a Node.
             * @implements INode
             * @constructor
             * @param {topodata.ShardReplication.INode=} [properties] Properties to set
             */
            function Node(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Node tablet_alias.
             * @member {topodata.ITabletAlias|null|undefined} tablet_alias
             * @memberof topodata.ShardReplication.Node
             * @instance
             */
            Node.prototype.tablet_alias = null;

            /**
             * Creates a new Node instance using the specified properties.
             * @function create
             * @memberof topodata.ShardReplication.Node
             * @static
             * @param {topodata.ShardReplication.INode=} [properties] Properties to set
             * @returns {topodata.ShardReplication.Node} Node instance
             */
            Node.create = function create(properties) {
                return new Node(properties);
            };

            /**
             * Encodes the specified Node message. Does not implicitly {@link topodata.ShardReplication.Node.verify|verify} messages.
             * @function encode
             * @memberof topodata.ShardReplication.Node
             * @static
             * @param {topodata.ShardReplication.INode} message Node message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Node.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tablet_alias != null && Object.hasOwnProperty.call(message, "tablet_alias"))
                    $root.topodata.TabletAlias.encode(message.tablet_alias, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Node message, length delimited. Does not implicitly {@link topodata.ShardReplication.Node.verify|verify} messages.
             * @function encodeDelimited
             * @memberof topodata.ShardReplication.Node
             * @static
             * @param {topodata.ShardReplication.INode} message Node message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Node.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Node message from the specified reader or buffer.
             * @function decode
             * @memberof topodata.ShardReplication.Node
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {topodata.ShardReplication.Node} Node
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Node.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.topodata.ShardReplication.Node();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tablet_alias = $root.topodata.TabletAlias.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Node message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof topodata.ShardReplication.Node
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {topodata.ShardReplication.Node} Node
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Node.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Node message.
             * @function verify
             * @memberof topodata.ShardReplication.Node
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Node.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tablet_alias != null && message.hasOwnProperty("tablet_alias")) {
                    var error = $root.topodata.TabletAlias.verify(message.tablet_alias);
                    if (error)
                        return "tablet_alias." + error;
                }
                return null;
            };

            /**
             * Creates a Node message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof topodata.ShardReplication.Node
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {topodata.ShardReplication.Node} Node
             */
            Node.fromObject = function fromObject(object) {
                if (object instanceof $root.topodata.ShardReplication.Node)
                    return object;
                var message = new $root.topodata.ShardReplication.Node();
                if (object.tablet_alias != null) {
                    if (typeof object.tablet_alias !== "object")
                        throw TypeError(".topodata.ShardReplication.Node.tablet_alias: object expected");
                    message.tablet_alias = $root.topodata.TabletAlias.fromObject(object.tablet_alias);
                }
                return message;
            };

            /**
             * Creates a plain object from a Node message. Also converts values to other types if specified.
             * @function toObject
             * @memberof topodata.ShardReplication.Node
             * @static
             * @param {topodata.ShardReplication.Node} message Node
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Node.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.tablet_alias = null;
                if (message.tablet_alias != null && message.hasOwnProperty("tablet_alias"))
                    object.tablet_alias = $root.topodata.TabletAlias.toObject(message.tablet_alias, options);
                return object;
            };

            /**
             * Converts this Node to JSON.
             * @function toJSON
             * @memberof topodata.ShardReplication.Node
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Node.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Node;
        })();

        return ShardReplication;
    })();

    topodata.ShardReference = (function() {

        /**
         * Properties of a ShardReference.
         * @memberof topodata
         * @interface IShardReference
         * @property {string|null} [name] ShardReference name
         * @property {topodata.IKeyRange|null} [key_range] ShardReference key_range
         */

        /**
         * Constructs a new ShardReference.
         * @memberof topodata
         * @classdesc Represents a ShardReference.
         * @implements IShardReference
         * @constructor
         * @param {topodata.IShardReference=} [properties] Properties to set
         */
        function ShardReference(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ShardReference name.
         * @member {string} name
         * @memberof topodata.ShardReference
         * @instance
         */
        ShardReference.prototype.name = "";

        /**
         * ShardReference key_range.
         * @member {topodata.IKeyRange|null|undefined} key_range
         * @memberof topodata.ShardReference
         * @instance
         */
        ShardReference.prototype.key_range = null;

        /**
         * Creates a new ShardReference instance using the specified properties.
         * @function create
         * @memberof topodata.ShardReference
         * @static
         * @param {topodata.IShardReference=} [properties] Properties to set
         * @returns {topodata.ShardReference} ShardReference instance
         */
        ShardReference.create = function create(properties) {
            return new ShardReference(properties);
        };

        /**
         * Encodes the specified ShardReference message. Does not implicitly {@link topodata.ShardReference.verify|verify} messages.
         * @function encode
         * @memberof topodata.ShardReference
         * @static
         * @param {topodata.IShardReference} message ShardReference message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShardReference.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.key_range != null && Object.hasOwnProperty.call(message, "key_range"))
                $root.topodata.KeyRange.encode(message.key_range, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ShardReference message, length delimited. Does not implicitly {@link topodata.ShardReference.verify|verify} messages.
         * @function encodeDelimited
         * @memberof topodata.ShardReference
         * @static
         * @param {topodata.IShardReference} message ShardReference message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShardReference.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ShardReference message from the specified reader or buffer.
         * @function decode
         * @memberof topodata.ShardReference
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {topodata.ShardReference} ShardReference
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShardReference.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.topodata.ShardReference();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.key_range = $root.topodata.KeyRange.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ShardReference message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof topodata.ShardReference
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {topodata.ShardReference} ShardReference
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShardReference.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ShardReference message.
         * @function verify
         * @memberof topodata.ShardReference
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ShardReference.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.key_range != null && message.hasOwnProperty("key_range")) {
                var error = $root.topodata.KeyRange.verify(message.key_range);
                if (error)
                    return "key_range." + error;
            }
            return null;
        };

        /**
         * Creates a ShardReference message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof topodata.ShardReference
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {topodata.ShardReference} ShardReference
         */
        ShardReference.fromObject = function fromObject(object) {
            if (object instanceof $root.topodata.ShardReference)
                return object;
            var message = new $root.topodata.ShardReference();
            if (object.name != null)
                message.name = String(object.name);
            if (object.key_range != null) {
                if (typeof object.key_range !== "object")
                    throw TypeError(".topodata.ShardReference.key_range: object expected");
                message.key_range = $root.topodata.KeyRange.fromObject(object.key_range);
            }
            return message;
        };

        /**
         * Creates a plain object from a ShardReference message. Also converts values to other types if specified.
         * @function toObject
         * @memberof topodata.ShardReference
         * @static
         * @param {topodata.ShardReference} message ShardReference
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ShardReference.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.key_range = null;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.key_range != null && message.hasOwnProperty("key_range"))
                object.key_range = $root.topodata.KeyRange.toObject(message.key_range, options);
            return object;
        };

        /**
         * Converts this ShardReference to JSON.
         * @function toJSON
         * @memberof topodata.ShardReference
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ShardReference.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ShardReference;
    })();

    topodata.ShardTabletControl = (function() {

        /**
         * Properties of a ShardTabletControl.
         * @memberof topodata
         * @interface IShardTabletControl
         * @property {string|null} [name] ShardTabletControl name
         * @property {topodata.IKeyRange|null} [key_range] ShardTabletControl key_range
         * @property {boolean|null} [query_service_disabled] ShardTabletControl query_service_disabled
         */

        /**
         * Constructs a new ShardTabletControl.
         * @memberof topodata
         * @classdesc Represents a ShardTabletControl.
         * @implements IShardTabletControl
         * @constructor
         * @param {topodata.IShardTabletControl=} [properties] Properties to set
         */
        function ShardTabletControl(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ShardTabletControl name.
         * @member {string} name
         * @memberof topodata.ShardTabletControl
         * @instance
         */
        ShardTabletControl.prototype.name = "";

        /**
         * ShardTabletControl key_range.
         * @member {topodata.IKeyRange|null|undefined} key_range
         * @memberof topodata.ShardTabletControl
         * @instance
         */
        ShardTabletControl.prototype.key_range = null;

        /**
         * ShardTabletControl query_service_disabled.
         * @member {boolean} query_service_disabled
         * @memberof topodata.ShardTabletControl
         * @instance
         */
        ShardTabletControl.prototype.query_service_disabled = false;

        /**
         * Creates a new ShardTabletControl instance using the specified properties.
         * @function create
         * @memberof topodata.ShardTabletControl
         * @static
         * @param {topodata.IShardTabletControl=} [properties] Properties to set
         * @returns {topodata.ShardTabletControl} ShardTabletControl instance
         */
        ShardTabletControl.create = function create(properties) {
            return new ShardTabletControl(properties);
        };

        /**
         * Encodes the specified ShardTabletControl message. Does not implicitly {@link topodata.ShardTabletControl.verify|verify} messages.
         * @function encode
         * @memberof topodata.ShardTabletControl
         * @static
         * @param {topodata.IShardTabletControl} message ShardTabletControl message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShardTabletControl.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.key_range != null && Object.hasOwnProperty.call(message, "key_range"))
                $root.topodata.KeyRange.encode(message.key_range, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.query_service_disabled != null && Object.hasOwnProperty.call(message, "query_service_disabled"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.query_service_disabled);
            return writer;
        };

        /**
         * Encodes the specified ShardTabletControl message, length delimited. Does not implicitly {@link topodata.ShardTabletControl.verify|verify} messages.
         * @function encodeDelimited
         * @memberof topodata.ShardTabletControl
         * @static
         * @param {topodata.IShardTabletControl} message ShardTabletControl message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShardTabletControl.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ShardTabletControl message from the specified reader or buffer.
         * @function decode
         * @memberof topodata.ShardTabletControl
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {topodata.ShardTabletControl} ShardTabletControl
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShardTabletControl.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.topodata.ShardTabletControl();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.key_range = $root.topodata.KeyRange.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.query_service_disabled = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ShardTabletControl message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof topodata.ShardTabletControl
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {topodata.ShardTabletControl} ShardTabletControl
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShardTabletControl.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ShardTabletControl message.
         * @function verify
         * @memberof topodata.ShardTabletControl
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ShardTabletControl.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.key_range != null && message.hasOwnProperty("key_range")) {
                var error = $root.topodata.KeyRange.verify(message.key_range);
                if (error)
                    return "key_range." + error;
            }
            if (message.query_service_disabled != null && message.hasOwnProperty("query_service_disabled"))
                if (typeof message.query_service_disabled !== "boolean")
                    return "query_service_disabled: boolean expected";
            return null;
        };

        /**
         * Creates a ShardTabletControl message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof topodata.ShardTabletControl
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {topodata.ShardTabletControl} ShardTabletControl
         */
        ShardTabletControl.fromObject = function fromObject(object) {
            if (object instanceof $root.topodata.ShardTabletControl)
                return object;
            var message = new $root.topodata.ShardTabletControl();
            if (object.name != null)
                message.name = String(object.name);
            if (object.key_range != null) {
                if (typeof object.key_range !== "object")
                    throw TypeError(".topodata.ShardTabletControl.key_range: object expected");
                message.key_range = $root.topodata.KeyRange.fromObject(object.key_range);
            }
            if (object.query_service_disabled != null)
                message.query_service_disabled = Boolean(object.query_service_disabled);
            return message;
        };

        /**
         * Creates a plain object from a ShardTabletControl message. Also converts values to other types if specified.
         * @function toObject
         * @memberof topodata.ShardTabletControl
         * @static
         * @param {topodata.ShardTabletControl} message ShardTabletControl
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ShardTabletControl.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.key_range = null;
                object.query_service_disabled = false;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.key_range != null && message.hasOwnProperty("key_range"))
                object.key_range = $root.topodata.KeyRange.toObject(message.key_range, options);
            if (message.query_service_disabled != null && message.hasOwnProperty("query_service_disabled"))
                object.query_service_disabled = message.query_service_disabled;
            return object;
        };

        /**
         * Converts this ShardTabletControl to JSON.
         * @function toJSON
         * @memberof topodata.ShardTabletControl
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ShardTabletControl.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ShardTabletControl;
    })();

    topodata.SrvKeyspace = (function() {

        /**
         * Properties of a SrvKeyspace.
         * @memberof topodata
         * @interface ISrvKeyspace
         * @property {Array.<topodata.SrvKeyspace.IKeyspacePartition>|null} [partitions] SrvKeyspace partitions
         * @property {string|null} [sharding_column_name] SrvKeyspace sharding_column_name
         * @property {topodata.KeyspaceIdType|null} [sharding_column_type] SrvKeyspace sharding_column_type
         * @property {Array.<topodata.SrvKeyspace.IServedFrom>|null} [served_from] SrvKeyspace served_from
         */

        /**
         * Constructs a new SrvKeyspace.
         * @memberof topodata
         * @classdesc Represents a SrvKeyspace.
         * @implements ISrvKeyspace
         * @constructor
         * @param {topodata.ISrvKeyspace=} [properties] Properties to set
         */
        function SrvKeyspace(properties) {
            this.partitions = [];
            this.served_from = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SrvKeyspace partitions.
         * @member {Array.<topodata.SrvKeyspace.IKeyspacePartition>} partitions
         * @memberof topodata.SrvKeyspace
         * @instance
         */
        SrvKeyspace.prototype.partitions = $util.emptyArray;

        /**
         * SrvKeyspace sharding_column_name.
         * @member {string} sharding_column_name
         * @memberof topodata.SrvKeyspace
         * @instance
         */
        SrvKeyspace.prototype.sharding_column_name = "";

        /**
         * SrvKeyspace sharding_column_type.
         * @member {topodata.KeyspaceIdType} sharding_column_type
         * @memberof topodata.SrvKeyspace
         * @instance
         */
        SrvKeyspace.prototype.sharding_column_type = 0;

        /**
         * SrvKeyspace served_from.
         * @member {Array.<topodata.SrvKeyspace.IServedFrom>} served_from
         * @memberof topodata.SrvKeyspace
         * @instance
         */
        SrvKeyspace.prototype.served_from = $util.emptyArray;

        /**
         * Creates a new SrvKeyspace instance using the specified properties.
         * @function create
         * @memberof topodata.SrvKeyspace
         * @static
         * @param {topodata.ISrvKeyspace=} [properties] Properties to set
         * @returns {topodata.SrvKeyspace} SrvKeyspace instance
         */
        SrvKeyspace.create = function create(properties) {
            return new SrvKeyspace(properties);
        };

        /**
         * Encodes the specified SrvKeyspace message. Does not implicitly {@link topodata.SrvKeyspace.verify|verify} messages.
         * @function encode
         * @memberof topodata.SrvKeyspace
         * @static
         * @param {topodata.ISrvKeyspace} message SrvKeyspace message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SrvKeyspace.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.partitions != null && message.partitions.length)
                for (var i = 0; i < message.partitions.length; ++i)
                    $root.topodata.SrvKeyspace.KeyspacePartition.encode(message.partitions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.sharding_column_name != null && Object.hasOwnProperty.call(message, "sharding_column_name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.sharding_column_name);
            if (message.sharding_column_type != null && Object.hasOwnProperty.call(message, "sharding_column_type"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.sharding_column_type);
            if (message.served_from != null && message.served_from.length)
                for (var i = 0; i < message.served_from.length; ++i)
                    $root.topodata.SrvKeyspace.ServedFrom.encode(message.served_from[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SrvKeyspace message, length delimited. Does not implicitly {@link topodata.SrvKeyspace.verify|verify} messages.
         * @function encodeDelimited
         * @memberof topodata.SrvKeyspace
         * @static
         * @param {topodata.ISrvKeyspace} message SrvKeyspace message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SrvKeyspace.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SrvKeyspace message from the specified reader or buffer.
         * @function decode
         * @memberof topodata.SrvKeyspace
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {topodata.SrvKeyspace} SrvKeyspace
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SrvKeyspace.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.topodata.SrvKeyspace();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.partitions && message.partitions.length))
                        message.partitions = [];
                    message.partitions.push($root.topodata.SrvKeyspace.KeyspacePartition.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.sharding_column_name = reader.string();
                    break;
                case 3:
                    message.sharding_column_type = reader.int32();
                    break;
                case 4:
                    if (!(message.served_from && message.served_from.length))
                        message.served_from = [];
                    message.served_from.push($root.topodata.SrvKeyspace.ServedFrom.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SrvKeyspace message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof topodata.SrvKeyspace
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {topodata.SrvKeyspace} SrvKeyspace
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SrvKeyspace.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SrvKeyspace message.
         * @function verify
         * @memberof topodata.SrvKeyspace
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SrvKeyspace.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.partitions != null && message.hasOwnProperty("partitions")) {
                if (!Array.isArray(message.partitions))
                    return "partitions: array expected";
                for (var i = 0; i < message.partitions.length; ++i) {
                    var error = $root.topodata.SrvKeyspace.KeyspacePartition.verify(message.partitions[i]);
                    if (error)
                        return "partitions." + error;
                }
            }
            if (message.sharding_column_name != null && message.hasOwnProperty("sharding_column_name"))
                if (!$util.isString(message.sharding_column_name))
                    return "sharding_column_name: string expected";
            if (message.sharding_column_type != null && message.hasOwnProperty("sharding_column_type"))
                switch (message.sharding_column_type) {
                default:
                    return "sharding_column_type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.served_from != null && message.hasOwnProperty("served_from")) {
                if (!Array.isArray(message.served_from))
                    return "served_from: array expected";
                for (var i = 0; i < message.served_from.length; ++i) {
                    var error = $root.topodata.SrvKeyspace.ServedFrom.verify(message.served_from[i]);
                    if (error)
                        return "served_from." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SrvKeyspace message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof topodata.SrvKeyspace
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {topodata.SrvKeyspace} SrvKeyspace
         */
        SrvKeyspace.fromObject = function fromObject(object) {
            if (object instanceof $root.topodata.SrvKeyspace)
                return object;
            var message = new $root.topodata.SrvKeyspace();
            if (object.partitions) {
                if (!Array.isArray(object.partitions))
                    throw TypeError(".topodata.SrvKeyspace.partitions: array expected");
                message.partitions = [];
                for (var i = 0; i < object.partitions.length; ++i) {
                    if (typeof object.partitions[i] !== "object")
                        throw TypeError(".topodata.SrvKeyspace.partitions: object expected");
                    message.partitions[i] = $root.topodata.SrvKeyspace.KeyspacePartition.fromObject(object.partitions[i]);
                }
            }
            if (object.sharding_column_name != null)
                message.sharding_column_name = String(object.sharding_column_name);
            switch (object.sharding_column_type) {
            case "UNSET":
            case 0:
                message.sharding_column_type = 0;
                break;
            case "UINT64":
            case 1:
                message.sharding_column_type = 1;
                break;
            case "BYTES":
            case 2:
                message.sharding_column_type = 2;
                break;
            }
            if (object.served_from) {
                if (!Array.isArray(object.served_from))
                    throw TypeError(".topodata.SrvKeyspace.served_from: array expected");
                message.served_from = [];
                for (var i = 0; i < object.served_from.length; ++i) {
                    if (typeof object.served_from[i] !== "object")
                        throw TypeError(".topodata.SrvKeyspace.served_from: object expected");
                    message.served_from[i] = $root.topodata.SrvKeyspace.ServedFrom.fromObject(object.served_from[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SrvKeyspace message. Also converts values to other types if specified.
         * @function toObject
         * @memberof topodata.SrvKeyspace
         * @static
         * @param {topodata.SrvKeyspace} message SrvKeyspace
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SrvKeyspace.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.partitions = [];
                object.served_from = [];
            }
            if (options.defaults) {
                object.sharding_column_name = "";
                object.sharding_column_type = options.enums === String ? "UNSET" : 0;
            }
            if (message.partitions && message.partitions.length) {
                object.partitions = [];
                for (var j = 0; j < message.partitions.length; ++j)
                    object.partitions[j] = $root.topodata.SrvKeyspace.KeyspacePartition.toObject(message.partitions[j], options);
            }
            if (message.sharding_column_name != null && message.hasOwnProperty("sharding_column_name"))
                object.sharding_column_name = message.sharding_column_name;
            if (message.sharding_column_type != null && message.hasOwnProperty("sharding_column_type"))
                object.sharding_column_type = options.enums === String ? $root.topodata.KeyspaceIdType[message.sharding_column_type] : message.sharding_column_type;
            if (message.served_from && message.served_from.length) {
                object.served_from = [];
                for (var j = 0; j < message.served_from.length; ++j)
                    object.served_from[j] = $root.topodata.SrvKeyspace.ServedFrom.toObject(message.served_from[j], options);
            }
            return object;
        };

        /**
         * Converts this SrvKeyspace to JSON.
         * @function toJSON
         * @memberof topodata.SrvKeyspace
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SrvKeyspace.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        SrvKeyspace.KeyspacePartition = (function() {

            /**
             * Properties of a KeyspacePartition.
             * @memberof topodata.SrvKeyspace
             * @interface IKeyspacePartition
             * @property {topodata.TabletType|null} [served_type] KeyspacePartition served_type
             * @property {Array.<topodata.IShardReference>|null} [shard_references] KeyspacePartition shard_references
             * @property {Array.<topodata.IShardTabletControl>|null} [shard_tablet_controls] KeyspacePartition shard_tablet_controls
             */

            /**
             * Constructs a new KeyspacePartition.
             * @memberof topodata.SrvKeyspace
             * @classdesc Represents a KeyspacePartition.
             * @implements IKeyspacePartition
             * @constructor
             * @param {topodata.SrvKeyspace.IKeyspacePartition=} [properties] Properties to set
             */
            function KeyspacePartition(properties) {
                this.shard_references = [];
                this.shard_tablet_controls = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KeyspacePartition served_type.
             * @member {topodata.TabletType} served_type
             * @memberof topodata.SrvKeyspace.KeyspacePartition
             * @instance
             */
            KeyspacePartition.prototype.served_type = 0;

            /**
             * KeyspacePartition shard_references.
             * @member {Array.<topodata.IShardReference>} shard_references
             * @memberof topodata.SrvKeyspace.KeyspacePartition
             * @instance
             */
            KeyspacePartition.prototype.shard_references = $util.emptyArray;

            /**
             * KeyspacePartition shard_tablet_controls.
             * @member {Array.<topodata.IShardTabletControl>} shard_tablet_controls
             * @memberof topodata.SrvKeyspace.KeyspacePartition
             * @instance
             */
            KeyspacePartition.prototype.shard_tablet_controls = $util.emptyArray;

            /**
             * Creates a new KeyspacePartition instance using the specified properties.
             * @function create
             * @memberof topodata.SrvKeyspace.KeyspacePartition
             * @static
             * @param {topodata.SrvKeyspace.IKeyspacePartition=} [properties] Properties to set
             * @returns {topodata.SrvKeyspace.KeyspacePartition} KeyspacePartition instance
             */
            KeyspacePartition.create = function create(properties) {
                return new KeyspacePartition(properties);
            };

            /**
             * Encodes the specified KeyspacePartition message. Does not implicitly {@link topodata.SrvKeyspace.KeyspacePartition.verify|verify} messages.
             * @function encode
             * @memberof topodata.SrvKeyspace.KeyspacePartition
             * @static
             * @param {topodata.SrvKeyspace.IKeyspacePartition} message KeyspacePartition message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeyspacePartition.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.served_type != null && Object.hasOwnProperty.call(message, "served_type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.served_type);
                if (message.shard_references != null && message.shard_references.length)
                    for (var i = 0; i < message.shard_references.length; ++i)
                        $root.topodata.ShardReference.encode(message.shard_references[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.shard_tablet_controls != null && message.shard_tablet_controls.length)
                    for (var i = 0; i < message.shard_tablet_controls.length; ++i)
                        $root.topodata.ShardTabletControl.encode(message.shard_tablet_controls[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified KeyspacePartition message, length delimited. Does not implicitly {@link topodata.SrvKeyspace.KeyspacePartition.verify|verify} messages.
             * @function encodeDelimited
             * @memberof topodata.SrvKeyspace.KeyspacePartition
             * @static
             * @param {topodata.SrvKeyspace.IKeyspacePartition} message KeyspacePartition message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeyspacePartition.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KeyspacePartition message from the specified reader or buffer.
             * @function decode
             * @memberof topodata.SrvKeyspace.KeyspacePartition
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {topodata.SrvKeyspace.KeyspacePartition} KeyspacePartition
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeyspacePartition.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.topodata.SrvKeyspace.KeyspacePartition();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.served_type = reader.int32();
                        break;
                    case 2:
                        if (!(message.shard_references && message.shard_references.length))
                            message.shard_references = [];
                        message.shard_references.push($root.topodata.ShardReference.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.shard_tablet_controls && message.shard_tablet_controls.length))
                            message.shard_tablet_controls = [];
                        message.shard_tablet_controls.push($root.topodata.ShardTabletControl.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KeyspacePartition message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof topodata.SrvKeyspace.KeyspacePartition
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {topodata.SrvKeyspace.KeyspacePartition} KeyspacePartition
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeyspacePartition.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KeyspacePartition message.
             * @function verify
             * @memberof topodata.SrvKeyspace.KeyspacePartition
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KeyspacePartition.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.served_type != null && message.hasOwnProperty("served_type"))
                    switch (message.served_type) {
                    default:
                        return "served_type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                        break;
                    }
                if (message.shard_references != null && message.hasOwnProperty("shard_references")) {
                    if (!Array.isArray(message.shard_references))
                        return "shard_references: array expected";
                    for (var i = 0; i < message.shard_references.length; ++i) {
                        var error = $root.topodata.ShardReference.verify(message.shard_references[i]);
                        if (error)
                            return "shard_references." + error;
                    }
                }
                if (message.shard_tablet_controls != null && message.hasOwnProperty("shard_tablet_controls")) {
                    if (!Array.isArray(message.shard_tablet_controls))
                        return "shard_tablet_controls: array expected";
                    for (var i = 0; i < message.shard_tablet_controls.length; ++i) {
                        var error = $root.topodata.ShardTabletControl.verify(message.shard_tablet_controls[i]);
                        if (error)
                            return "shard_tablet_controls." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a KeyspacePartition message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof topodata.SrvKeyspace.KeyspacePartition
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {topodata.SrvKeyspace.KeyspacePartition} KeyspacePartition
             */
            KeyspacePartition.fromObject = function fromObject(object) {
                if (object instanceof $root.topodata.SrvKeyspace.KeyspacePartition)
                    return object;
                var message = new $root.topodata.SrvKeyspace.KeyspacePartition();
                switch (object.served_type) {
                case "UNKNOWN":
                case 0:
                    message.served_type = 0;
                    break;
                case "MASTER":
                case 1:
                    message.served_type = 1;
                    break;
                case "REPLICA":
                case 2:
                    message.served_type = 2;
                    break;
                case "RDONLY":
                case 3:
                    message.served_type = 3;
                    break;
                case "BATCH":
                case 3:
                    message.served_type = 3;
                    break;
                case "SPARE":
                case 4:
                    message.served_type = 4;
                    break;
                case "EXPERIMENTAL":
                case 5:
                    message.served_type = 5;
                    break;
                case "BACKUP":
                case 6:
                    message.served_type = 6;
                    break;
                case "RESTORE":
                case 7:
                    message.served_type = 7;
                    break;
                case "DRAINED":
                case 8:
                    message.served_type = 8;
                    break;
                }
                if (object.shard_references) {
                    if (!Array.isArray(object.shard_references))
                        throw TypeError(".topodata.SrvKeyspace.KeyspacePartition.shard_references: array expected");
                    message.shard_references = [];
                    for (var i = 0; i < object.shard_references.length; ++i) {
                        if (typeof object.shard_references[i] !== "object")
                            throw TypeError(".topodata.SrvKeyspace.KeyspacePartition.shard_references: object expected");
                        message.shard_references[i] = $root.topodata.ShardReference.fromObject(object.shard_references[i]);
                    }
                }
                if (object.shard_tablet_controls) {
                    if (!Array.isArray(object.shard_tablet_controls))
                        throw TypeError(".topodata.SrvKeyspace.KeyspacePartition.shard_tablet_controls: array expected");
                    message.shard_tablet_controls = [];
                    for (var i = 0; i < object.shard_tablet_controls.length; ++i) {
                        if (typeof object.shard_tablet_controls[i] !== "object")
                            throw TypeError(".topodata.SrvKeyspace.KeyspacePartition.shard_tablet_controls: object expected");
                        message.shard_tablet_controls[i] = $root.topodata.ShardTabletControl.fromObject(object.shard_tablet_controls[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a KeyspacePartition message. Also converts values to other types if specified.
             * @function toObject
             * @memberof topodata.SrvKeyspace.KeyspacePartition
             * @static
             * @param {topodata.SrvKeyspace.KeyspacePartition} message KeyspacePartition
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KeyspacePartition.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.shard_references = [];
                    object.shard_tablet_controls = [];
                }
                if (options.defaults)
                    object.served_type = options.enums === String ? "UNKNOWN" : 0;
                if (message.served_type != null && message.hasOwnProperty("served_type"))
                    object.served_type = options.enums === String ? $root.topodata.TabletType[message.served_type] : message.served_type;
                if (message.shard_references && message.shard_references.length) {
                    object.shard_references = [];
                    for (var j = 0; j < message.shard_references.length; ++j)
                        object.shard_references[j] = $root.topodata.ShardReference.toObject(message.shard_references[j], options);
                }
                if (message.shard_tablet_controls && message.shard_tablet_controls.length) {
                    object.shard_tablet_controls = [];
                    for (var j = 0; j < message.shard_tablet_controls.length; ++j)
                        object.shard_tablet_controls[j] = $root.topodata.ShardTabletControl.toObject(message.shard_tablet_controls[j], options);
                }
                return object;
            };

            /**
             * Converts this KeyspacePartition to JSON.
             * @function toJSON
             * @memberof topodata.SrvKeyspace.KeyspacePartition
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KeyspacePartition.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KeyspacePartition;
        })();

        SrvKeyspace.ServedFrom = (function() {

            /**
             * Properties of a ServedFrom.
             * @memberof topodata.SrvKeyspace
             * @interface IServedFrom
             * @property {topodata.TabletType|null} [tablet_type] ServedFrom tablet_type
             * @property {string|null} [keyspace] ServedFrom keyspace
             */

            /**
             * Constructs a new ServedFrom.
             * @memberof topodata.SrvKeyspace
             * @classdesc Represents a ServedFrom.
             * @implements IServedFrom
             * @constructor
             * @param {topodata.SrvKeyspace.IServedFrom=} [properties] Properties to set
             */
            function ServedFrom(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServedFrom tablet_type.
             * @member {topodata.TabletType} tablet_type
             * @memberof topodata.SrvKeyspace.ServedFrom
             * @instance
             */
            ServedFrom.prototype.tablet_type = 0;

            /**
             * ServedFrom keyspace.
             * @member {string} keyspace
             * @memberof topodata.SrvKeyspace.ServedFrom
             * @instance
             */
            ServedFrom.prototype.keyspace = "";

            /**
             * Creates a new ServedFrom instance using the specified properties.
             * @function create
             * @memberof topodata.SrvKeyspace.ServedFrom
             * @static
             * @param {topodata.SrvKeyspace.IServedFrom=} [properties] Properties to set
             * @returns {topodata.SrvKeyspace.ServedFrom} ServedFrom instance
             */
            ServedFrom.create = function create(properties) {
                return new ServedFrom(properties);
            };

            /**
             * Encodes the specified ServedFrom message. Does not implicitly {@link topodata.SrvKeyspace.ServedFrom.verify|verify} messages.
             * @function encode
             * @memberof topodata.SrvKeyspace.ServedFrom
             * @static
             * @param {topodata.SrvKeyspace.IServedFrom} message ServedFrom message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServedFrom.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tablet_type != null && Object.hasOwnProperty.call(message, "tablet_type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tablet_type);
                if (message.keyspace != null && Object.hasOwnProperty.call(message, "keyspace"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.keyspace);
                return writer;
            };

            /**
             * Encodes the specified ServedFrom message, length delimited. Does not implicitly {@link topodata.SrvKeyspace.ServedFrom.verify|verify} messages.
             * @function encodeDelimited
             * @memberof topodata.SrvKeyspace.ServedFrom
             * @static
             * @param {topodata.SrvKeyspace.IServedFrom} message ServedFrom message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServedFrom.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ServedFrom message from the specified reader or buffer.
             * @function decode
             * @memberof topodata.SrvKeyspace.ServedFrom
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {topodata.SrvKeyspace.ServedFrom} ServedFrom
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServedFrom.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.topodata.SrvKeyspace.ServedFrom();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tablet_type = reader.int32();
                        break;
                    case 2:
                        message.keyspace = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ServedFrom message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof topodata.SrvKeyspace.ServedFrom
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {topodata.SrvKeyspace.ServedFrom} ServedFrom
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServedFrom.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ServedFrom message.
             * @function verify
             * @memberof topodata.SrvKeyspace.ServedFrom
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ServedFrom.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tablet_type != null && message.hasOwnProperty("tablet_type"))
                    switch (message.tablet_type) {
                    default:
                        return "tablet_type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                        break;
                    }
                if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                    if (!$util.isString(message.keyspace))
                        return "keyspace: string expected";
                return null;
            };

            /**
             * Creates a ServedFrom message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof topodata.SrvKeyspace.ServedFrom
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {topodata.SrvKeyspace.ServedFrom} ServedFrom
             */
            ServedFrom.fromObject = function fromObject(object) {
                if (object instanceof $root.topodata.SrvKeyspace.ServedFrom)
                    return object;
                var message = new $root.topodata.SrvKeyspace.ServedFrom();
                switch (object.tablet_type) {
                case "UNKNOWN":
                case 0:
                    message.tablet_type = 0;
                    break;
                case "MASTER":
                case 1:
                    message.tablet_type = 1;
                    break;
                case "REPLICA":
                case 2:
                    message.tablet_type = 2;
                    break;
                case "RDONLY":
                case 3:
                    message.tablet_type = 3;
                    break;
                case "BATCH":
                case 3:
                    message.tablet_type = 3;
                    break;
                case "SPARE":
                case 4:
                    message.tablet_type = 4;
                    break;
                case "EXPERIMENTAL":
                case 5:
                    message.tablet_type = 5;
                    break;
                case "BACKUP":
                case 6:
                    message.tablet_type = 6;
                    break;
                case "RESTORE":
                case 7:
                    message.tablet_type = 7;
                    break;
                case "DRAINED":
                case 8:
                    message.tablet_type = 8;
                    break;
                }
                if (object.keyspace != null)
                    message.keyspace = String(object.keyspace);
                return message;
            };

            /**
             * Creates a plain object from a ServedFrom message. Also converts values to other types if specified.
             * @function toObject
             * @memberof topodata.SrvKeyspace.ServedFrom
             * @static
             * @param {topodata.SrvKeyspace.ServedFrom} message ServedFrom
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServedFrom.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.tablet_type = options.enums === String ? "UNKNOWN" : 0;
                    object.keyspace = "";
                }
                if (message.tablet_type != null && message.hasOwnProperty("tablet_type"))
                    object.tablet_type = options.enums === String ? $root.topodata.TabletType[message.tablet_type] : message.tablet_type;
                if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                    object.keyspace = message.keyspace;
                return object;
            };

            /**
             * Converts this ServedFrom to JSON.
             * @function toJSON
             * @memberof topodata.SrvKeyspace.ServedFrom
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ServedFrom.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ServedFrom;
        })();

        return SrvKeyspace;
    })();

    topodata.CellInfo = (function() {

        /**
         * Properties of a CellInfo.
         * @memberof topodata
         * @interface ICellInfo
         * @property {string|null} [server_address] CellInfo server_address
         * @property {string|null} [root] CellInfo root
         */

        /**
         * Constructs a new CellInfo.
         * @memberof topodata
         * @classdesc Represents a CellInfo.
         * @implements ICellInfo
         * @constructor
         * @param {topodata.ICellInfo=} [properties] Properties to set
         */
        function CellInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CellInfo server_address.
         * @member {string} server_address
         * @memberof topodata.CellInfo
         * @instance
         */
        CellInfo.prototype.server_address = "";

        /**
         * CellInfo root.
         * @member {string} root
         * @memberof topodata.CellInfo
         * @instance
         */
        CellInfo.prototype.root = "";

        /**
         * Creates a new CellInfo instance using the specified properties.
         * @function create
         * @memberof topodata.CellInfo
         * @static
         * @param {topodata.ICellInfo=} [properties] Properties to set
         * @returns {topodata.CellInfo} CellInfo instance
         */
        CellInfo.create = function create(properties) {
            return new CellInfo(properties);
        };

        /**
         * Encodes the specified CellInfo message. Does not implicitly {@link topodata.CellInfo.verify|verify} messages.
         * @function encode
         * @memberof topodata.CellInfo
         * @static
         * @param {topodata.ICellInfo} message CellInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CellInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.server_address != null && Object.hasOwnProperty.call(message, "server_address"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.server_address);
            if (message.root != null && Object.hasOwnProperty.call(message, "root"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.root);
            return writer;
        };

        /**
         * Encodes the specified CellInfo message, length delimited. Does not implicitly {@link topodata.CellInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof topodata.CellInfo
         * @static
         * @param {topodata.ICellInfo} message CellInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CellInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CellInfo message from the specified reader or buffer.
         * @function decode
         * @memberof topodata.CellInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {topodata.CellInfo} CellInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CellInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.topodata.CellInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.server_address = reader.string();
                    break;
                case 2:
                    message.root = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CellInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof topodata.CellInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {topodata.CellInfo} CellInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CellInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CellInfo message.
         * @function verify
         * @memberof topodata.CellInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CellInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.server_address != null && message.hasOwnProperty("server_address"))
                if (!$util.isString(message.server_address))
                    return "server_address: string expected";
            if (message.root != null && message.hasOwnProperty("root"))
                if (!$util.isString(message.root))
                    return "root: string expected";
            return null;
        };

        /**
         * Creates a CellInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof topodata.CellInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {topodata.CellInfo} CellInfo
         */
        CellInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.topodata.CellInfo)
                return object;
            var message = new $root.topodata.CellInfo();
            if (object.server_address != null)
                message.server_address = String(object.server_address);
            if (object.root != null)
                message.root = String(object.root);
            return message;
        };

        /**
         * Creates a plain object from a CellInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof topodata.CellInfo
         * @static
         * @param {topodata.CellInfo} message CellInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CellInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.server_address = "";
                object.root = "";
            }
            if (message.server_address != null && message.hasOwnProperty("server_address"))
                object.server_address = message.server_address;
            if (message.root != null && message.hasOwnProperty("root"))
                object.root = message.root;
            return object;
        };

        /**
         * Converts this CellInfo to JSON.
         * @function toJSON
         * @memberof topodata.CellInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CellInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CellInfo;
    })();

    topodata.CellsAlias = (function() {

        /**
         * Properties of a CellsAlias.
         * @memberof topodata
         * @interface ICellsAlias
         * @property {Array.<string>|null} [cells] CellsAlias cells
         */

        /**
         * Constructs a new CellsAlias.
         * @memberof topodata
         * @classdesc Represents a CellsAlias.
         * @implements ICellsAlias
         * @constructor
         * @param {topodata.ICellsAlias=} [properties] Properties to set
         */
        function CellsAlias(properties) {
            this.cells = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CellsAlias cells.
         * @member {Array.<string>} cells
         * @memberof topodata.CellsAlias
         * @instance
         */
        CellsAlias.prototype.cells = $util.emptyArray;

        /**
         * Creates a new CellsAlias instance using the specified properties.
         * @function create
         * @memberof topodata.CellsAlias
         * @static
         * @param {topodata.ICellsAlias=} [properties] Properties to set
         * @returns {topodata.CellsAlias} CellsAlias instance
         */
        CellsAlias.create = function create(properties) {
            return new CellsAlias(properties);
        };

        /**
         * Encodes the specified CellsAlias message. Does not implicitly {@link topodata.CellsAlias.verify|verify} messages.
         * @function encode
         * @memberof topodata.CellsAlias
         * @static
         * @param {topodata.ICellsAlias} message CellsAlias message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CellsAlias.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cells != null && message.cells.length)
                for (var i = 0; i < message.cells.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.cells[i]);
            return writer;
        };

        /**
         * Encodes the specified CellsAlias message, length delimited. Does not implicitly {@link topodata.CellsAlias.verify|verify} messages.
         * @function encodeDelimited
         * @memberof topodata.CellsAlias
         * @static
         * @param {topodata.ICellsAlias} message CellsAlias message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CellsAlias.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CellsAlias message from the specified reader or buffer.
         * @function decode
         * @memberof topodata.CellsAlias
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {topodata.CellsAlias} CellsAlias
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CellsAlias.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.topodata.CellsAlias();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    if (!(message.cells && message.cells.length))
                        message.cells = [];
                    message.cells.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CellsAlias message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof topodata.CellsAlias
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {topodata.CellsAlias} CellsAlias
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CellsAlias.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CellsAlias message.
         * @function verify
         * @memberof topodata.CellsAlias
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CellsAlias.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cells != null && message.hasOwnProperty("cells")) {
                if (!Array.isArray(message.cells))
                    return "cells: array expected";
                for (var i = 0; i < message.cells.length; ++i)
                    if (!$util.isString(message.cells[i]))
                        return "cells: string[] expected";
            }
            return null;
        };

        /**
         * Creates a CellsAlias message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof topodata.CellsAlias
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {topodata.CellsAlias} CellsAlias
         */
        CellsAlias.fromObject = function fromObject(object) {
            if (object instanceof $root.topodata.CellsAlias)
                return object;
            var message = new $root.topodata.CellsAlias();
            if (object.cells) {
                if (!Array.isArray(object.cells))
                    throw TypeError(".topodata.CellsAlias.cells: array expected");
                message.cells = [];
                for (var i = 0; i < object.cells.length; ++i)
                    message.cells[i] = String(object.cells[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a CellsAlias message. Also converts values to other types if specified.
         * @function toObject
         * @memberof topodata.CellsAlias
         * @static
         * @param {topodata.CellsAlias} message CellsAlias
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CellsAlias.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.cells = [];
            if (message.cells && message.cells.length) {
                object.cells = [];
                for (var j = 0; j < message.cells.length; ++j)
                    object.cells[j] = message.cells[j];
            }
            return object;
        };

        /**
         * Converts this CellsAlias to JSON.
         * @function toJSON
         * @memberof topodata.CellsAlias
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CellsAlias.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CellsAlias;
    })();

    topodata.TopoConfig = (function() {

        /**
         * Properties of a TopoConfig.
         * @memberof topodata
         * @interface ITopoConfig
         * @property {string|null} [topo_type] TopoConfig topo_type
         * @property {string|null} [server] TopoConfig server
         * @property {string|null} [root] TopoConfig root
         */

        /**
         * Constructs a new TopoConfig.
         * @memberof topodata
         * @classdesc Represents a TopoConfig.
         * @implements ITopoConfig
         * @constructor
         * @param {topodata.ITopoConfig=} [properties] Properties to set
         */
        function TopoConfig(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TopoConfig topo_type.
         * @member {string} topo_type
         * @memberof topodata.TopoConfig
         * @instance
         */
        TopoConfig.prototype.topo_type = "";

        /**
         * TopoConfig server.
         * @member {string} server
         * @memberof topodata.TopoConfig
         * @instance
         */
        TopoConfig.prototype.server = "";

        /**
         * TopoConfig root.
         * @member {string} root
         * @memberof topodata.TopoConfig
         * @instance
         */
        TopoConfig.prototype.root = "";

        /**
         * Creates a new TopoConfig instance using the specified properties.
         * @function create
         * @memberof topodata.TopoConfig
         * @static
         * @param {topodata.ITopoConfig=} [properties] Properties to set
         * @returns {topodata.TopoConfig} TopoConfig instance
         */
        TopoConfig.create = function create(properties) {
            return new TopoConfig(properties);
        };

        /**
         * Encodes the specified TopoConfig message. Does not implicitly {@link topodata.TopoConfig.verify|verify} messages.
         * @function encode
         * @memberof topodata.TopoConfig
         * @static
         * @param {topodata.ITopoConfig} message TopoConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TopoConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.topo_type != null && Object.hasOwnProperty.call(message, "topo_type"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.topo_type);
            if (message.server != null && Object.hasOwnProperty.call(message, "server"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.server);
            if (message.root != null && Object.hasOwnProperty.call(message, "root"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.root);
            return writer;
        };

        /**
         * Encodes the specified TopoConfig message, length delimited. Does not implicitly {@link topodata.TopoConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof topodata.TopoConfig
         * @static
         * @param {topodata.ITopoConfig} message TopoConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TopoConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TopoConfig message from the specified reader or buffer.
         * @function decode
         * @memberof topodata.TopoConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {topodata.TopoConfig} TopoConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TopoConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.topodata.TopoConfig();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.topo_type = reader.string();
                    break;
                case 2:
                    message.server = reader.string();
                    break;
                case 3:
                    message.root = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TopoConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof topodata.TopoConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {topodata.TopoConfig} TopoConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TopoConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TopoConfig message.
         * @function verify
         * @memberof topodata.TopoConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TopoConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.topo_type != null && message.hasOwnProperty("topo_type"))
                if (!$util.isString(message.topo_type))
                    return "topo_type: string expected";
            if (message.server != null && message.hasOwnProperty("server"))
                if (!$util.isString(message.server))
                    return "server: string expected";
            if (message.root != null && message.hasOwnProperty("root"))
                if (!$util.isString(message.root))
                    return "root: string expected";
            return null;
        };

        /**
         * Creates a TopoConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof topodata.TopoConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {topodata.TopoConfig} TopoConfig
         */
        TopoConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.topodata.TopoConfig)
                return object;
            var message = new $root.topodata.TopoConfig();
            if (object.topo_type != null)
                message.topo_type = String(object.topo_type);
            if (object.server != null)
                message.server = String(object.server);
            if (object.root != null)
                message.root = String(object.root);
            return message;
        };

        /**
         * Creates a plain object from a TopoConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof topodata.TopoConfig
         * @static
         * @param {topodata.TopoConfig} message TopoConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TopoConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.topo_type = "";
                object.server = "";
                object.root = "";
            }
            if (message.topo_type != null && message.hasOwnProperty("topo_type"))
                object.topo_type = message.topo_type;
            if (message.server != null && message.hasOwnProperty("server"))
                object.server = message.server;
            if (message.root != null && message.hasOwnProperty("root"))
                object.root = message.root;
            return object;
        };

        /**
         * Converts this TopoConfig to JSON.
         * @function toJSON
         * @memberof topodata.TopoConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TopoConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TopoConfig;
    })();

    topodata.ExternalVitessCluster = (function() {

        /**
         * Properties of an ExternalVitessCluster.
         * @memberof topodata
         * @interface IExternalVitessCluster
         * @property {topodata.ITopoConfig|null} [topo_config] ExternalVitessCluster topo_config
         */

        /**
         * Constructs a new ExternalVitessCluster.
         * @memberof topodata
         * @classdesc Represents an ExternalVitessCluster.
         * @implements IExternalVitessCluster
         * @constructor
         * @param {topodata.IExternalVitessCluster=} [properties] Properties to set
         */
        function ExternalVitessCluster(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExternalVitessCluster topo_config.
         * @member {topodata.ITopoConfig|null|undefined} topo_config
         * @memberof topodata.ExternalVitessCluster
         * @instance
         */
        ExternalVitessCluster.prototype.topo_config = null;

        /**
         * Creates a new ExternalVitessCluster instance using the specified properties.
         * @function create
         * @memberof topodata.ExternalVitessCluster
         * @static
         * @param {topodata.IExternalVitessCluster=} [properties] Properties to set
         * @returns {topodata.ExternalVitessCluster} ExternalVitessCluster instance
         */
        ExternalVitessCluster.create = function create(properties) {
            return new ExternalVitessCluster(properties);
        };

        /**
         * Encodes the specified ExternalVitessCluster message. Does not implicitly {@link topodata.ExternalVitessCluster.verify|verify} messages.
         * @function encode
         * @memberof topodata.ExternalVitessCluster
         * @static
         * @param {topodata.IExternalVitessCluster} message ExternalVitessCluster message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExternalVitessCluster.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.topo_config != null && Object.hasOwnProperty.call(message, "topo_config"))
                $root.topodata.TopoConfig.encode(message.topo_config, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ExternalVitessCluster message, length delimited. Does not implicitly {@link topodata.ExternalVitessCluster.verify|verify} messages.
         * @function encodeDelimited
         * @memberof topodata.ExternalVitessCluster
         * @static
         * @param {topodata.IExternalVitessCluster} message ExternalVitessCluster message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExternalVitessCluster.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExternalVitessCluster message from the specified reader or buffer.
         * @function decode
         * @memberof topodata.ExternalVitessCluster
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {topodata.ExternalVitessCluster} ExternalVitessCluster
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExternalVitessCluster.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.topodata.ExternalVitessCluster();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.topo_config = $root.topodata.TopoConfig.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExternalVitessCluster message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof topodata.ExternalVitessCluster
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {topodata.ExternalVitessCluster} ExternalVitessCluster
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExternalVitessCluster.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExternalVitessCluster message.
         * @function verify
         * @memberof topodata.ExternalVitessCluster
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExternalVitessCluster.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.topo_config != null && message.hasOwnProperty("topo_config")) {
                var error = $root.topodata.TopoConfig.verify(message.topo_config);
                if (error)
                    return "topo_config." + error;
            }
            return null;
        };

        /**
         * Creates an ExternalVitessCluster message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof topodata.ExternalVitessCluster
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {topodata.ExternalVitessCluster} ExternalVitessCluster
         */
        ExternalVitessCluster.fromObject = function fromObject(object) {
            if (object instanceof $root.topodata.ExternalVitessCluster)
                return object;
            var message = new $root.topodata.ExternalVitessCluster();
            if (object.topo_config != null) {
                if (typeof object.topo_config !== "object")
                    throw TypeError(".topodata.ExternalVitessCluster.topo_config: object expected");
                message.topo_config = $root.topodata.TopoConfig.fromObject(object.topo_config);
            }
            return message;
        };

        /**
         * Creates a plain object from an ExternalVitessCluster message. Also converts values to other types if specified.
         * @function toObject
         * @memberof topodata.ExternalVitessCluster
         * @static
         * @param {topodata.ExternalVitessCluster} message ExternalVitessCluster
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExternalVitessCluster.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.topo_config = null;
            if (message.topo_config != null && message.hasOwnProperty("topo_config"))
                object.topo_config = $root.topodata.TopoConfig.toObject(message.topo_config, options);
            return object;
        };

        /**
         * Converts this ExternalVitessCluster to JSON.
         * @function toJSON
         * @memberof topodata.ExternalVitessCluster
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExternalVitessCluster.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExternalVitessCluster;
    })();

    topodata.ExternalClusters = (function() {

        /**
         * Properties of an ExternalClusters.
         * @memberof topodata
         * @interface IExternalClusters
         * @property {Array.<topodata.IExternalVitessCluster>|null} [vitess_cluster] ExternalClusters vitess_cluster
         */

        /**
         * Constructs a new ExternalClusters.
         * @memberof topodata
         * @classdesc Represents an ExternalClusters.
         * @implements IExternalClusters
         * @constructor
         * @param {topodata.IExternalClusters=} [properties] Properties to set
         */
        function ExternalClusters(properties) {
            this.vitess_cluster = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExternalClusters vitess_cluster.
         * @member {Array.<topodata.IExternalVitessCluster>} vitess_cluster
         * @memberof topodata.ExternalClusters
         * @instance
         */
        ExternalClusters.prototype.vitess_cluster = $util.emptyArray;

        /**
         * Creates a new ExternalClusters instance using the specified properties.
         * @function create
         * @memberof topodata.ExternalClusters
         * @static
         * @param {topodata.IExternalClusters=} [properties] Properties to set
         * @returns {topodata.ExternalClusters} ExternalClusters instance
         */
        ExternalClusters.create = function create(properties) {
            return new ExternalClusters(properties);
        };

        /**
         * Encodes the specified ExternalClusters message. Does not implicitly {@link topodata.ExternalClusters.verify|verify} messages.
         * @function encode
         * @memberof topodata.ExternalClusters
         * @static
         * @param {topodata.IExternalClusters} message ExternalClusters message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExternalClusters.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.vitess_cluster != null && message.vitess_cluster.length)
                for (var i = 0; i < message.vitess_cluster.length; ++i)
                    $root.topodata.ExternalVitessCluster.encode(message.vitess_cluster[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ExternalClusters message, length delimited. Does not implicitly {@link topodata.ExternalClusters.verify|verify} messages.
         * @function encodeDelimited
         * @memberof topodata.ExternalClusters
         * @static
         * @param {topodata.IExternalClusters} message ExternalClusters message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExternalClusters.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExternalClusters message from the specified reader or buffer.
         * @function decode
         * @memberof topodata.ExternalClusters
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {topodata.ExternalClusters} ExternalClusters
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExternalClusters.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.topodata.ExternalClusters();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.vitess_cluster && message.vitess_cluster.length))
                        message.vitess_cluster = [];
                    message.vitess_cluster.push($root.topodata.ExternalVitessCluster.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExternalClusters message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof topodata.ExternalClusters
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {topodata.ExternalClusters} ExternalClusters
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExternalClusters.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExternalClusters message.
         * @function verify
         * @memberof topodata.ExternalClusters
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExternalClusters.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.vitess_cluster != null && message.hasOwnProperty("vitess_cluster")) {
                if (!Array.isArray(message.vitess_cluster))
                    return "vitess_cluster: array expected";
                for (var i = 0; i < message.vitess_cluster.length; ++i) {
                    var error = $root.topodata.ExternalVitessCluster.verify(message.vitess_cluster[i]);
                    if (error)
                        return "vitess_cluster." + error;
                }
            }
            return null;
        };

        /**
         * Creates an ExternalClusters message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof topodata.ExternalClusters
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {topodata.ExternalClusters} ExternalClusters
         */
        ExternalClusters.fromObject = function fromObject(object) {
            if (object instanceof $root.topodata.ExternalClusters)
                return object;
            var message = new $root.topodata.ExternalClusters();
            if (object.vitess_cluster) {
                if (!Array.isArray(object.vitess_cluster))
                    throw TypeError(".topodata.ExternalClusters.vitess_cluster: array expected");
                message.vitess_cluster = [];
                for (var i = 0; i < object.vitess_cluster.length; ++i) {
                    if (typeof object.vitess_cluster[i] !== "object")
                        throw TypeError(".topodata.ExternalClusters.vitess_cluster: object expected");
                    message.vitess_cluster[i] = $root.topodata.ExternalVitessCluster.fromObject(object.vitess_cluster[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an ExternalClusters message. Also converts values to other types if specified.
         * @function toObject
         * @memberof topodata.ExternalClusters
         * @static
         * @param {topodata.ExternalClusters} message ExternalClusters
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExternalClusters.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.vitess_cluster = [];
            if (message.vitess_cluster && message.vitess_cluster.length) {
                object.vitess_cluster = [];
                for (var j = 0; j < message.vitess_cluster.length; ++j)
                    object.vitess_cluster[j] = $root.topodata.ExternalVitessCluster.toObject(message.vitess_cluster[j], options);
            }
            return object;
        };

        /**
         * Converts this ExternalClusters to JSON.
         * @function toJSON
         * @memberof topodata.ExternalClusters
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExternalClusters.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExternalClusters;
    })();

    return topodata;
})();

$root.vttime = (function() {

    /**
     * Namespace vttime.
     * @exports vttime
     * @namespace
     */
    var vttime = {};

    vttime.Time = (function() {

        /**
         * Properties of a Time.
         * @memberof vttime
         * @interface ITime
         * @property {number|Long|null} [seconds] Time seconds
         * @property {number|null} [nanoseconds] Time nanoseconds
         */

        /**
         * Constructs a new Time.
         * @memberof vttime
         * @classdesc Represents a Time.
         * @implements ITime
         * @constructor
         * @param {vttime.ITime=} [properties] Properties to set
         */
        function Time(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Time seconds.
         * @member {number|Long} seconds
         * @memberof vttime.Time
         * @instance
         */
        Time.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Time nanoseconds.
         * @member {number} nanoseconds
         * @memberof vttime.Time
         * @instance
         */
        Time.prototype.nanoseconds = 0;

        /**
         * Creates a new Time instance using the specified properties.
         * @function create
         * @memberof vttime.Time
         * @static
         * @param {vttime.ITime=} [properties] Properties to set
         * @returns {vttime.Time} Time instance
         */
        Time.create = function create(properties) {
            return new Time(properties);
        };

        /**
         * Encodes the specified Time message. Does not implicitly {@link vttime.Time.verify|verify} messages.
         * @function encode
         * @memberof vttime.Time
         * @static
         * @param {vttime.ITime} message Time message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Time.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
            if (message.nanoseconds != null && Object.hasOwnProperty.call(message, "nanoseconds"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanoseconds);
            return writer;
        };

        /**
         * Encodes the specified Time message, length delimited. Does not implicitly {@link vttime.Time.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vttime.Time
         * @static
         * @param {vttime.ITime} message Time message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Time.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Time message from the specified reader or buffer.
         * @function decode
         * @memberof vttime.Time
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vttime.Time} Time
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Time.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vttime.Time();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.seconds = reader.int64();
                    break;
                case 2:
                    message.nanoseconds = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Time message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vttime.Time
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vttime.Time} Time
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Time.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Time message.
         * @function verify
         * @memberof vttime.Time
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Time.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.seconds != null && message.hasOwnProperty("seconds"))
                if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                    return "seconds: integer|Long expected";
            if (message.nanoseconds != null && message.hasOwnProperty("nanoseconds"))
                if (!$util.isInteger(message.nanoseconds))
                    return "nanoseconds: integer expected";
            return null;
        };

        /**
         * Creates a Time message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vttime.Time
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vttime.Time} Time
         */
        Time.fromObject = function fromObject(object) {
            if (object instanceof $root.vttime.Time)
                return object;
            var message = new $root.vttime.Time();
            if (object.seconds != null)
                if ($util.Long)
                    (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
                else if (typeof object.seconds === "string")
                    message.seconds = parseInt(object.seconds, 10);
                else if (typeof object.seconds === "number")
                    message.seconds = object.seconds;
                else if (typeof object.seconds === "object")
                    message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
            if (object.nanoseconds != null)
                message.nanoseconds = object.nanoseconds | 0;
            return message;
        };

        /**
         * Creates a plain object from a Time message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vttime.Time
         * @static
         * @param {vttime.Time} message Time
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Time.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.seconds = options.longs === String ? "0" : 0;
                object.nanoseconds = 0;
            }
            if (message.seconds != null && message.hasOwnProperty("seconds"))
                if (typeof message.seconds === "number")
                    object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
                else
                    object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
            if (message.nanoseconds != null && message.hasOwnProperty("nanoseconds"))
                object.nanoseconds = message.nanoseconds;
            return object;
        };

        /**
         * Converts this Time to JSON.
         * @function toJSON
         * @memberof vttime.Time
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Time.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Time;
    })();

    vttime.Duration = (function() {

        /**
         * Properties of a Duration.
         * @memberof vttime
         * @interface IDuration
         * @property {number|Long|null} [seconds] Duration seconds
         * @property {number|null} [nanos] Duration nanos
         */

        /**
         * Constructs a new Duration.
         * @memberof vttime
         * @classdesc Represents a Duration.
         * @implements IDuration
         * @constructor
         * @param {vttime.IDuration=} [properties] Properties to set
         */
        function Duration(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Duration seconds.
         * @member {number|Long} seconds
         * @memberof vttime.Duration
         * @instance
         */
        Duration.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Duration nanos.
         * @member {number} nanos
         * @memberof vttime.Duration
         * @instance
         */
        Duration.prototype.nanos = 0;

        /**
         * Creates a new Duration instance using the specified properties.
         * @function create
         * @memberof vttime.Duration
         * @static
         * @param {vttime.IDuration=} [properties] Properties to set
         * @returns {vttime.Duration} Duration instance
         */
        Duration.create = function create(properties) {
            return new Duration(properties);
        };

        /**
         * Encodes the specified Duration message. Does not implicitly {@link vttime.Duration.verify|verify} messages.
         * @function encode
         * @memberof vttime.Duration
         * @static
         * @param {vttime.IDuration} message Duration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Duration.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
            if (message.nanos != null && Object.hasOwnProperty.call(message, "nanos"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);
            return writer;
        };

        /**
         * Encodes the specified Duration message, length delimited. Does not implicitly {@link vttime.Duration.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vttime.Duration
         * @static
         * @param {vttime.IDuration} message Duration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Duration.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Duration message from the specified reader or buffer.
         * @function decode
         * @memberof vttime.Duration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vttime.Duration} Duration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Duration.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vttime.Duration();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.seconds = reader.int64();
                    break;
                case 2:
                    message.nanos = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Duration message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vttime.Duration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vttime.Duration} Duration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Duration.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Duration message.
         * @function verify
         * @memberof vttime.Duration
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Duration.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.seconds != null && message.hasOwnProperty("seconds"))
                if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                    return "seconds: integer|Long expected";
            if (message.nanos != null && message.hasOwnProperty("nanos"))
                if (!$util.isInteger(message.nanos))
                    return "nanos: integer expected";
            return null;
        };

        /**
         * Creates a Duration message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vttime.Duration
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vttime.Duration} Duration
         */
        Duration.fromObject = function fromObject(object) {
            if (object instanceof $root.vttime.Duration)
                return object;
            var message = new $root.vttime.Duration();
            if (object.seconds != null)
                if ($util.Long)
                    (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
                else if (typeof object.seconds === "string")
                    message.seconds = parseInt(object.seconds, 10);
                else if (typeof object.seconds === "number")
                    message.seconds = object.seconds;
                else if (typeof object.seconds === "object")
                    message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
            if (object.nanos != null)
                message.nanos = object.nanos | 0;
            return message;
        };

        /**
         * Creates a plain object from a Duration message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vttime.Duration
         * @static
         * @param {vttime.Duration} message Duration
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Duration.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.seconds = options.longs === String ? "0" : 0;
                object.nanos = 0;
            }
            if (message.seconds != null && message.hasOwnProperty("seconds"))
                if (typeof message.seconds === "number")
                    object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
                else
                    object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
            if (message.nanos != null && message.hasOwnProperty("nanos"))
                object.nanos = message.nanos;
            return object;
        };

        /**
         * Converts this Duration to JSON.
         * @function toJSON
         * @memberof vttime.Duration
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Duration.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Duration;
    })();

    return vttime;
})();

$root.vtrpc = (function() {

    /**
     * Namespace vtrpc.
     * @exports vtrpc
     * @namespace
     */
    var vtrpc = {};

    vtrpc.CallerID = (function() {

        /**
         * Properties of a CallerID.
         * @memberof vtrpc
         * @interface ICallerID
         * @property {string|null} [principal] CallerID principal
         * @property {string|null} [component] CallerID component
         * @property {string|null} [subcomponent] CallerID subcomponent
         */

        /**
         * Constructs a new CallerID.
         * @memberof vtrpc
         * @classdesc Represents a CallerID.
         * @implements ICallerID
         * @constructor
         * @param {vtrpc.ICallerID=} [properties] Properties to set
         */
        function CallerID(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CallerID principal.
         * @member {string} principal
         * @memberof vtrpc.CallerID
         * @instance
         */
        CallerID.prototype.principal = "";

        /**
         * CallerID component.
         * @member {string} component
         * @memberof vtrpc.CallerID
         * @instance
         */
        CallerID.prototype.component = "";

        /**
         * CallerID subcomponent.
         * @member {string} subcomponent
         * @memberof vtrpc.CallerID
         * @instance
         */
        CallerID.prototype.subcomponent = "";

        /**
         * Creates a new CallerID instance using the specified properties.
         * @function create
         * @memberof vtrpc.CallerID
         * @static
         * @param {vtrpc.ICallerID=} [properties] Properties to set
         * @returns {vtrpc.CallerID} CallerID instance
         */
        CallerID.create = function create(properties) {
            return new CallerID(properties);
        };

        /**
         * Encodes the specified CallerID message. Does not implicitly {@link vtrpc.CallerID.verify|verify} messages.
         * @function encode
         * @memberof vtrpc.CallerID
         * @static
         * @param {vtrpc.ICallerID} message CallerID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CallerID.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.principal != null && Object.hasOwnProperty.call(message, "principal"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.principal);
            if (message.component != null && Object.hasOwnProperty.call(message, "component"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.component);
            if (message.subcomponent != null && Object.hasOwnProperty.call(message, "subcomponent"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.subcomponent);
            return writer;
        };

        /**
         * Encodes the specified CallerID message, length delimited. Does not implicitly {@link vtrpc.CallerID.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtrpc.CallerID
         * @static
         * @param {vtrpc.ICallerID} message CallerID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CallerID.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CallerID message from the specified reader or buffer.
         * @function decode
         * @memberof vtrpc.CallerID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtrpc.CallerID} CallerID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CallerID.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtrpc.CallerID();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.principal = reader.string();
                    break;
                case 2:
                    message.component = reader.string();
                    break;
                case 3:
                    message.subcomponent = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CallerID message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtrpc.CallerID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtrpc.CallerID} CallerID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CallerID.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CallerID message.
         * @function verify
         * @memberof vtrpc.CallerID
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CallerID.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.principal != null && message.hasOwnProperty("principal"))
                if (!$util.isString(message.principal))
                    return "principal: string expected";
            if (message.component != null && message.hasOwnProperty("component"))
                if (!$util.isString(message.component))
                    return "component: string expected";
            if (message.subcomponent != null && message.hasOwnProperty("subcomponent"))
                if (!$util.isString(message.subcomponent))
                    return "subcomponent: string expected";
            return null;
        };

        /**
         * Creates a CallerID message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtrpc.CallerID
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtrpc.CallerID} CallerID
         */
        CallerID.fromObject = function fromObject(object) {
            if (object instanceof $root.vtrpc.CallerID)
                return object;
            var message = new $root.vtrpc.CallerID();
            if (object.principal != null)
                message.principal = String(object.principal);
            if (object.component != null)
                message.component = String(object.component);
            if (object.subcomponent != null)
                message.subcomponent = String(object.subcomponent);
            return message;
        };

        /**
         * Creates a plain object from a CallerID message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtrpc.CallerID
         * @static
         * @param {vtrpc.CallerID} message CallerID
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CallerID.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.principal = "";
                object.component = "";
                object.subcomponent = "";
            }
            if (message.principal != null && message.hasOwnProperty("principal"))
                object.principal = message.principal;
            if (message.component != null && message.hasOwnProperty("component"))
                object.component = message.component;
            if (message.subcomponent != null && message.hasOwnProperty("subcomponent"))
                object.subcomponent = message.subcomponent;
            return object;
        };

        /**
         * Converts this CallerID to JSON.
         * @function toJSON
         * @memberof vtrpc.CallerID
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CallerID.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CallerID;
    })();

    /**
     * Code enum.
     * @name vtrpc.Code
     * @enum {number}
     * @property {number} OK=0 OK value
     * @property {number} CANCELED=1 CANCELED value
     * @property {number} UNKNOWN=2 UNKNOWN value
     * @property {number} INVALID_ARGUMENT=3 INVALID_ARGUMENT value
     * @property {number} DEADLINE_EXCEEDED=4 DEADLINE_EXCEEDED value
     * @property {number} NOT_FOUND=5 NOT_FOUND value
     * @property {number} ALREADY_EXISTS=6 ALREADY_EXISTS value
     * @property {number} PERMISSION_DENIED=7 PERMISSION_DENIED value
     * @property {number} UNAUTHENTICATED=16 UNAUTHENTICATED value
     * @property {number} RESOURCE_EXHAUSTED=8 RESOURCE_EXHAUSTED value
     * @property {number} FAILED_PRECONDITION=9 FAILED_PRECONDITION value
     * @property {number} ABORTED=10 ABORTED value
     * @property {number} OUT_OF_RANGE=11 OUT_OF_RANGE value
     * @property {number} UNIMPLEMENTED=12 UNIMPLEMENTED value
     * @property {number} INTERNAL=13 INTERNAL value
     * @property {number} UNAVAILABLE=14 UNAVAILABLE value
     * @property {number} DATA_LOSS=15 DATA_LOSS value
     */
    vtrpc.Code = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "OK"] = 0;
        values[valuesById[1] = "CANCELED"] = 1;
        values[valuesById[2] = "UNKNOWN"] = 2;
        values[valuesById[3] = "INVALID_ARGUMENT"] = 3;
        values[valuesById[4] = "DEADLINE_EXCEEDED"] = 4;
        values[valuesById[5] = "NOT_FOUND"] = 5;
        values[valuesById[6] = "ALREADY_EXISTS"] = 6;
        values[valuesById[7] = "PERMISSION_DENIED"] = 7;
        values[valuesById[16] = "UNAUTHENTICATED"] = 16;
        values[valuesById[8] = "RESOURCE_EXHAUSTED"] = 8;
        values[valuesById[9] = "FAILED_PRECONDITION"] = 9;
        values[valuesById[10] = "ABORTED"] = 10;
        values[valuesById[11] = "OUT_OF_RANGE"] = 11;
        values[valuesById[12] = "UNIMPLEMENTED"] = 12;
        values[valuesById[13] = "INTERNAL"] = 13;
        values[valuesById[14] = "UNAVAILABLE"] = 14;
        values[valuesById[15] = "DATA_LOSS"] = 15;
        return values;
    })();

    /**
     * LegacyErrorCode enum.
     * @name vtrpc.LegacyErrorCode
     * @enum {number}
     * @property {number} SUCCESS_LEGACY=0 SUCCESS_LEGACY value
     * @property {number} CANCELLED_LEGACY=1 CANCELLED_LEGACY value
     * @property {number} UNKNOWN_ERROR_LEGACY=2 UNKNOWN_ERROR_LEGACY value
     * @property {number} BAD_INPUT_LEGACY=3 BAD_INPUT_LEGACY value
     * @property {number} DEADLINE_EXCEEDED_LEGACY=4 DEADLINE_EXCEEDED_LEGACY value
     * @property {number} INTEGRITY_ERROR_LEGACY=5 INTEGRITY_ERROR_LEGACY value
     * @property {number} PERMISSION_DENIED_LEGACY=6 PERMISSION_DENIED_LEGACY value
     * @property {number} RESOURCE_EXHAUSTED_LEGACY=7 RESOURCE_EXHAUSTED_LEGACY value
     * @property {number} QUERY_NOT_SERVED_LEGACY=8 QUERY_NOT_SERVED_LEGACY value
     * @property {number} NOT_IN_TX_LEGACY=9 NOT_IN_TX_LEGACY value
     * @property {number} INTERNAL_ERROR_LEGACY=10 INTERNAL_ERROR_LEGACY value
     * @property {number} TRANSIENT_ERROR_LEGACY=11 TRANSIENT_ERROR_LEGACY value
     * @property {number} UNAUTHENTICATED_LEGACY=12 UNAUTHENTICATED_LEGACY value
     */
    vtrpc.LegacyErrorCode = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SUCCESS_LEGACY"] = 0;
        values[valuesById[1] = "CANCELLED_LEGACY"] = 1;
        values[valuesById[2] = "UNKNOWN_ERROR_LEGACY"] = 2;
        values[valuesById[3] = "BAD_INPUT_LEGACY"] = 3;
        values[valuesById[4] = "DEADLINE_EXCEEDED_LEGACY"] = 4;
        values[valuesById[5] = "INTEGRITY_ERROR_LEGACY"] = 5;
        values[valuesById[6] = "PERMISSION_DENIED_LEGACY"] = 6;
        values[valuesById[7] = "RESOURCE_EXHAUSTED_LEGACY"] = 7;
        values[valuesById[8] = "QUERY_NOT_SERVED_LEGACY"] = 8;
        values[valuesById[9] = "NOT_IN_TX_LEGACY"] = 9;
        values[valuesById[10] = "INTERNAL_ERROR_LEGACY"] = 10;
        values[valuesById[11] = "TRANSIENT_ERROR_LEGACY"] = 11;
        values[valuesById[12] = "UNAUTHENTICATED_LEGACY"] = 12;
        return values;
    })();

    vtrpc.RPCError = (function() {

        /**
         * Properties of a RPCError.
         * @memberof vtrpc
         * @interface IRPCError
         * @property {vtrpc.LegacyErrorCode|null} [legacy_code] RPCError legacy_code
         * @property {string|null} [message] RPCError message
         * @property {vtrpc.Code|null} [code] RPCError code
         */

        /**
         * Constructs a new RPCError.
         * @memberof vtrpc
         * @classdesc Represents a RPCError.
         * @implements IRPCError
         * @constructor
         * @param {vtrpc.IRPCError=} [properties] Properties to set
         */
        function RPCError(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RPCError legacy_code.
         * @member {vtrpc.LegacyErrorCode} legacy_code
         * @memberof vtrpc.RPCError
         * @instance
         */
        RPCError.prototype.legacy_code = 0;

        /**
         * RPCError message.
         * @member {string} message
         * @memberof vtrpc.RPCError
         * @instance
         */
        RPCError.prototype.message = "";

        /**
         * RPCError code.
         * @member {vtrpc.Code} code
         * @memberof vtrpc.RPCError
         * @instance
         */
        RPCError.prototype.code = 0;

        /**
         * Creates a new RPCError instance using the specified properties.
         * @function create
         * @memberof vtrpc.RPCError
         * @static
         * @param {vtrpc.IRPCError=} [properties] Properties to set
         * @returns {vtrpc.RPCError} RPCError instance
         */
        RPCError.create = function create(properties) {
            return new RPCError(properties);
        };

        /**
         * Encodes the specified RPCError message. Does not implicitly {@link vtrpc.RPCError.verify|verify} messages.
         * @function encode
         * @memberof vtrpc.RPCError
         * @static
         * @param {vtrpc.IRPCError} message RPCError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RPCError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.legacy_code != null && Object.hasOwnProperty.call(message, "legacy_code"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.legacy_code);
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
            if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.code);
            return writer;
        };

        /**
         * Encodes the specified RPCError message, length delimited. Does not implicitly {@link vtrpc.RPCError.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtrpc.RPCError
         * @static
         * @param {vtrpc.IRPCError} message RPCError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RPCError.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RPCError message from the specified reader or buffer.
         * @function decode
         * @memberof vtrpc.RPCError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtrpc.RPCError} RPCError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RPCError.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtrpc.RPCError();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.legacy_code = reader.int32();
                    break;
                case 2:
                    message.message = reader.string();
                    break;
                case 3:
                    message.code = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RPCError message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtrpc.RPCError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtrpc.RPCError} RPCError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RPCError.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RPCError message.
         * @function verify
         * @memberof vtrpc.RPCError
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RPCError.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.legacy_code != null && message.hasOwnProperty("legacy_code"))
                switch (message.legacy_code) {
                default:
                    return "legacy_code: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                    break;
                }
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            if (message.code != null && message.hasOwnProperty("code"))
                switch (message.code) {
                default:
                    return "code: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 16:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                    break;
                }
            return null;
        };

        /**
         * Creates a RPCError message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtrpc.RPCError
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtrpc.RPCError} RPCError
         */
        RPCError.fromObject = function fromObject(object) {
            if (object instanceof $root.vtrpc.RPCError)
                return object;
            var message = new $root.vtrpc.RPCError();
            switch (object.legacy_code) {
            case "SUCCESS_LEGACY":
            case 0:
                message.legacy_code = 0;
                break;
            case "CANCELLED_LEGACY":
            case 1:
                message.legacy_code = 1;
                break;
            case "UNKNOWN_ERROR_LEGACY":
            case 2:
                message.legacy_code = 2;
                break;
            case "BAD_INPUT_LEGACY":
            case 3:
                message.legacy_code = 3;
                break;
            case "DEADLINE_EXCEEDED_LEGACY":
            case 4:
                message.legacy_code = 4;
                break;
            case "INTEGRITY_ERROR_LEGACY":
            case 5:
                message.legacy_code = 5;
                break;
            case "PERMISSION_DENIED_LEGACY":
            case 6:
                message.legacy_code = 6;
                break;
            case "RESOURCE_EXHAUSTED_LEGACY":
            case 7:
                message.legacy_code = 7;
                break;
            case "QUERY_NOT_SERVED_LEGACY":
            case 8:
                message.legacy_code = 8;
                break;
            case "NOT_IN_TX_LEGACY":
            case 9:
                message.legacy_code = 9;
                break;
            case "INTERNAL_ERROR_LEGACY":
            case 10:
                message.legacy_code = 10;
                break;
            case "TRANSIENT_ERROR_LEGACY":
            case 11:
                message.legacy_code = 11;
                break;
            case "UNAUTHENTICATED_LEGACY":
            case 12:
                message.legacy_code = 12;
                break;
            }
            if (object.message != null)
                message.message = String(object.message);
            switch (object.code) {
            case "OK":
            case 0:
                message.code = 0;
                break;
            case "CANCELED":
            case 1:
                message.code = 1;
                break;
            case "UNKNOWN":
            case 2:
                message.code = 2;
                break;
            case "INVALID_ARGUMENT":
            case 3:
                message.code = 3;
                break;
            case "DEADLINE_EXCEEDED":
            case 4:
                message.code = 4;
                break;
            case "NOT_FOUND":
            case 5:
                message.code = 5;
                break;
            case "ALREADY_EXISTS":
            case 6:
                message.code = 6;
                break;
            case "PERMISSION_DENIED":
            case 7:
                message.code = 7;
                break;
            case "UNAUTHENTICATED":
            case 16:
                message.code = 16;
                break;
            case "RESOURCE_EXHAUSTED":
            case 8:
                message.code = 8;
                break;
            case "FAILED_PRECONDITION":
            case 9:
                message.code = 9;
                break;
            case "ABORTED":
            case 10:
                message.code = 10;
                break;
            case "OUT_OF_RANGE":
            case 11:
                message.code = 11;
                break;
            case "UNIMPLEMENTED":
            case 12:
                message.code = 12;
                break;
            case "INTERNAL":
            case 13:
                message.code = 13;
                break;
            case "UNAVAILABLE":
            case 14:
                message.code = 14;
                break;
            case "DATA_LOSS":
            case 15:
                message.code = 15;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a RPCError message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtrpc.RPCError
         * @static
         * @param {vtrpc.RPCError} message RPCError
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RPCError.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.legacy_code = options.enums === String ? "SUCCESS_LEGACY" : 0;
                object.message = "";
                object.code = options.enums === String ? "OK" : 0;
            }
            if (message.legacy_code != null && message.hasOwnProperty("legacy_code"))
                object.legacy_code = options.enums === String ? $root.vtrpc.LegacyErrorCode[message.legacy_code] : message.legacy_code;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = options.enums === String ? $root.vtrpc.Code[message.code] : message.code;
            return object;
        };

        /**
         * Converts this RPCError to JSON.
         * @function toJSON
         * @memberof vtrpc.RPCError
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RPCError.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RPCError;
    })();

    return vtrpc;
})();

$root.replicationdata = (function() {

    /**
     * Namespace replicationdata.
     * @exports replicationdata
     * @namespace
     */
    var replicationdata = {};

    replicationdata.Status = (function() {

        /**
         * Properties of a Status.
         * @memberof replicationdata
         * @interface IStatus
         * @property {string|null} [position] Status position
         * @property {boolean|null} [io_thread_running] Status io_thread_running
         * @property {boolean|null} [sql_thread_running] Status sql_thread_running
         * @property {number|null} [seconds_behind_master] Status seconds_behind_master
         * @property {string|null} [master_host] Status master_host
         * @property {number|null} [master_port] Status master_port
         * @property {number|null} [master_connect_retry] Status master_connect_retry
         * @property {string|null} [relay_log_position] Status relay_log_position
         * @property {string|null} [file_position] Status file_position
         * @property {string|null} [file_relay_log_position] Status file_relay_log_position
         * @property {number|null} [master_server_id] Status master_server_id
         * @property {string|null} [master_uuid] Status master_uuid
         */

        /**
         * Constructs a new Status.
         * @memberof replicationdata
         * @classdesc Represents a Status.
         * @implements IStatus
         * @constructor
         * @param {replicationdata.IStatus=} [properties] Properties to set
         */
        function Status(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Status position.
         * @member {string} position
         * @memberof replicationdata.Status
         * @instance
         */
        Status.prototype.position = "";

        /**
         * Status io_thread_running.
         * @member {boolean} io_thread_running
         * @memberof replicationdata.Status
         * @instance
         */
        Status.prototype.io_thread_running = false;

        /**
         * Status sql_thread_running.
         * @member {boolean} sql_thread_running
         * @memberof replicationdata.Status
         * @instance
         */
        Status.prototype.sql_thread_running = false;

        /**
         * Status seconds_behind_master.
         * @member {number} seconds_behind_master
         * @memberof replicationdata.Status
         * @instance
         */
        Status.prototype.seconds_behind_master = 0;

        /**
         * Status master_host.
         * @member {string} master_host
         * @memberof replicationdata.Status
         * @instance
         */
        Status.prototype.master_host = "";

        /**
         * Status master_port.
         * @member {number} master_port
         * @memberof replicationdata.Status
         * @instance
         */
        Status.prototype.master_port = 0;

        /**
         * Status master_connect_retry.
         * @member {number} master_connect_retry
         * @memberof replicationdata.Status
         * @instance
         */
        Status.prototype.master_connect_retry = 0;

        /**
         * Status relay_log_position.
         * @member {string} relay_log_position
         * @memberof replicationdata.Status
         * @instance
         */
        Status.prototype.relay_log_position = "";

        /**
         * Status file_position.
         * @member {string} file_position
         * @memberof replicationdata.Status
         * @instance
         */
        Status.prototype.file_position = "";

        /**
         * Status file_relay_log_position.
         * @member {string} file_relay_log_position
         * @memberof replicationdata.Status
         * @instance
         */
        Status.prototype.file_relay_log_position = "";

        /**
         * Status master_server_id.
         * @member {number} master_server_id
         * @memberof replicationdata.Status
         * @instance
         */
        Status.prototype.master_server_id = 0;

        /**
         * Status master_uuid.
         * @member {string} master_uuid
         * @memberof replicationdata.Status
         * @instance
         */
        Status.prototype.master_uuid = "";

        /**
         * Creates a new Status instance using the specified properties.
         * @function create
         * @memberof replicationdata.Status
         * @static
         * @param {replicationdata.IStatus=} [properties] Properties to set
         * @returns {replicationdata.Status} Status instance
         */
        Status.create = function create(properties) {
            return new Status(properties);
        };

        /**
         * Encodes the specified Status message. Does not implicitly {@link replicationdata.Status.verify|verify} messages.
         * @function encode
         * @memberof replicationdata.Status
         * @static
         * @param {replicationdata.IStatus} message Status message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Status.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.position);
            if (message.io_thread_running != null && Object.hasOwnProperty.call(message, "io_thread_running"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.io_thread_running);
            if (message.sql_thread_running != null && Object.hasOwnProperty.call(message, "sql_thread_running"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.sql_thread_running);
            if (message.seconds_behind_master != null && Object.hasOwnProperty.call(message, "seconds_behind_master"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.seconds_behind_master);
            if (message.master_host != null && Object.hasOwnProperty.call(message, "master_host"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.master_host);
            if (message.master_port != null && Object.hasOwnProperty.call(message, "master_port"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.master_port);
            if (message.master_connect_retry != null && Object.hasOwnProperty.call(message, "master_connect_retry"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.master_connect_retry);
            if (message.relay_log_position != null && Object.hasOwnProperty.call(message, "relay_log_position"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.relay_log_position);
            if (message.file_position != null && Object.hasOwnProperty.call(message, "file_position"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.file_position);
            if (message.file_relay_log_position != null && Object.hasOwnProperty.call(message, "file_relay_log_position"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.file_relay_log_position);
            if (message.master_server_id != null && Object.hasOwnProperty.call(message, "master_server_id"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.master_server_id);
            if (message.master_uuid != null && Object.hasOwnProperty.call(message, "master_uuid"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.master_uuid);
            return writer;
        };

        /**
         * Encodes the specified Status message, length delimited. Does not implicitly {@link replicationdata.Status.verify|verify} messages.
         * @function encodeDelimited
         * @memberof replicationdata.Status
         * @static
         * @param {replicationdata.IStatus} message Status message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Status.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Status message from the specified reader or buffer.
         * @function decode
         * @memberof replicationdata.Status
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {replicationdata.Status} Status
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Status.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.replicationdata.Status();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.position = reader.string();
                    break;
                case 2:
                    message.io_thread_running = reader.bool();
                    break;
                case 3:
                    message.sql_thread_running = reader.bool();
                    break;
                case 4:
                    message.seconds_behind_master = reader.uint32();
                    break;
                case 5:
                    message.master_host = reader.string();
                    break;
                case 6:
                    message.master_port = reader.int32();
                    break;
                case 7:
                    message.master_connect_retry = reader.int32();
                    break;
                case 8:
                    message.relay_log_position = reader.string();
                    break;
                case 9:
                    message.file_position = reader.string();
                    break;
                case 10:
                    message.file_relay_log_position = reader.string();
                    break;
                case 11:
                    message.master_server_id = reader.uint32();
                    break;
                case 12:
                    message.master_uuid = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Status message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof replicationdata.Status
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {replicationdata.Status} Status
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Status.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Status message.
         * @function verify
         * @memberof replicationdata.Status
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Status.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.position != null && message.hasOwnProperty("position"))
                if (!$util.isString(message.position))
                    return "position: string expected";
            if (message.io_thread_running != null && message.hasOwnProperty("io_thread_running"))
                if (typeof message.io_thread_running !== "boolean")
                    return "io_thread_running: boolean expected";
            if (message.sql_thread_running != null && message.hasOwnProperty("sql_thread_running"))
                if (typeof message.sql_thread_running !== "boolean")
                    return "sql_thread_running: boolean expected";
            if (message.seconds_behind_master != null && message.hasOwnProperty("seconds_behind_master"))
                if (!$util.isInteger(message.seconds_behind_master))
                    return "seconds_behind_master: integer expected";
            if (message.master_host != null && message.hasOwnProperty("master_host"))
                if (!$util.isString(message.master_host))
                    return "master_host: string expected";
            if (message.master_port != null && message.hasOwnProperty("master_port"))
                if (!$util.isInteger(message.master_port))
                    return "master_port: integer expected";
            if (message.master_connect_retry != null && message.hasOwnProperty("master_connect_retry"))
                if (!$util.isInteger(message.master_connect_retry))
                    return "master_connect_retry: integer expected";
            if (message.relay_log_position != null && message.hasOwnProperty("relay_log_position"))
                if (!$util.isString(message.relay_log_position))
                    return "relay_log_position: string expected";
            if (message.file_position != null && message.hasOwnProperty("file_position"))
                if (!$util.isString(message.file_position))
                    return "file_position: string expected";
            if (message.file_relay_log_position != null && message.hasOwnProperty("file_relay_log_position"))
                if (!$util.isString(message.file_relay_log_position))
                    return "file_relay_log_position: string expected";
            if (message.master_server_id != null && message.hasOwnProperty("master_server_id"))
                if (!$util.isInteger(message.master_server_id))
                    return "master_server_id: integer expected";
            if (message.master_uuid != null && message.hasOwnProperty("master_uuid"))
                if (!$util.isString(message.master_uuid))
                    return "master_uuid: string expected";
            return null;
        };

        /**
         * Creates a Status message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof replicationdata.Status
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {replicationdata.Status} Status
         */
        Status.fromObject = function fromObject(object) {
            if (object instanceof $root.replicationdata.Status)
                return object;
            var message = new $root.replicationdata.Status();
            if (object.position != null)
                message.position = String(object.position);
            if (object.io_thread_running != null)
                message.io_thread_running = Boolean(object.io_thread_running);
            if (object.sql_thread_running != null)
                message.sql_thread_running = Boolean(object.sql_thread_running);
            if (object.seconds_behind_master != null)
                message.seconds_behind_master = object.seconds_behind_master >>> 0;
            if (object.master_host != null)
                message.master_host = String(object.master_host);
            if (object.master_port != null)
                message.master_port = object.master_port | 0;
            if (object.master_connect_retry != null)
                message.master_connect_retry = object.master_connect_retry | 0;
            if (object.relay_log_position != null)
                message.relay_log_position = String(object.relay_log_position);
            if (object.file_position != null)
                message.file_position = String(object.file_position);
            if (object.file_relay_log_position != null)
                message.file_relay_log_position = String(object.file_relay_log_position);
            if (object.master_server_id != null)
                message.master_server_id = object.master_server_id >>> 0;
            if (object.master_uuid != null)
                message.master_uuid = String(object.master_uuid);
            return message;
        };

        /**
         * Creates a plain object from a Status message. Also converts values to other types if specified.
         * @function toObject
         * @memberof replicationdata.Status
         * @static
         * @param {replicationdata.Status} message Status
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Status.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.position = "";
                object.io_thread_running = false;
                object.sql_thread_running = false;
                object.seconds_behind_master = 0;
                object.master_host = "";
                object.master_port = 0;
                object.master_connect_retry = 0;
                object.relay_log_position = "";
                object.file_position = "";
                object.file_relay_log_position = "";
                object.master_server_id = 0;
                object.master_uuid = "";
            }
            if (message.position != null && message.hasOwnProperty("position"))
                object.position = message.position;
            if (message.io_thread_running != null && message.hasOwnProperty("io_thread_running"))
                object.io_thread_running = message.io_thread_running;
            if (message.sql_thread_running != null && message.hasOwnProperty("sql_thread_running"))
                object.sql_thread_running = message.sql_thread_running;
            if (message.seconds_behind_master != null && message.hasOwnProperty("seconds_behind_master"))
                object.seconds_behind_master = message.seconds_behind_master;
            if (message.master_host != null && message.hasOwnProperty("master_host"))
                object.master_host = message.master_host;
            if (message.master_port != null && message.hasOwnProperty("master_port"))
                object.master_port = message.master_port;
            if (message.master_connect_retry != null && message.hasOwnProperty("master_connect_retry"))
                object.master_connect_retry = message.master_connect_retry;
            if (message.relay_log_position != null && message.hasOwnProperty("relay_log_position"))
                object.relay_log_position = message.relay_log_position;
            if (message.file_position != null && message.hasOwnProperty("file_position"))
                object.file_position = message.file_position;
            if (message.file_relay_log_position != null && message.hasOwnProperty("file_relay_log_position"))
                object.file_relay_log_position = message.file_relay_log_position;
            if (message.master_server_id != null && message.hasOwnProperty("master_server_id"))
                object.master_server_id = message.master_server_id;
            if (message.master_uuid != null && message.hasOwnProperty("master_uuid"))
                object.master_uuid = message.master_uuid;
            return object;
        };

        /**
         * Converts this Status to JSON.
         * @function toJSON
         * @memberof replicationdata.Status
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Status.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Status;
    })();

    replicationdata.StopReplicationStatus = (function() {

        /**
         * Properties of a StopReplicationStatus.
         * @memberof replicationdata
         * @interface IStopReplicationStatus
         * @property {replicationdata.IStatus|null} [before] StopReplicationStatus before
         * @property {replicationdata.IStatus|null} [after] StopReplicationStatus after
         */

        /**
         * Constructs a new StopReplicationStatus.
         * @memberof replicationdata
         * @classdesc Represents a StopReplicationStatus.
         * @implements IStopReplicationStatus
         * @constructor
         * @param {replicationdata.IStopReplicationStatus=} [properties] Properties to set
         */
        function StopReplicationStatus(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StopReplicationStatus before.
         * @member {replicationdata.IStatus|null|undefined} before
         * @memberof replicationdata.StopReplicationStatus
         * @instance
         */
        StopReplicationStatus.prototype.before = null;

        /**
         * StopReplicationStatus after.
         * @member {replicationdata.IStatus|null|undefined} after
         * @memberof replicationdata.StopReplicationStatus
         * @instance
         */
        StopReplicationStatus.prototype.after = null;

        /**
         * Creates a new StopReplicationStatus instance using the specified properties.
         * @function create
         * @memberof replicationdata.StopReplicationStatus
         * @static
         * @param {replicationdata.IStopReplicationStatus=} [properties] Properties to set
         * @returns {replicationdata.StopReplicationStatus} StopReplicationStatus instance
         */
        StopReplicationStatus.create = function create(properties) {
            return new StopReplicationStatus(properties);
        };

        /**
         * Encodes the specified StopReplicationStatus message. Does not implicitly {@link replicationdata.StopReplicationStatus.verify|verify} messages.
         * @function encode
         * @memberof replicationdata.StopReplicationStatus
         * @static
         * @param {replicationdata.IStopReplicationStatus} message StopReplicationStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopReplicationStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.before != null && Object.hasOwnProperty.call(message, "before"))
                $root.replicationdata.Status.encode(message.before, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.after != null && Object.hasOwnProperty.call(message, "after"))
                $root.replicationdata.Status.encode(message.after, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified StopReplicationStatus message, length delimited. Does not implicitly {@link replicationdata.StopReplicationStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof replicationdata.StopReplicationStatus
         * @static
         * @param {replicationdata.IStopReplicationStatus} message StopReplicationStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopReplicationStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StopReplicationStatus message from the specified reader or buffer.
         * @function decode
         * @memberof replicationdata.StopReplicationStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {replicationdata.StopReplicationStatus} StopReplicationStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopReplicationStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.replicationdata.StopReplicationStatus();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.before = $root.replicationdata.Status.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.after = $root.replicationdata.Status.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StopReplicationStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof replicationdata.StopReplicationStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {replicationdata.StopReplicationStatus} StopReplicationStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopReplicationStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StopReplicationStatus message.
         * @function verify
         * @memberof replicationdata.StopReplicationStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StopReplicationStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.before != null && message.hasOwnProperty("before")) {
                var error = $root.replicationdata.Status.verify(message.before);
                if (error)
                    return "before." + error;
            }
            if (message.after != null && message.hasOwnProperty("after")) {
                var error = $root.replicationdata.Status.verify(message.after);
                if (error)
                    return "after." + error;
            }
            return null;
        };

        /**
         * Creates a StopReplicationStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof replicationdata.StopReplicationStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {replicationdata.StopReplicationStatus} StopReplicationStatus
         */
        StopReplicationStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.replicationdata.StopReplicationStatus)
                return object;
            var message = new $root.replicationdata.StopReplicationStatus();
            if (object.before != null) {
                if (typeof object.before !== "object")
                    throw TypeError(".replicationdata.StopReplicationStatus.before: object expected");
                message.before = $root.replicationdata.Status.fromObject(object.before);
            }
            if (object.after != null) {
                if (typeof object.after !== "object")
                    throw TypeError(".replicationdata.StopReplicationStatus.after: object expected");
                message.after = $root.replicationdata.Status.fromObject(object.after);
            }
            return message;
        };

        /**
         * Creates a plain object from a StopReplicationStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof replicationdata.StopReplicationStatus
         * @static
         * @param {replicationdata.StopReplicationStatus} message StopReplicationStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StopReplicationStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.before = null;
                object.after = null;
            }
            if (message.before != null && message.hasOwnProperty("before"))
                object.before = $root.replicationdata.Status.toObject(message.before, options);
            if (message.after != null && message.hasOwnProperty("after"))
                object.after = $root.replicationdata.Status.toObject(message.after, options);
            return object;
        };

        /**
         * Converts this StopReplicationStatus to JSON.
         * @function toJSON
         * @memberof replicationdata.StopReplicationStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StopReplicationStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StopReplicationStatus;
    })();

    /**
     * StopReplicationMode enum.
     * @name replicationdata.StopReplicationMode
     * @enum {number}
     * @property {number} IOANDSQLTHREAD=0 IOANDSQLTHREAD value
     * @property {number} IOTHREADONLY=1 IOTHREADONLY value
     */
    replicationdata.StopReplicationMode = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "IOANDSQLTHREAD"] = 0;
        values[valuesById[1] = "IOTHREADONLY"] = 1;
        return values;
    })();

    replicationdata.MasterStatus = (function() {

        /**
         * Properties of a MasterStatus.
         * @memberof replicationdata
         * @interface IMasterStatus
         * @property {string|null} [position] MasterStatus position
         * @property {string|null} [file_position] MasterStatus file_position
         */

        /**
         * Constructs a new MasterStatus.
         * @memberof replicationdata
         * @classdesc Represents a MasterStatus.
         * @implements IMasterStatus
         * @constructor
         * @param {replicationdata.IMasterStatus=} [properties] Properties to set
         */
        function MasterStatus(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MasterStatus position.
         * @member {string} position
         * @memberof replicationdata.MasterStatus
         * @instance
         */
        MasterStatus.prototype.position = "";

        /**
         * MasterStatus file_position.
         * @member {string} file_position
         * @memberof replicationdata.MasterStatus
         * @instance
         */
        MasterStatus.prototype.file_position = "";

        /**
         * Creates a new MasterStatus instance using the specified properties.
         * @function create
         * @memberof replicationdata.MasterStatus
         * @static
         * @param {replicationdata.IMasterStatus=} [properties] Properties to set
         * @returns {replicationdata.MasterStatus} MasterStatus instance
         */
        MasterStatus.create = function create(properties) {
            return new MasterStatus(properties);
        };

        /**
         * Encodes the specified MasterStatus message. Does not implicitly {@link replicationdata.MasterStatus.verify|verify} messages.
         * @function encode
         * @memberof replicationdata.MasterStatus
         * @static
         * @param {replicationdata.IMasterStatus} message MasterStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MasterStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.position);
            if (message.file_position != null && Object.hasOwnProperty.call(message, "file_position"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.file_position);
            return writer;
        };

        /**
         * Encodes the specified MasterStatus message, length delimited. Does not implicitly {@link replicationdata.MasterStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof replicationdata.MasterStatus
         * @static
         * @param {replicationdata.IMasterStatus} message MasterStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MasterStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MasterStatus message from the specified reader or buffer.
         * @function decode
         * @memberof replicationdata.MasterStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {replicationdata.MasterStatus} MasterStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MasterStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.replicationdata.MasterStatus();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.position = reader.string();
                    break;
                case 2:
                    message.file_position = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MasterStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof replicationdata.MasterStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {replicationdata.MasterStatus} MasterStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MasterStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MasterStatus message.
         * @function verify
         * @memberof replicationdata.MasterStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MasterStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.position != null && message.hasOwnProperty("position"))
                if (!$util.isString(message.position))
                    return "position: string expected";
            if (message.file_position != null && message.hasOwnProperty("file_position"))
                if (!$util.isString(message.file_position))
                    return "file_position: string expected";
            return null;
        };

        /**
         * Creates a MasterStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof replicationdata.MasterStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {replicationdata.MasterStatus} MasterStatus
         */
        MasterStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.replicationdata.MasterStatus)
                return object;
            var message = new $root.replicationdata.MasterStatus();
            if (object.position != null)
                message.position = String(object.position);
            if (object.file_position != null)
                message.file_position = String(object.file_position);
            return message;
        };

        /**
         * Creates a plain object from a MasterStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof replicationdata.MasterStatus
         * @static
         * @param {replicationdata.MasterStatus} message MasterStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MasterStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.position = "";
                object.file_position = "";
            }
            if (message.position != null && message.hasOwnProperty("position"))
                object.position = message.position;
            if (message.file_position != null && message.hasOwnProperty("file_position"))
                object.file_position = message.file_position;
            return object;
        };

        /**
         * Converts this MasterStatus to JSON.
         * @function toJSON
         * @memberof replicationdata.MasterStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MasterStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MasterStatus;
    })();

    return replicationdata;
})();

$root.logutil = (function() {

    /**
     * Namespace logutil.
     * @exports logutil
     * @namespace
     */
    var logutil = {};

    /**
     * Level enum.
     * @name logutil.Level
     * @enum {number}
     * @property {number} INFO=0 INFO value
     * @property {number} WARNING=1 WARNING value
     * @property {number} ERROR=2 ERROR value
     * @property {number} CONSOLE=3 CONSOLE value
     */
    logutil.Level = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "INFO"] = 0;
        values[valuesById[1] = "WARNING"] = 1;
        values[valuesById[2] = "ERROR"] = 2;
        values[valuesById[3] = "CONSOLE"] = 3;
        return values;
    })();

    logutil.Event = (function() {

        /**
         * Properties of an Event.
         * @memberof logutil
         * @interface IEvent
         * @property {vttime.ITime|null} [time] Event time
         * @property {logutil.Level|null} [level] Event level
         * @property {string|null} [file] Event file
         * @property {number|Long|null} [line] Event line
         * @property {string|null} [value] Event value
         */

        /**
         * Constructs a new Event.
         * @memberof logutil
         * @classdesc Represents an Event.
         * @implements IEvent
         * @constructor
         * @param {logutil.IEvent=} [properties] Properties to set
         */
        function Event(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Event time.
         * @member {vttime.ITime|null|undefined} time
         * @memberof logutil.Event
         * @instance
         */
        Event.prototype.time = null;

        /**
         * Event level.
         * @member {logutil.Level} level
         * @memberof logutil.Event
         * @instance
         */
        Event.prototype.level = 0;

        /**
         * Event file.
         * @member {string} file
         * @memberof logutil.Event
         * @instance
         */
        Event.prototype.file = "";

        /**
         * Event line.
         * @member {number|Long} line
         * @memberof logutil.Event
         * @instance
         */
        Event.prototype.line = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Event value.
         * @member {string} value
         * @memberof logutil.Event
         * @instance
         */
        Event.prototype.value = "";

        /**
         * Creates a new Event instance using the specified properties.
         * @function create
         * @memberof logutil.Event
         * @static
         * @param {logutil.IEvent=} [properties] Properties to set
         * @returns {logutil.Event} Event instance
         */
        Event.create = function create(properties) {
            return new Event(properties);
        };

        /**
         * Encodes the specified Event message. Does not implicitly {@link logutil.Event.verify|verify} messages.
         * @function encode
         * @memberof logutil.Event
         * @static
         * @param {logutil.IEvent} message Event message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Event.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                $root.vttime.Time.encode(message.time, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.level != null && Object.hasOwnProperty.call(message, "level"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.level);
            if (message.file != null && Object.hasOwnProperty.call(message, "file"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.file);
            if (message.line != null && Object.hasOwnProperty.call(message, "line"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.line);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.value);
            return writer;
        };

        /**
         * Encodes the specified Event message, length delimited. Does not implicitly {@link logutil.Event.verify|verify} messages.
         * @function encodeDelimited
         * @memberof logutil.Event
         * @static
         * @param {logutil.IEvent} message Event message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Event.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Event message from the specified reader or buffer.
         * @function decode
         * @memberof logutil.Event
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {logutil.Event} Event
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Event.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.logutil.Event();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.time = $root.vttime.Time.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.level = reader.int32();
                    break;
                case 3:
                    message.file = reader.string();
                    break;
                case 4:
                    message.line = reader.int64();
                    break;
                case 5:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Event message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof logutil.Event
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {logutil.Event} Event
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Event.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Event message.
         * @function verify
         * @memberof logutil.Event
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Event.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.time != null && message.hasOwnProperty("time")) {
                var error = $root.vttime.Time.verify(message.time);
                if (error)
                    return "time." + error;
            }
            if (message.level != null && message.hasOwnProperty("level"))
                switch (message.level) {
                default:
                    return "level: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.file != null && message.hasOwnProperty("file"))
                if (!$util.isString(message.file))
                    return "file: string expected";
            if (message.line != null && message.hasOwnProperty("line"))
                if (!$util.isInteger(message.line) && !(message.line && $util.isInteger(message.line.low) && $util.isInteger(message.line.high)))
                    return "line: integer|Long expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            return null;
        };

        /**
         * Creates an Event message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof logutil.Event
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {logutil.Event} Event
         */
        Event.fromObject = function fromObject(object) {
            if (object instanceof $root.logutil.Event)
                return object;
            var message = new $root.logutil.Event();
            if (object.time != null) {
                if (typeof object.time !== "object")
                    throw TypeError(".logutil.Event.time: object expected");
                message.time = $root.vttime.Time.fromObject(object.time);
            }
            switch (object.level) {
            case "INFO":
            case 0:
                message.level = 0;
                break;
            case "WARNING":
            case 1:
                message.level = 1;
                break;
            case "ERROR":
            case 2:
                message.level = 2;
                break;
            case "CONSOLE":
            case 3:
                message.level = 3;
                break;
            }
            if (object.file != null)
                message.file = String(object.file);
            if (object.line != null)
                if ($util.Long)
                    (message.line = $util.Long.fromValue(object.line)).unsigned = false;
                else if (typeof object.line === "string")
                    message.line = parseInt(object.line, 10);
                else if (typeof object.line === "number")
                    message.line = object.line;
                else if (typeof object.line === "object")
                    message.line = new $util.LongBits(object.line.low >>> 0, object.line.high >>> 0).toNumber();
            if (object.value != null)
                message.value = String(object.value);
            return message;
        };

        /**
         * Creates a plain object from an Event message. Also converts values to other types if specified.
         * @function toObject
         * @memberof logutil.Event
         * @static
         * @param {logutil.Event} message Event
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Event.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.time = null;
                object.level = options.enums === String ? "INFO" : 0;
                object.file = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.line = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.line = options.longs === String ? "0" : 0;
                object.value = "";
            }
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = $root.vttime.Time.toObject(message.time, options);
            if (message.level != null && message.hasOwnProperty("level"))
                object.level = options.enums === String ? $root.logutil.Level[message.level] : message.level;
            if (message.file != null && message.hasOwnProperty("file"))
                object.file = message.file;
            if (message.line != null && message.hasOwnProperty("line"))
                if (typeof message.line === "number")
                    object.line = options.longs === String ? String(message.line) : message.line;
                else
                    object.line = options.longs === String ? $util.Long.prototype.toString.call(message.line) : options.longs === Number ? new $util.LongBits(message.line.low >>> 0, message.line.high >>> 0).toNumber() : message.line;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };

        /**
         * Converts this Event to JSON.
         * @function toJSON
         * @memberof logutil.Event
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Event.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Event;
    })();

    return logutil;
})();

$root.vschema = (function() {

    /**
     * Namespace vschema.
     * @exports vschema
     * @namespace
     */
    var vschema = {};

    vschema.RoutingRules = (function() {

        /**
         * Properties of a RoutingRules.
         * @memberof vschema
         * @interface IRoutingRules
         * @property {Array.<vschema.IRoutingRule>|null} [rules] RoutingRules rules
         */

        /**
         * Constructs a new RoutingRules.
         * @memberof vschema
         * @classdesc Represents a RoutingRules.
         * @implements IRoutingRules
         * @constructor
         * @param {vschema.IRoutingRules=} [properties] Properties to set
         */
        function RoutingRules(properties) {
            this.rules = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RoutingRules rules.
         * @member {Array.<vschema.IRoutingRule>} rules
         * @memberof vschema.RoutingRules
         * @instance
         */
        RoutingRules.prototype.rules = $util.emptyArray;

        /**
         * Creates a new RoutingRules instance using the specified properties.
         * @function create
         * @memberof vschema.RoutingRules
         * @static
         * @param {vschema.IRoutingRules=} [properties] Properties to set
         * @returns {vschema.RoutingRules} RoutingRules instance
         */
        RoutingRules.create = function create(properties) {
            return new RoutingRules(properties);
        };

        /**
         * Encodes the specified RoutingRules message. Does not implicitly {@link vschema.RoutingRules.verify|verify} messages.
         * @function encode
         * @memberof vschema.RoutingRules
         * @static
         * @param {vschema.IRoutingRules} message RoutingRules message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RoutingRules.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rules != null && message.rules.length)
                for (var i = 0; i < message.rules.length; ++i)
                    $root.vschema.RoutingRule.encode(message.rules[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RoutingRules message, length delimited. Does not implicitly {@link vschema.RoutingRules.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vschema.RoutingRules
         * @static
         * @param {vschema.IRoutingRules} message RoutingRules message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RoutingRules.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RoutingRules message from the specified reader or buffer.
         * @function decode
         * @memberof vschema.RoutingRules
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vschema.RoutingRules} RoutingRules
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoutingRules.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vschema.RoutingRules();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.rules && message.rules.length))
                        message.rules = [];
                    message.rules.push($root.vschema.RoutingRule.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RoutingRules message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vschema.RoutingRules
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vschema.RoutingRules} RoutingRules
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoutingRules.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RoutingRules message.
         * @function verify
         * @memberof vschema.RoutingRules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RoutingRules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rules != null && message.hasOwnProperty("rules")) {
                if (!Array.isArray(message.rules))
                    return "rules: array expected";
                for (var i = 0; i < message.rules.length; ++i) {
                    var error = $root.vschema.RoutingRule.verify(message.rules[i]);
                    if (error)
                        return "rules." + error;
                }
            }
            return null;
        };

        /**
         * Creates a RoutingRules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vschema.RoutingRules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vschema.RoutingRules} RoutingRules
         */
        RoutingRules.fromObject = function fromObject(object) {
            if (object instanceof $root.vschema.RoutingRules)
                return object;
            var message = new $root.vschema.RoutingRules();
            if (object.rules) {
                if (!Array.isArray(object.rules))
                    throw TypeError(".vschema.RoutingRules.rules: array expected");
                message.rules = [];
                for (var i = 0; i < object.rules.length; ++i) {
                    if (typeof object.rules[i] !== "object")
                        throw TypeError(".vschema.RoutingRules.rules: object expected");
                    message.rules[i] = $root.vschema.RoutingRule.fromObject(object.rules[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a RoutingRules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vschema.RoutingRules
         * @static
         * @param {vschema.RoutingRules} message RoutingRules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RoutingRules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.rules = [];
            if (message.rules && message.rules.length) {
                object.rules = [];
                for (var j = 0; j < message.rules.length; ++j)
                    object.rules[j] = $root.vschema.RoutingRule.toObject(message.rules[j], options);
            }
            return object;
        };

        /**
         * Converts this RoutingRules to JSON.
         * @function toJSON
         * @memberof vschema.RoutingRules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RoutingRules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RoutingRules;
    })();

    vschema.RoutingRule = (function() {

        /**
         * Properties of a RoutingRule.
         * @memberof vschema
         * @interface IRoutingRule
         * @property {string|null} [from_table] RoutingRule from_table
         * @property {Array.<string>|null} [to_tables] RoutingRule to_tables
         */

        /**
         * Constructs a new RoutingRule.
         * @memberof vschema
         * @classdesc Represents a RoutingRule.
         * @implements IRoutingRule
         * @constructor
         * @param {vschema.IRoutingRule=} [properties] Properties to set
         */
        function RoutingRule(properties) {
            this.to_tables = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RoutingRule from_table.
         * @member {string} from_table
         * @memberof vschema.RoutingRule
         * @instance
         */
        RoutingRule.prototype.from_table = "";

        /**
         * RoutingRule to_tables.
         * @member {Array.<string>} to_tables
         * @memberof vschema.RoutingRule
         * @instance
         */
        RoutingRule.prototype.to_tables = $util.emptyArray;

        /**
         * Creates a new RoutingRule instance using the specified properties.
         * @function create
         * @memberof vschema.RoutingRule
         * @static
         * @param {vschema.IRoutingRule=} [properties] Properties to set
         * @returns {vschema.RoutingRule} RoutingRule instance
         */
        RoutingRule.create = function create(properties) {
            return new RoutingRule(properties);
        };

        /**
         * Encodes the specified RoutingRule message. Does not implicitly {@link vschema.RoutingRule.verify|verify} messages.
         * @function encode
         * @memberof vschema.RoutingRule
         * @static
         * @param {vschema.IRoutingRule} message RoutingRule message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RoutingRule.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.from_table != null && Object.hasOwnProperty.call(message, "from_table"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.from_table);
            if (message.to_tables != null && message.to_tables.length)
                for (var i = 0; i < message.to_tables.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.to_tables[i]);
            return writer;
        };

        /**
         * Encodes the specified RoutingRule message, length delimited. Does not implicitly {@link vschema.RoutingRule.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vschema.RoutingRule
         * @static
         * @param {vschema.IRoutingRule} message RoutingRule message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RoutingRule.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RoutingRule message from the specified reader or buffer.
         * @function decode
         * @memberof vschema.RoutingRule
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vschema.RoutingRule} RoutingRule
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoutingRule.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vschema.RoutingRule();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.from_table = reader.string();
                    break;
                case 2:
                    if (!(message.to_tables && message.to_tables.length))
                        message.to_tables = [];
                    message.to_tables.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RoutingRule message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vschema.RoutingRule
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vschema.RoutingRule} RoutingRule
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoutingRule.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RoutingRule message.
         * @function verify
         * @memberof vschema.RoutingRule
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RoutingRule.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.from_table != null && message.hasOwnProperty("from_table"))
                if (!$util.isString(message.from_table))
                    return "from_table: string expected";
            if (message.to_tables != null && message.hasOwnProperty("to_tables")) {
                if (!Array.isArray(message.to_tables))
                    return "to_tables: array expected";
                for (var i = 0; i < message.to_tables.length; ++i)
                    if (!$util.isString(message.to_tables[i]))
                        return "to_tables: string[] expected";
            }
            return null;
        };

        /**
         * Creates a RoutingRule message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vschema.RoutingRule
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vschema.RoutingRule} RoutingRule
         */
        RoutingRule.fromObject = function fromObject(object) {
            if (object instanceof $root.vschema.RoutingRule)
                return object;
            var message = new $root.vschema.RoutingRule();
            if (object.from_table != null)
                message.from_table = String(object.from_table);
            if (object.to_tables) {
                if (!Array.isArray(object.to_tables))
                    throw TypeError(".vschema.RoutingRule.to_tables: array expected");
                message.to_tables = [];
                for (var i = 0; i < object.to_tables.length; ++i)
                    message.to_tables[i] = String(object.to_tables[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a RoutingRule message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vschema.RoutingRule
         * @static
         * @param {vschema.RoutingRule} message RoutingRule
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RoutingRule.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.to_tables = [];
            if (options.defaults)
                object.from_table = "";
            if (message.from_table != null && message.hasOwnProperty("from_table"))
                object.from_table = message.from_table;
            if (message.to_tables && message.to_tables.length) {
                object.to_tables = [];
                for (var j = 0; j < message.to_tables.length; ++j)
                    object.to_tables[j] = message.to_tables[j];
            }
            return object;
        };

        /**
         * Converts this RoutingRule to JSON.
         * @function toJSON
         * @memberof vschema.RoutingRule
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RoutingRule.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RoutingRule;
    })();

    vschema.Keyspace = (function() {

        /**
         * Properties of a Keyspace.
         * @memberof vschema
         * @interface IKeyspace
         * @property {boolean|null} [sharded] Keyspace sharded
         * @property {Object.<string,vschema.IVindex>|null} [vindexes] Keyspace vindexes
         * @property {Object.<string,vschema.ITable>|null} [tables] Keyspace tables
         * @property {boolean|null} [require_explicit_routing] Keyspace require_explicit_routing
         */

        /**
         * Constructs a new Keyspace.
         * @memberof vschema
         * @classdesc Represents a Keyspace.
         * @implements IKeyspace
         * @constructor
         * @param {vschema.IKeyspace=} [properties] Properties to set
         */
        function Keyspace(properties) {
            this.vindexes = {};
            this.tables = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Keyspace sharded.
         * @member {boolean} sharded
         * @memberof vschema.Keyspace
         * @instance
         */
        Keyspace.prototype.sharded = false;

        /**
         * Keyspace vindexes.
         * @member {Object.<string,vschema.IVindex>} vindexes
         * @memberof vschema.Keyspace
         * @instance
         */
        Keyspace.prototype.vindexes = $util.emptyObject;

        /**
         * Keyspace tables.
         * @member {Object.<string,vschema.ITable>} tables
         * @memberof vschema.Keyspace
         * @instance
         */
        Keyspace.prototype.tables = $util.emptyObject;

        /**
         * Keyspace require_explicit_routing.
         * @member {boolean} require_explicit_routing
         * @memberof vschema.Keyspace
         * @instance
         */
        Keyspace.prototype.require_explicit_routing = false;

        /**
         * Creates a new Keyspace instance using the specified properties.
         * @function create
         * @memberof vschema.Keyspace
         * @static
         * @param {vschema.IKeyspace=} [properties] Properties to set
         * @returns {vschema.Keyspace} Keyspace instance
         */
        Keyspace.create = function create(properties) {
            return new Keyspace(properties);
        };

        /**
         * Encodes the specified Keyspace message. Does not implicitly {@link vschema.Keyspace.verify|verify} messages.
         * @function encode
         * @memberof vschema.Keyspace
         * @static
         * @param {vschema.IKeyspace} message Keyspace message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Keyspace.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sharded != null && Object.hasOwnProperty.call(message, "sharded"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.sharded);
            if (message.vindexes != null && Object.hasOwnProperty.call(message, "vindexes"))
                for (var keys = Object.keys(message.vindexes), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.vschema.Vindex.encode(message.vindexes[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            if (message.tables != null && Object.hasOwnProperty.call(message, "tables"))
                for (var keys = Object.keys(message.tables), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.vschema.Table.encode(message.tables[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            if (message.require_explicit_routing != null && Object.hasOwnProperty.call(message, "require_explicit_routing"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.require_explicit_routing);
            return writer;
        };

        /**
         * Encodes the specified Keyspace message, length delimited. Does not implicitly {@link vschema.Keyspace.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vschema.Keyspace
         * @static
         * @param {vschema.IKeyspace} message Keyspace message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Keyspace.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Keyspace message from the specified reader or buffer.
         * @function decode
         * @memberof vschema.Keyspace
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vschema.Keyspace} Keyspace
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Keyspace.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vschema.Keyspace(), key, value;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sharded = reader.bool();
                    break;
                case 2:
                    if (message.vindexes === $util.emptyObject)
                        message.vindexes = {};
                    var end2 = reader.uint32() + reader.pos;
                    key = "";
                    value = null;
                    while (reader.pos < end2) {
                        var tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.string();
                            break;
                        case 2:
                            value = $root.vschema.Vindex.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.vindexes[key] = value;
                    break;
                case 3:
                    if (message.tables === $util.emptyObject)
                        message.tables = {};
                    var end2 = reader.uint32() + reader.pos;
                    key = "";
                    value = null;
                    while (reader.pos < end2) {
                        var tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.string();
                            break;
                        case 2:
                            value = $root.vschema.Table.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.tables[key] = value;
                    break;
                case 4:
                    message.require_explicit_routing = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Keyspace message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vschema.Keyspace
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vschema.Keyspace} Keyspace
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Keyspace.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Keyspace message.
         * @function verify
         * @memberof vschema.Keyspace
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Keyspace.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sharded != null && message.hasOwnProperty("sharded"))
                if (typeof message.sharded !== "boolean")
                    return "sharded: boolean expected";
            if (message.vindexes != null && message.hasOwnProperty("vindexes")) {
                if (!$util.isObject(message.vindexes))
                    return "vindexes: object expected";
                var key = Object.keys(message.vindexes);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.vschema.Vindex.verify(message.vindexes[key[i]]);
                    if (error)
                        return "vindexes." + error;
                }
            }
            if (message.tables != null && message.hasOwnProperty("tables")) {
                if (!$util.isObject(message.tables))
                    return "tables: object expected";
                var key = Object.keys(message.tables);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.vschema.Table.verify(message.tables[key[i]]);
                    if (error)
                        return "tables." + error;
                }
            }
            if (message.require_explicit_routing != null && message.hasOwnProperty("require_explicit_routing"))
                if (typeof message.require_explicit_routing !== "boolean")
                    return "require_explicit_routing: boolean expected";
            return null;
        };

        /**
         * Creates a Keyspace message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vschema.Keyspace
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vschema.Keyspace} Keyspace
         */
        Keyspace.fromObject = function fromObject(object) {
            if (object instanceof $root.vschema.Keyspace)
                return object;
            var message = new $root.vschema.Keyspace();
            if (object.sharded != null)
                message.sharded = Boolean(object.sharded);
            if (object.vindexes) {
                if (typeof object.vindexes !== "object")
                    throw TypeError(".vschema.Keyspace.vindexes: object expected");
                message.vindexes = {};
                for (var keys = Object.keys(object.vindexes), i = 0; i < keys.length; ++i) {
                    if (typeof object.vindexes[keys[i]] !== "object")
                        throw TypeError(".vschema.Keyspace.vindexes: object expected");
                    message.vindexes[keys[i]] = $root.vschema.Vindex.fromObject(object.vindexes[keys[i]]);
                }
            }
            if (object.tables) {
                if (typeof object.tables !== "object")
                    throw TypeError(".vschema.Keyspace.tables: object expected");
                message.tables = {};
                for (var keys = Object.keys(object.tables), i = 0; i < keys.length; ++i) {
                    if (typeof object.tables[keys[i]] !== "object")
                        throw TypeError(".vschema.Keyspace.tables: object expected");
                    message.tables[keys[i]] = $root.vschema.Table.fromObject(object.tables[keys[i]]);
                }
            }
            if (object.require_explicit_routing != null)
                message.require_explicit_routing = Boolean(object.require_explicit_routing);
            return message;
        };

        /**
         * Creates a plain object from a Keyspace message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vschema.Keyspace
         * @static
         * @param {vschema.Keyspace} message Keyspace
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Keyspace.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults) {
                object.vindexes = {};
                object.tables = {};
            }
            if (options.defaults) {
                object.sharded = false;
                object.require_explicit_routing = false;
            }
            if (message.sharded != null && message.hasOwnProperty("sharded"))
                object.sharded = message.sharded;
            var keys2;
            if (message.vindexes && (keys2 = Object.keys(message.vindexes)).length) {
                object.vindexes = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.vindexes[keys2[j]] = $root.vschema.Vindex.toObject(message.vindexes[keys2[j]], options);
            }
            if (message.tables && (keys2 = Object.keys(message.tables)).length) {
                object.tables = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.tables[keys2[j]] = $root.vschema.Table.toObject(message.tables[keys2[j]], options);
            }
            if (message.require_explicit_routing != null && message.hasOwnProperty("require_explicit_routing"))
                object.require_explicit_routing = message.require_explicit_routing;
            return object;
        };

        /**
         * Converts this Keyspace to JSON.
         * @function toJSON
         * @memberof vschema.Keyspace
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Keyspace.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Keyspace;
    })();

    vschema.Vindex = (function() {

        /**
         * Properties of a Vindex.
         * @memberof vschema
         * @interface IVindex
         * @property {string|null} [type] Vindex type
         * @property {Object.<string,string>|null} [params] Vindex params
         * @property {string|null} [owner] Vindex owner
         */

        /**
         * Constructs a new Vindex.
         * @memberof vschema
         * @classdesc Represents a Vindex.
         * @implements IVindex
         * @constructor
         * @param {vschema.IVindex=} [properties] Properties to set
         */
        function Vindex(properties) {
            this.params = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Vindex type.
         * @member {string} type
         * @memberof vschema.Vindex
         * @instance
         */
        Vindex.prototype.type = "";

        /**
         * Vindex params.
         * @member {Object.<string,string>} params
         * @memberof vschema.Vindex
         * @instance
         */
        Vindex.prototype.params = $util.emptyObject;

        /**
         * Vindex owner.
         * @member {string} owner
         * @memberof vschema.Vindex
         * @instance
         */
        Vindex.prototype.owner = "";

        /**
         * Creates a new Vindex instance using the specified properties.
         * @function create
         * @memberof vschema.Vindex
         * @static
         * @param {vschema.IVindex=} [properties] Properties to set
         * @returns {vschema.Vindex} Vindex instance
         */
        Vindex.create = function create(properties) {
            return new Vindex(properties);
        };

        /**
         * Encodes the specified Vindex message. Does not implicitly {@link vschema.Vindex.verify|verify} messages.
         * @function encode
         * @memberof vschema.Vindex
         * @static
         * @param {vschema.IVindex} message Vindex message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Vindex.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.type);
            if (message.params != null && Object.hasOwnProperty.call(message, "params"))
                for (var keys = Object.keys(message.params), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.params[keys[i]]).ldelim();
            if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.owner);
            return writer;
        };

        /**
         * Encodes the specified Vindex message, length delimited. Does not implicitly {@link vschema.Vindex.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vschema.Vindex
         * @static
         * @param {vschema.IVindex} message Vindex message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Vindex.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Vindex message from the specified reader or buffer.
         * @function decode
         * @memberof vschema.Vindex
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vschema.Vindex} Vindex
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Vindex.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vschema.Vindex(), key, value;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.string();
                    break;
                case 2:
                    if (message.params === $util.emptyObject)
                        message.params = {};
                    var end2 = reader.uint32() + reader.pos;
                    key = "";
                    value = "";
                    while (reader.pos < end2) {
                        var tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.string();
                            break;
                        case 2:
                            value = reader.string();
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.params[key] = value;
                    break;
                case 3:
                    message.owner = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Vindex message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vschema.Vindex
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vschema.Vindex} Vindex
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Vindex.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Vindex message.
         * @function verify
         * @memberof vschema.Vindex
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Vindex.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isString(message.type))
                    return "type: string expected";
            if (message.params != null && message.hasOwnProperty("params")) {
                if (!$util.isObject(message.params))
                    return "params: object expected";
                var key = Object.keys(message.params);
                for (var i = 0; i < key.length; ++i)
                    if (!$util.isString(message.params[key[i]]))
                        return "params: string{k:string} expected";
            }
            if (message.owner != null && message.hasOwnProperty("owner"))
                if (!$util.isString(message.owner))
                    return "owner: string expected";
            return null;
        };

        /**
         * Creates a Vindex message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vschema.Vindex
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vschema.Vindex} Vindex
         */
        Vindex.fromObject = function fromObject(object) {
            if (object instanceof $root.vschema.Vindex)
                return object;
            var message = new $root.vschema.Vindex();
            if (object.type != null)
                message.type = String(object.type);
            if (object.params) {
                if (typeof object.params !== "object")
                    throw TypeError(".vschema.Vindex.params: object expected");
                message.params = {};
                for (var keys = Object.keys(object.params), i = 0; i < keys.length; ++i)
                    message.params[keys[i]] = String(object.params[keys[i]]);
            }
            if (object.owner != null)
                message.owner = String(object.owner);
            return message;
        };

        /**
         * Creates a plain object from a Vindex message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vschema.Vindex
         * @static
         * @param {vschema.Vindex} message Vindex
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Vindex.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults)
                object.params = {};
            if (options.defaults) {
                object.type = "";
                object.owner = "";
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            var keys2;
            if (message.params && (keys2 = Object.keys(message.params)).length) {
                object.params = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.params[keys2[j]] = message.params[keys2[j]];
            }
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = message.owner;
            return object;
        };

        /**
         * Converts this Vindex to JSON.
         * @function toJSON
         * @memberof vschema.Vindex
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Vindex.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Vindex;
    })();

    vschema.Table = (function() {

        /**
         * Properties of a Table.
         * @memberof vschema
         * @interface ITable
         * @property {string|null} [type] Table type
         * @property {Array.<vschema.IColumnVindex>|null} [column_vindexes] Table column_vindexes
         * @property {vschema.IAutoIncrement|null} [auto_increment] Table auto_increment
         * @property {Array.<vschema.IColumn>|null} [columns] Table columns
         * @property {string|null} [pinned] Table pinned
         * @property {boolean|null} [column_list_authoritative] Table column_list_authoritative
         */

        /**
         * Constructs a new Table.
         * @memberof vschema
         * @classdesc Represents a Table.
         * @implements ITable
         * @constructor
         * @param {vschema.ITable=} [properties] Properties to set
         */
        function Table(properties) {
            this.column_vindexes = [];
            this.columns = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Table type.
         * @member {string} type
         * @memberof vschema.Table
         * @instance
         */
        Table.prototype.type = "";

        /**
         * Table column_vindexes.
         * @member {Array.<vschema.IColumnVindex>} column_vindexes
         * @memberof vschema.Table
         * @instance
         */
        Table.prototype.column_vindexes = $util.emptyArray;

        /**
         * Table auto_increment.
         * @member {vschema.IAutoIncrement|null|undefined} auto_increment
         * @memberof vschema.Table
         * @instance
         */
        Table.prototype.auto_increment = null;

        /**
         * Table columns.
         * @member {Array.<vschema.IColumn>} columns
         * @memberof vschema.Table
         * @instance
         */
        Table.prototype.columns = $util.emptyArray;

        /**
         * Table pinned.
         * @member {string} pinned
         * @memberof vschema.Table
         * @instance
         */
        Table.prototype.pinned = "";

        /**
         * Table column_list_authoritative.
         * @member {boolean} column_list_authoritative
         * @memberof vschema.Table
         * @instance
         */
        Table.prototype.column_list_authoritative = false;

        /**
         * Creates a new Table instance using the specified properties.
         * @function create
         * @memberof vschema.Table
         * @static
         * @param {vschema.ITable=} [properties] Properties to set
         * @returns {vschema.Table} Table instance
         */
        Table.create = function create(properties) {
            return new Table(properties);
        };

        /**
         * Encodes the specified Table message. Does not implicitly {@link vschema.Table.verify|verify} messages.
         * @function encode
         * @memberof vschema.Table
         * @static
         * @param {vschema.ITable} message Table message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Table.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.type);
            if (message.column_vindexes != null && message.column_vindexes.length)
                for (var i = 0; i < message.column_vindexes.length; ++i)
                    $root.vschema.ColumnVindex.encode(message.column_vindexes[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.auto_increment != null && Object.hasOwnProperty.call(message, "auto_increment"))
                $root.vschema.AutoIncrement.encode(message.auto_increment, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.columns != null && message.columns.length)
                for (var i = 0; i < message.columns.length; ++i)
                    $root.vschema.Column.encode(message.columns[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.pinned != null && Object.hasOwnProperty.call(message, "pinned"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.pinned);
            if (message.column_list_authoritative != null && Object.hasOwnProperty.call(message, "column_list_authoritative"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.column_list_authoritative);
            return writer;
        };

        /**
         * Encodes the specified Table message, length delimited. Does not implicitly {@link vschema.Table.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vschema.Table
         * @static
         * @param {vschema.ITable} message Table message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Table.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Table message from the specified reader or buffer.
         * @function decode
         * @memberof vschema.Table
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vschema.Table} Table
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Table.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vschema.Table();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.string();
                    break;
                case 2:
                    if (!(message.column_vindexes && message.column_vindexes.length))
                        message.column_vindexes = [];
                    message.column_vindexes.push($root.vschema.ColumnVindex.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.auto_increment = $root.vschema.AutoIncrement.decode(reader, reader.uint32());
                    break;
                case 4:
                    if (!(message.columns && message.columns.length))
                        message.columns = [];
                    message.columns.push($root.vschema.Column.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.pinned = reader.string();
                    break;
                case 6:
                    message.column_list_authoritative = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Table message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vschema.Table
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vschema.Table} Table
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Table.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Table message.
         * @function verify
         * @memberof vschema.Table
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Table.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isString(message.type))
                    return "type: string expected";
            if (message.column_vindexes != null && message.hasOwnProperty("column_vindexes")) {
                if (!Array.isArray(message.column_vindexes))
                    return "column_vindexes: array expected";
                for (var i = 0; i < message.column_vindexes.length; ++i) {
                    var error = $root.vschema.ColumnVindex.verify(message.column_vindexes[i]);
                    if (error)
                        return "column_vindexes." + error;
                }
            }
            if (message.auto_increment != null && message.hasOwnProperty("auto_increment")) {
                var error = $root.vschema.AutoIncrement.verify(message.auto_increment);
                if (error)
                    return "auto_increment." + error;
            }
            if (message.columns != null && message.hasOwnProperty("columns")) {
                if (!Array.isArray(message.columns))
                    return "columns: array expected";
                for (var i = 0; i < message.columns.length; ++i) {
                    var error = $root.vschema.Column.verify(message.columns[i]);
                    if (error)
                        return "columns." + error;
                }
            }
            if (message.pinned != null && message.hasOwnProperty("pinned"))
                if (!$util.isString(message.pinned))
                    return "pinned: string expected";
            if (message.column_list_authoritative != null && message.hasOwnProperty("column_list_authoritative"))
                if (typeof message.column_list_authoritative !== "boolean")
                    return "column_list_authoritative: boolean expected";
            return null;
        };

        /**
         * Creates a Table message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vschema.Table
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vschema.Table} Table
         */
        Table.fromObject = function fromObject(object) {
            if (object instanceof $root.vschema.Table)
                return object;
            var message = new $root.vschema.Table();
            if (object.type != null)
                message.type = String(object.type);
            if (object.column_vindexes) {
                if (!Array.isArray(object.column_vindexes))
                    throw TypeError(".vschema.Table.column_vindexes: array expected");
                message.column_vindexes = [];
                for (var i = 0; i < object.column_vindexes.length; ++i) {
                    if (typeof object.column_vindexes[i] !== "object")
                        throw TypeError(".vschema.Table.column_vindexes: object expected");
                    message.column_vindexes[i] = $root.vschema.ColumnVindex.fromObject(object.column_vindexes[i]);
                }
            }
            if (object.auto_increment != null) {
                if (typeof object.auto_increment !== "object")
                    throw TypeError(".vschema.Table.auto_increment: object expected");
                message.auto_increment = $root.vschema.AutoIncrement.fromObject(object.auto_increment);
            }
            if (object.columns) {
                if (!Array.isArray(object.columns))
                    throw TypeError(".vschema.Table.columns: array expected");
                message.columns = [];
                for (var i = 0; i < object.columns.length; ++i) {
                    if (typeof object.columns[i] !== "object")
                        throw TypeError(".vschema.Table.columns: object expected");
                    message.columns[i] = $root.vschema.Column.fromObject(object.columns[i]);
                }
            }
            if (object.pinned != null)
                message.pinned = String(object.pinned);
            if (object.column_list_authoritative != null)
                message.column_list_authoritative = Boolean(object.column_list_authoritative);
            return message;
        };

        /**
         * Creates a plain object from a Table message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vschema.Table
         * @static
         * @param {vschema.Table} message Table
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Table.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.column_vindexes = [];
                object.columns = [];
            }
            if (options.defaults) {
                object.type = "";
                object.auto_increment = null;
                object.pinned = "";
                object.column_list_authoritative = false;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.column_vindexes && message.column_vindexes.length) {
                object.column_vindexes = [];
                for (var j = 0; j < message.column_vindexes.length; ++j)
                    object.column_vindexes[j] = $root.vschema.ColumnVindex.toObject(message.column_vindexes[j], options);
            }
            if (message.auto_increment != null && message.hasOwnProperty("auto_increment"))
                object.auto_increment = $root.vschema.AutoIncrement.toObject(message.auto_increment, options);
            if (message.columns && message.columns.length) {
                object.columns = [];
                for (var j = 0; j < message.columns.length; ++j)
                    object.columns[j] = $root.vschema.Column.toObject(message.columns[j], options);
            }
            if (message.pinned != null && message.hasOwnProperty("pinned"))
                object.pinned = message.pinned;
            if (message.column_list_authoritative != null && message.hasOwnProperty("column_list_authoritative"))
                object.column_list_authoritative = message.column_list_authoritative;
            return object;
        };

        /**
         * Converts this Table to JSON.
         * @function toJSON
         * @memberof vschema.Table
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Table.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Table;
    })();

    vschema.ColumnVindex = (function() {

        /**
         * Properties of a ColumnVindex.
         * @memberof vschema
         * @interface IColumnVindex
         * @property {string|null} [column] ColumnVindex column
         * @property {string|null} [name] ColumnVindex name
         * @property {Array.<string>|null} [columns] ColumnVindex columns
         */

        /**
         * Constructs a new ColumnVindex.
         * @memberof vschema
         * @classdesc Represents a ColumnVindex.
         * @implements IColumnVindex
         * @constructor
         * @param {vschema.IColumnVindex=} [properties] Properties to set
         */
        function ColumnVindex(properties) {
            this.columns = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ColumnVindex column.
         * @member {string} column
         * @memberof vschema.ColumnVindex
         * @instance
         */
        ColumnVindex.prototype.column = "";

        /**
         * ColumnVindex name.
         * @member {string} name
         * @memberof vschema.ColumnVindex
         * @instance
         */
        ColumnVindex.prototype.name = "";

        /**
         * ColumnVindex columns.
         * @member {Array.<string>} columns
         * @memberof vschema.ColumnVindex
         * @instance
         */
        ColumnVindex.prototype.columns = $util.emptyArray;

        /**
         * Creates a new ColumnVindex instance using the specified properties.
         * @function create
         * @memberof vschema.ColumnVindex
         * @static
         * @param {vschema.IColumnVindex=} [properties] Properties to set
         * @returns {vschema.ColumnVindex} ColumnVindex instance
         */
        ColumnVindex.create = function create(properties) {
            return new ColumnVindex(properties);
        };

        /**
         * Encodes the specified ColumnVindex message. Does not implicitly {@link vschema.ColumnVindex.verify|verify} messages.
         * @function encode
         * @memberof vschema.ColumnVindex
         * @static
         * @param {vschema.IColumnVindex} message ColumnVindex message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ColumnVindex.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.column != null && Object.hasOwnProperty.call(message, "column"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.column);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.columns != null && message.columns.length)
                for (var i = 0; i < message.columns.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.columns[i]);
            return writer;
        };

        /**
         * Encodes the specified ColumnVindex message, length delimited. Does not implicitly {@link vschema.ColumnVindex.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vschema.ColumnVindex
         * @static
         * @param {vschema.IColumnVindex} message ColumnVindex message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ColumnVindex.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ColumnVindex message from the specified reader or buffer.
         * @function decode
         * @memberof vschema.ColumnVindex
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vschema.ColumnVindex} ColumnVindex
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ColumnVindex.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vschema.ColumnVindex();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.column = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    if (!(message.columns && message.columns.length))
                        message.columns = [];
                    message.columns.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ColumnVindex message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vschema.ColumnVindex
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vschema.ColumnVindex} ColumnVindex
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ColumnVindex.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ColumnVindex message.
         * @function verify
         * @memberof vschema.ColumnVindex
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ColumnVindex.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.column != null && message.hasOwnProperty("column"))
                if (!$util.isString(message.column))
                    return "column: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.columns != null && message.hasOwnProperty("columns")) {
                if (!Array.isArray(message.columns))
                    return "columns: array expected";
                for (var i = 0; i < message.columns.length; ++i)
                    if (!$util.isString(message.columns[i]))
                        return "columns: string[] expected";
            }
            return null;
        };

        /**
         * Creates a ColumnVindex message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vschema.ColumnVindex
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vschema.ColumnVindex} ColumnVindex
         */
        ColumnVindex.fromObject = function fromObject(object) {
            if (object instanceof $root.vschema.ColumnVindex)
                return object;
            var message = new $root.vschema.ColumnVindex();
            if (object.column != null)
                message.column = String(object.column);
            if (object.name != null)
                message.name = String(object.name);
            if (object.columns) {
                if (!Array.isArray(object.columns))
                    throw TypeError(".vschema.ColumnVindex.columns: array expected");
                message.columns = [];
                for (var i = 0; i < object.columns.length; ++i)
                    message.columns[i] = String(object.columns[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a ColumnVindex message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vschema.ColumnVindex
         * @static
         * @param {vschema.ColumnVindex} message ColumnVindex
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ColumnVindex.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.columns = [];
            if (options.defaults) {
                object.column = "";
                object.name = "";
            }
            if (message.column != null && message.hasOwnProperty("column"))
                object.column = message.column;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.columns && message.columns.length) {
                object.columns = [];
                for (var j = 0; j < message.columns.length; ++j)
                    object.columns[j] = message.columns[j];
            }
            return object;
        };

        /**
         * Converts this ColumnVindex to JSON.
         * @function toJSON
         * @memberof vschema.ColumnVindex
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ColumnVindex.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ColumnVindex;
    })();

    vschema.AutoIncrement = (function() {

        /**
         * Properties of an AutoIncrement.
         * @memberof vschema
         * @interface IAutoIncrement
         * @property {string|null} [column] AutoIncrement column
         * @property {string|null} [sequence] AutoIncrement sequence
         */

        /**
         * Constructs a new AutoIncrement.
         * @memberof vschema
         * @classdesc Represents an AutoIncrement.
         * @implements IAutoIncrement
         * @constructor
         * @param {vschema.IAutoIncrement=} [properties] Properties to set
         */
        function AutoIncrement(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AutoIncrement column.
         * @member {string} column
         * @memberof vschema.AutoIncrement
         * @instance
         */
        AutoIncrement.prototype.column = "";

        /**
         * AutoIncrement sequence.
         * @member {string} sequence
         * @memberof vschema.AutoIncrement
         * @instance
         */
        AutoIncrement.prototype.sequence = "";

        /**
         * Creates a new AutoIncrement instance using the specified properties.
         * @function create
         * @memberof vschema.AutoIncrement
         * @static
         * @param {vschema.IAutoIncrement=} [properties] Properties to set
         * @returns {vschema.AutoIncrement} AutoIncrement instance
         */
        AutoIncrement.create = function create(properties) {
            return new AutoIncrement(properties);
        };

        /**
         * Encodes the specified AutoIncrement message. Does not implicitly {@link vschema.AutoIncrement.verify|verify} messages.
         * @function encode
         * @memberof vschema.AutoIncrement
         * @static
         * @param {vschema.IAutoIncrement} message AutoIncrement message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AutoIncrement.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.column != null && Object.hasOwnProperty.call(message, "column"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.column);
            if (message.sequence != null && Object.hasOwnProperty.call(message, "sequence"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.sequence);
            return writer;
        };

        /**
         * Encodes the specified AutoIncrement message, length delimited. Does not implicitly {@link vschema.AutoIncrement.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vschema.AutoIncrement
         * @static
         * @param {vschema.IAutoIncrement} message AutoIncrement message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AutoIncrement.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AutoIncrement message from the specified reader or buffer.
         * @function decode
         * @memberof vschema.AutoIncrement
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vschema.AutoIncrement} AutoIncrement
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AutoIncrement.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vschema.AutoIncrement();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.column = reader.string();
                    break;
                case 2:
                    message.sequence = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AutoIncrement message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vschema.AutoIncrement
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vschema.AutoIncrement} AutoIncrement
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AutoIncrement.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AutoIncrement message.
         * @function verify
         * @memberof vschema.AutoIncrement
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AutoIncrement.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.column != null && message.hasOwnProperty("column"))
                if (!$util.isString(message.column))
                    return "column: string expected";
            if (message.sequence != null && message.hasOwnProperty("sequence"))
                if (!$util.isString(message.sequence))
                    return "sequence: string expected";
            return null;
        };

        /**
         * Creates an AutoIncrement message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vschema.AutoIncrement
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vschema.AutoIncrement} AutoIncrement
         */
        AutoIncrement.fromObject = function fromObject(object) {
            if (object instanceof $root.vschema.AutoIncrement)
                return object;
            var message = new $root.vschema.AutoIncrement();
            if (object.column != null)
                message.column = String(object.column);
            if (object.sequence != null)
                message.sequence = String(object.sequence);
            return message;
        };

        /**
         * Creates a plain object from an AutoIncrement message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vschema.AutoIncrement
         * @static
         * @param {vschema.AutoIncrement} message AutoIncrement
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AutoIncrement.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.column = "";
                object.sequence = "";
            }
            if (message.column != null && message.hasOwnProperty("column"))
                object.column = message.column;
            if (message.sequence != null && message.hasOwnProperty("sequence"))
                object.sequence = message.sequence;
            return object;
        };

        /**
         * Converts this AutoIncrement to JSON.
         * @function toJSON
         * @memberof vschema.AutoIncrement
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AutoIncrement.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AutoIncrement;
    })();

    vschema.Column = (function() {

        /**
         * Properties of a Column.
         * @memberof vschema
         * @interface IColumn
         * @property {string|null} [name] Column name
         * @property {query.Type|null} [type] Column type
         */

        /**
         * Constructs a new Column.
         * @memberof vschema
         * @classdesc Represents a Column.
         * @implements IColumn
         * @constructor
         * @param {vschema.IColumn=} [properties] Properties to set
         */
        function Column(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Column name.
         * @member {string} name
         * @memberof vschema.Column
         * @instance
         */
        Column.prototype.name = "";

        /**
         * Column type.
         * @member {query.Type} type
         * @memberof vschema.Column
         * @instance
         */
        Column.prototype.type = 0;

        /**
         * Creates a new Column instance using the specified properties.
         * @function create
         * @memberof vschema.Column
         * @static
         * @param {vschema.IColumn=} [properties] Properties to set
         * @returns {vschema.Column} Column instance
         */
        Column.create = function create(properties) {
            return new Column(properties);
        };

        /**
         * Encodes the specified Column message. Does not implicitly {@link vschema.Column.verify|verify} messages.
         * @function encode
         * @memberof vschema.Column
         * @static
         * @param {vschema.IColumn} message Column message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Column.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified Column message, length delimited. Does not implicitly {@link vschema.Column.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vschema.Column
         * @static
         * @param {vschema.IColumn} message Column message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Column.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Column message from the specified reader or buffer.
         * @function decode
         * @memberof vschema.Column
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vschema.Column} Column
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Column.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vschema.Column();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Column message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vschema.Column
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vschema.Column} Column
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Column.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Column message.
         * @function verify
         * @memberof vschema.Column
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Column.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 257:
                case 770:
                case 259:
                case 772:
                case 261:
                case 774:
                case 263:
                case 776:
                case 265:
                case 778:
                case 1035:
                case 1036:
                case 2061:
                case 2062:
                case 2063:
                case 2064:
                case 785:
                case 18:
                case 6163:
                case 10260:
                case 6165:
                case 10262:
                case 6167:
                case 10264:
                case 2073:
                case 2074:
                case 2075:
                case 28:
                case 2077:
                case 2078:
                case 31:
                    break;
                }
            return null;
        };

        /**
         * Creates a Column message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vschema.Column
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vschema.Column} Column
         */
        Column.fromObject = function fromObject(object) {
            if (object instanceof $root.vschema.Column)
                return object;
            var message = new $root.vschema.Column();
            if (object.name != null)
                message.name = String(object.name);
            switch (object.type) {
            case "NULL_TYPE":
            case 0:
                message.type = 0;
                break;
            case "INT8":
            case 257:
                message.type = 257;
                break;
            case "UINT8":
            case 770:
                message.type = 770;
                break;
            case "INT16":
            case 259:
                message.type = 259;
                break;
            case "UINT16":
            case 772:
                message.type = 772;
                break;
            case "INT24":
            case 261:
                message.type = 261;
                break;
            case "UINT24":
            case 774:
                message.type = 774;
                break;
            case "INT32":
            case 263:
                message.type = 263;
                break;
            case "UINT32":
            case 776:
                message.type = 776;
                break;
            case "INT64":
            case 265:
                message.type = 265;
                break;
            case "UINT64":
            case 778:
                message.type = 778;
                break;
            case "FLOAT32":
            case 1035:
                message.type = 1035;
                break;
            case "FLOAT64":
            case 1036:
                message.type = 1036;
                break;
            case "TIMESTAMP":
            case 2061:
                message.type = 2061;
                break;
            case "DATE":
            case 2062:
                message.type = 2062;
                break;
            case "TIME":
            case 2063:
                message.type = 2063;
                break;
            case "DATETIME":
            case 2064:
                message.type = 2064;
                break;
            case "YEAR":
            case 785:
                message.type = 785;
                break;
            case "DECIMAL":
            case 18:
                message.type = 18;
                break;
            case "TEXT":
            case 6163:
                message.type = 6163;
                break;
            case "BLOB":
            case 10260:
                message.type = 10260;
                break;
            case "VARCHAR":
            case 6165:
                message.type = 6165;
                break;
            case "VARBINARY":
            case 10262:
                message.type = 10262;
                break;
            case "CHAR":
            case 6167:
                message.type = 6167;
                break;
            case "BINARY":
            case 10264:
                message.type = 10264;
                break;
            case "BIT":
            case 2073:
                message.type = 2073;
                break;
            case "ENUM":
            case 2074:
                message.type = 2074;
                break;
            case "SET":
            case 2075:
                message.type = 2075;
                break;
            case "TUPLE":
            case 28:
                message.type = 28;
                break;
            case "GEOMETRY":
            case 2077:
                message.type = 2077;
                break;
            case "JSON":
            case 2078:
                message.type = 2078;
                break;
            case "EXPRESSION":
            case 31:
                message.type = 31;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a Column message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vschema.Column
         * @static
         * @param {vschema.Column} message Column
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Column.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.type = options.enums === String ? "NULL_TYPE" : 0;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.query.Type[message.type] : message.type;
            return object;
        };

        /**
         * Converts this Column to JSON.
         * @function toJSON
         * @memberof vschema.Column
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Column.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Column;
    })();

    vschema.SrvVSchema = (function() {

        /**
         * Properties of a SrvVSchema.
         * @memberof vschema
         * @interface ISrvVSchema
         * @property {Object.<string,vschema.IKeyspace>|null} [keyspaces] SrvVSchema keyspaces
         * @property {vschema.IRoutingRules|null} [routing_rules] SrvVSchema routing_rules
         */

        /**
         * Constructs a new SrvVSchema.
         * @memberof vschema
         * @classdesc Represents a SrvVSchema.
         * @implements ISrvVSchema
         * @constructor
         * @param {vschema.ISrvVSchema=} [properties] Properties to set
         */
        function SrvVSchema(properties) {
            this.keyspaces = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SrvVSchema keyspaces.
         * @member {Object.<string,vschema.IKeyspace>} keyspaces
         * @memberof vschema.SrvVSchema
         * @instance
         */
        SrvVSchema.prototype.keyspaces = $util.emptyObject;

        /**
         * SrvVSchema routing_rules.
         * @member {vschema.IRoutingRules|null|undefined} routing_rules
         * @memberof vschema.SrvVSchema
         * @instance
         */
        SrvVSchema.prototype.routing_rules = null;

        /**
         * Creates a new SrvVSchema instance using the specified properties.
         * @function create
         * @memberof vschema.SrvVSchema
         * @static
         * @param {vschema.ISrvVSchema=} [properties] Properties to set
         * @returns {vschema.SrvVSchema} SrvVSchema instance
         */
        SrvVSchema.create = function create(properties) {
            return new SrvVSchema(properties);
        };

        /**
         * Encodes the specified SrvVSchema message. Does not implicitly {@link vschema.SrvVSchema.verify|verify} messages.
         * @function encode
         * @memberof vschema.SrvVSchema
         * @static
         * @param {vschema.ISrvVSchema} message SrvVSchema message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SrvVSchema.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keyspaces != null && Object.hasOwnProperty.call(message, "keyspaces"))
                for (var keys = Object.keys(message.keyspaces), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.vschema.Keyspace.encode(message.keyspaces[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            if (message.routing_rules != null && Object.hasOwnProperty.call(message, "routing_rules"))
                $root.vschema.RoutingRules.encode(message.routing_rules, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SrvVSchema message, length delimited. Does not implicitly {@link vschema.SrvVSchema.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vschema.SrvVSchema
         * @static
         * @param {vschema.ISrvVSchema} message SrvVSchema message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SrvVSchema.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SrvVSchema message from the specified reader or buffer.
         * @function decode
         * @memberof vschema.SrvVSchema
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vschema.SrvVSchema} SrvVSchema
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SrvVSchema.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vschema.SrvVSchema(), key, value;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (message.keyspaces === $util.emptyObject)
                        message.keyspaces = {};
                    var end2 = reader.uint32() + reader.pos;
                    key = "";
                    value = null;
                    while (reader.pos < end2) {
                        var tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.string();
                            break;
                        case 2:
                            value = $root.vschema.Keyspace.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.keyspaces[key] = value;
                    break;
                case 2:
                    message.routing_rules = $root.vschema.RoutingRules.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SrvVSchema message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vschema.SrvVSchema
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vschema.SrvVSchema} SrvVSchema
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SrvVSchema.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SrvVSchema message.
         * @function verify
         * @memberof vschema.SrvVSchema
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SrvVSchema.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keyspaces != null && message.hasOwnProperty("keyspaces")) {
                if (!$util.isObject(message.keyspaces))
                    return "keyspaces: object expected";
                var key = Object.keys(message.keyspaces);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.vschema.Keyspace.verify(message.keyspaces[key[i]]);
                    if (error)
                        return "keyspaces." + error;
                }
            }
            if (message.routing_rules != null && message.hasOwnProperty("routing_rules")) {
                var error = $root.vschema.RoutingRules.verify(message.routing_rules);
                if (error)
                    return "routing_rules." + error;
            }
            return null;
        };

        /**
         * Creates a SrvVSchema message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vschema.SrvVSchema
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vschema.SrvVSchema} SrvVSchema
         */
        SrvVSchema.fromObject = function fromObject(object) {
            if (object instanceof $root.vschema.SrvVSchema)
                return object;
            var message = new $root.vschema.SrvVSchema();
            if (object.keyspaces) {
                if (typeof object.keyspaces !== "object")
                    throw TypeError(".vschema.SrvVSchema.keyspaces: object expected");
                message.keyspaces = {};
                for (var keys = Object.keys(object.keyspaces), i = 0; i < keys.length; ++i) {
                    if (typeof object.keyspaces[keys[i]] !== "object")
                        throw TypeError(".vschema.SrvVSchema.keyspaces: object expected");
                    message.keyspaces[keys[i]] = $root.vschema.Keyspace.fromObject(object.keyspaces[keys[i]]);
                }
            }
            if (object.routing_rules != null) {
                if (typeof object.routing_rules !== "object")
                    throw TypeError(".vschema.SrvVSchema.routing_rules: object expected");
                message.routing_rules = $root.vschema.RoutingRules.fromObject(object.routing_rules);
            }
            return message;
        };

        /**
         * Creates a plain object from a SrvVSchema message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vschema.SrvVSchema
         * @static
         * @param {vschema.SrvVSchema} message SrvVSchema
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SrvVSchema.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults)
                object.keyspaces = {};
            if (options.defaults)
                object.routing_rules = null;
            var keys2;
            if (message.keyspaces && (keys2 = Object.keys(message.keyspaces)).length) {
                object.keyspaces = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.keyspaces[keys2[j]] = $root.vschema.Keyspace.toObject(message.keyspaces[keys2[j]], options);
            }
            if (message.routing_rules != null && message.hasOwnProperty("routing_rules"))
                object.routing_rules = $root.vschema.RoutingRules.toObject(message.routing_rules, options);
            return object;
        };

        /**
         * Converts this SrvVSchema to JSON.
         * @function toJSON
         * @memberof vschema.SrvVSchema
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SrvVSchema.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SrvVSchema;
    })();

    return vschema;
})();

$root.vtctldata = (function() {

    /**
     * Namespace vtctldata.
     * @exports vtctldata
     * @namespace
     */
    var vtctldata = {};

    vtctldata.ExecuteVtctlCommandRequest = (function() {

        /**
         * Properties of an ExecuteVtctlCommandRequest.
         * @memberof vtctldata
         * @interface IExecuteVtctlCommandRequest
         * @property {Array.<string>|null} [args] ExecuteVtctlCommandRequest args
         * @property {number|Long|null} [action_timeout] ExecuteVtctlCommandRequest action_timeout
         */

        /**
         * Constructs a new ExecuteVtctlCommandRequest.
         * @memberof vtctldata
         * @classdesc Represents an ExecuteVtctlCommandRequest.
         * @implements IExecuteVtctlCommandRequest
         * @constructor
         * @param {vtctldata.IExecuteVtctlCommandRequest=} [properties] Properties to set
         */
        function ExecuteVtctlCommandRequest(properties) {
            this.args = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExecuteVtctlCommandRequest args.
         * @member {Array.<string>} args
         * @memberof vtctldata.ExecuteVtctlCommandRequest
         * @instance
         */
        ExecuteVtctlCommandRequest.prototype.args = $util.emptyArray;

        /**
         * ExecuteVtctlCommandRequest action_timeout.
         * @member {number|Long} action_timeout
         * @memberof vtctldata.ExecuteVtctlCommandRequest
         * @instance
         */
        ExecuteVtctlCommandRequest.prototype.action_timeout = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ExecuteVtctlCommandRequest instance using the specified properties.
         * @function create
         * @memberof vtctldata.ExecuteVtctlCommandRequest
         * @static
         * @param {vtctldata.IExecuteVtctlCommandRequest=} [properties] Properties to set
         * @returns {vtctldata.ExecuteVtctlCommandRequest} ExecuteVtctlCommandRequest instance
         */
        ExecuteVtctlCommandRequest.create = function create(properties) {
            return new ExecuteVtctlCommandRequest(properties);
        };

        /**
         * Encodes the specified ExecuteVtctlCommandRequest message. Does not implicitly {@link vtctldata.ExecuteVtctlCommandRequest.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.ExecuteVtctlCommandRequest
         * @static
         * @param {vtctldata.IExecuteVtctlCommandRequest} message ExecuteVtctlCommandRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecuteVtctlCommandRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.args != null && message.args.length)
                for (var i = 0; i < message.args.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.args[i]);
            if (message.action_timeout != null && Object.hasOwnProperty.call(message, "action_timeout"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.action_timeout);
            return writer;
        };

        /**
         * Encodes the specified ExecuteVtctlCommandRequest message, length delimited. Does not implicitly {@link vtctldata.ExecuteVtctlCommandRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.ExecuteVtctlCommandRequest
         * @static
         * @param {vtctldata.IExecuteVtctlCommandRequest} message ExecuteVtctlCommandRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecuteVtctlCommandRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExecuteVtctlCommandRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.ExecuteVtctlCommandRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.ExecuteVtctlCommandRequest} ExecuteVtctlCommandRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecuteVtctlCommandRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.ExecuteVtctlCommandRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.args && message.args.length))
                        message.args = [];
                    message.args.push(reader.string());
                    break;
                case 2:
                    message.action_timeout = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExecuteVtctlCommandRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.ExecuteVtctlCommandRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.ExecuteVtctlCommandRequest} ExecuteVtctlCommandRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecuteVtctlCommandRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExecuteVtctlCommandRequest message.
         * @function verify
         * @memberof vtctldata.ExecuteVtctlCommandRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExecuteVtctlCommandRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.args != null && message.hasOwnProperty("args")) {
                if (!Array.isArray(message.args))
                    return "args: array expected";
                for (var i = 0; i < message.args.length; ++i)
                    if (!$util.isString(message.args[i]))
                        return "args: string[] expected";
            }
            if (message.action_timeout != null && message.hasOwnProperty("action_timeout"))
                if (!$util.isInteger(message.action_timeout) && !(message.action_timeout && $util.isInteger(message.action_timeout.low) && $util.isInteger(message.action_timeout.high)))
                    return "action_timeout: integer|Long expected";
            return null;
        };

        /**
         * Creates an ExecuteVtctlCommandRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.ExecuteVtctlCommandRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.ExecuteVtctlCommandRequest} ExecuteVtctlCommandRequest
         */
        ExecuteVtctlCommandRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.ExecuteVtctlCommandRequest)
                return object;
            var message = new $root.vtctldata.ExecuteVtctlCommandRequest();
            if (object.args) {
                if (!Array.isArray(object.args))
                    throw TypeError(".vtctldata.ExecuteVtctlCommandRequest.args: array expected");
                message.args = [];
                for (var i = 0; i < object.args.length; ++i)
                    message.args[i] = String(object.args[i]);
            }
            if (object.action_timeout != null)
                if ($util.Long)
                    (message.action_timeout = $util.Long.fromValue(object.action_timeout)).unsigned = false;
                else if (typeof object.action_timeout === "string")
                    message.action_timeout = parseInt(object.action_timeout, 10);
                else if (typeof object.action_timeout === "number")
                    message.action_timeout = object.action_timeout;
                else if (typeof object.action_timeout === "object")
                    message.action_timeout = new $util.LongBits(object.action_timeout.low >>> 0, object.action_timeout.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an ExecuteVtctlCommandRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.ExecuteVtctlCommandRequest
         * @static
         * @param {vtctldata.ExecuteVtctlCommandRequest} message ExecuteVtctlCommandRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExecuteVtctlCommandRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.args = [];
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.action_timeout = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.action_timeout = options.longs === String ? "0" : 0;
            if (message.args && message.args.length) {
                object.args = [];
                for (var j = 0; j < message.args.length; ++j)
                    object.args[j] = message.args[j];
            }
            if (message.action_timeout != null && message.hasOwnProperty("action_timeout"))
                if (typeof message.action_timeout === "number")
                    object.action_timeout = options.longs === String ? String(message.action_timeout) : message.action_timeout;
                else
                    object.action_timeout = options.longs === String ? $util.Long.prototype.toString.call(message.action_timeout) : options.longs === Number ? new $util.LongBits(message.action_timeout.low >>> 0, message.action_timeout.high >>> 0).toNumber() : message.action_timeout;
            return object;
        };

        /**
         * Converts this ExecuteVtctlCommandRequest to JSON.
         * @function toJSON
         * @memberof vtctldata.ExecuteVtctlCommandRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExecuteVtctlCommandRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExecuteVtctlCommandRequest;
    })();

    vtctldata.ExecuteVtctlCommandResponse = (function() {

        /**
         * Properties of an ExecuteVtctlCommandResponse.
         * @memberof vtctldata
         * @interface IExecuteVtctlCommandResponse
         * @property {logutil.IEvent|null} [event] ExecuteVtctlCommandResponse event
         */

        /**
         * Constructs a new ExecuteVtctlCommandResponse.
         * @memberof vtctldata
         * @classdesc Represents an ExecuteVtctlCommandResponse.
         * @implements IExecuteVtctlCommandResponse
         * @constructor
         * @param {vtctldata.IExecuteVtctlCommandResponse=} [properties] Properties to set
         */
        function ExecuteVtctlCommandResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExecuteVtctlCommandResponse event.
         * @member {logutil.IEvent|null|undefined} event
         * @memberof vtctldata.ExecuteVtctlCommandResponse
         * @instance
         */
        ExecuteVtctlCommandResponse.prototype.event = null;

        /**
         * Creates a new ExecuteVtctlCommandResponse instance using the specified properties.
         * @function create
         * @memberof vtctldata.ExecuteVtctlCommandResponse
         * @static
         * @param {vtctldata.IExecuteVtctlCommandResponse=} [properties] Properties to set
         * @returns {vtctldata.ExecuteVtctlCommandResponse} ExecuteVtctlCommandResponse instance
         */
        ExecuteVtctlCommandResponse.create = function create(properties) {
            return new ExecuteVtctlCommandResponse(properties);
        };

        /**
         * Encodes the specified ExecuteVtctlCommandResponse message. Does not implicitly {@link vtctldata.ExecuteVtctlCommandResponse.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.ExecuteVtctlCommandResponse
         * @static
         * @param {vtctldata.IExecuteVtctlCommandResponse} message ExecuteVtctlCommandResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecuteVtctlCommandResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.event != null && Object.hasOwnProperty.call(message, "event"))
                $root.logutil.Event.encode(message.event, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ExecuteVtctlCommandResponse message, length delimited. Does not implicitly {@link vtctldata.ExecuteVtctlCommandResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.ExecuteVtctlCommandResponse
         * @static
         * @param {vtctldata.IExecuteVtctlCommandResponse} message ExecuteVtctlCommandResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecuteVtctlCommandResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExecuteVtctlCommandResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.ExecuteVtctlCommandResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.ExecuteVtctlCommandResponse} ExecuteVtctlCommandResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecuteVtctlCommandResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.ExecuteVtctlCommandResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.event = $root.logutil.Event.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExecuteVtctlCommandResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.ExecuteVtctlCommandResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.ExecuteVtctlCommandResponse} ExecuteVtctlCommandResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecuteVtctlCommandResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExecuteVtctlCommandResponse message.
         * @function verify
         * @memberof vtctldata.ExecuteVtctlCommandResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExecuteVtctlCommandResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.event != null && message.hasOwnProperty("event")) {
                var error = $root.logutil.Event.verify(message.event);
                if (error)
                    return "event." + error;
            }
            return null;
        };

        /**
         * Creates an ExecuteVtctlCommandResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.ExecuteVtctlCommandResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.ExecuteVtctlCommandResponse} ExecuteVtctlCommandResponse
         */
        ExecuteVtctlCommandResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.ExecuteVtctlCommandResponse)
                return object;
            var message = new $root.vtctldata.ExecuteVtctlCommandResponse();
            if (object.event != null) {
                if (typeof object.event !== "object")
                    throw TypeError(".vtctldata.ExecuteVtctlCommandResponse.event: object expected");
                message.event = $root.logutil.Event.fromObject(object.event);
            }
            return message;
        };

        /**
         * Creates a plain object from an ExecuteVtctlCommandResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.ExecuteVtctlCommandResponse
         * @static
         * @param {vtctldata.ExecuteVtctlCommandResponse} message ExecuteVtctlCommandResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExecuteVtctlCommandResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.event = null;
            if (message.event != null && message.hasOwnProperty("event"))
                object.event = $root.logutil.Event.toObject(message.event, options);
            return object;
        };

        /**
         * Converts this ExecuteVtctlCommandResponse to JSON.
         * @function toJSON
         * @memberof vtctldata.ExecuteVtctlCommandResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExecuteVtctlCommandResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExecuteVtctlCommandResponse;
    })();

    vtctldata.TableMaterializeSettings = (function() {

        /**
         * Properties of a TableMaterializeSettings.
         * @memberof vtctldata
         * @interface ITableMaterializeSettings
         * @property {string|null} [target_table] TableMaterializeSettings target_table
         * @property {string|null} [source_expression] TableMaterializeSettings source_expression
         * @property {string|null} [create_ddl] TableMaterializeSettings create_ddl
         */

        /**
         * Constructs a new TableMaterializeSettings.
         * @memberof vtctldata
         * @classdesc Represents a TableMaterializeSettings.
         * @implements ITableMaterializeSettings
         * @constructor
         * @param {vtctldata.ITableMaterializeSettings=} [properties] Properties to set
         */
        function TableMaterializeSettings(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TableMaterializeSettings target_table.
         * @member {string} target_table
         * @memberof vtctldata.TableMaterializeSettings
         * @instance
         */
        TableMaterializeSettings.prototype.target_table = "";

        /**
         * TableMaterializeSettings source_expression.
         * @member {string} source_expression
         * @memberof vtctldata.TableMaterializeSettings
         * @instance
         */
        TableMaterializeSettings.prototype.source_expression = "";

        /**
         * TableMaterializeSettings create_ddl.
         * @member {string} create_ddl
         * @memberof vtctldata.TableMaterializeSettings
         * @instance
         */
        TableMaterializeSettings.prototype.create_ddl = "";

        /**
         * Creates a new TableMaterializeSettings instance using the specified properties.
         * @function create
         * @memberof vtctldata.TableMaterializeSettings
         * @static
         * @param {vtctldata.ITableMaterializeSettings=} [properties] Properties to set
         * @returns {vtctldata.TableMaterializeSettings} TableMaterializeSettings instance
         */
        TableMaterializeSettings.create = function create(properties) {
            return new TableMaterializeSettings(properties);
        };

        /**
         * Encodes the specified TableMaterializeSettings message. Does not implicitly {@link vtctldata.TableMaterializeSettings.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.TableMaterializeSettings
         * @static
         * @param {vtctldata.ITableMaterializeSettings} message TableMaterializeSettings message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TableMaterializeSettings.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.target_table != null && Object.hasOwnProperty.call(message, "target_table"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.target_table);
            if (message.source_expression != null && Object.hasOwnProperty.call(message, "source_expression"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.source_expression);
            if (message.create_ddl != null && Object.hasOwnProperty.call(message, "create_ddl"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.create_ddl);
            return writer;
        };

        /**
         * Encodes the specified TableMaterializeSettings message, length delimited. Does not implicitly {@link vtctldata.TableMaterializeSettings.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.TableMaterializeSettings
         * @static
         * @param {vtctldata.ITableMaterializeSettings} message TableMaterializeSettings message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TableMaterializeSettings.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TableMaterializeSettings message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.TableMaterializeSettings
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.TableMaterializeSettings} TableMaterializeSettings
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TableMaterializeSettings.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.TableMaterializeSettings();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.target_table = reader.string();
                    break;
                case 2:
                    message.source_expression = reader.string();
                    break;
                case 3:
                    message.create_ddl = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TableMaterializeSettings message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.TableMaterializeSettings
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.TableMaterializeSettings} TableMaterializeSettings
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TableMaterializeSettings.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TableMaterializeSettings message.
         * @function verify
         * @memberof vtctldata.TableMaterializeSettings
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TableMaterializeSettings.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.target_table != null && message.hasOwnProperty("target_table"))
                if (!$util.isString(message.target_table))
                    return "target_table: string expected";
            if (message.source_expression != null && message.hasOwnProperty("source_expression"))
                if (!$util.isString(message.source_expression))
                    return "source_expression: string expected";
            if (message.create_ddl != null && message.hasOwnProperty("create_ddl"))
                if (!$util.isString(message.create_ddl))
                    return "create_ddl: string expected";
            return null;
        };

        /**
         * Creates a TableMaterializeSettings message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.TableMaterializeSettings
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.TableMaterializeSettings} TableMaterializeSettings
         */
        TableMaterializeSettings.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.TableMaterializeSettings)
                return object;
            var message = new $root.vtctldata.TableMaterializeSettings();
            if (object.target_table != null)
                message.target_table = String(object.target_table);
            if (object.source_expression != null)
                message.source_expression = String(object.source_expression);
            if (object.create_ddl != null)
                message.create_ddl = String(object.create_ddl);
            return message;
        };

        /**
         * Creates a plain object from a TableMaterializeSettings message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.TableMaterializeSettings
         * @static
         * @param {vtctldata.TableMaterializeSettings} message TableMaterializeSettings
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TableMaterializeSettings.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.target_table = "";
                object.source_expression = "";
                object.create_ddl = "";
            }
            if (message.target_table != null && message.hasOwnProperty("target_table"))
                object.target_table = message.target_table;
            if (message.source_expression != null && message.hasOwnProperty("source_expression"))
                object.source_expression = message.source_expression;
            if (message.create_ddl != null && message.hasOwnProperty("create_ddl"))
                object.create_ddl = message.create_ddl;
            return object;
        };

        /**
         * Converts this TableMaterializeSettings to JSON.
         * @function toJSON
         * @memberof vtctldata.TableMaterializeSettings
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TableMaterializeSettings.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TableMaterializeSettings;
    })();

    vtctldata.MaterializeSettings = (function() {

        /**
         * Properties of a MaterializeSettings.
         * @memberof vtctldata
         * @interface IMaterializeSettings
         * @property {string|null} [workflow] MaterializeSettings workflow
         * @property {string|null} [source_keyspace] MaterializeSettings source_keyspace
         * @property {string|null} [target_keyspace] MaterializeSettings target_keyspace
         * @property {boolean|null} [stop_after_copy] MaterializeSettings stop_after_copy
         * @property {Array.<vtctldata.ITableMaterializeSettings>|null} [table_settings] MaterializeSettings table_settings
         * @property {string|null} [cell] MaterializeSettings cell
         * @property {string|null} [tablet_types] MaterializeSettings tablet_types
         * @property {string|null} [external_cluster] MaterializeSettings external_cluster
         */

        /**
         * Constructs a new MaterializeSettings.
         * @memberof vtctldata
         * @classdesc Represents a MaterializeSettings.
         * @implements IMaterializeSettings
         * @constructor
         * @param {vtctldata.IMaterializeSettings=} [properties] Properties to set
         */
        function MaterializeSettings(properties) {
            this.table_settings = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MaterializeSettings workflow.
         * @member {string} workflow
         * @memberof vtctldata.MaterializeSettings
         * @instance
         */
        MaterializeSettings.prototype.workflow = "";

        /**
         * MaterializeSettings source_keyspace.
         * @member {string} source_keyspace
         * @memberof vtctldata.MaterializeSettings
         * @instance
         */
        MaterializeSettings.prototype.source_keyspace = "";

        /**
         * MaterializeSettings target_keyspace.
         * @member {string} target_keyspace
         * @memberof vtctldata.MaterializeSettings
         * @instance
         */
        MaterializeSettings.prototype.target_keyspace = "";

        /**
         * MaterializeSettings stop_after_copy.
         * @member {boolean} stop_after_copy
         * @memberof vtctldata.MaterializeSettings
         * @instance
         */
        MaterializeSettings.prototype.stop_after_copy = false;

        /**
         * MaterializeSettings table_settings.
         * @member {Array.<vtctldata.ITableMaterializeSettings>} table_settings
         * @memberof vtctldata.MaterializeSettings
         * @instance
         */
        MaterializeSettings.prototype.table_settings = $util.emptyArray;

        /**
         * MaterializeSettings cell.
         * @member {string} cell
         * @memberof vtctldata.MaterializeSettings
         * @instance
         */
        MaterializeSettings.prototype.cell = "";

        /**
         * MaterializeSettings tablet_types.
         * @member {string} tablet_types
         * @memberof vtctldata.MaterializeSettings
         * @instance
         */
        MaterializeSettings.prototype.tablet_types = "";

        /**
         * MaterializeSettings external_cluster.
         * @member {string} external_cluster
         * @memberof vtctldata.MaterializeSettings
         * @instance
         */
        MaterializeSettings.prototype.external_cluster = "";

        /**
         * Creates a new MaterializeSettings instance using the specified properties.
         * @function create
         * @memberof vtctldata.MaterializeSettings
         * @static
         * @param {vtctldata.IMaterializeSettings=} [properties] Properties to set
         * @returns {vtctldata.MaterializeSettings} MaterializeSettings instance
         */
        MaterializeSettings.create = function create(properties) {
            return new MaterializeSettings(properties);
        };

        /**
         * Encodes the specified MaterializeSettings message. Does not implicitly {@link vtctldata.MaterializeSettings.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.MaterializeSettings
         * @static
         * @param {vtctldata.IMaterializeSettings} message MaterializeSettings message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MaterializeSettings.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.workflow != null && Object.hasOwnProperty.call(message, "workflow"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.workflow);
            if (message.source_keyspace != null && Object.hasOwnProperty.call(message, "source_keyspace"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.source_keyspace);
            if (message.target_keyspace != null && Object.hasOwnProperty.call(message, "target_keyspace"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.target_keyspace);
            if (message.stop_after_copy != null && Object.hasOwnProperty.call(message, "stop_after_copy"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.stop_after_copy);
            if (message.table_settings != null && message.table_settings.length)
                for (var i = 0; i < message.table_settings.length; ++i)
                    $root.vtctldata.TableMaterializeSettings.encode(message.table_settings[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.cell != null && Object.hasOwnProperty.call(message, "cell"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.cell);
            if (message.tablet_types != null && Object.hasOwnProperty.call(message, "tablet_types"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.tablet_types);
            if (message.external_cluster != null && Object.hasOwnProperty.call(message, "external_cluster"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.external_cluster);
            return writer;
        };

        /**
         * Encodes the specified MaterializeSettings message, length delimited. Does not implicitly {@link vtctldata.MaterializeSettings.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.MaterializeSettings
         * @static
         * @param {vtctldata.IMaterializeSettings} message MaterializeSettings message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MaterializeSettings.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MaterializeSettings message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.MaterializeSettings
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.MaterializeSettings} MaterializeSettings
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MaterializeSettings.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.MaterializeSettings();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.workflow = reader.string();
                    break;
                case 2:
                    message.source_keyspace = reader.string();
                    break;
                case 3:
                    message.target_keyspace = reader.string();
                    break;
                case 4:
                    message.stop_after_copy = reader.bool();
                    break;
                case 5:
                    if (!(message.table_settings && message.table_settings.length))
                        message.table_settings = [];
                    message.table_settings.push($root.vtctldata.TableMaterializeSettings.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.cell = reader.string();
                    break;
                case 7:
                    message.tablet_types = reader.string();
                    break;
                case 8:
                    message.external_cluster = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MaterializeSettings message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.MaterializeSettings
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.MaterializeSettings} MaterializeSettings
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MaterializeSettings.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MaterializeSettings message.
         * @function verify
         * @memberof vtctldata.MaterializeSettings
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MaterializeSettings.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.workflow != null && message.hasOwnProperty("workflow"))
                if (!$util.isString(message.workflow))
                    return "workflow: string expected";
            if (message.source_keyspace != null && message.hasOwnProperty("source_keyspace"))
                if (!$util.isString(message.source_keyspace))
                    return "source_keyspace: string expected";
            if (message.target_keyspace != null && message.hasOwnProperty("target_keyspace"))
                if (!$util.isString(message.target_keyspace))
                    return "target_keyspace: string expected";
            if (message.stop_after_copy != null && message.hasOwnProperty("stop_after_copy"))
                if (typeof message.stop_after_copy !== "boolean")
                    return "stop_after_copy: boolean expected";
            if (message.table_settings != null && message.hasOwnProperty("table_settings")) {
                if (!Array.isArray(message.table_settings))
                    return "table_settings: array expected";
                for (var i = 0; i < message.table_settings.length; ++i) {
                    var error = $root.vtctldata.TableMaterializeSettings.verify(message.table_settings[i]);
                    if (error)
                        return "table_settings." + error;
                }
            }
            if (message.cell != null && message.hasOwnProperty("cell"))
                if (!$util.isString(message.cell))
                    return "cell: string expected";
            if (message.tablet_types != null && message.hasOwnProperty("tablet_types"))
                if (!$util.isString(message.tablet_types))
                    return "tablet_types: string expected";
            if (message.external_cluster != null && message.hasOwnProperty("external_cluster"))
                if (!$util.isString(message.external_cluster))
                    return "external_cluster: string expected";
            return null;
        };

        /**
         * Creates a MaterializeSettings message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.MaterializeSettings
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.MaterializeSettings} MaterializeSettings
         */
        MaterializeSettings.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.MaterializeSettings)
                return object;
            var message = new $root.vtctldata.MaterializeSettings();
            if (object.workflow != null)
                message.workflow = String(object.workflow);
            if (object.source_keyspace != null)
                message.source_keyspace = String(object.source_keyspace);
            if (object.target_keyspace != null)
                message.target_keyspace = String(object.target_keyspace);
            if (object.stop_after_copy != null)
                message.stop_after_copy = Boolean(object.stop_after_copy);
            if (object.table_settings) {
                if (!Array.isArray(object.table_settings))
                    throw TypeError(".vtctldata.MaterializeSettings.table_settings: array expected");
                message.table_settings = [];
                for (var i = 0; i < object.table_settings.length; ++i) {
                    if (typeof object.table_settings[i] !== "object")
                        throw TypeError(".vtctldata.MaterializeSettings.table_settings: object expected");
                    message.table_settings[i] = $root.vtctldata.TableMaterializeSettings.fromObject(object.table_settings[i]);
                }
            }
            if (object.cell != null)
                message.cell = String(object.cell);
            if (object.tablet_types != null)
                message.tablet_types = String(object.tablet_types);
            if (object.external_cluster != null)
                message.external_cluster = String(object.external_cluster);
            return message;
        };

        /**
         * Creates a plain object from a MaterializeSettings message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.MaterializeSettings
         * @static
         * @param {vtctldata.MaterializeSettings} message MaterializeSettings
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MaterializeSettings.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.table_settings = [];
            if (options.defaults) {
                object.workflow = "";
                object.source_keyspace = "";
                object.target_keyspace = "";
                object.stop_after_copy = false;
                object.cell = "";
                object.tablet_types = "";
                object.external_cluster = "";
            }
            if (message.workflow != null && message.hasOwnProperty("workflow"))
                object.workflow = message.workflow;
            if (message.source_keyspace != null && message.hasOwnProperty("source_keyspace"))
                object.source_keyspace = message.source_keyspace;
            if (message.target_keyspace != null && message.hasOwnProperty("target_keyspace"))
                object.target_keyspace = message.target_keyspace;
            if (message.stop_after_copy != null && message.hasOwnProperty("stop_after_copy"))
                object.stop_after_copy = message.stop_after_copy;
            if (message.table_settings && message.table_settings.length) {
                object.table_settings = [];
                for (var j = 0; j < message.table_settings.length; ++j)
                    object.table_settings[j] = $root.vtctldata.TableMaterializeSettings.toObject(message.table_settings[j], options);
            }
            if (message.cell != null && message.hasOwnProperty("cell"))
                object.cell = message.cell;
            if (message.tablet_types != null && message.hasOwnProperty("tablet_types"))
                object.tablet_types = message.tablet_types;
            if (message.external_cluster != null && message.hasOwnProperty("external_cluster"))
                object.external_cluster = message.external_cluster;
            return object;
        };

        /**
         * Converts this MaterializeSettings to JSON.
         * @function toJSON
         * @memberof vtctldata.MaterializeSettings
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MaterializeSettings.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MaterializeSettings;
    })();

    vtctldata.Keyspace = (function() {

        /**
         * Properties of a Keyspace.
         * @memberof vtctldata
         * @interface IKeyspace
         * @property {string|null} [name] Keyspace name
         * @property {topodata.IKeyspace|null} [keyspace] Keyspace keyspace
         */

        /**
         * Constructs a new Keyspace.
         * @memberof vtctldata
         * @classdesc Represents a Keyspace.
         * @implements IKeyspace
         * @constructor
         * @param {vtctldata.IKeyspace=} [properties] Properties to set
         */
        function Keyspace(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Keyspace name.
         * @member {string} name
         * @memberof vtctldata.Keyspace
         * @instance
         */
        Keyspace.prototype.name = "";

        /**
         * Keyspace keyspace.
         * @member {topodata.IKeyspace|null|undefined} keyspace
         * @memberof vtctldata.Keyspace
         * @instance
         */
        Keyspace.prototype.keyspace = null;

        /**
         * Creates a new Keyspace instance using the specified properties.
         * @function create
         * @memberof vtctldata.Keyspace
         * @static
         * @param {vtctldata.IKeyspace=} [properties] Properties to set
         * @returns {vtctldata.Keyspace} Keyspace instance
         */
        Keyspace.create = function create(properties) {
            return new Keyspace(properties);
        };

        /**
         * Encodes the specified Keyspace message. Does not implicitly {@link vtctldata.Keyspace.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.Keyspace
         * @static
         * @param {vtctldata.IKeyspace} message Keyspace message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Keyspace.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.keyspace != null && Object.hasOwnProperty.call(message, "keyspace"))
                $root.topodata.Keyspace.encode(message.keyspace, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Keyspace message, length delimited. Does not implicitly {@link vtctldata.Keyspace.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.Keyspace
         * @static
         * @param {vtctldata.IKeyspace} message Keyspace message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Keyspace.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Keyspace message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.Keyspace
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.Keyspace} Keyspace
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Keyspace.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.Keyspace();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.keyspace = $root.topodata.Keyspace.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Keyspace message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.Keyspace
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.Keyspace} Keyspace
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Keyspace.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Keyspace message.
         * @function verify
         * @memberof vtctldata.Keyspace
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Keyspace.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.keyspace != null && message.hasOwnProperty("keyspace")) {
                var error = $root.topodata.Keyspace.verify(message.keyspace);
                if (error)
                    return "keyspace." + error;
            }
            return null;
        };

        /**
         * Creates a Keyspace message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.Keyspace
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.Keyspace} Keyspace
         */
        Keyspace.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.Keyspace)
                return object;
            var message = new $root.vtctldata.Keyspace();
            if (object.name != null)
                message.name = String(object.name);
            if (object.keyspace != null) {
                if (typeof object.keyspace !== "object")
                    throw TypeError(".vtctldata.Keyspace.keyspace: object expected");
                message.keyspace = $root.topodata.Keyspace.fromObject(object.keyspace);
            }
            return message;
        };

        /**
         * Creates a plain object from a Keyspace message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.Keyspace
         * @static
         * @param {vtctldata.Keyspace} message Keyspace
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Keyspace.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.keyspace = null;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                object.keyspace = $root.topodata.Keyspace.toObject(message.keyspace, options);
            return object;
        };

        /**
         * Converts this Keyspace to JSON.
         * @function toJSON
         * @memberof vtctldata.Keyspace
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Keyspace.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Keyspace;
    })();

    vtctldata.Shard = (function() {

        /**
         * Properties of a Shard.
         * @memberof vtctldata
         * @interface IShard
         * @property {string|null} [keyspace] Shard keyspace
         * @property {string|null} [name] Shard name
         * @property {topodata.IShard|null} [shard] Shard shard
         */

        /**
         * Constructs a new Shard.
         * @memberof vtctldata
         * @classdesc Represents a Shard.
         * @implements IShard
         * @constructor
         * @param {vtctldata.IShard=} [properties] Properties to set
         */
        function Shard(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Shard keyspace.
         * @member {string} keyspace
         * @memberof vtctldata.Shard
         * @instance
         */
        Shard.prototype.keyspace = "";

        /**
         * Shard name.
         * @member {string} name
         * @memberof vtctldata.Shard
         * @instance
         */
        Shard.prototype.name = "";

        /**
         * Shard shard.
         * @member {topodata.IShard|null|undefined} shard
         * @memberof vtctldata.Shard
         * @instance
         */
        Shard.prototype.shard = null;

        /**
         * Creates a new Shard instance using the specified properties.
         * @function create
         * @memberof vtctldata.Shard
         * @static
         * @param {vtctldata.IShard=} [properties] Properties to set
         * @returns {vtctldata.Shard} Shard instance
         */
        Shard.create = function create(properties) {
            return new Shard(properties);
        };

        /**
         * Encodes the specified Shard message. Does not implicitly {@link vtctldata.Shard.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.Shard
         * @static
         * @param {vtctldata.IShard} message Shard message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Shard.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keyspace != null && Object.hasOwnProperty.call(message, "keyspace"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.keyspace);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.shard != null && Object.hasOwnProperty.call(message, "shard"))
                $root.topodata.Shard.encode(message.shard, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Shard message, length delimited. Does not implicitly {@link vtctldata.Shard.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.Shard
         * @static
         * @param {vtctldata.IShard} message Shard message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Shard.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Shard message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.Shard
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.Shard} Shard
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Shard.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.Shard();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.keyspace = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.shard = $root.topodata.Shard.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Shard message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.Shard
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.Shard} Shard
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Shard.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Shard message.
         * @function verify
         * @memberof vtctldata.Shard
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Shard.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                if (!$util.isString(message.keyspace))
                    return "keyspace: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.shard != null && message.hasOwnProperty("shard")) {
                var error = $root.topodata.Shard.verify(message.shard);
                if (error)
                    return "shard." + error;
            }
            return null;
        };

        /**
         * Creates a Shard message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.Shard
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.Shard} Shard
         */
        Shard.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.Shard)
                return object;
            var message = new $root.vtctldata.Shard();
            if (object.keyspace != null)
                message.keyspace = String(object.keyspace);
            if (object.name != null)
                message.name = String(object.name);
            if (object.shard != null) {
                if (typeof object.shard !== "object")
                    throw TypeError(".vtctldata.Shard.shard: object expected");
                message.shard = $root.topodata.Shard.fromObject(object.shard);
            }
            return message;
        };

        /**
         * Creates a plain object from a Shard message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.Shard
         * @static
         * @param {vtctldata.Shard} message Shard
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Shard.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.keyspace = "";
                object.name = "";
                object.shard = null;
            }
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                object.keyspace = message.keyspace;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.shard != null && message.hasOwnProperty("shard"))
                object.shard = $root.topodata.Shard.toObject(message.shard, options);
            return object;
        };

        /**
         * Converts this Shard to JSON.
         * @function toJSON
         * @memberof vtctldata.Shard
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Shard.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Shard;
    })();

    vtctldata.Workflow = (function() {

        /**
         * Properties of a Workflow.
         * @memberof vtctldata
         * @interface IWorkflow
         * @property {string|null} [name] Workflow name
         * @property {vtctldata.Workflow.IReplicationLocation|null} [source] Workflow source
         * @property {vtctldata.Workflow.IReplicationLocation|null} [target] Workflow target
         * @property {number|Long|null} [max_v_replication_lag] Workflow max_v_replication_lag
         * @property {Object.<string,vtctldata.Workflow.IShardStream>|null} [shard_streams] Workflow shard_streams
         */

        /**
         * Constructs a new Workflow.
         * @memberof vtctldata
         * @classdesc Represents a Workflow.
         * @implements IWorkflow
         * @constructor
         * @param {vtctldata.IWorkflow=} [properties] Properties to set
         */
        function Workflow(properties) {
            this.shard_streams = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Workflow name.
         * @member {string} name
         * @memberof vtctldata.Workflow
         * @instance
         */
        Workflow.prototype.name = "";

        /**
         * Workflow source.
         * @member {vtctldata.Workflow.IReplicationLocation|null|undefined} source
         * @memberof vtctldata.Workflow
         * @instance
         */
        Workflow.prototype.source = null;

        /**
         * Workflow target.
         * @member {vtctldata.Workflow.IReplicationLocation|null|undefined} target
         * @memberof vtctldata.Workflow
         * @instance
         */
        Workflow.prototype.target = null;

        /**
         * Workflow max_v_replication_lag.
         * @member {number|Long} max_v_replication_lag
         * @memberof vtctldata.Workflow
         * @instance
         */
        Workflow.prototype.max_v_replication_lag = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Workflow shard_streams.
         * @member {Object.<string,vtctldata.Workflow.IShardStream>} shard_streams
         * @memberof vtctldata.Workflow
         * @instance
         */
        Workflow.prototype.shard_streams = $util.emptyObject;

        /**
         * Creates a new Workflow instance using the specified properties.
         * @function create
         * @memberof vtctldata.Workflow
         * @static
         * @param {vtctldata.IWorkflow=} [properties] Properties to set
         * @returns {vtctldata.Workflow} Workflow instance
         */
        Workflow.create = function create(properties) {
            return new Workflow(properties);
        };

        /**
         * Encodes the specified Workflow message. Does not implicitly {@link vtctldata.Workflow.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.Workflow
         * @static
         * @param {vtctldata.IWorkflow} message Workflow message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Workflow.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.source != null && Object.hasOwnProperty.call(message, "source"))
                $root.vtctldata.Workflow.ReplicationLocation.encode(message.source, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                $root.vtctldata.Workflow.ReplicationLocation.encode(message.target, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.max_v_replication_lag != null && Object.hasOwnProperty.call(message, "max_v_replication_lag"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.max_v_replication_lag);
            if (message.shard_streams != null && Object.hasOwnProperty.call(message, "shard_streams"))
                for (var keys = Object.keys(message.shard_streams), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 5, wireType 2 =*/42).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.vtctldata.Workflow.ShardStream.encode(message.shard_streams[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            return writer;
        };

        /**
         * Encodes the specified Workflow message, length delimited. Does not implicitly {@link vtctldata.Workflow.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.Workflow
         * @static
         * @param {vtctldata.IWorkflow} message Workflow message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Workflow.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Workflow message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.Workflow
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.Workflow} Workflow
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Workflow.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.Workflow(), key, value;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.source = $root.vtctldata.Workflow.ReplicationLocation.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.target = $root.vtctldata.Workflow.ReplicationLocation.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.max_v_replication_lag = reader.int64();
                    break;
                case 5:
                    if (message.shard_streams === $util.emptyObject)
                        message.shard_streams = {};
                    var end2 = reader.uint32() + reader.pos;
                    key = "";
                    value = null;
                    while (reader.pos < end2) {
                        var tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.string();
                            break;
                        case 2:
                            value = $root.vtctldata.Workflow.ShardStream.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.shard_streams[key] = value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Workflow message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.Workflow
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.Workflow} Workflow
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Workflow.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Workflow message.
         * @function verify
         * @memberof vtctldata.Workflow
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Workflow.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.source != null && message.hasOwnProperty("source")) {
                var error = $root.vtctldata.Workflow.ReplicationLocation.verify(message.source);
                if (error)
                    return "source." + error;
            }
            if (message.target != null && message.hasOwnProperty("target")) {
                var error = $root.vtctldata.Workflow.ReplicationLocation.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.max_v_replication_lag != null && message.hasOwnProperty("max_v_replication_lag"))
                if (!$util.isInteger(message.max_v_replication_lag) && !(message.max_v_replication_lag && $util.isInteger(message.max_v_replication_lag.low) && $util.isInteger(message.max_v_replication_lag.high)))
                    return "max_v_replication_lag: integer|Long expected";
            if (message.shard_streams != null && message.hasOwnProperty("shard_streams")) {
                if (!$util.isObject(message.shard_streams))
                    return "shard_streams: object expected";
                var key = Object.keys(message.shard_streams);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.vtctldata.Workflow.ShardStream.verify(message.shard_streams[key[i]]);
                    if (error)
                        return "shard_streams." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Workflow message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.Workflow
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.Workflow} Workflow
         */
        Workflow.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.Workflow)
                return object;
            var message = new $root.vtctldata.Workflow();
            if (object.name != null)
                message.name = String(object.name);
            if (object.source != null) {
                if (typeof object.source !== "object")
                    throw TypeError(".vtctldata.Workflow.source: object expected");
                message.source = $root.vtctldata.Workflow.ReplicationLocation.fromObject(object.source);
            }
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".vtctldata.Workflow.target: object expected");
                message.target = $root.vtctldata.Workflow.ReplicationLocation.fromObject(object.target);
            }
            if (object.max_v_replication_lag != null)
                if ($util.Long)
                    (message.max_v_replication_lag = $util.Long.fromValue(object.max_v_replication_lag)).unsigned = false;
                else if (typeof object.max_v_replication_lag === "string")
                    message.max_v_replication_lag = parseInt(object.max_v_replication_lag, 10);
                else if (typeof object.max_v_replication_lag === "number")
                    message.max_v_replication_lag = object.max_v_replication_lag;
                else if (typeof object.max_v_replication_lag === "object")
                    message.max_v_replication_lag = new $util.LongBits(object.max_v_replication_lag.low >>> 0, object.max_v_replication_lag.high >>> 0).toNumber();
            if (object.shard_streams) {
                if (typeof object.shard_streams !== "object")
                    throw TypeError(".vtctldata.Workflow.shard_streams: object expected");
                message.shard_streams = {};
                for (var keys = Object.keys(object.shard_streams), i = 0; i < keys.length; ++i) {
                    if (typeof object.shard_streams[keys[i]] !== "object")
                        throw TypeError(".vtctldata.Workflow.shard_streams: object expected");
                    message.shard_streams[keys[i]] = $root.vtctldata.Workflow.ShardStream.fromObject(object.shard_streams[keys[i]]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Workflow message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.Workflow
         * @static
         * @param {vtctldata.Workflow} message Workflow
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Workflow.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults)
                object.shard_streams = {};
            if (options.defaults) {
                object.name = "";
                object.source = null;
                object.target = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.max_v_replication_lag = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.max_v_replication_lag = options.longs === String ? "0" : 0;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.source != null && message.hasOwnProperty("source"))
                object.source = $root.vtctldata.Workflow.ReplicationLocation.toObject(message.source, options);
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.vtctldata.Workflow.ReplicationLocation.toObject(message.target, options);
            if (message.max_v_replication_lag != null && message.hasOwnProperty("max_v_replication_lag"))
                if (typeof message.max_v_replication_lag === "number")
                    object.max_v_replication_lag = options.longs === String ? String(message.max_v_replication_lag) : message.max_v_replication_lag;
                else
                    object.max_v_replication_lag = options.longs === String ? $util.Long.prototype.toString.call(message.max_v_replication_lag) : options.longs === Number ? new $util.LongBits(message.max_v_replication_lag.low >>> 0, message.max_v_replication_lag.high >>> 0).toNumber() : message.max_v_replication_lag;
            var keys2;
            if (message.shard_streams && (keys2 = Object.keys(message.shard_streams)).length) {
                object.shard_streams = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.shard_streams[keys2[j]] = $root.vtctldata.Workflow.ShardStream.toObject(message.shard_streams[keys2[j]], options);
            }
            return object;
        };

        /**
         * Converts this Workflow to JSON.
         * @function toJSON
         * @memberof vtctldata.Workflow
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Workflow.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        Workflow.ReplicationLocation = (function() {

            /**
             * Properties of a ReplicationLocation.
             * @memberof vtctldata.Workflow
             * @interface IReplicationLocation
             * @property {string|null} [keyspace] ReplicationLocation keyspace
             * @property {Array.<string>|null} [shards] ReplicationLocation shards
             */

            /**
             * Constructs a new ReplicationLocation.
             * @memberof vtctldata.Workflow
             * @classdesc Represents a ReplicationLocation.
             * @implements IReplicationLocation
             * @constructor
             * @param {vtctldata.Workflow.IReplicationLocation=} [properties] Properties to set
             */
            function ReplicationLocation(properties) {
                this.shards = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReplicationLocation keyspace.
             * @member {string} keyspace
             * @memberof vtctldata.Workflow.ReplicationLocation
             * @instance
             */
            ReplicationLocation.prototype.keyspace = "";

            /**
             * ReplicationLocation shards.
             * @member {Array.<string>} shards
             * @memberof vtctldata.Workflow.ReplicationLocation
             * @instance
             */
            ReplicationLocation.prototype.shards = $util.emptyArray;

            /**
             * Creates a new ReplicationLocation instance using the specified properties.
             * @function create
             * @memberof vtctldata.Workflow.ReplicationLocation
             * @static
             * @param {vtctldata.Workflow.IReplicationLocation=} [properties] Properties to set
             * @returns {vtctldata.Workflow.ReplicationLocation} ReplicationLocation instance
             */
            ReplicationLocation.create = function create(properties) {
                return new ReplicationLocation(properties);
            };

            /**
             * Encodes the specified ReplicationLocation message. Does not implicitly {@link vtctldata.Workflow.ReplicationLocation.verify|verify} messages.
             * @function encode
             * @memberof vtctldata.Workflow.ReplicationLocation
             * @static
             * @param {vtctldata.Workflow.IReplicationLocation} message ReplicationLocation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReplicationLocation.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.keyspace != null && Object.hasOwnProperty.call(message, "keyspace"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.keyspace);
                if (message.shards != null && message.shards.length)
                    for (var i = 0; i < message.shards.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.shards[i]);
                return writer;
            };

            /**
             * Encodes the specified ReplicationLocation message, length delimited. Does not implicitly {@link vtctldata.Workflow.ReplicationLocation.verify|verify} messages.
             * @function encodeDelimited
             * @memberof vtctldata.Workflow.ReplicationLocation
             * @static
             * @param {vtctldata.Workflow.IReplicationLocation} message ReplicationLocation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReplicationLocation.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReplicationLocation message from the specified reader or buffer.
             * @function decode
             * @memberof vtctldata.Workflow.ReplicationLocation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {vtctldata.Workflow.ReplicationLocation} ReplicationLocation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReplicationLocation.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.Workflow.ReplicationLocation();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.keyspace = reader.string();
                        break;
                    case 2:
                        if (!(message.shards && message.shards.length))
                            message.shards = [];
                        message.shards.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReplicationLocation message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof vtctldata.Workflow.ReplicationLocation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {vtctldata.Workflow.ReplicationLocation} ReplicationLocation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReplicationLocation.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReplicationLocation message.
             * @function verify
             * @memberof vtctldata.Workflow.ReplicationLocation
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReplicationLocation.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                    if (!$util.isString(message.keyspace))
                        return "keyspace: string expected";
                if (message.shards != null && message.hasOwnProperty("shards")) {
                    if (!Array.isArray(message.shards))
                        return "shards: array expected";
                    for (var i = 0; i < message.shards.length; ++i)
                        if (!$util.isString(message.shards[i]))
                            return "shards: string[] expected";
                }
                return null;
            };

            /**
             * Creates a ReplicationLocation message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof vtctldata.Workflow.ReplicationLocation
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {vtctldata.Workflow.ReplicationLocation} ReplicationLocation
             */
            ReplicationLocation.fromObject = function fromObject(object) {
                if (object instanceof $root.vtctldata.Workflow.ReplicationLocation)
                    return object;
                var message = new $root.vtctldata.Workflow.ReplicationLocation();
                if (object.keyspace != null)
                    message.keyspace = String(object.keyspace);
                if (object.shards) {
                    if (!Array.isArray(object.shards))
                        throw TypeError(".vtctldata.Workflow.ReplicationLocation.shards: array expected");
                    message.shards = [];
                    for (var i = 0; i < object.shards.length; ++i)
                        message.shards[i] = String(object.shards[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReplicationLocation message. Also converts values to other types if specified.
             * @function toObject
             * @memberof vtctldata.Workflow.ReplicationLocation
             * @static
             * @param {vtctldata.Workflow.ReplicationLocation} message ReplicationLocation
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReplicationLocation.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.shards = [];
                if (options.defaults)
                    object.keyspace = "";
                if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                    object.keyspace = message.keyspace;
                if (message.shards && message.shards.length) {
                    object.shards = [];
                    for (var j = 0; j < message.shards.length; ++j)
                        object.shards[j] = message.shards[j];
                }
                return object;
            };

            /**
             * Converts this ReplicationLocation to JSON.
             * @function toJSON
             * @memberof vtctldata.Workflow.ReplicationLocation
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReplicationLocation.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReplicationLocation;
        })();

        Workflow.ShardStream = (function() {

            /**
             * Properties of a ShardStream.
             * @memberof vtctldata.Workflow
             * @interface IShardStream
             * @property {Array.<vtctldata.Workflow.IStream>|null} [streams] ShardStream streams
             * @property {Array.<topodata.Shard.ITabletControl>|null} [tablet_controls] ShardStream tablet_controls
             * @property {boolean|null} [is_primary_serving] ShardStream is_primary_serving
             */

            /**
             * Constructs a new ShardStream.
             * @memberof vtctldata.Workflow
             * @classdesc Represents a ShardStream.
             * @implements IShardStream
             * @constructor
             * @param {vtctldata.Workflow.IShardStream=} [properties] Properties to set
             */
            function ShardStream(properties) {
                this.streams = [];
                this.tablet_controls = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ShardStream streams.
             * @member {Array.<vtctldata.Workflow.IStream>} streams
             * @memberof vtctldata.Workflow.ShardStream
             * @instance
             */
            ShardStream.prototype.streams = $util.emptyArray;

            /**
             * ShardStream tablet_controls.
             * @member {Array.<topodata.Shard.ITabletControl>} tablet_controls
             * @memberof vtctldata.Workflow.ShardStream
             * @instance
             */
            ShardStream.prototype.tablet_controls = $util.emptyArray;

            /**
             * ShardStream is_primary_serving.
             * @member {boolean} is_primary_serving
             * @memberof vtctldata.Workflow.ShardStream
             * @instance
             */
            ShardStream.prototype.is_primary_serving = false;

            /**
             * Creates a new ShardStream instance using the specified properties.
             * @function create
             * @memberof vtctldata.Workflow.ShardStream
             * @static
             * @param {vtctldata.Workflow.IShardStream=} [properties] Properties to set
             * @returns {vtctldata.Workflow.ShardStream} ShardStream instance
             */
            ShardStream.create = function create(properties) {
                return new ShardStream(properties);
            };

            /**
             * Encodes the specified ShardStream message. Does not implicitly {@link vtctldata.Workflow.ShardStream.verify|verify} messages.
             * @function encode
             * @memberof vtctldata.Workflow.ShardStream
             * @static
             * @param {vtctldata.Workflow.IShardStream} message ShardStream message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ShardStream.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.streams != null && message.streams.length)
                    for (var i = 0; i < message.streams.length; ++i)
                        $root.vtctldata.Workflow.Stream.encode(message.streams[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.tablet_controls != null && message.tablet_controls.length)
                    for (var i = 0; i < message.tablet_controls.length; ++i)
                        $root.topodata.Shard.TabletControl.encode(message.tablet_controls[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.is_primary_serving != null && Object.hasOwnProperty.call(message, "is_primary_serving"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.is_primary_serving);
                return writer;
            };

            /**
             * Encodes the specified ShardStream message, length delimited. Does not implicitly {@link vtctldata.Workflow.ShardStream.verify|verify} messages.
             * @function encodeDelimited
             * @memberof vtctldata.Workflow.ShardStream
             * @static
             * @param {vtctldata.Workflow.IShardStream} message ShardStream message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ShardStream.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ShardStream message from the specified reader or buffer.
             * @function decode
             * @memberof vtctldata.Workflow.ShardStream
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {vtctldata.Workflow.ShardStream} ShardStream
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ShardStream.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.Workflow.ShardStream();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.streams && message.streams.length))
                            message.streams = [];
                        message.streams.push($root.vtctldata.Workflow.Stream.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        if (!(message.tablet_controls && message.tablet_controls.length))
                            message.tablet_controls = [];
                        message.tablet_controls.push($root.topodata.Shard.TabletControl.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.is_primary_serving = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ShardStream message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof vtctldata.Workflow.ShardStream
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {vtctldata.Workflow.ShardStream} ShardStream
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ShardStream.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ShardStream message.
             * @function verify
             * @memberof vtctldata.Workflow.ShardStream
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ShardStream.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.streams != null && message.hasOwnProperty("streams")) {
                    if (!Array.isArray(message.streams))
                        return "streams: array expected";
                    for (var i = 0; i < message.streams.length; ++i) {
                        var error = $root.vtctldata.Workflow.Stream.verify(message.streams[i]);
                        if (error)
                            return "streams." + error;
                    }
                }
                if (message.tablet_controls != null && message.hasOwnProperty("tablet_controls")) {
                    if (!Array.isArray(message.tablet_controls))
                        return "tablet_controls: array expected";
                    for (var i = 0; i < message.tablet_controls.length; ++i) {
                        var error = $root.topodata.Shard.TabletControl.verify(message.tablet_controls[i]);
                        if (error)
                            return "tablet_controls." + error;
                    }
                }
                if (message.is_primary_serving != null && message.hasOwnProperty("is_primary_serving"))
                    if (typeof message.is_primary_serving !== "boolean")
                        return "is_primary_serving: boolean expected";
                return null;
            };

            /**
             * Creates a ShardStream message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof vtctldata.Workflow.ShardStream
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {vtctldata.Workflow.ShardStream} ShardStream
             */
            ShardStream.fromObject = function fromObject(object) {
                if (object instanceof $root.vtctldata.Workflow.ShardStream)
                    return object;
                var message = new $root.vtctldata.Workflow.ShardStream();
                if (object.streams) {
                    if (!Array.isArray(object.streams))
                        throw TypeError(".vtctldata.Workflow.ShardStream.streams: array expected");
                    message.streams = [];
                    for (var i = 0; i < object.streams.length; ++i) {
                        if (typeof object.streams[i] !== "object")
                            throw TypeError(".vtctldata.Workflow.ShardStream.streams: object expected");
                        message.streams[i] = $root.vtctldata.Workflow.Stream.fromObject(object.streams[i]);
                    }
                }
                if (object.tablet_controls) {
                    if (!Array.isArray(object.tablet_controls))
                        throw TypeError(".vtctldata.Workflow.ShardStream.tablet_controls: array expected");
                    message.tablet_controls = [];
                    for (var i = 0; i < object.tablet_controls.length; ++i) {
                        if (typeof object.tablet_controls[i] !== "object")
                            throw TypeError(".vtctldata.Workflow.ShardStream.tablet_controls: object expected");
                        message.tablet_controls[i] = $root.topodata.Shard.TabletControl.fromObject(object.tablet_controls[i]);
                    }
                }
                if (object.is_primary_serving != null)
                    message.is_primary_serving = Boolean(object.is_primary_serving);
                return message;
            };

            /**
             * Creates a plain object from a ShardStream message. Also converts values to other types if specified.
             * @function toObject
             * @memberof vtctldata.Workflow.ShardStream
             * @static
             * @param {vtctldata.Workflow.ShardStream} message ShardStream
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ShardStream.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.streams = [];
                    object.tablet_controls = [];
                }
                if (options.defaults)
                    object.is_primary_serving = false;
                if (message.streams && message.streams.length) {
                    object.streams = [];
                    for (var j = 0; j < message.streams.length; ++j)
                        object.streams[j] = $root.vtctldata.Workflow.Stream.toObject(message.streams[j], options);
                }
                if (message.tablet_controls && message.tablet_controls.length) {
                    object.tablet_controls = [];
                    for (var j = 0; j < message.tablet_controls.length; ++j)
                        object.tablet_controls[j] = $root.topodata.Shard.TabletControl.toObject(message.tablet_controls[j], options);
                }
                if (message.is_primary_serving != null && message.hasOwnProperty("is_primary_serving"))
                    object.is_primary_serving = message.is_primary_serving;
                return object;
            };

            /**
             * Converts this ShardStream to JSON.
             * @function toJSON
             * @memberof vtctldata.Workflow.ShardStream
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ShardStream.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ShardStream;
        })();

        Workflow.Stream = (function() {

            /**
             * Properties of a Stream.
             * @memberof vtctldata.Workflow
             * @interface IStream
             * @property {number|Long|null} [id] Stream id
             * @property {string|null} [shard] Stream shard
             * @property {topodata.ITabletAlias|null} [tablet] Stream tablet
             * @property {binlogdata.IBinlogSource|null} [binlog_source] Stream binlog_source
             * @property {string|null} [position] Stream position
             * @property {string|null} [stop_position] Stream stop_position
             * @property {string|null} [state] Stream state
             * @property {string|null} [db_name] Stream db_name
             * @property {vttime.ITime|null} [transaction_timestamp] Stream transaction_timestamp
             * @property {vttime.ITime|null} [time_updated] Stream time_updated
             * @property {string|null} [message] Stream message
             * @property {Array.<vtctldata.Workflow.Stream.ICopyState>|null} [copy_states] Stream copy_states
             */

            /**
             * Constructs a new Stream.
             * @memberof vtctldata.Workflow
             * @classdesc Represents a Stream.
             * @implements IStream
             * @constructor
             * @param {vtctldata.Workflow.IStream=} [properties] Properties to set
             */
            function Stream(properties) {
                this.copy_states = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Stream id.
             * @member {number|Long} id
             * @memberof vtctldata.Workflow.Stream
             * @instance
             */
            Stream.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Stream shard.
             * @member {string} shard
             * @memberof vtctldata.Workflow.Stream
             * @instance
             */
            Stream.prototype.shard = "";

            /**
             * Stream tablet.
             * @member {topodata.ITabletAlias|null|undefined} tablet
             * @memberof vtctldata.Workflow.Stream
             * @instance
             */
            Stream.prototype.tablet = null;

            /**
             * Stream binlog_source.
             * @member {binlogdata.IBinlogSource|null|undefined} binlog_source
             * @memberof vtctldata.Workflow.Stream
             * @instance
             */
            Stream.prototype.binlog_source = null;

            /**
             * Stream position.
             * @member {string} position
             * @memberof vtctldata.Workflow.Stream
             * @instance
             */
            Stream.prototype.position = "";

            /**
             * Stream stop_position.
             * @member {string} stop_position
             * @memberof vtctldata.Workflow.Stream
             * @instance
             */
            Stream.prototype.stop_position = "";

            /**
             * Stream state.
             * @member {string} state
             * @memberof vtctldata.Workflow.Stream
             * @instance
             */
            Stream.prototype.state = "";

            /**
             * Stream db_name.
             * @member {string} db_name
             * @memberof vtctldata.Workflow.Stream
             * @instance
             */
            Stream.prototype.db_name = "";

            /**
             * Stream transaction_timestamp.
             * @member {vttime.ITime|null|undefined} transaction_timestamp
             * @memberof vtctldata.Workflow.Stream
             * @instance
             */
            Stream.prototype.transaction_timestamp = null;

            /**
             * Stream time_updated.
             * @member {vttime.ITime|null|undefined} time_updated
             * @memberof vtctldata.Workflow.Stream
             * @instance
             */
            Stream.prototype.time_updated = null;

            /**
             * Stream message.
             * @member {string} message
             * @memberof vtctldata.Workflow.Stream
             * @instance
             */
            Stream.prototype.message = "";

            /**
             * Stream copy_states.
             * @member {Array.<vtctldata.Workflow.Stream.ICopyState>} copy_states
             * @memberof vtctldata.Workflow.Stream
             * @instance
             */
            Stream.prototype.copy_states = $util.emptyArray;

            /**
             * Creates a new Stream instance using the specified properties.
             * @function create
             * @memberof vtctldata.Workflow.Stream
             * @static
             * @param {vtctldata.Workflow.IStream=} [properties] Properties to set
             * @returns {vtctldata.Workflow.Stream} Stream instance
             */
            Stream.create = function create(properties) {
                return new Stream(properties);
            };

            /**
             * Encodes the specified Stream message. Does not implicitly {@link vtctldata.Workflow.Stream.verify|verify} messages.
             * @function encode
             * @memberof vtctldata.Workflow.Stream
             * @static
             * @param {vtctldata.Workflow.IStream} message Stream message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Stream.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.id);
                if (message.shard != null && Object.hasOwnProperty.call(message, "shard"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.shard);
                if (message.tablet != null && Object.hasOwnProperty.call(message, "tablet"))
                    $root.topodata.TabletAlias.encode(message.tablet, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.binlog_source != null && Object.hasOwnProperty.call(message, "binlog_source"))
                    $root.binlogdata.BinlogSource.encode(message.binlog_source, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.position);
                if (message.stop_position != null && Object.hasOwnProperty.call(message, "stop_position"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.stop_position);
                if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.state);
                if (message.db_name != null && Object.hasOwnProperty.call(message, "db_name"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.db_name);
                if (message.transaction_timestamp != null && Object.hasOwnProperty.call(message, "transaction_timestamp"))
                    $root.vttime.Time.encode(message.transaction_timestamp, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.time_updated != null && Object.hasOwnProperty.call(message, "time_updated"))
                    $root.vttime.Time.encode(message.time_updated, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.message);
                if (message.copy_states != null && message.copy_states.length)
                    for (var i = 0; i < message.copy_states.length; ++i)
                        $root.vtctldata.Workflow.Stream.CopyState.encode(message.copy_states[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Stream message, length delimited. Does not implicitly {@link vtctldata.Workflow.Stream.verify|verify} messages.
             * @function encodeDelimited
             * @memberof vtctldata.Workflow.Stream
             * @static
             * @param {vtctldata.Workflow.IStream} message Stream message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Stream.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Stream message from the specified reader or buffer.
             * @function decode
             * @memberof vtctldata.Workflow.Stream
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {vtctldata.Workflow.Stream} Stream
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Stream.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.Workflow.Stream();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.int64();
                        break;
                    case 2:
                        message.shard = reader.string();
                        break;
                    case 3:
                        message.tablet = $root.topodata.TabletAlias.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.binlog_source = $root.binlogdata.BinlogSource.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.position = reader.string();
                        break;
                    case 6:
                        message.stop_position = reader.string();
                        break;
                    case 7:
                        message.state = reader.string();
                        break;
                    case 8:
                        message.db_name = reader.string();
                        break;
                    case 9:
                        message.transaction_timestamp = $root.vttime.Time.decode(reader, reader.uint32());
                        break;
                    case 10:
                        message.time_updated = $root.vttime.Time.decode(reader, reader.uint32());
                        break;
                    case 11:
                        message.message = reader.string();
                        break;
                    case 12:
                        if (!(message.copy_states && message.copy_states.length))
                            message.copy_states = [];
                        message.copy_states.push($root.vtctldata.Workflow.Stream.CopyState.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Stream message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof vtctldata.Workflow.Stream
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {vtctldata.Workflow.Stream} Stream
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Stream.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Stream message.
             * @function verify
             * @memberof vtctldata.Workflow.Stream
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Stream.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                        return "id: integer|Long expected";
                if (message.shard != null && message.hasOwnProperty("shard"))
                    if (!$util.isString(message.shard))
                        return "shard: string expected";
                if (message.tablet != null && message.hasOwnProperty("tablet")) {
                    var error = $root.topodata.TabletAlias.verify(message.tablet);
                    if (error)
                        return "tablet." + error;
                }
                if (message.binlog_source != null && message.hasOwnProperty("binlog_source")) {
                    var error = $root.binlogdata.BinlogSource.verify(message.binlog_source);
                    if (error)
                        return "binlog_source." + error;
                }
                if (message.position != null && message.hasOwnProperty("position"))
                    if (!$util.isString(message.position))
                        return "position: string expected";
                if (message.stop_position != null && message.hasOwnProperty("stop_position"))
                    if (!$util.isString(message.stop_position))
                        return "stop_position: string expected";
                if (message.state != null && message.hasOwnProperty("state"))
                    if (!$util.isString(message.state))
                        return "state: string expected";
                if (message.db_name != null && message.hasOwnProperty("db_name"))
                    if (!$util.isString(message.db_name))
                        return "db_name: string expected";
                if (message.transaction_timestamp != null && message.hasOwnProperty("transaction_timestamp")) {
                    var error = $root.vttime.Time.verify(message.transaction_timestamp);
                    if (error)
                        return "transaction_timestamp." + error;
                }
                if (message.time_updated != null && message.hasOwnProperty("time_updated")) {
                    var error = $root.vttime.Time.verify(message.time_updated);
                    if (error)
                        return "time_updated." + error;
                }
                if (message.message != null && message.hasOwnProperty("message"))
                    if (!$util.isString(message.message))
                        return "message: string expected";
                if (message.copy_states != null && message.hasOwnProperty("copy_states")) {
                    if (!Array.isArray(message.copy_states))
                        return "copy_states: array expected";
                    for (var i = 0; i < message.copy_states.length; ++i) {
                        var error = $root.vtctldata.Workflow.Stream.CopyState.verify(message.copy_states[i]);
                        if (error)
                            return "copy_states." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Stream message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof vtctldata.Workflow.Stream
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {vtctldata.Workflow.Stream} Stream
             */
            Stream.fromObject = function fromObject(object) {
                if (object instanceof $root.vtctldata.Workflow.Stream)
                    return object;
                var message = new $root.vtctldata.Workflow.Stream();
                if (object.id != null)
                    if ($util.Long)
                        (message.id = $util.Long.fromValue(object.id)).unsigned = false;
                    else if (typeof object.id === "string")
                        message.id = parseInt(object.id, 10);
                    else if (typeof object.id === "number")
                        message.id = object.id;
                    else if (typeof object.id === "object")
                        message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
                if (object.shard != null)
                    message.shard = String(object.shard);
                if (object.tablet != null) {
                    if (typeof object.tablet !== "object")
                        throw TypeError(".vtctldata.Workflow.Stream.tablet: object expected");
                    message.tablet = $root.topodata.TabletAlias.fromObject(object.tablet);
                }
                if (object.binlog_source != null) {
                    if (typeof object.binlog_source !== "object")
                        throw TypeError(".vtctldata.Workflow.Stream.binlog_source: object expected");
                    message.binlog_source = $root.binlogdata.BinlogSource.fromObject(object.binlog_source);
                }
                if (object.position != null)
                    message.position = String(object.position);
                if (object.stop_position != null)
                    message.stop_position = String(object.stop_position);
                if (object.state != null)
                    message.state = String(object.state);
                if (object.db_name != null)
                    message.db_name = String(object.db_name);
                if (object.transaction_timestamp != null) {
                    if (typeof object.transaction_timestamp !== "object")
                        throw TypeError(".vtctldata.Workflow.Stream.transaction_timestamp: object expected");
                    message.transaction_timestamp = $root.vttime.Time.fromObject(object.transaction_timestamp);
                }
                if (object.time_updated != null) {
                    if (typeof object.time_updated !== "object")
                        throw TypeError(".vtctldata.Workflow.Stream.time_updated: object expected");
                    message.time_updated = $root.vttime.Time.fromObject(object.time_updated);
                }
                if (object.message != null)
                    message.message = String(object.message);
                if (object.copy_states) {
                    if (!Array.isArray(object.copy_states))
                        throw TypeError(".vtctldata.Workflow.Stream.copy_states: array expected");
                    message.copy_states = [];
                    for (var i = 0; i < object.copy_states.length; ++i) {
                        if (typeof object.copy_states[i] !== "object")
                            throw TypeError(".vtctldata.Workflow.Stream.copy_states: object expected");
                        message.copy_states[i] = $root.vtctldata.Workflow.Stream.CopyState.fromObject(object.copy_states[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Stream message. Also converts values to other types if specified.
             * @function toObject
             * @memberof vtctldata.Workflow.Stream
             * @static
             * @param {vtctldata.Workflow.Stream} message Stream
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Stream.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.copy_states = [];
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.id = options.longs === String ? "0" : 0;
                    object.shard = "";
                    object.tablet = null;
                    object.binlog_source = null;
                    object.position = "";
                    object.stop_position = "";
                    object.state = "";
                    object.db_name = "";
                    object.transaction_timestamp = null;
                    object.time_updated = null;
                    object.message = "";
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    if (typeof message.id === "number")
                        object.id = options.longs === String ? String(message.id) : message.id;
                    else
                        object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
                if (message.shard != null && message.hasOwnProperty("shard"))
                    object.shard = message.shard;
                if (message.tablet != null && message.hasOwnProperty("tablet"))
                    object.tablet = $root.topodata.TabletAlias.toObject(message.tablet, options);
                if (message.binlog_source != null && message.hasOwnProperty("binlog_source"))
                    object.binlog_source = $root.binlogdata.BinlogSource.toObject(message.binlog_source, options);
                if (message.position != null && message.hasOwnProperty("position"))
                    object.position = message.position;
                if (message.stop_position != null && message.hasOwnProperty("stop_position"))
                    object.stop_position = message.stop_position;
                if (message.state != null && message.hasOwnProperty("state"))
                    object.state = message.state;
                if (message.db_name != null && message.hasOwnProperty("db_name"))
                    object.db_name = message.db_name;
                if (message.transaction_timestamp != null && message.hasOwnProperty("transaction_timestamp"))
                    object.transaction_timestamp = $root.vttime.Time.toObject(message.transaction_timestamp, options);
                if (message.time_updated != null && message.hasOwnProperty("time_updated"))
                    object.time_updated = $root.vttime.Time.toObject(message.time_updated, options);
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = message.message;
                if (message.copy_states && message.copy_states.length) {
                    object.copy_states = [];
                    for (var j = 0; j < message.copy_states.length; ++j)
                        object.copy_states[j] = $root.vtctldata.Workflow.Stream.CopyState.toObject(message.copy_states[j], options);
                }
                return object;
            };

            /**
             * Converts this Stream to JSON.
             * @function toJSON
             * @memberof vtctldata.Workflow.Stream
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Stream.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            Stream.CopyState = (function() {

                /**
                 * Properties of a CopyState.
                 * @memberof vtctldata.Workflow.Stream
                 * @interface ICopyState
                 * @property {string|null} [table] CopyState table
                 * @property {string|null} [last_pk] CopyState last_pk
                 */

                /**
                 * Constructs a new CopyState.
                 * @memberof vtctldata.Workflow.Stream
                 * @classdesc Represents a CopyState.
                 * @implements ICopyState
                 * @constructor
                 * @param {vtctldata.Workflow.Stream.ICopyState=} [properties] Properties to set
                 */
                function CopyState(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CopyState table.
                 * @member {string} table
                 * @memberof vtctldata.Workflow.Stream.CopyState
                 * @instance
                 */
                CopyState.prototype.table = "";

                /**
                 * CopyState last_pk.
                 * @member {string} last_pk
                 * @memberof vtctldata.Workflow.Stream.CopyState
                 * @instance
                 */
                CopyState.prototype.last_pk = "";

                /**
                 * Creates a new CopyState instance using the specified properties.
                 * @function create
                 * @memberof vtctldata.Workflow.Stream.CopyState
                 * @static
                 * @param {vtctldata.Workflow.Stream.ICopyState=} [properties] Properties to set
                 * @returns {vtctldata.Workflow.Stream.CopyState} CopyState instance
                 */
                CopyState.create = function create(properties) {
                    return new CopyState(properties);
                };

                /**
                 * Encodes the specified CopyState message. Does not implicitly {@link vtctldata.Workflow.Stream.CopyState.verify|verify} messages.
                 * @function encode
                 * @memberof vtctldata.Workflow.Stream.CopyState
                 * @static
                 * @param {vtctldata.Workflow.Stream.ICopyState} message CopyState message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CopyState.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.table != null && Object.hasOwnProperty.call(message, "table"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.table);
                    if (message.last_pk != null && Object.hasOwnProperty.call(message, "last_pk"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.last_pk);
                    return writer;
                };

                /**
                 * Encodes the specified CopyState message, length delimited. Does not implicitly {@link vtctldata.Workflow.Stream.CopyState.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof vtctldata.Workflow.Stream.CopyState
                 * @static
                 * @param {vtctldata.Workflow.Stream.ICopyState} message CopyState message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CopyState.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CopyState message from the specified reader or buffer.
                 * @function decode
                 * @memberof vtctldata.Workflow.Stream.CopyState
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {vtctldata.Workflow.Stream.CopyState} CopyState
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CopyState.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.Workflow.Stream.CopyState();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.table = reader.string();
                            break;
                        case 2:
                            message.last_pk = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a CopyState message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof vtctldata.Workflow.Stream.CopyState
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {vtctldata.Workflow.Stream.CopyState} CopyState
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CopyState.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CopyState message.
                 * @function verify
                 * @memberof vtctldata.Workflow.Stream.CopyState
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CopyState.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.table != null && message.hasOwnProperty("table"))
                        if (!$util.isString(message.table))
                            return "table: string expected";
                    if (message.last_pk != null && message.hasOwnProperty("last_pk"))
                        if (!$util.isString(message.last_pk))
                            return "last_pk: string expected";
                    return null;
                };

                /**
                 * Creates a CopyState message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof vtctldata.Workflow.Stream.CopyState
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {vtctldata.Workflow.Stream.CopyState} CopyState
                 */
                CopyState.fromObject = function fromObject(object) {
                    if (object instanceof $root.vtctldata.Workflow.Stream.CopyState)
                        return object;
                    var message = new $root.vtctldata.Workflow.Stream.CopyState();
                    if (object.table != null)
                        message.table = String(object.table);
                    if (object.last_pk != null)
                        message.last_pk = String(object.last_pk);
                    return message;
                };

                /**
                 * Creates a plain object from a CopyState message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof vtctldata.Workflow.Stream.CopyState
                 * @static
                 * @param {vtctldata.Workflow.Stream.CopyState} message CopyState
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CopyState.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.table = "";
                        object.last_pk = "";
                    }
                    if (message.table != null && message.hasOwnProperty("table"))
                        object.table = message.table;
                    if (message.last_pk != null && message.hasOwnProperty("last_pk"))
                        object.last_pk = message.last_pk;
                    return object;
                };

                /**
                 * Converts this CopyState to JSON.
                 * @function toJSON
                 * @memberof vtctldata.Workflow.Stream.CopyState
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CopyState.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CopyState;
            })();

            return Stream;
        })();

        return Workflow;
    })();

    vtctldata.ChangeTabletTypeRequest = (function() {

        /**
         * Properties of a ChangeTabletTypeRequest.
         * @memberof vtctldata
         * @interface IChangeTabletTypeRequest
         * @property {topodata.ITabletAlias|null} [tablet_alias] ChangeTabletTypeRequest tablet_alias
         * @property {topodata.TabletType|null} [db_type] ChangeTabletTypeRequest db_type
         * @property {boolean|null} [dry_run] ChangeTabletTypeRequest dry_run
         */

        /**
         * Constructs a new ChangeTabletTypeRequest.
         * @memberof vtctldata
         * @classdesc Represents a ChangeTabletTypeRequest.
         * @implements IChangeTabletTypeRequest
         * @constructor
         * @param {vtctldata.IChangeTabletTypeRequest=} [properties] Properties to set
         */
        function ChangeTabletTypeRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChangeTabletTypeRequest tablet_alias.
         * @member {topodata.ITabletAlias|null|undefined} tablet_alias
         * @memberof vtctldata.ChangeTabletTypeRequest
         * @instance
         */
        ChangeTabletTypeRequest.prototype.tablet_alias = null;

        /**
         * ChangeTabletTypeRequest db_type.
         * @member {topodata.TabletType} db_type
         * @memberof vtctldata.ChangeTabletTypeRequest
         * @instance
         */
        ChangeTabletTypeRequest.prototype.db_type = 0;

        /**
         * ChangeTabletTypeRequest dry_run.
         * @member {boolean} dry_run
         * @memberof vtctldata.ChangeTabletTypeRequest
         * @instance
         */
        ChangeTabletTypeRequest.prototype.dry_run = false;

        /**
         * Creates a new ChangeTabletTypeRequest instance using the specified properties.
         * @function create
         * @memberof vtctldata.ChangeTabletTypeRequest
         * @static
         * @param {vtctldata.IChangeTabletTypeRequest=} [properties] Properties to set
         * @returns {vtctldata.ChangeTabletTypeRequest} ChangeTabletTypeRequest instance
         */
        ChangeTabletTypeRequest.create = function create(properties) {
            return new ChangeTabletTypeRequest(properties);
        };

        /**
         * Encodes the specified ChangeTabletTypeRequest message. Does not implicitly {@link vtctldata.ChangeTabletTypeRequest.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.ChangeTabletTypeRequest
         * @static
         * @param {vtctldata.IChangeTabletTypeRequest} message ChangeTabletTypeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeTabletTypeRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tablet_alias != null && Object.hasOwnProperty.call(message, "tablet_alias"))
                $root.topodata.TabletAlias.encode(message.tablet_alias, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.db_type != null && Object.hasOwnProperty.call(message, "db_type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.db_type);
            if (message.dry_run != null && Object.hasOwnProperty.call(message, "dry_run"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.dry_run);
            return writer;
        };

        /**
         * Encodes the specified ChangeTabletTypeRequest message, length delimited. Does not implicitly {@link vtctldata.ChangeTabletTypeRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.ChangeTabletTypeRequest
         * @static
         * @param {vtctldata.IChangeTabletTypeRequest} message ChangeTabletTypeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeTabletTypeRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChangeTabletTypeRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.ChangeTabletTypeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.ChangeTabletTypeRequest} ChangeTabletTypeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeTabletTypeRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.ChangeTabletTypeRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tablet_alias = $root.topodata.TabletAlias.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.db_type = reader.int32();
                    break;
                case 3:
                    message.dry_run = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChangeTabletTypeRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.ChangeTabletTypeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.ChangeTabletTypeRequest} ChangeTabletTypeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeTabletTypeRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChangeTabletTypeRequest message.
         * @function verify
         * @memberof vtctldata.ChangeTabletTypeRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChangeTabletTypeRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tablet_alias != null && message.hasOwnProperty("tablet_alias")) {
                var error = $root.topodata.TabletAlias.verify(message.tablet_alias);
                if (error)
                    return "tablet_alias." + error;
            }
            if (message.db_type != null && message.hasOwnProperty("db_type"))
                switch (message.db_type) {
                default:
                    return "db_type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                    break;
                }
            if (message.dry_run != null && message.hasOwnProperty("dry_run"))
                if (typeof message.dry_run !== "boolean")
                    return "dry_run: boolean expected";
            return null;
        };

        /**
         * Creates a ChangeTabletTypeRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.ChangeTabletTypeRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.ChangeTabletTypeRequest} ChangeTabletTypeRequest
         */
        ChangeTabletTypeRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.ChangeTabletTypeRequest)
                return object;
            var message = new $root.vtctldata.ChangeTabletTypeRequest();
            if (object.tablet_alias != null) {
                if (typeof object.tablet_alias !== "object")
                    throw TypeError(".vtctldata.ChangeTabletTypeRequest.tablet_alias: object expected");
                message.tablet_alias = $root.topodata.TabletAlias.fromObject(object.tablet_alias);
            }
            switch (object.db_type) {
            case "UNKNOWN":
            case 0:
                message.db_type = 0;
                break;
            case "MASTER":
            case 1:
                message.db_type = 1;
                break;
            case "REPLICA":
            case 2:
                message.db_type = 2;
                break;
            case "RDONLY":
            case 3:
                message.db_type = 3;
                break;
            case "BATCH":
            case 3:
                message.db_type = 3;
                break;
            case "SPARE":
            case 4:
                message.db_type = 4;
                break;
            case "EXPERIMENTAL":
            case 5:
                message.db_type = 5;
                break;
            case "BACKUP":
            case 6:
                message.db_type = 6;
                break;
            case "RESTORE":
            case 7:
                message.db_type = 7;
                break;
            case "DRAINED":
            case 8:
                message.db_type = 8;
                break;
            }
            if (object.dry_run != null)
                message.dry_run = Boolean(object.dry_run);
            return message;
        };

        /**
         * Creates a plain object from a ChangeTabletTypeRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.ChangeTabletTypeRequest
         * @static
         * @param {vtctldata.ChangeTabletTypeRequest} message ChangeTabletTypeRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChangeTabletTypeRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tablet_alias = null;
                object.db_type = options.enums === String ? "UNKNOWN" : 0;
                object.dry_run = false;
            }
            if (message.tablet_alias != null && message.hasOwnProperty("tablet_alias"))
                object.tablet_alias = $root.topodata.TabletAlias.toObject(message.tablet_alias, options);
            if (message.db_type != null && message.hasOwnProperty("db_type"))
                object.db_type = options.enums === String ? $root.topodata.TabletType[message.db_type] : message.db_type;
            if (message.dry_run != null && message.hasOwnProperty("dry_run"))
                object.dry_run = message.dry_run;
            return object;
        };

        /**
         * Converts this ChangeTabletTypeRequest to JSON.
         * @function toJSON
         * @memberof vtctldata.ChangeTabletTypeRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChangeTabletTypeRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChangeTabletTypeRequest;
    })();

    vtctldata.ChangeTabletTypeResponse = (function() {

        /**
         * Properties of a ChangeTabletTypeResponse.
         * @memberof vtctldata
         * @interface IChangeTabletTypeResponse
         * @property {topodata.ITablet|null} [before_tablet] ChangeTabletTypeResponse before_tablet
         * @property {topodata.ITablet|null} [after_tablet] ChangeTabletTypeResponse after_tablet
         * @property {boolean|null} [was_dry_run] ChangeTabletTypeResponse was_dry_run
         */

        /**
         * Constructs a new ChangeTabletTypeResponse.
         * @memberof vtctldata
         * @classdesc Represents a ChangeTabletTypeResponse.
         * @implements IChangeTabletTypeResponse
         * @constructor
         * @param {vtctldata.IChangeTabletTypeResponse=} [properties] Properties to set
         */
        function ChangeTabletTypeResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChangeTabletTypeResponse before_tablet.
         * @member {topodata.ITablet|null|undefined} before_tablet
         * @memberof vtctldata.ChangeTabletTypeResponse
         * @instance
         */
        ChangeTabletTypeResponse.prototype.before_tablet = null;

        /**
         * ChangeTabletTypeResponse after_tablet.
         * @member {topodata.ITablet|null|undefined} after_tablet
         * @memberof vtctldata.ChangeTabletTypeResponse
         * @instance
         */
        ChangeTabletTypeResponse.prototype.after_tablet = null;

        /**
         * ChangeTabletTypeResponse was_dry_run.
         * @member {boolean} was_dry_run
         * @memberof vtctldata.ChangeTabletTypeResponse
         * @instance
         */
        ChangeTabletTypeResponse.prototype.was_dry_run = false;

        /**
         * Creates a new ChangeTabletTypeResponse instance using the specified properties.
         * @function create
         * @memberof vtctldata.ChangeTabletTypeResponse
         * @static
         * @param {vtctldata.IChangeTabletTypeResponse=} [properties] Properties to set
         * @returns {vtctldata.ChangeTabletTypeResponse} ChangeTabletTypeResponse instance
         */
        ChangeTabletTypeResponse.create = function create(properties) {
            return new ChangeTabletTypeResponse(properties);
        };

        /**
         * Encodes the specified ChangeTabletTypeResponse message. Does not implicitly {@link vtctldata.ChangeTabletTypeResponse.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.ChangeTabletTypeResponse
         * @static
         * @param {vtctldata.IChangeTabletTypeResponse} message ChangeTabletTypeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeTabletTypeResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.before_tablet != null && Object.hasOwnProperty.call(message, "before_tablet"))
                $root.topodata.Tablet.encode(message.before_tablet, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.after_tablet != null && Object.hasOwnProperty.call(message, "after_tablet"))
                $root.topodata.Tablet.encode(message.after_tablet, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.was_dry_run != null && Object.hasOwnProperty.call(message, "was_dry_run"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.was_dry_run);
            return writer;
        };

        /**
         * Encodes the specified ChangeTabletTypeResponse message, length delimited. Does not implicitly {@link vtctldata.ChangeTabletTypeResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.ChangeTabletTypeResponse
         * @static
         * @param {vtctldata.IChangeTabletTypeResponse} message ChangeTabletTypeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeTabletTypeResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChangeTabletTypeResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.ChangeTabletTypeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.ChangeTabletTypeResponse} ChangeTabletTypeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeTabletTypeResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.ChangeTabletTypeResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.before_tablet = $root.topodata.Tablet.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.after_tablet = $root.topodata.Tablet.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.was_dry_run = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChangeTabletTypeResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.ChangeTabletTypeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.ChangeTabletTypeResponse} ChangeTabletTypeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeTabletTypeResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChangeTabletTypeResponse message.
         * @function verify
         * @memberof vtctldata.ChangeTabletTypeResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChangeTabletTypeResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.before_tablet != null && message.hasOwnProperty("before_tablet")) {
                var error = $root.topodata.Tablet.verify(message.before_tablet);
                if (error)
                    return "before_tablet." + error;
            }
            if (message.after_tablet != null && message.hasOwnProperty("after_tablet")) {
                var error = $root.topodata.Tablet.verify(message.after_tablet);
                if (error)
                    return "after_tablet." + error;
            }
            if (message.was_dry_run != null && message.hasOwnProperty("was_dry_run"))
                if (typeof message.was_dry_run !== "boolean")
                    return "was_dry_run: boolean expected";
            return null;
        };

        /**
         * Creates a ChangeTabletTypeResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.ChangeTabletTypeResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.ChangeTabletTypeResponse} ChangeTabletTypeResponse
         */
        ChangeTabletTypeResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.ChangeTabletTypeResponse)
                return object;
            var message = new $root.vtctldata.ChangeTabletTypeResponse();
            if (object.before_tablet != null) {
                if (typeof object.before_tablet !== "object")
                    throw TypeError(".vtctldata.ChangeTabletTypeResponse.before_tablet: object expected");
                message.before_tablet = $root.topodata.Tablet.fromObject(object.before_tablet);
            }
            if (object.after_tablet != null) {
                if (typeof object.after_tablet !== "object")
                    throw TypeError(".vtctldata.ChangeTabletTypeResponse.after_tablet: object expected");
                message.after_tablet = $root.topodata.Tablet.fromObject(object.after_tablet);
            }
            if (object.was_dry_run != null)
                message.was_dry_run = Boolean(object.was_dry_run);
            return message;
        };

        /**
         * Creates a plain object from a ChangeTabletTypeResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.ChangeTabletTypeResponse
         * @static
         * @param {vtctldata.ChangeTabletTypeResponse} message ChangeTabletTypeResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChangeTabletTypeResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.before_tablet = null;
                object.after_tablet = null;
                object.was_dry_run = false;
            }
            if (message.before_tablet != null && message.hasOwnProperty("before_tablet"))
                object.before_tablet = $root.topodata.Tablet.toObject(message.before_tablet, options);
            if (message.after_tablet != null && message.hasOwnProperty("after_tablet"))
                object.after_tablet = $root.topodata.Tablet.toObject(message.after_tablet, options);
            if (message.was_dry_run != null && message.hasOwnProperty("was_dry_run"))
                object.was_dry_run = message.was_dry_run;
            return object;
        };

        /**
         * Converts this ChangeTabletTypeResponse to JSON.
         * @function toJSON
         * @memberof vtctldata.ChangeTabletTypeResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChangeTabletTypeResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChangeTabletTypeResponse;
    })();

    vtctldata.CreateKeyspaceRequest = (function() {

        /**
         * Properties of a CreateKeyspaceRequest.
         * @memberof vtctldata
         * @interface ICreateKeyspaceRequest
         * @property {string|null} [name] CreateKeyspaceRequest name
         * @property {boolean|null} [force] CreateKeyspaceRequest force
         * @property {boolean|null} [allow_empty_v_schema] CreateKeyspaceRequest allow_empty_v_schema
         * @property {string|null} [sharding_column_name] CreateKeyspaceRequest sharding_column_name
         * @property {topodata.KeyspaceIdType|null} [sharding_column_type] CreateKeyspaceRequest sharding_column_type
         * @property {Array.<topodata.Keyspace.IServedFrom>|null} [served_froms] CreateKeyspaceRequest served_froms
         * @property {topodata.KeyspaceType|null} [type] CreateKeyspaceRequest type
         * @property {string|null} [base_keyspace] CreateKeyspaceRequest base_keyspace
         * @property {vttime.ITime|null} [snapshot_time] CreateKeyspaceRequest snapshot_time
         */

        /**
         * Constructs a new CreateKeyspaceRequest.
         * @memberof vtctldata
         * @classdesc Represents a CreateKeyspaceRequest.
         * @implements ICreateKeyspaceRequest
         * @constructor
         * @param {vtctldata.ICreateKeyspaceRequest=} [properties] Properties to set
         */
        function CreateKeyspaceRequest(properties) {
            this.served_froms = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateKeyspaceRequest name.
         * @member {string} name
         * @memberof vtctldata.CreateKeyspaceRequest
         * @instance
         */
        CreateKeyspaceRequest.prototype.name = "";

        /**
         * CreateKeyspaceRequest force.
         * @member {boolean} force
         * @memberof vtctldata.CreateKeyspaceRequest
         * @instance
         */
        CreateKeyspaceRequest.prototype.force = false;

        /**
         * CreateKeyspaceRequest allow_empty_v_schema.
         * @member {boolean} allow_empty_v_schema
         * @memberof vtctldata.CreateKeyspaceRequest
         * @instance
         */
        CreateKeyspaceRequest.prototype.allow_empty_v_schema = false;

        /**
         * CreateKeyspaceRequest sharding_column_name.
         * @member {string} sharding_column_name
         * @memberof vtctldata.CreateKeyspaceRequest
         * @instance
         */
        CreateKeyspaceRequest.prototype.sharding_column_name = "";

        /**
         * CreateKeyspaceRequest sharding_column_type.
         * @member {topodata.KeyspaceIdType} sharding_column_type
         * @memberof vtctldata.CreateKeyspaceRequest
         * @instance
         */
        CreateKeyspaceRequest.prototype.sharding_column_type = 0;

        /**
         * CreateKeyspaceRequest served_froms.
         * @member {Array.<topodata.Keyspace.IServedFrom>} served_froms
         * @memberof vtctldata.CreateKeyspaceRequest
         * @instance
         */
        CreateKeyspaceRequest.prototype.served_froms = $util.emptyArray;

        /**
         * CreateKeyspaceRequest type.
         * @member {topodata.KeyspaceType} type
         * @memberof vtctldata.CreateKeyspaceRequest
         * @instance
         */
        CreateKeyspaceRequest.prototype.type = 0;

        /**
         * CreateKeyspaceRequest base_keyspace.
         * @member {string} base_keyspace
         * @memberof vtctldata.CreateKeyspaceRequest
         * @instance
         */
        CreateKeyspaceRequest.prototype.base_keyspace = "";

        /**
         * CreateKeyspaceRequest snapshot_time.
         * @member {vttime.ITime|null|undefined} snapshot_time
         * @memberof vtctldata.CreateKeyspaceRequest
         * @instance
         */
        CreateKeyspaceRequest.prototype.snapshot_time = null;

        /**
         * Creates a new CreateKeyspaceRequest instance using the specified properties.
         * @function create
         * @memberof vtctldata.CreateKeyspaceRequest
         * @static
         * @param {vtctldata.ICreateKeyspaceRequest=} [properties] Properties to set
         * @returns {vtctldata.CreateKeyspaceRequest} CreateKeyspaceRequest instance
         */
        CreateKeyspaceRequest.create = function create(properties) {
            return new CreateKeyspaceRequest(properties);
        };

        /**
         * Encodes the specified CreateKeyspaceRequest message. Does not implicitly {@link vtctldata.CreateKeyspaceRequest.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.CreateKeyspaceRequest
         * @static
         * @param {vtctldata.ICreateKeyspaceRequest} message CreateKeyspaceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateKeyspaceRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.force != null && Object.hasOwnProperty.call(message, "force"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.force);
            if (message.allow_empty_v_schema != null && Object.hasOwnProperty.call(message, "allow_empty_v_schema"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.allow_empty_v_schema);
            if (message.sharding_column_name != null && Object.hasOwnProperty.call(message, "sharding_column_name"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.sharding_column_name);
            if (message.sharding_column_type != null && Object.hasOwnProperty.call(message, "sharding_column_type"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.sharding_column_type);
            if (message.served_froms != null && message.served_froms.length)
                for (var i = 0; i < message.served_froms.length; ++i)
                    $root.topodata.Keyspace.ServedFrom.encode(message.served_froms[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.type);
            if (message.base_keyspace != null && Object.hasOwnProperty.call(message, "base_keyspace"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.base_keyspace);
            if (message.snapshot_time != null && Object.hasOwnProperty.call(message, "snapshot_time"))
                $root.vttime.Time.encode(message.snapshot_time, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CreateKeyspaceRequest message, length delimited. Does not implicitly {@link vtctldata.CreateKeyspaceRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.CreateKeyspaceRequest
         * @static
         * @param {vtctldata.ICreateKeyspaceRequest} message CreateKeyspaceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateKeyspaceRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateKeyspaceRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.CreateKeyspaceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.CreateKeyspaceRequest} CreateKeyspaceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateKeyspaceRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.CreateKeyspaceRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.force = reader.bool();
                    break;
                case 3:
                    message.allow_empty_v_schema = reader.bool();
                    break;
                case 4:
                    message.sharding_column_name = reader.string();
                    break;
                case 5:
                    message.sharding_column_type = reader.int32();
                    break;
                case 6:
                    if (!(message.served_froms && message.served_froms.length))
                        message.served_froms = [];
                    message.served_froms.push($root.topodata.Keyspace.ServedFrom.decode(reader, reader.uint32()));
                    break;
                case 7:
                    message.type = reader.int32();
                    break;
                case 8:
                    message.base_keyspace = reader.string();
                    break;
                case 9:
                    message.snapshot_time = $root.vttime.Time.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateKeyspaceRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.CreateKeyspaceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.CreateKeyspaceRequest} CreateKeyspaceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateKeyspaceRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateKeyspaceRequest message.
         * @function verify
         * @memberof vtctldata.CreateKeyspaceRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateKeyspaceRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.force != null && message.hasOwnProperty("force"))
                if (typeof message.force !== "boolean")
                    return "force: boolean expected";
            if (message.allow_empty_v_schema != null && message.hasOwnProperty("allow_empty_v_schema"))
                if (typeof message.allow_empty_v_schema !== "boolean")
                    return "allow_empty_v_schema: boolean expected";
            if (message.sharding_column_name != null && message.hasOwnProperty("sharding_column_name"))
                if (!$util.isString(message.sharding_column_name))
                    return "sharding_column_name: string expected";
            if (message.sharding_column_type != null && message.hasOwnProperty("sharding_column_type"))
                switch (message.sharding_column_type) {
                default:
                    return "sharding_column_type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.served_froms != null && message.hasOwnProperty("served_froms")) {
                if (!Array.isArray(message.served_froms))
                    return "served_froms: array expected";
                for (var i = 0; i < message.served_froms.length; ++i) {
                    var error = $root.topodata.Keyspace.ServedFrom.verify(message.served_froms[i]);
                    if (error)
                        return "served_froms." + error;
                }
            }
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.base_keyspace != null && message.hasOwnProperty("base_keyspace"))
                if (!$util.isString(message.base_keyspace))
                    return "base_keyspace: string expected";
            if (message.snapshot_time != null && message.hasOwnProperty("snapshot_time")) {
                var error = $root.vttime.Time.verify(message.snapshot_time);
                if (error)
                    return "snapshot_time." + error;
            }
            return null;
        };

        /**
         * Creates a CreateKeyspaceRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.CreateKeyspaceRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.CreateKeyspaceRequest} CreateKeyspaceRequest
         */
        CreateKeyspaceRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.CreateKeyspaceRequest)
                return object;
            var message = new $root.vtctldata.CreateKeyspaceRequest();
            if (object.name != null)
                message.name = String(object.name);
            if (object.force != null)
                message.force = Boolean(object.force);
            if (object.allow_empty_v_schema != null)
                message.allow_empty_v_schema = Boolean(object.allow_empty_v_schema);
            if (object.sharding_column_name != null)
                message.sharding_column_name = String(object.sharding_column_name);
            switch (object.sharding_column_type) {
            case "UNSET":
            case 0:
                message.sharding_column_type = 0;
                break;
            case "UINT64":
            case 1:
                message.sharding_column_type = 1;
                break;
            case "BYTES":
            case 2:
                message.sharding_column_type = 2;
                break;
            }
            if (object.served_froms) {
                if (!Array.isArray(object.served_froms))
                    throw TypeError(".vtctldata.CreateKeyspaceRequest.served_froms: array expected");
                message.served_froms = [];
                for (var i = 0; i < object.served_froms.length; ++i) {
                    if (typeof object.served_froms[i] !== "object")
                        throw TypeError(".vtctldata.CreateKeyspaceRequest.served_froms: object expected");
                    message.served_froms[i] = $root.topodata.Keyspace.ServedFrom.fromObject(object.served_froms[i]);
                }
            }
            switch (object.type) {
            case "NORMAL":
            case 0:
                message.type = 0;
                break;
            case "SNAPSHOT":
            case 1:
                message.type = 1;
                break;
            }
            if (object.base_keyspace != null)
                message.base_keyspace = String(object.base_keyspace);
            if (object.snapshot_time != null) {
                if (typeof object.snapshot_time !== "object")
                    throw TypeError(".vtctldata.CreateKeyspaceRequest.snapshot_time: object expected");
                message.snapshot_time = $root.vttime.Time.fromObject(object.snapshot_time);
            }
            return message;
        };

        /**
         * Creates a plain object from a CreateKeyspaceRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.CreateKeyspaceRequest
         * @static
         * @param {vtctldata.CreateKeyspaceRequest} message CreateKeyspaceRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateKeyspaceRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.served_froms = [];
            if (options.defaults) {
                object.name = "";
                object.force = false;
                object.allow_empty_v_schema = false;
                object.sharding_column_name = "";
                object.sharding_column_type = options.enums === String ? "UNSET" : 0;
                object.type = options.enums === String ? "NORMAL" : 0;
                object.base_keyspace = "";
                object.snapshot_time = null;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.force != null && message.hasOwnProperty("force"))
                object.force = message.force;
            if (message.allow_empty_v_schema != null && message.hasOwnProperty("allow_empty_v_schema"))
                object.allow_empty_v_schema = message.allow_empty_v_schema;
            if (message.sharding_column_name != null && message.hasOwnProperty("sharding_column_name"))
                object.sharding_column_name = message.sharding_column_name;
            if (message.sharding_column_type != null && message.hasOwnProperty("sharding_column_type"))
                object.sharding_column_type = options.enums === String ? $root.topodata.KeyspaceIdType[message.sharding_column_type] : message.sharding_column_type;
            if (message.served_froms && message.served_froms.length) {
                object.served_froms = [];
                for (var j = 0; j < message.served_froms.length; ++j)
                    object.served_froms[j] = $root.topodata.Keyspace.ServedFrom.toObject(message.served_froms[j], options);
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.topodata.KeyspaceType[message.type] : message.type;
            if (message.base_keyspace != null && message.hasOwnProperty("base_keyspace"))
                object.base_keyspace = message.base_keyspace;
            if (message.snapshot_time != null && message.hasOwnProperty("snapshot_time"))
                object.snapshot_time = $root.vttime.Time.toObject(message.snapshot_time, options);
            return object;
        };

        /**
         * Converts this CreateKeyspaceRequest to JSON.
         * @function toJSON
         * @memberof vtctldata.CreateKeyspaceRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateKeyspaceRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateKeyspaceRequest;
    })();

    vtctldata.CreateKeyspaceResponse = (function() {

        /**
         * Properties of a CreateKeyspaceResponse.
         * @memberof vtctldata
         * @interface ICreateKeyspaceResponse
         * @property {vtctldata.IKeyspace|null} [keyspace] CreateKeyspaceResponse keyspace
         */

        /**
         * Constructs a new CreateKeyspaceResponse.
         * @memberof vtctldata
         * @classdesc Represents a CreateKeyspaceResponse.
         * @implements ICreateKeyspaceResponse
         * @constructor
         * @param {vtctldata.ICreateKeyspaceResponse=} [properties] Properties to set
         */
        function CreateKeyspaceResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateKeyspaceResponse keyspace.
         * @member {vtctldata.IKeyspace|null|undefined} keyspace
         * @memberof vtctldata.CreateKeyspaceResponse
         * @instance
         */
        CreateKeyspaceResponse.prototype.keyspace = null;

        /**
         * Creates a new CreateKeyspaceResponse instance using the specified properties.
         * @function create
         * @memberof vtctldata.CreateKeyspaceResponse
         * @static
         * @param {vtctldata.ICreateKeyspaceResponse=} [properties] Properties to set
         * @returns {vtctldata.CreateKeyspaceResponse} CreateKeyspaceResponse instance
         */
        CreateKeyspaceResponse.create = function create(properties) {
            return new CreateKeyspaceResponse(properties);
        };

        /**
         * Encodes the specified CreateKeyspaceResponse message. Does not implicitly {@link vtctldata.CreateKeyspaceResponse.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.CreateKeyspaceResponse
         * @static
         * @param {vtctldata.ICreateKeyspaceResponse} message CreateKeyspaceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateKeyspaceResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keyspace != null && Object.hasOwnProperty.call(message, "keyspace"))
                $root.vtctldata.Keyspace.encode(message.keyspace, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CreateKeyspaceResponse message, length delimited. Does not implicitly {@link vtctldata.CreateKeyspaceResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.CreateKeyspaceResponse
         * @static
         * @param {vtctldata.ICreateKeyspaceResponse} message CreateKeyspaceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateKeyspaceResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateKeyspaceResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.CreateKeyspaceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.CreateKeyspaceResponse} CreateKeyspaceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateKeyspaceResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.CreateKeyspaceResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.keyspace = $root.vtctldata.Keyspace.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateKeyspaceResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.CreateKeyspaceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.CreateKeyspaceResponse} CreateKeyspaceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateKeyspaceResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateKeyspaceResponse message.
         * @function verify
         * @memberof vtctldata.CreateKeyspaceResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateKeyspaceResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keyspace != null && message.hasOwnProperty("keyspace")) {
                var error = $root.vtctldata.Keyspace.verify(message.keyspace);
                if (error)
                    return "keyspace." + error;
            }
            return null;
        };

        /**
         * Creates a CreateKeyspaceResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.CreateKeyspaceResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.CreateKeyspaceResponse} CreateKeyspaceResponse
         */
        CreateKeyspaceResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.CreateKeyspaceResponse)
                return object;
            var message = new $root.vtctldata.CreateKeyspaceResponse();
            if (object.keyspace != null) {
                if (typeof object.keyspace !== "object")
                    throw TypeError(".vtctldata.CreateKeyspaceResponse.keyspace: object expected");
                message.keyspace = $root.vtctldata.Keyspace.fromObject(object.keyspace);
            }
            return message;
        };

        /**
         * Creates a plain object from a CreateKeyspaceResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.CreateKeyspaceResponse
         * @static
         * @param {vtctldata.CreateKeyspaceResponse} message CreateKeyspaceResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateKeyspaceResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.keyspace = null;
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                object.keyspace = $root.vtctldata.Keyspace.toObject(message.keyspace, options);
            return object;
        };

        /**
         * Converts this CreateKeyspaceResponse to JSON.
         * @function toJSON
         * @memberof vtctldata.CreateKeyspaceResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateKeyspaceResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateKeyspaceResponse;
    })();

    vtctldata.CreateShardRequest = (function() {

        /**
         * Properties of a CreateShardRequest.
         * @memberof vtctldata
         * @interface ICreateShardRequest
         * @property {string|null} [keyspace] CreateShardRequest keyspace
         * @property {string|null} [shard_name] CreateShardRequest shard_name
         * @property {boolean|null} [force] CreateShardRequest force
         * @property {boolean|null} [include_parent] CreateShardRequest include_parent
         */

        /**
         * Constructs a new CreateShardRequest.
         * @memberof vtctldata
         * @classdesc Represents a CreateShardRequest.
         * @implements ICreateShardRequest
         * @constructor
         * @param {vtctldata.ICreateShardRequest=} [properties] Properties to set
         */
        function CreateShardRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateShardRequest keyspace.
         * @member {string} keyspace
         * @memberof vtctldata.CreateShardRequest
         * @instance
         */
        CreateShardRequest.prototype.keyspace = "";

        /**
         * CreateShardRequest shard_name.
         * @member {string} shard_name
         * @memberof vtctldata.CreateShardRequest
         * @instance
         */
        CreateShardRequest.prototype.shard_name = "";

        /**
         * CreateShardRequest force.
         * @member {boolean} force
         * @memberof vtctldata.CreateShardRequest
         * @instance
         */
        CreateShardRequest.prototype.force = false;

        /**
         * CreateShardRequest include_parent.
         * @member {boolean} include_parent
         * @memberof vtctldata.CreateShardRequest
         * @instance
         */
        CreateShardRequest.prototype.include_parent = false;

        /**
         * Creates a new CreateShardRequest instance using the specified properties.
         * @function create
         * @memberof vtctldata.CreateShardRequest
         * @static
         * @param {vtctldata.ICreateShardRequest=} [properties] Properties to set
         * @returns {vtctldata.CreateShardRequest} CreateShardRequest instance
         */
        CreateShardRequest.create = function create(properties) {
            return new CreateShardRequest(properties);
        };

        /**
         * Encodes the specified CreateShardRequest message. Does not implicitly {@link vtctldata.CreateShardRequest.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.CreateShardRequest
         * @static
         * @param {vtctldata.ICreateShardRequest} message CreateShardRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateShardRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keyspace != null && Object.hasOwnProperty.call(message, "keyspace"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.keyspace);
            if (message.shard_name != null && Object.hasOwnProperty.call(message, "shard_name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.shard_name);
            if (message.force != null && Object.hasOwnProperty.call(message, "force"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.force);
            if (message.include_parent != null && Object.hasOwnProperty.call(message, "include_parent"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.include_parent);
            return writer;
        };

        /**
         * Encodes the specified CreateShardRequest message, length delimited. Does not implicitly {@link vtctldata.CreateShardRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.CreateShardRequest
         * @static
         * @param {vtctldata.ICreateShardRequest} message CreateShardRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateShardRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateShardRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.CreateShardRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.CreateShardRequest} CreateShardRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateShardRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.CreateShardRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.keyspace = reader.string();
                    break;
                case 2:
                    message.shard_name = reader.string();
                    break;
                case 3:
                    message.force = reader.bool();
                    break;
                case 4:
                    message.include_parent = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateShardRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.CreateShardRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.CreateShardRequest} CreateShardRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateShardRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateShardRequest message.
         * @function verify
         * @memberof vtctldata.CreateShardRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateShardRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                if (!$util.isString(message.keyspace))
                    return "keyspace: string expected";
            if (message.shard_name != null && message.hasOwnProperty("shard_name"))
                if (!$util.isString(message.shard_name))
                    return "shard_name: string expected";
            if (message.force != null && message.hasOwnProperty("force"))
                if (typeof message.force !== "boolean")
                    return "force: boolean expected";
            if (message.include_parent != null && message.hasOwnProperty("include_parent"))
                if (typeof message.include_parent !== "boolean")
                    return "include_parent: boolean expected";
            return null;
        };

        /**
         * Creates a CreateShardRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.CreateShardRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.CreateShardRequest} CreateShardRequest
         */
        CreateShardRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.CreateShardRequest)
                return object;
            var message = new $root.vtctldata.CreateShardRequest();
            if (object.keyspace != null)
                message.keyspace = String(object.keyspace);
            if (object.shard_name != null)
                message.shard_name = String(object.shard_name);
            if (object.force != null)
                message.force = Boolean(object.force);
            if (object.include_parent != null)
                message.include_parent = Boolean(object.include_parent);
            return message;
        };

        /**
         * Creates a plain object from a CreateShardRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.CreateShardRequest
         * @static
         * @param {vtctldata.CreateShardRequest} message CreateShardRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateShardRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.keyspace = "";
                object.shard_name = "";
                object.force = false;
                object.include_parent = false;
            }
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                object.keyspace = message.keyspace;
            if (message.shard_name != null && message.hasOwnProperty("shard_name"))
                object.shard_name = message.shard_name;
            if (message.force != null && message.hasOwnProperty("force"))
                object.force = message.force;
            if (message.include_parent != null && message.hasOwnProperty("include_parent"))
                object.include_parent = message.include_parent;
            return object;
        };

        /**
         * Converts this CreateShardRequest to JSON.
         * @function toJSON
         * @memberof vtctldata.CreateShardRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateShardRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateShardRequest;
    })();

    vtctldata.CreateShardResponse = (function() {

        /**
         * Properties of a CreateShardResponse.
         * @memberof vtctldata
         * @interface ICreateShardResponse
         * @property {vtctldata.IKeyspace|null} [keyspace] CreateShardResponse keyspace
         * @property {vtctldata.IShard|null} [shard] CreateShardResponse shard
         * @property {boolean|null} [shard_already_exists] CreateShardResponse shard_already_exists
         */

        /**
         * Constructs a new CreateShardResponse.
         * @memberof vtctldata
         * @classdesc Represents a CreateShardResponse.
         * @implements ICreateShardResponse
         * @constructor
         * @param {vtctldata.ICreateShardResponse=} [properties] Properties to set
         */
        function CreateShardResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateShardResponse keyspace.
         * @member {vtctldata.IKeyspace|null|undefined} keyspace
         * @memberof vtctldata.CreateShardResponse
         * @instance
         */
        CreateShardResponse.prototype.keyspace = null;

        /**
         * CreateShardResponse shard.
         * @member {vtctldata.IShard|null|undefined} shard
         * @memberof vtctldata.CreateShardResponse
         * @instance
         */
        CreateShardResponse.prototype.shard = null;

        /**
         * CreateShardResponse shard_already_exists.
         * @member {boolean} shard_already_exists
         * @memberof vtctldata.CreateShardResponse
         * @instance
         */
        CreateShardResponse.prototype.shard_already_exists = false;

        /**
         * Creates a new CreateShardResponse instance using the specified properties.
         * @function create
         * @memberof vtctldata.CreateShardResponse
         * @static
         * @param {vtctldata.ICreateShardResponse=} [properties] Properties to set
         * @returns {vtctldata.CreateShardResponse} CreateShardResponse instance
         */
        CreateShardResponse.create = function create(properties) {
            return new CreateShardResponse(properties);
        };

        /**
         * Encodes the specified CreateShardResponse message. Does not implicitly {@link vtctldata.CreateShardResponse.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.CreateShardResponse
         * @static
         * @param {vtctldata.ICreateShardResponse} message CreateShardResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateShardResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keyspace != null && Object.hasOwnProperty.call(message, "keyspace"))
                $root.vtctldata.Keyspace.encode(message.keyspace, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.shard != null && Object.hasOwnProperty.call(message, "shard"))
                $root.vtctldata.Shard.encode(message.shard, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.shard_already_exists != null && Object.hasOwnProperty.call(message, "shard_already_exists"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.shard_already_exists);
            return writer;
        };

        /**
         * Encodes the specified CreateShardResponse message, length delimited. Does not implicitly {@link vtctldata.CreateShardResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.CreateShardResponse
         * @static
         * @param {vtctldata.ICreateShardResponse} message CreateShardResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateShardResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateShardResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.CreateShardResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.CreateShardResponse} CreateShardResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateShardResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.CreateShardResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.keyspace = $root.vtctldata.Keyspace.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.shard = $root.vtctldata.Shard.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.shard_already_exists = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateShardResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.CreateShardResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.CreateShardResponse} CreateShardResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateShardResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateShardResponse message.
         * @function verify
         * @memberof vtctldata.CreateShardResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateShardResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keyspace != null && message.hasOwnProperty("keyspace")) {
                var error = $root.vtctldata.Keyspace.verify(message.keyspace);
                if (error)
                    return "keyspace." + error;
            }
            if (message.shard != null && message.hasOwnProperty("shard")) {
                var error = $root.vtctldata.Shard.verify(message.shard);
                if (error)
                    return "shard." + error;
            }
            if (message.shard_already_exists != null && message.hasOwnProperty("shard_already_exists"))
                if (typeof message.shard_already_exists !== "boolean")
                    return "shard_already_exists: boolean expected";
            return null;
        };

        /**
         * Creates a CreateShardResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.CreateShardResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.CreateShardResponse} CreateShardResponse
         */
        CreateShardResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.CreateShardResponse)
                return object;
            var message = new $root.vtctldata.CreateShardResponse();
            if (object.keyspace != null) {
                if (typeof object.keyspace !== "object")
                    throw TypeError(".vtctldata.CreateShardResponse.keyspace: object expected");
                message.keyspace = $root.vtctldata.Keyspace.fromObject(object.keyspace);
            }
            if (object.shard != null) {
                if (typeof object.shard !== "object")
                    throw TypeError(".vtctldata.CreateShardResponse.shard: object expected");
                message.shard = $root.vtctldata.Shard.fromObject(object.shard);
            }
            if (object.shard_already_exists != null)
                message.shard_already_exists = Boolean(object.shard_already_exists);
            return message;
        };

        /**
         * Creates a plain object from a CreateShardResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.CreateShardResponse
         * @static
         * @param {vtctldata.CreateShardResponse} message CreateShardResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateShardResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.keyspace = null;
                object.shard = null;
                object.shard_already_exists = false;
            }
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                object.keyspace = $root.vtctldata.Keyspace.toObject(message.keyspace, options);
            if (message.shard != null && message.hasOwnProperty("shard"))
                object.shard = $root.vtctldata.Shard.toObject(message.shard, options);
            if (message.shard_already_exists != null && message.hasOwnProperty("shard_already_exists"))
                object.shard_already_exists = message.shard_already_exists;
            return object;
        };

        /**
         * Converts this CreateShardResponse to JSON.
         * @function toJSON
         * @memberof vtctldata.CreateShardResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateShardResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateShardResponse;
    })();

    vtctldata.DeleteKeyspaceRequest = (function() {

        /**
         * Properties of a DeleteKeyspaceRequest.
         * @memberof vtctldata
         * @interface IDeleteKeyspaceRequest
         * @property {string|null} [keyspace] DeleteKeyspaceRequest keyspace
         * @property {boolean|null} [recursive] DeleteKeyspaceRequest recursive
         */

        /**
         * Constructs a new DeleteKeyspaceRequest.
         * @memberof vtctldata
         * @classdesc Represents a DeleteKeyspaceRequest.
         * @implements IDeleteKeyspaceRequest
         * @constructor
         * @param {vtctldata.IDeleteKeyspaceRequest=} [properties] Properties to set
         */
        function DeleteKeyspaceRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteKeyspaceRequest keyspace.
         * @member {string} keyspace
         * @memberof vtctldata.DeleteKeyspaceRequest
         * @instance
         */
        DeleteKeyspaceRequest.prototype.keyspace = "";

        /**
         * DeleteKeyspaceRequest recursive.
         * @member {boolean} recursive
         * @memberof vtctldata.DeleteKeyspaceRequest
         * @instance
         */
        DeleteKeyspaceRequest.prototype.recursive = false;

        /**
         * Creates a new DeleteKeyspaceRequest instance using the specified properties.
         * @function create
         * @memberof vtctldata.DeleteKeyspaceRequest
         * @static
         * @param {vtctldata.IDeleteKeyspaceRequest=} [properties] Properties to set
         * @returns {vtctldata.DeleteKeyspaceRequest} DeleteKeyspaceRequest instance
         */
        DeleteKeyspaceRequest.create = function create(properties) {
            return new DeleteKeyspaceRequest(properties);
        };

        /**
         * Encodes the specified DeleteKeyspaceRequest message. Does not implicitly {@link vtctldata.DeleteKeyspaceRequest.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.DeleteKeyspaceRequest
         * @static
         * @param {vtctldata.IDeleteKeyspaceRequest} message DeleteKeyspaceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteKeyspaceRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keyspace != null && Object.hasOwnProperty.call(message, "keyspace"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.keyspace);
            if (message.recursive != null && Object.hasOwnProperty.call(message, "recursive"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.recursive);
            return writer;
        };

        /**
         * Encodes the specified DeleteKeyspaceRequest message, length delimited. Does not implicitly {@link vtctldata.DeleteKeyspaceRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.DeleteKeyspaceRequest
         * @static
         * @param {vtctldata.IDeleteKeyspaceRequest} message DeleteKeyspaceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteKeyspaceRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteKeyspaceRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.DeleteKeyspaceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.DeleteKeyspaceRequest} DeleteKeyspaceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteKeyspaceRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.DeleteKeyspaceRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.keyspace = reader.string();
                    break;
                case 2:
                    message.recursive = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteKeyspaceRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.DeleteKeyspaceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.DeleteKeyspaceRequest} DeleteKeyspaceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteKeyspaceRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteKeyspaceRequest message.
         * @function verify
         * @memberof vtctldata.DeleteKeyspaceRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteKeyspaceRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                if (!$util.isString(message.keyspace))
                    return "keyspace: string expected";
            if (message.recursive != null && message.hasOwnProperty("recursive"))
                if (typeof message.recursive !== "boolean")
                    return "recursive: boolean expected";
            return null;
        };

        /**
         * Creates a DeleteKeyspaceRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.DeleteKeyspaceRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.DeleteKeyspaceRequest} DeleteKeyspaceRequest
         */
        DeleteKeyspaceRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.DeleteKeyspaceRequest)
                return object;
            var message = new $root.vtctldata.DeleteKeyspaceRequest();
            if (object.keyspace != null)
                message.keyspace = String(object.keyspace);
            if (object.recursive != null)
                message.recursive = Boolean(object.recursive);
            return message;
        };

        /**
         * Creates a plain object from a DeleteKeyspaceRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.DeleteKeyspaceRequest
         * @static
         * @param {vtctldata.DeleteKeyspaceRequest} message DeleteKeyspaceRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteKeyspaceRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.keyspace = "";
                object.recursive = false;
            }
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                object.keyspace = message.keyspace;
            if (message.recursive != null && message.hasOwnProperty("recursive"))
                object.recursive = message.recursive;
            return object;
        };

        /**
         * Converts this DeleteKeyspaceRequest to JSON.
         * @function toJSON
         * @memberof vtctldata.DeleteKeyspaceRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteKeyspaceRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteKeyspaceRequest;
    })();

    vtctldata.DeleteKeyspaceResponse = (function() {

        /**
         * Properties of a DeleteKeyspaceResponse.
         * @memberof vtctldata
         * @interface IDeleteKeyspaceResponse
         */

        /**
         * Constructs a new DeleteKeyspaceResponse.
         * @memberof vtctldata
         * @classdesc Represents a DeleteKeyspaceResponse.
         * @implements IDeleteKeyspaceResponse
         * @constructor
         * @param {vtctldata.IDeleteKeyspaceResponse=} [properties] Properties to set
         */
        function DeleteKeyspaceResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new DeleteKeyspaceResponse instance using the specified properties.
         * @function create
         * @memberof vtctldata.DeleteKeyspaceResponse
         * @static
         * @param {vtctldata.IDeleteKeyspaceResponse=} [properties] Properties to set
         * @returns {vtctldata.DeleteKeyspaceResponse} DeleteKeyspaceResponse instance
         */
        DeleteKeyspaceResponse.create = function create(properties) {
            return new DeleteKeyspaceResponse(properties);
        };

        /**
         * Encodes the specified DeleteKeyspaceResponse message. Does not implicitly {@link vtctldata.DeleteKeyspaceResponse.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.DeleteKeyspaceResponse
         * @static
         * @param {vtctldata.IDeleteKeyspaceResponse} message DeleteKeyspaceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteKeyspaceResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified DeleteKeyspaceResponse message, length delimited. Does not implicitly {@link vtctldata.DeleteKeyspaceResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.DeleteKeyspaceResponse
         * @static
         * @param {vtctldata.IDeleteKeyspaceResponse} message DeleteKeyspaceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteKeyspaceResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteKeyspaceResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.DeleteKeyspaceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.DeleteKeyspaceResponse} DeleteKeyspaceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteKeyspaceResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.DeleteKeyspaceResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteKeyspaceResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.DeleteKeyspaceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.DeleteKeyspaceResponse} DeleteKeyspaceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteKeyspaceResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteKeyspaceResponse message.
         * @function verify
         * @memberof vtctldata.DeleteKeyspaceResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteKeyspaceResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a DeleteKeyspaceResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.DeleteKeyspaceResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.DeleteKeyspaceResponse} DeleteKeyspaceResponse
         */
        DeleteKeyspaceResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.DeleteKeyspaceResponse)
                return object;
            return new $root.vtctldata.DeleteKeyspaceResponse();
        };

        /**
         * Creates a plain object from a DeleteKeyspaceResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.DeleteKeyspaceResponse
         * @static
         * @param {vtctldata.DeleteKeyspaceResponse} message DeleteKeyspaceResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteKeyspaceResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this DeleteKeyspaceResponse to JSON.
         * @function toJSON
         * @memberof vtctldata.DeleteKeyspaceResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteKeyspaceResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteKeyspaceResponse;
    })();

    vtctldata.DeleteShardsRequest = (function() {

        /**
         * Properties of a DeleteShardsRequest.
         * @memberof vtctldata
         * @interface IDeleteShardsRequest
         * @property {Array.<vtctldata.IShard>|null} [shards] DeleteShardsRequest shards
         * @property {boolean|null} [recursive] DeleteShardsRequest recursive
         * @property {boolean|null} [even_if_serving] DeleteShardsRequest even_if_serving
         */

        /**
         * Constructs a new DeleteShardsRequest.
         * @memberof vtctldata
         * @classdesc Represents a DeleteShardsRequest.
         * @implements IDeleteShardsRequest
         * @constructor
         * @param {vtctldata.IDeleteShardsRequest=} [properties] Properties to set
         */
        function DeleteShardsRequest(properties) {
            this.shards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteShardsRequest shards.
         * @member {Array.<vtctldata.IShard>} shards
         * @memberof vtctldata.DeleteShardsRequest
         * @instance
         */
        DeleteShardsRequest.prototype.shards = $util.emptyArray;

        /**
         * DeleteShardsRequest recursive.
         * @member {boolean} recursive
         * @memberof vtctldata.DeleteShardsRequest
         * @instance
         */
        DeleteShardsRequest.prototype.recursive = false;

        /**
         * DeleteShardsRequest even_if_serving.
         * @member {boolean} even_if_serving
         * @memberof vtctldata.DeleteShardsRequest
         * @instance
         */
        DeleteShardsRequest.prototype.even_if_serving = false;

        /**
         * Creates a new DeleteShardsRequest instance using the specified properties.
         * @function create
         * @memberof vtctldata.DeleteShardsRequest
         * @static
         * @param {vtctldata.IDeleteShardsRequest=} [properties] Properties to set
         * @returns {vtctldata.DeleteShardsRequest} DeleteShardsRequest instance
         */
        DeleteShardsRequest.create = function create(properties) {
            return new DeleteShardsRequest(properties);
        };

        /**
         * Encodes the specified DeleteShardsRequest message. Does not implicitly {@link vtctldata.DeleteShardsRequest.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.DeleteShardsRequest
         * @static
         * @param {vtctldata.IDeleteShardsRequest} message DeleteShardsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteShardsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.shards != null && message.shards.length)
                for (var i = 0; i < message.shards.length; ++i)
                    $root.vtctldata.Shard.encode(message.shards[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.recursive != null && Object.hasOwnProperty.call(message, "recursive"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.recursive);
            if (message.even_if_serving != null && Object.hasOwnProperty.call(message, "even_if_serving"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.even_if_serving);
            return writer;
        };

        /**
         * Encodes the specified DeleteShardsRequest message, length delimited. Does not implicitly {@link vtctldata.DeleteShardsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.DeleteShardsRequest
         * @static
         * @param {vtctldata.IDeleteShardsRequest} message DeleteShardsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteShardsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteShardsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.DeleteShardsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.DeleteShardsRequest} DeleteShardsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteShardsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.DeleteShardsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.shards && message.shards.length))
                        message.shards = [];
                    message.shards.push($root.vtctldata.Shard.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.recursive = reader.bool();
                    break;
                case 4:
                    message.even_if_serving = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteShardsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.DeleteShardsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.DeleteShardsRequest} DeleteShardsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteShardsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteShardsRequest message.
         * @function verify
         * @memberof vtctldata.DeleteShardsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteShardsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.shards != null && message.hasOwnProperty("shards")) {
                if (!Array.isArray(message.shards))
                    return "shards: array expected";
                for (var i = 0; i < message.shards.length; ++i) {
                    var error = $root.vtctldata.Shard.verify(message.shards[i]);
                    if (error)
                        return "shards." + error;
                }
            }
            if (message.recursive != null && message.hasOwnProperty("recursive"))
                if (typeof message.recursive !== "boolean")
                    return "recursive: boolean expected";
            if (message.even_if_serving != null && message.hasOwnProperty("even_if_serving"))
                if (typeof message.even_if_serving !== "boolean")
                    return "even_if_serving: boolean expected";
            return null;
        };

        /**
         * Creates a DeleteShardsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.DeleteShardsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.DeleteShardsRequest} DeleteShardsRequest
         */
        DeleteShardsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.DeleteShardsRequest)
                return object;
            var message = new $root.vtctldata.DeleteShardsRequest();
            if (object.shards) {
                if (!Array.isArray(object.shards))
                    throw TypeError(".vtctldata.DeleteShardsRequest.shards: array expected");
                message.shards = [];
                for (var i = 0; i < object.shards.length; ++i) {
                    if (typeof object.shards[i] !== "object")
                        throw TypeError(".vtctldata.DeleteShardsRequest.shards: object expected");
                    message.shards[i] = $root.vtctldata.Shard.fromObject(object.shards[i]);
                }
            }
            if (object.recursive != null)
                message.recursive = Boolean(object.recursive);
            if (object.even_if_serving != null)
                message.even_if_serving = Boolean(object.even_if_serving);
            return message;
        };

        /**
         * Creates a plain object from a DeleteShardsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.DeleteShardsRequest
         * @static
         * @param {vtctldata.DeleteShardsRequest} message DeleteShardsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteShardsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.shards = [];
            if (options.defaults) {
                object.recursive = false;
                object.even_if_serving = false;
            }
            if (message.shards && message.shards.length) {
                object.shards = [];
                for (var j = 0; j < message.shards.length; ++j)
                    object.shards[j] = $root.vtctldata.Shard.toObject(message.shards[j], options);
            }
            if (message.recursive != null && message.hasOwnProperty("recursive"))
                object.recursive = message.recursive;
            if (message.even_if_serving != null && message.hasOwnProperty("even_if_serving"))
                object.even_if_serving = message.even_if_serving;
            return object;
        };

        /**
         * Converts this DeleteShardsRequest to JSON.
         * @function toJSON
         * @memberof vtctldata.DeleteShardsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteShardsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteShardsRequest;
    })();

    vtctldata.DeleteShardsResponse = (function() {

        /**
         * Properties of a DeleteShardsResponse.
         * @memberof vtctldata
         * @interface IDeleteShardsResponse
         */

        /**
         * Constructs a new DeleteShardsResponse.
         * @memberof vtctldata
         * @classdesc Represents a DeleteShardsResponse.
         * @implements IDeleteShardsResponse
         * @constructor
         * @param {vtctldata.IDeleteShardsResponse=} [properties] Properties to set
         */
        function DeleteShardsResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new DeleteShardsResponse instance using the specified properties.
         * @function create
         * @memberof vtctldata.DeleteShardsResponse
         * @static
         * @param {vtctldata.IDeleteShardsResponse=} [properties] Properties to set
         * @returns {vtctldata.DeleteShardsResponse} DeleteShardsResponse instance
         */
        DeleteShardsResponse.create = function create(properties) {
            return new DeleteShardsResponse(properties);
        };

        /**
         * Encodes the specified DeleteShardsResponse message. Does not implicitly {@link vtctldata.DeleteShardsResponse.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.DeleteShardsResponse
         * @static
         * @param {vtctldata.IDeleteShardsResponse} message DeleteShardsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteShardsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified DeleteShardsResponse message, length delimited. Does not implicitly {@link vtctldata.DeleteShardsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.DeleteShardsResponse
         * @static
         * @param {vtctldata.IDeleteShardsResponse} message DeleteShardsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteShardsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteShardsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.DeleteShardsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.DeleteShardsResponse} DeleteShardsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteShardsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.DeleteShardsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteShardsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.DeleteShardsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.DeleteShardsResponse} DeleteShardsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteShardsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteShardsResponse message.
         * @function verify
         * @memberof vtctldata.DeleteShardsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteShardsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a DeleteShardsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.DeleteShardsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.DeleteShardsResponse} DeleteShardsResponse
         */
        DeleteShardsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.DeleteShardsResponse)
                return object;
            return new $root.vtctldata.DeleteShardsResponse();
        };

        /**
         * Creates a plain object from a DeleteShardsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.DeleteShardsResponse
         * @static
         * @param {vtctldata.DeleteShardsResponse} message DeleteShardsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteShardsResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this DeleteShardsResponse to JSON.
         * @function toJSON
         * @memberof vtctldata.DeleteShardsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteShardsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteShardsResponse;
    })();

    vtctldata.DeleteTabletsRequest = (function() {

        /**
         * Properties of a DeleteTabletsRequest.
         * @memberof vtctldata
         * @interface IDeleteTabletsRequest
         * @property {Array.<topodata.ITabletAlias>|null} [tablet_aliases] DeleteTabletsRequest tablet_aliases
         * @property {boolean|null} [allow_primary] DeleteTabletsRequest allow_primary
         */

        /**
         * Constructs a new DeleteTabletsRequest.
         * @memberof vtctldata
         * @classdesc Represents a DeleteTabletsRequest.
         * @implements IDeleteTabletsRequest
         * @constructor
         * @param {vtctldata.IDeleteTabletsRequest=} [properties] Properties to set
         */
        function DeleteTabletsRequest(properties) {
            this.tablet_aliases = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteTabletsRequest tablet_aliases.
         * @member {Array.<topodata.ITabletAlias>} tablet_aliases
         * @memberof vtctldata.DeleteTabletsRequest
         * @instance
         */
        DeleteTabletsRequest.prototype.tablet_aliases = $util.emptyArray;

        /**
         * DeleteTabletsRequest allow_primary.
         * @member {boolean} allow_primary
         * @memberof vtctldata.DeleteTabletsRequest
         * @instance
         */
        DeleteTabletsRequest.prototype.allow_primary = false;

        /**
         * Creates a new DeleteTabletsRequest instance using the specified properties.
         * @function create
         * @memberof vtctldata.DeleteTabletsRequest
         * @static
         * @param {vtctldata.IDeleteTabletsRequest=} [properties] Properties to set
         * @returns {vtctldata.DeleteTabletsRequest} DeleteTabletsRequest instance
         */
        DeleteTabletsRequest.create = function create(properties) {
            return new DeleteTabletsRequest(properties);
        };

        /**
         * Encodes the specified DeleteTabletsRequest message. Does not implicitly {@link vtctldata.DeleteTabletsRequest.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.DeleteTabletsRequest
         * @static
         * @param {vtctldata.IDeleteTabletsRequest} message DeleteTabletsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteTabletsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tablet_aliases != null && message.tablet_aliases.length)
                for (var i = 0; i < message.tablet_aliases.length; ++i)
                    $root.topodata.TabletAlias.encode(message.tablet_aliases[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.allow_primary != null && Object.hasOwnProperty.call(message, "allow_primary"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.allow_primary);
            return writer;
        };

        /**
         * Encodes the specified DeleteTabletsRequest message, length delimited. Does not implicitly {@link vtctldata.DeleteTabletsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.DeleteTabletsRequest
         * @static
         * @param {vtctldata.IDeleteTabletsRequest} message DeleteTabletsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteTabletsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteTabletsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.DeleteTabletsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.DeleteTabletsRequest} DeleteTabletsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteTabletsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.DeleteTabletsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.tablet_aliases && message.tablet_aliases.length))
                        message.tablet_aliases = [];
                    message.tablet_aliases.push($root.topodata.TabletAlias.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.allow_primary = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteTabletsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.DeleteTabletsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.DeleteTabletsRequest} DeleteTabletsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteTabletsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteTabletsRequest message.
         * @function verify
         * @memberof vtctldata.DeleteTabletsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteTabletsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tablet_aliases != null && message.hasOwnProperty("tablet_aliases")) {
                if (!Array.isArray(message.tablet_aliases))
                    return "tablet_aliases: array expected";
                for (var i = 0; i < message.tablet_aliases.length; ++i) {
                    var error = $root.topodata.TabletAlias.verify(message.tablet_aliases[i]);
                    if (error)
                        return "tablet_aliases." + error;
                }
            }
            if (message.allow_primary != null && message.hasOwnProperty("allow_primary"))
                if (typeof message.allow_primary !== "boolean")
                    return "allow_primary: boolean expected";
            return null;
        };

        /**
         * Creates a DeleteTabletsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.DeleteTabletsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.DeleteTabletsRequest} DeleteTabletsRequest
         */
        DeleteTabletsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.DeleteTabletsRequest)
                return object;
            var message = new $root.vtctldata.DeleteTabletsRequest();
            if (object.tablet_aliases) {
                if (!Array.isArray(object.tablet_aliases))
                    throw TypeError(".vtctldata.DeleteTabletsRequest.tablet_aliases: array expected");
                message.tablet_aliases = [];
                for (var i = 0; i < object.tablet_aliases.length; ++i) {
                    if (typeof object.tablet_aliases[i] !== "object")
                        throw TypeError(".vtctldata.DeleteTabletsRequest.tablet_aliases: object expected");
                    message.tablet_aliases[i] = $root.topodata.TabletAlias.fromObject(object.tablet_aliases[i]);
                }
            }
            if (object.allow_primary != null)
                message.allow_primary = Boolean(object.allow_primary);
            return message;
        };

        /**
         * Creates a plain object from a DeleteTabletsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.DeleteTabletsRequest
         * @static
         * @param {vtctldata.DeleteTabletsRequest} message DeleteTabletsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteTabletsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.tablet_aliases = [];
            if (options.defaults)
                object.allow_primary = false;
            if (message.tablet_aliases && message.tablet_aliases.length) {
                object.tablet_aliases = [];
                for (var j = 0; j < message.tablet_aliases.length; ++j)
                    object.tablet_aliases[j] = $root.topodata.TabletAlias.toObject(message.tablet_aliases[j], options);
            }
            if (message.allow_primary != null && message.hasOwnProperty("allow_primary"))
                object.allow_primary = message.allow_primary;
            return object;
        };

        /**
         * Converts this DeleteTabletsRequest to JSON.
         * @function toJSON
         * @memberof vtctldata.DeleteTabletsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteTabletsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteTabletsRequest;
    })();

    vtctldata.DeleteTabletsResponse = (function() {

        /**
         * Properties of a DeleteTabletsResponse.
         * @memberof vtctldata
         * @interface IDeleteTabletsResponse
         */

        /**
         * Constructs a new DeleteTabletsResponse.
         * @memberof vtctldata
         * @classdesc Represents a DeleteTabletsResponse.
         * @implements IDeleteTabletsResponse
         * @constructor
         * @param {vtctldata.IDeleteTabletsResponse=} [properties] Properties to set
         */
        function DeleteTabletsResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new DeleteTabletsResponse instance using the specified properties.
         * @function create
         * @memberof vtctldata.DeleteTabletsResponse
         * @static
         * @param {vtctldata.IDeleteTabletsResponse=} [properties] Properties to set
         * @returns {vtctldata.DeleteTabletsResponse} DeleteTabletsResponse instance
         */
        DeleteTabletsResponse.create = function create(properties) {
            return new DeleteTabletsResponse(properties);
        };

        /**
         * Encodes the specified DeleteTabletsResponse message. Does not implicitly {@link vtctldata.DeleteTabletsResponse.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.DeleteTabletsResponse
         * @static
         * @param {vtctldata.IDeleteTabletsResponse} message DeleteTabletsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteTabletsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified DeleteTabletsResponse message, length delimited. Does not implicitly {@link vtctldata.DeleteTabletsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.DeleteTabletsResponse
         * @static
         * @param {vtctldata.IDeleteTabletsResponse} message DeleteTabletsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteTabletsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteTabletsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.DeleteTabletsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.DeleteTabletsResponse} DeleteTabletsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteTabletsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.DeleteTabletsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteTabletsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.DeleteTabletsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.DeleteTabletsResponse} DeleteTabletsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteTabletsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteTabletsResponse message.
         * @function verify
         * @memberof vtctldata.DeleteTabletsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteTabletsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a DeleteTabletsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.DeleteTabletsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.DeleteTabletsResponse} DeleteTabletsResponse
         */
        DeleteTabletsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.DeleteTabletsResponse)
                return object;
            return new $root.vtctldata.DeleteTabletsResponse();
        };

        /**
         * Creates a plain object from a DeleteTabletsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.DeleteTabletsResponse
         * @static
         * @param {vtctldata.DeleteTabletsResponse} message DeleteTabletsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteTabletsResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this DeleteTabletsResponse to JSON.
         * @function toJSON
         * @memberof vtctldata.DeleteTabletsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteTabletsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteTabletsResponse;
    })();

    vtctldata.EmergencyReparentShardRequest = (function() {

        /**
         * Properties of an EmergencyReparentShardRequest.
         * @memberof vtctldata
         * @interface IEmergencyReparentShardRequest
         * @property {string|null} [keyspace] EmergencyReparentShardRequest keyspace
         * @property {string|null} [shard] EmergencyReparentShardRequest shard
         * @property {topodata.ITabletAlias|null} [new_primary] EmergencyReparentShardRequest new_primary
         * @property {Array.<topodata.ITabletAlias>|null} [ignore_replicas] EmergencyReparentShardRequest ignore_replicas
         * @property {vttime.IDuration|null} [wait_replicas_timeout] EmergencyReparentShardRequest wait_replicas_timeout
         */

        /**
         * Constructs a new EmergencyReparentShardRequest.
         * @memberof vtctldata
         * @classdesc Represents an EmergencyReparentShardRequest.
         * @implements IEmergencyReparentShardRequest
         * @constructor
         * @param {vtctldata.IEmergencyReparentShardRequest=} [properties] Properties to set
         */
        function EmergencyReparentShardRequest(properties) {
            this.ignore_replicas = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EmergencyReparentShardRequest keyspace.
         * @member {string} keyspace
         * @memberof vtctldata.EmergencyReparentShardRequest
         * @instance
         */
        EmergencyReparentShardRequest.prototype.keyspace = "";

        /**
         * EmergencyReparentShardRequest shard.
         * @member {string} shard
         * @memberof vtctldata.EmergencyReparentShardRequest
         * @instance
         */
        EmergencyReparentShardRequest.prototype.shard = "";

        /**
         * EmergencyReparentShardRequest new_primary.
         * @member {topodata.ITabletAlias|null|undefined} new_primary
         * @memberof vtctldata.EmergencyReparentShardRequest
         * @instance
         */
        EmergencyReparentShardRequest.prototype.new_primary = null;

        /**
         * EmergencyReparentShardRequest ignore_replicas.
         * @member {Array.<topodata.ITabletAlias>} ignore_replicas
         * @memberof vtctldata.EmergencyReparentShardRequest
         * @instance
         */
        EmergencyReparentShardRequest.prototype.ignore_replicas = $util.emptyArray;

        /**
         * EmergencyReparentShardRequest wait_replicas_timeout.
         * @member {vttime.IDuration|null|undefined} wait_replicas_timeout
         * @memberof vtctldata.EmergencyReparentShardRequest
         * @instance
         */
        EmergencyReparentShardRequest.prototype.wait_replicas_timeout = null;

        /**
         * Creates a new EmergencyReparentShardRequest instance using the specified properties.
         * @function create
         * @memberof vtctldata.EmergencyReparentShardRequest
         * @static
         * @param {vtctldata.IEmergencyReparentShardRequest=} [properties] Properties to set
         * @returns {vtctldata.EmergencyReparentShardRequest} EmergencyReparentShardRequest instance
         */
        EmergencyReparentShardRequest.create = function create(properties) {
            return new EmergencyReparentShardRequest(properties);
        };

        /**
         * Encodes the specified EmergencyReparentShardRequest message. Does not implicitly {@link vtctldata.EmergencyReparentShardRequest.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.EmergencyReparentShardRequest
         * @static
         * @param {vtctldata.IEmergencyReparentShardRequest} message EmergencyReparentShardRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EmergencyReparentShardRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keyspace != null && Object.hasOwnProperty.call(message, "keyspace"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.keyspace);
            if (message.shard != null && Object.hasOwnProperty.call(message, "shard"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.shard);
            if (message.new_primary != null && Object.hasOwnProperty.call(message, "new_primary"))
                $root.topodata.TabletAlias.encode(message.new_primary, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.ignore_replicas != null && message.ignore_replicas.length)
                for (var i = 0; i < message.ignore_replicas.length; ++i)
                    $root.topodata.TabletAlias.encode(message.ignore_replicas[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.wait_replicas_timeout != null && Object.hasOwnProperty.call(message, "wait_replicas_timeout"))
                $root.vttime.Duration.encode(message.wait_replicas_timeout, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified EmergencyReparentShardRequest message, length delimited. Does not implicitly {@link vtctldata.EmergencyReparentShardRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.EmergencyReparentShardRequest
         * @static
         * @param {vtctldata.IEmergencyReparentShardRequest} message EmergencyReparentShardRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EmergencyReparentShardRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EmergencyReparentShardRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.EmergencyReparentShardRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.EmergencyReparentShardRequest} EmergencyReparentShardRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EmergencyReparentShardRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.EmergencyReparentShardRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.keyspace = reader.string();
                    break;
                case 2:
                    message.shard = reader.string();
                    break;
                case 3:
                    message.new_primary = $root.topodata.TabletAlias.decode(reader, reader.uint32());
                    break;
                case 4:
                    if (!(message.ignore_replicas && message.ignore_replicas.length))
                        message.ignore_replicas = [];
                    message.ignore_replicas.push($root.topodata.TabletAlias.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.wait_replicas_timeout = $root.vttime.Duration.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EmergencyReparentShardRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.EmergencyReparentShardRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.EmergencyReparentShardRequest} EmergencyReparentShardRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EmergencyReparentShardRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EmergencyReparentShardRequest message.
         * @function verify
         * @memberof vtctldata.EmergencyReparentShardRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EmergencyReparentShardRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                if (!$util.isString(message.keyspace))
                    return "keyspace: string expected";
            if (message.shard != null && message.hasOwnProperty("shard"))
                if (!$util.isString(message.shard))
                    return "shard: string expected";
            if (message.new_primary != null && message.hasOwnProperty("new_primary")) {
                var error = $root.topodata.TabletAlias.verify(message.new_primary);
                if (error)
                    return "new_primary." + error;
            }
            if (message.ignore_replicas != null && message.hasOwnProperty("ignore_replicas")) {
                if (!Array.isArray(message.ignore_replicas))
                    return "ignore_replicas: array expected";
                for (var i = 0; i < message.ignore_replicas.length; ++i) {
                    var error = $root.topodata.TabletAlias.verify(message.ignore_replicas[i]);
                    if (error)
                        return "ignore_replicas." + error;
                }
            }
            if (message.wait_replicas_timeout != null && message.hasOwnProperty("wait_replicas_timeout")) {
                var error = $root.vttime.Duration.verify(message.wait_replicas_timeout);
                if (error)
                    return "wait_replicas_timeout." + error;
            }
            return null;
        };

        /**
         * Creates an EmergencyReparentShardRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.EmergencyReparentShardRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.EmergencyReparentShardRequest} EmergencyReparentShardRequest
         */
        EmergencyReparentShardRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.EmergencyReparentShardRequest)
                return object;
            var message = new $root.vtctldata.EmergencyReparentShardRequest();
            if (object.keyspace != null)
                message.keyspace = String(object.keyspace);
            if (object.shard != null)
                message.shard = String(object.shard);
            if (object.new_primary != null) {
                if (typeof object.new_primary !== "object")
                    throw TypeError(".vtctldata.EmergencyReparentShardRequest.new_primary: object expected");
                message.new_primary = $root.topodata.TabletAlias.fromObject(object.new_primary);
            }
            if (object.ignore_replicas) {
                if (!Array.isArray(object.ignore_replicas))
                    throw TypeError(".vtctldata.EmergencyReparentShardRequest.ignore_replicas: array expected");
                message.ignore_replicas = [];
                for (var i = 0; i < object.ignore_replicas.length; ++i) {
                    if (typeof object.ignore_replicas[i] !== "object")
                        throw TypeError(".vtctldata.EmergencyReparentShardRequest.ignore_replicas: object expected");
                    message.ignore_replicas[i] = $root.topodata.TabletAlias.fromObject(object.ignore_replicas[i]);
                }
            }
            if (object.wait_replicas_timeout != null) {
                if (typeof object.wait_replicas_timeout !== "object")
                    throw TypeError(".vtctldata.EmergencyReparentShardRequest.wait_replicas_timeout: object expected");
                message.wait_replicas_timeout = $root.vttime.Duration.fromObject(object.wait_replicas_timeout);
            }
            return message;
        };

        /**
         * Creates a plain object from an EmergencyReparentShardRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.EmergencyReparentShardRequest
         * @static
         * @param {vtctldata.EmergencyReparentShardRequest} message EmergencyReparentShardRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EmergencyReparentShardRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.ignore_replicas = [];
            if (options.defaults) {
                object.keyspace = "";
                object.shard = "";
                object.new_primary = null;
                object.wait_replicas_timeout = null;
            }
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                object.keyspace = message.keyspace;
            if (message.shard != null && message.hasOwnProperty("shard"))
                object.shard = message.shard;
            if (message.new_primary != null && message.hasOwnProperty("new_primary"))
                object.new_primary = $root.topodata.TabletAlias.toObject(message.new_primary, options);
            if (message.ignore_replicas && message.ignore_replicas.length) {
                object.ignore_replicas = [];
                for (var j = 0; j < message.ignore_replicas.length; ++j)
                    object.ignore_replicas[j] = $root.topodata.TabletAlias.toObject(message.ignore_replicas[j], options);
            }
            if (message.wait_replicas_timeout != null && message.hasOwnProperty("wait_replicas_timeout"))
                object.wait_replicas_timeout = $root.vttime.Duration.toObject(message.wait_replicas_timeout, options);
            return object;
        };

        /**
         * Converts this EmergencyReparentShardRequest to JSON.
         * @function toJSON
         * @memberof vtctldata.EmergencyReparentShardRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EmergencyReparentShardRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EmergencyReparentShardRequest;
    })();

    vtctldata.EmergencyReparentShardResponse = (function() {

        /**
         * Properties of an EmergencyReparentShardResponse.
         * @memberof vtctldata
         * @interface IEmergencyReparentShardResponse
         * @property {string|null} [keyspace] EmergencyReparentShardResponse keyspace
         * @property {string|null} [shard] EmergencyReparentShardResponse shard
         * @property {topodata.ITabletAlias|null} [promoted_primary] EmergencyReparentShardResponse promoted_primary
         * @property {Array.<logutil.IEvent>|null} [events] EmergencyReparentShardResponse events
         */

        /**
         * Constructs a new EmergencyReparentShardResponse.
         * @memberof vtctldata
         * @classdesc Represents an EmergencyReparentShardResponse.
         * @implements IEmergencyReparentShardResponse
         * @constructor
         * @param {vtctldata.IEmergencyReparentShardResponse=} [properties] Properties to set
         */
        function EmergencyReparentShardResponse(properties) {
            this.events = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EmergencyReparentShardResponse keyspace.
         * @member {string} keyspace
         * @memberof vtctldata.EmergencyReparentShardResponse
         * @instance
         */
        EmergencyReparentShardResponse.prototype.keyspace = "";

        /**
         * EmergencyReparentShardResponse shard.
         * @member {string} shard
         * @memberof vtctldata.EmergencyReparentShardResponse
         * @instance
         */
        EmergencyReparentShardResponse.prototype.shard = "";

        /**
         * EmergencyReparentShardResponse promoted_primary.
         * @member {topodata.ITabletAlias|null|undefined} promoted_primary
         * @memberof vtctldata.EmergencyReparentShardResponse
         * @instance
         */
        EmergencyReparentShardResponse.prototype.promoted_primary = null;

        /**
         * EmergencyReparentShardResponse events.
         * @member {Array.<logutil.IEvent>} events
         * @memberof vtctldata.EmergencyReparentShardResponse
         * @instance
         */
        EmergencyReparentShardResponse.prototype.events = $util.emptyArray;

        /**
         * Creates a new EmergencyReparentShardResponse instance using the specified properties.
         * @function create
         * @memberof vtctldata.EmergencyReparentShardResponse
         * @static
         * @param {vtctldata.IEmergencyReparentShardResponse=} [properties] Properties to set
         * @returns {vtctldata.EmergencyReparentShardResponse} EmergencyReparentShardResponse instance
         */
        EmergencyReparentShardResponse.create = function create(properties) {
            return new EmergencyReparentShardResponse(properties);
        };

        /**
         * Encodes the specified EmergencyReparentShardResponse message. Does not implicitly {@link vtctldata.EmergencyReparentShardResponse.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.EmergencyReparentShardResponse
         * @static
         * @param {vtctldata.IEmergencyReparentShardResponse} message EmergencyReparentShardResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EmergencyReparentShardResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keyspace != null && Object.hasOwnProperty.call(message, "keyspace"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.keyspace);
            if (message.shard != null && Object.hasOwnProperty.call(message, "shard"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.shard);
            if (message.promoted_primary != null && Object.hasOwnProperty.call(message, "promoted_primary"))
                $root.topodata.TabletAlias.encode(message.promoted_primary, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.events != null && message.events.length)
                for (var i = 0; i < message.events.length; ++i)
                    $root.logutil.Event.encode(message.events[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified EmergencyReparentShardResponse message, length delimited. Does not implicitly {@link vtctldata.EmergencyReparentShardResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.EmergencyReparentShardResponse
         * @static
         * @param {vtctldata.IEmergencyReparentShardResponse} message EmergencyReparentShardResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EmergencyReparentShardResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EmergencyReparentShardResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.EmergencyReparentShardResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.EmergencyReparentShardResponse} EmergencyReparentShardResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EmergencyReparentShardResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.EmergencyReparentShardResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.keyspace = reader.string();
                    break;
                case 2:
                    message.shard = reader.string();
                    break;
                case 3:
                    message.promoted_primary = $root.topodata.TabletAlias.decode(reader, reader.uint32());
                    break;
                case 4:
                    if (!(message.events && message.events.length))
                        message.events = [];
                    message.events.push($root.logutil.Event.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EmergencyReparentShardResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.EmergencyReparentShardResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.EmergencyReparentShardResponse} EmergencyReparentShardResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EmergencyReparentShardResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EmergencyReparentShardResponse message.
         * @function verify
         * @memberof vtctldata.EmergencyReparentShardResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EmergencyReparentShardResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                if (!$util.isString(message.keyspace))
                    return "keyspace: string expected";
            if (message.shard != null && message.hasOwnProperty("shard"))
                if (!$util.isString(message.shard))
                    return "shard: string expected";
            if (message.promoted_primary != null && message.hasOwnProperty("promoted_primary")) {
                var error = $root.topodata.TabletAlias.verify(message.promoted_primary);
                if (error)
                    return "promoted_primary." + error;
            }
            if (message.events != null && message.hasOwnProperty("events")) {
                if (!Array.isArray(message.events))
                    return "events: array expected";
                for (var i = 0; i < message.events.length; ++i) {
                    var error = $root.logutil.Event.verify(message.events[i]);
                    if (error)
                        return "events." + error;
                }
            }
            return null;
        };

        /**
         * Creates an EmergencyReparentShardResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.EmergencyReparentShardResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.EmergencyReparentShardResponse} EmergencyReparentShardResponse
         */
        EmergencyReparentShardResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.EmergencyReparentShardResponse)
                return object;
            var message = new $root.vtctldata.EmergencyReparentShardResponse();
            if (object.keyspace != null)
                message.keyspace = String(object.keyspace);
            if (object.shard != null)
                message.shard = String(object.shard);
            if (object.promoted_primary != null) {
                if (typeof object.promoted_primary !== "object")
                    throw TypeError(".vtctldata.EmergencyReparentShardResponse.promoted_primary: object expected");
                message.promoted_primary = $root.topodata.TabletAlias.fromObject(object.promoted_primary);
            }
            if (object.events) {
                if (!Array.isArray(object.events))
                    throw TypeError(".vtctldata.EmergencyReparentShardResponse.events: array expected");
                message.events = [];
                for (var i = 0; i < object.events.length; ++i) {
                    if (typeof object.events[i] !== "object")
                        throw TypeError(".vtctldata.EmergencyReparentShardResponse.events: object expected");
                    message.events[i] = $root.logutil.Event.fromObject(object.events[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an EmergencyReparentShardResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.EmergencyReparentShardResponse
         * @static
         * @param {vtctldata.EmergencyReparentShardResponse} message EmergencyReparentShardResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EmergencyReparentShardResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.events = [];
            if (options.defaults) {
                object.keyspace = "";
                object.shard = "";
                object.promoted_primary = null;
            }
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                object.keyspace = message.keyspace;
            if (message.shard != null && message.hasOwnProperty("shard"))
                object.shard = message.shard;
            if (message.promoted_primary != null && message.hasOwnProperty("promoted_primary"))
                object.promoted_primary = $root.topodata.TabletAlias.toObject(message.promoted_primary, options);
            if (message.events && message.events.length) {
                object.events = [];
                for (var j = 0; j < message.events.length; ++j)
                    object.events[j] = $root.logutil.Event.toObject(message.events[j], options);
            }
            return object;
        };

        /**
         * Converts this EmergencyReparentShardResponse to JSON.
         * @function toJSON
         * @memberof vtctldata.EmergencyReparentShardResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EmergencyReparentShardResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EmergencyReparentShardResponse;
    })();

    vtctldata.FindAllShardsInKeyspaceRequest = (function() {

        /**
         * Properties of a FindAllShardsInKeyspaceRequest.
         * @memberof vtctldata
         * @interface IFindAllShardsInKeyspaceRequest
         * @property {string|null} [keyspace] FindAllShardsInKeyspaceRequest keyspace
         */

        /**
         * Constructs a new FindAllShardsInKeyspaceRequest.
         * @memberof vtctldata
         * @classdesc Represents a FindAllShardsInKeyspaceRequest.
         * @implements IFindAllShardsInKeyspaceRequest
         * @constructor
         * @param {vtctldata.IFindAllShardsInKeyspaceRequest=} [properties] Properties to set
         */
        function FindAllShardsInKeyspaceRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FindAllShardsInKeyspaceRequest keyspace.
         * @member {string} keyspace
         * @memberof vtctldata.FindAllShardsInKeyspaceRequest
         * @instance
         */
        FindAllShardsInKeyspaceRequest.prototype.keyspace = "";

        /**
         * Creates a new FindAllShardsInKeyspaceRequest instance using the specified properties.
         * @function create
         * @memberof vtctldata.FindAllShardsInKeyspaceRequest
         * @static
         * @param {vtctldata.IFindAllShardsInKeyspaceRequest=} [properties] Properties to set
         * @returns {vtctldata.FindAllShardsInKeyspaceRequest} FindAllShardsInKeyspaceRequest instance
         */
        FindAllShardsInKeyspaceRequest.create = function create(properties) {
            return new FindAllShardsInKeyspaceRequest(properties);
        };

        /**
         * Encodes the specified FindAllShardsInKeyspaceRequest message. Does not implicitly {@link vtctldata.FindAllShardsInKeyspaceRequest.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.FindAllShardsInKeyspaceRequest
         * @static
         * @param {vtctldata.IFindAllShardsInKeyspaceRequest} message FindAllShardsInKeyspaceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FindAllShardsInKeyspaceRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keyspace != null && Object.hasOwnProperty.call(message, "keyspace"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.keyspace);
            return writer;
        };

        /**
         * Encodes the specified FindAllShardsInKeyspaceRequest message, length delimited. Does not implicitly {@link vtctldata.FindAllShardsInKeyspaceRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.FindAllShardsInKeyspaceRequest
         * @static
         * @param {vtctldata.IFindAllShardsInKeyspaceRequest} message FindAllShardsInKeyspaceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FindAllShardsInKeyspaceRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FindAllShardsInKeyspaceRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.FindAllShardsInKeyspaceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.FindAllShardsInKeyspaceRequest} FindAllShardsInKeyspaceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FindAllShardsInKeyspaceRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.FindAllShardsInKeyspaceRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.keyspace = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FindAllShardsInKeyspaceRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.FindAllShardsInKeyspaceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.FindAllShardsInKeyspaceRequest} FindAllShardsInKeyspaceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FindAllShardsInKeyspaceRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FindAllShardsInKeyspaceRequest message.
         * @function verify
         * @memberof vtctldata.FindAllShardsInKeyspaceRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FindAllShardsInKeyspaceRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                if (!$util.isString(message.keyspace))
                    return "keyspace: string expected";
            return null;
        };

        /**
         * Creates a FindAllShardsInKeyspaceRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.FindAllShardsInKeyspaceRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.FindAllShardsInKeyspaceRequest} FindAllShardsInKeyspaceRequest
         */
        FindAllShardsInKeyspaceRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.FindAllShardsInKeyspaceRequest)
                return object;
            var message = new $root.vtctldata.FindAllShardsInKeyspaceRequest();
            if (object.keyspace != null)
                message.keyspace = String(object.keyspace);
            return message;
        };

        /**
         * Creates a plain object from a FindAllShardsInKeyspaceRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.FindAllShardsInKeyspaceRequest
         * @static
         * @param {vtctldata.FindAllShardsInKeyspaceRequest} message FindAllShardsInKeyspaceRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FindAllShardsInKeyspaceRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.keyspace = "";
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                object.keyspace = message.keyspace;
            return object;
        };

        /**
         * Converts this FindAllShardsInKeyspaceRequest to JSON.
         * @function toJSON
         * @memberof vtctldata.FindAllShardsInKeyspaceRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FindAllShardsInKeyspaceRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FindAllShardsInKeyspaceRequest;
    })();

    vtctldata.FindAllShardsInKeyspaceResponse = (function() {

        /**
         * Properties of a FindAllShardsInKeyspaceResponse.
         * @memberof vtctldata
         * @interface IFindAllShardsInKeyspaceResponse
         * @property {Object.<string,vtctldata.IShard>|null} [shards] FindAllShardsInKeyspaceResponse shards
         */

        /**
         * Constructs a new FindAllShardsInKeyspaceResponse.
         * @memberof vtctldata
         * @classdesc Represents a FindAllShardsInKeyspaceResponse.
         * @implements IFindAllShardsInKeyspaceResponse
         * @constructor
         * @param {vtctldata.IFindAllShardsInKeyspaceResponse=} [properties] Properties to set
         */
        function FindAllShardsInKeyspaceResponse(properties) {
            this.shards = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FindAllShardsInKeyspaceResponse shards.
         * @member {Object.<string,vtctldata.IShard>} shards
         * @memberof vtctldata.FindAllShardsInKeyspaceResponse
         * @instance
         */
        FindAllShardsInKeyspaceResponse.prototype.shards = $util.emptyObject;

        /**
         * Creates a new FindAllShardsInKeyspaceResponse instance using the specified properties.
         * @function create
         * @memberof vtctldata.FindAllShardsInKeyspaceResponse
         * @static
         * @param {vtctldata.IFindAllShardsInKeyspaceResponse=} [properties] Properties to set
         * @returns {vtctldata.FindAllShardsInKeyspaceResponse} FindAllShardsInKeyspaceResponse instance
         */
        FindAllShardsInKeyspaceResponse.create = function create(properties) {
            return new FindAllShardsInKeyspaceResponse(properties);
        };

        /**
         * Encodes the specified FindAllShardsInKeyspaceResponse message. Does not implicitly {@link vtctldata.FindAllShardsInKeyspaceResponse.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.FindAllShardsInKeyspaceResponse
         * @static
         * @param {vtctldata.IFindAllShardsInKeyspaceResponse} message FindAllShardsInKeyspaceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FindAllShardsInKeyspaceResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.shards != null && Object.hasOwnProperty.call(message, "shards"))
                for (var keys = Object.keys(message.shards), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.vtctldata.Shard.encode(message.shards[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            return writer;
        };

        /**
         * Encodes the specified FindAllShardsInKeyspaceResponse message, length delimited. Does not implicitly {@link vtctldata.FindAllShardsInKeyspaceResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.FindAllShardsInKeyspaceResponse
         * @static
         * @param {vtctldata.IFindAllShardsInKeyspaceResponse} message FindAllShardsInKeyspaceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FindAllShardsInKeyspaceResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FindAllShardsInKeyspaceResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.FindAllShardsInKeyspaceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.FindAllShardsInKeyspaceResponse} FindAllShardsInKeyspaceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FindAllShardsInKeyspaceResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.FindAllShardsInKeyspaceResponse(), key, value;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (message.shards === $util.emptyObject)
                        message.shards = {};
                    var end2 = reader.uint32() + reader.pos;
                    key = "";
                    value = null;
                    while (reader.pos < end2) {
                        var tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.string();
                            break;
                        case 2:
                            value = $root.vtctldata.Shard.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.shards[key] = value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FindAllShardsInKeyspaceResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.FindAllShardsInKeyspaceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.FindAllShardsInKeyspaceResponse} FindAllShardsInKeyspaceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FindAllShardsInKeyspaceResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FindAllShardsInKeyspaceResponse message.
         * @function verify
         * @memberof vtctldata.FindAllShardsInKeyspaceResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FindAllShardsInKeyspaceResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.shards != null && message.hasOwnProperty("shards")) {
                if (!$util.isObject(message.shards))
                    return "shards: object expected";
                var key = Object.keys(message.shards);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.vtctldata.Shard.verify(message.shards[key[i]]);
                    if (error)
                        return "shards." + error;
                }
            }
            return null;
        };

        /**
         * Creates a FindAllShardsInKeyspaceResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.FindAllShardsInKeyspaceResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.FindAllShardsInKeyspaceResponse} FindAllShardsInKeyspaceResponse
         */
        FindAllShardsInKeyspaceResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.FindAllShardsInKeyspaceResponse)
                return object;
            var message = new $root.vtctldata.FindAllShardsInKeyspaceResponse();
            if (object.shards) {
                if (typeof object.shards !== "object")
                    throw TypeError(".vtctldata.FindAllShardsInKeyspaceResponse.shards: object expected");
                message.shards = {};
                for (var keys = Object.keys(object.shards), i = 0; i < keys.length; ++i) {
                    if (typeof object.shards[keys[i]] !== "object")
                        throw TypeError(".vtctldata.FindAllShardsInKeyspaceResponse.shards: object expected");
                    message.shards[keys[i]] = $root.vtctldata.Shard.fromObject(object.shards[keys[i]]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a FindAllShardsInKeyspaceResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.FindAllShardsInKeyspaceResponse
         * @static
         * @param {vtctldata.FindAllShardsInKeyspaceResponse} message FindAllShardsInKeyspaceResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FindAllShardsInKeyspaceResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults)
                object.shards = {};
            var keys2;
            if (message.shards && (keys2 = Object.keys(message.shards)).length) {
                object.shards = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.shards[keys2[j]] = $root.vtctldata.Shard.toObject(message.shards[keys2[j]], options);
            }
            return object;
        };

        /**
         * Converts this FindAllShardsInKeyspaceResponse to JSON.
         * @function toJSON
         * @memberof vtctldata.FindAllShardsInKeyspaceResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FindAllShardsInKeyspaceResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FindAllShardsInKeyspaceResponse;
    })();

    vtctldata.GetBackupsRequest = (function() {

        /**
         * Properties of a GetBackupsRequest.
         * @memberof vtctldata
         * @interface IGetBackupsRequest
         * @property {string|null} [keyspace] GetBackupsRequest keyspace
         * @property {string|null} [shard] GetBackupsRequest shard
         */

        /**
         * Constructs a new GetBackupsRequest.
         * @memberof vtctldata
         * @classdesc Represents a GetBackupsRequest.
         * @implements IGetBackupsRequest
         * @constructor
         * @param {vtctldata.IGetBackupsRequest=} [properties] Properties to set
         */
        function GetBackupsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetBackupsRequest keyspace.
         * @member {string} keyspace
         * @memberof vtctldata.GetBackupsRequest
         * @instance
         */
        GetBackupsRequest.prototype.keyspace = "";

        /**
         * GetBackupsRequest shard.
         * @member {string} shard
         * @memberof vtctldata.GetBackupsRequest
         * @instance
         */
        GetBackupsRequest.prototype.shard = "";

        /**
         * Creates a new GetBackupsRequest instance using the specified properties.
         * @function create
         * @memberof vtctldata.GetBackupsRequest
         * @static
         * @param {vtctldata.IGetBackupsRequest=} [properties] Properties to set
         * @returns {vtctldata.GetBackupsRequest} GetBackupsRequest instance
         */
        GetBackupsRequest.create = function create(properties) {
            return new GetBackupsRequest(properties);
        };

        /**
         * Encodes the specified GetBackupsRequest message. Does not implicitly {@link vtctldata.GetBackupsRequest.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.GetBackupsRequest
         * @static
         * @param {vtctldata.IGetBackupsRequest} message GetBackupsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetBackupsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keyspace != null && Object.hasOwnProperty.call(message, "keyspace"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.keyspace);
            if (message.shard != null && Object.hasOwnProperty.call(message, "shard"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.shard);
            return writer;
        };

        /**
         * Encodes the specified GetBackupsRequest message, length delimited. Does not implicitly {@link vtctldata.GetBackupsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.GetBackupsRequest
         * @static
         * @param {vtctldata.IGetBackupsRequest} message GetBackupsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetBackupsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetBackupsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.GetBackupsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.GetBackupsRequest} GetBackupsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetBackupsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.GetBackupsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.keyspace = reader.string();
                    break;
                case 2:
                    message.shard = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetBackupsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.GetBackupsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.GetBackupsRequest} GetBackupsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetBackupsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetBackupsRequest message.
         * @function verify
         * @memberof vtctldata.GetBackupsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetBackupsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                if (!$util.isString(message.keyspace))
                    return "keyspace: string expected";
            if (message.shard != null && message.hasOwnProperty("shard"))
                if (!$util.isString(message.shard))
                    return "shard: string expected";
            return null;
        };

        /**
         * Creates a GetBackupsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.GetBackupsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.GetBackupsRequest} GetBackupsRequest
         */
        GetBackupsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.GetBackupsRequest)
                return object;
            var message = new $root.vtctldata.GetBackupsRequest();
            if (object.keyspace != null)
                message.keyspace = String(object.keyspace);
            if (object.shard != null)
                message.shard = String(object.shard);
            return message;
        };

        /**
         * Creates a plain object from a GetBackupsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.GetBackupsRequest
         * @static
         * @param {vtctldata.GetBackupsRequest} message GetBackupsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetBackupsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.keyspace = "";
                object.shard = "";
            }
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                object.keyspace = message.keyspace;
            if (message.shard != null && message.hasOwnProperty("shard"))
                object.shard = message.shard;
            return object;
        };

        /**
         * Converts this GetBackupsRequest to JSON.
         * @function toJSON
         * @memberof vtctldata.GetBackupsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetBackupsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetBackupsRequest;
    })();

    vtctldata.GetBackupsResponse = (function() {

        /**
         * Properties of a GetBackupsResponse.
         * @memberof vtctldata
         * @interface IGetBackupsResponse
         * @property {Array.<mysqlctl.IBackupInfo>|null} [backups] GetBackupsResponse backups
         */

        /**
         * Constructs a new GetBackupsResponse.
         * @memberof vtctldata
         * @classdesc Represents a GetBackupsResponse.
         * @implements IGetBackupsResponse
         * @constructor
         * @param {vtctldata.IGetBackupsResponse=} [properties] Properties to set
         */
        function GetBackupsResponse(properties) {
            this.backups = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetBackupsResponse backups.
         * @member {Array.<mysqlctl.IBackupInfo>} backups
         * @memberof vtctldata.GetBackupsResponse
         * @instance
         */
        GetBackupsResponse.prototype.backups = $util.emptyArray;

        /**
         * Creates a new GetBackupsResponse instance using the specified properties.
         * @function create
         * @memberof vtctldata.GetBackupsResponse
         * @static
         * @param {vtctldata.IGetBackupsResponse=} [properties] Properties to set
         * @returns {vtctldata.GetBackupsResponse} GetBackupsResponse instance
         */
        GetBackupsResponse.create = function create(properties) {
            return new GetBackupsResponse(properties);
        };

        /**
         * Encodes the specified GetBackupsResponse message. Does not implicitly {@link vtctldata.GetBackupsResponse.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.GetBackupsResponse
         * @static
         * @param {vtctldata.IGetBackupsResponse} message GetBackupsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetBackupsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.backups != null && message.backups.length)
                for (var i = 0; i < message.backups.length; ++i)
                    $root.mysqlctl.BackupInfo.encode(message.backups[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetBackupsResponse message, length delimited. Does not implicitly {@link vtctldata.GetBackupsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.GetBackupsResponse
         * @static
         * @param {vtctldata.IGetBackupsResponse} message GetBackupsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetBackupsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetBackupsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.GetBackupsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.GetBackupsResponse} GetBackupsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetBackupsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.GetBackupsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.backups && message.backups.length))
                        message.backups = [];
                    message.backups.push($root.mysqlctl.BackupInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetBackupsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.GetBackupsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.GetBackupsResponse} GetBackupsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetBackupsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetBackupsResponse message.
         * @function verify
         * @memberof vtctldata.GetBackupsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetBackupsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.backups != null && message.hasOwnProperty("backups")) {
                if (!Array.isArray(message.backups))
                    return "backups: array expected";
                for (var i = 0; i < message.backups.length; ++i) {
                    var error = $root.mysqlctl.BackupInfo.verify(message.backups[i]);
                    if (error)
                        return "backups." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetBackupsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.GetBackupsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.GetBackupsResponse} GetBackupsResponse
         */
        GetBackupsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.GetBackupsResponse)
                return object;
            var message = new $root.vtctldata.GetBackupsResponse();
            if (object.backups) {
                if (!Array.isArray(object.backups))
                    throw TypeError(".vtctldata.GetBackupsResponse.backups: array expected");
                message.backups = [];
                for (var i = 0; i < object.backups.length; ++i) {
                    if (typeof object.backups[i] !== "object")
                        throw TypeError(".vtctldata.GetBackupsResponse.backups: object expected");
                    message.backups[i] = $root.mysqlctl.BackupInfo.fromObject(object.backups[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetBackupsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.GetBackupsResponse
         * @static
         * @param {vtctldata.GetBackupsResponse} message GetBackupsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetBackupsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.backups = [];
            if (message.backups && message.backups.length) {
                object.backups = [];
                for (var j = 0; j < message.backups.length; ++j)
                    object.backups[j] = $root.mysqlctl.BackupInfo.toObject(message.backups[j], options);
            }
            return object;
        };

        /**
         * Converts this GetBackupsResponse to JSON.
         * @function toJSON
         * @memberof vtctldata.GetBackupsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetBackupsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetBackupsResponse;
    })();

    vtctldata.GetCellInfoNamesRequest = (function() {

        /**
         * Properties of a GetCellInfoNamesRequest.
         * @memberof vtctldata
         * @interface IGetCellInfoNamesRequest
         */

        /**
         * Constructs a new GetCellInfoNamesRequest.
         * @memberof vtctldata
         * @classdesc Represents a GetCellInfoNamesRequest.
         * @implements IGetCellInfoNamesRequest
         * @constructor
         * @param {vtctldata.IGetCellInfoNamesRequest=} [properties] Properties to set
         */
        function GetCellInfoNamesRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new GetCellInfoNamesRequest instance using the specified properties.
         * @function create
         * @memberof vtctldata.GetCellInfoNamesRequest
         * @static
         * @param {vtctldata.IGetCellInfoNamesRequest=} [properties] Properties to set
         * @returns {vtctldata.GetCellInfoNamesRequest} GetCellInfoNamesRequest instance
         */
        GetCellInfoNamesRequest.create = function create(properties) {
            return new GetCellInfoNamesRequest(properties);
        };

        /**
         * Encodes the specified GetCellInfoNamesRequest message. Does not implicitly {@link vtctldata.GetCellInfoNamesRequest.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.GetCellInfoNamesRequest
         * @static
         * @param {vtctldata.IGetCellInfoNamesRequest} message GetCellInfoNamesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCellInfoNamesRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified GetCellInfoNamesRequest message, length delimited. Does not implicitly {@link vtctldata.GetCellInfoNamesRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.GetCellInfoNamesRequest
         * @static
         * @param {vtctldata.IGetCellInfoNamesRequest} message GetCellInfoNamesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCellInfoNamesRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetCellInfoNamesRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.GetCellInfoNamesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.GetCellInfoNamesRequest} GetCellInfoNamesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCellInfoNamesRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.GetCellInfoNamesRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetCellInfoNamesRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.GetCellInfoNamesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.GetCellInfoNamesRequest} GetCellInfoNamesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCellInfoNamesRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetCellInfoNamesRequest message.
         * @function verify
         * @memberof vtctldata.GetCellInfoNamesRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetCellInfoNamesRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a GetCellInfoNamesRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.GetCellInfoNamesRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.GetCellInfoNamesRequest} GetCellInfoNamesRequest
         */
        GetCellInfoNamesRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.GetCellInfoNamesRequest)
                return object;
            return new $root.vtctldata.GetCellInfoNamesRequest();
        };

        /**
         * Creates a plain object from a GetCellInfoNamesRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.GetCellInfoNamesRequest
         * @static
         * @param {vtctldata.GetCellInfoNamesRequest} message GetCellInfoNamesRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetCellInfoNamesRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this GetCellInfoNamesRequest to JSON.
         * @function toJSON
         * @memberof vtctldata.GetCellInfoNamesRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetCellInfoNamesRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetCellInfoNamesRequest;
    })();

    vtctldata.GetCellInfoNamesResponse = (function() {

        /**
         * Properties of a GetCellInfoNamesResponse.
         * @memberof vtctldata
         * @interface IGetCellInfoNamesResponse
         * @property {Array.<string>|null} [names] GetCellInfoNamesResponse names
         */

        /**
         * Constructs a new GetCellInfoNamesResponse.
         * @memberof vtctldata
         * @classdesc Represents a GetCellInfoNamesResponse.
         * @implements IGetCellInfoNamesResponse
         * @constructor
         * @param {vtctldata.IGetCellInfoNamesResponse=} [properties] Properties to set
         */
        function GetCellInfoNamesResponse(properties) {
            this.names = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetCellInfoNamesResponse names.
         * @member {Array.<string>} names
         * @memberof vtctldata.GetCellInfoNamesResponse
         * @instance
         */
        GetCellInfoNamesResponse.prototype.names = $util.emptyArray;

        /**
         * Creates a new GetCellInfoNamesResponse instance using the specified properties.
         * @function create
         * @memberof vtctldata.GetCellInfoNamesResponse
         * @static
         * @param {vtctldata.IGetCellInfoNamesResponse=} [properties] Properties to set
         * @returns {vtctldata.GetCellInfoNamesResponse} GetCellInfoNamesResponse instance
         */
        GetCellInfoNamesResponse.create = function create(properties) {
            return new GetCellInfoNamesResponse(properties);
        };

        /**
         * Encodes the specified GetCellInfoNamesResponse message. Does not implicitly {@link vtctldata.GetCellInfoNamesResponse.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.GetCellInfoNamesResponse
         * @static
         * @param {vtctldata.IGetCellInfoNamesResponse} message GetCellInfoNamesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCellInfoNamesResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.names != null && message.names.length)
                for (var i = 0; i < message.names.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.names[i]);
            return writer;
        };

        /**
         * Encodes the specified GetCellInfoNamesResponse message, length delimited. Does not implicitly {@link vtctldata.GetCellInfoNamesResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.GetCellInfoNamesResponse
         * @static
         * @param {vtctldata.IGetCellInfoNamesResponse} message GetCellInfoNamesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCellInfoNamesResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetCellInfoNamesResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.GetCellInfoNamesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.GetCellInfoNamesResponse} GetCellInfoNamesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCellInfoNamesResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.GetCellInfoNamesResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.names && message.names.length))
                        message.names = [];
                    message.names.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetCellInfoNamesResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.GetCellInfoNamesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.GetCellInfoNamesResponse} GetCellInfoNamesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCellInfoNamesResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetCellInfoNamesResponse message.
         * @function verify
         * @memberof vtctldata.GetCellInfoNamesResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetCellInfoNamesResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.names != null && message.hasOwnProperty("names")) {
                if (!Array.isArray(message.names))
                    return "names: array expected";
                for (var i = 0; i < message.names.length; ++i)
                    if (!$util.isString(message.names[i]))
                        return "names: string[] expected";
            }
            return null;
        };

        /**
         * Creates a GetCellInfoNamesResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.GetCellInfoNamesResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.GetCellInfoNamesResponse} GetCellInfoNamesResponse
         */
        GetCellInfoNamesResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.GetCellInfoNamesResponse)
                return object;
            var message = new $root.vtctldata.GetCellInfoNamesResponse();
            if (object.names) {
                if (!Array.isArray(object.names))
                    throw TypeError(".vtctldata.GetCellInfoNamesResponse.names: array expected");
                message.names = [];
                for (var i = 0; i < object.names.length; ++i)
                    message.names[i] = String(object.names[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetCellInfoNamesResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.GetCellInfoNamesResponse
         * @static
         * @param {vtctldata.GetCellInfoNamesResponse} message GetCellInfoNamesResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetCellInfoNamesResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.names = [];
            if (message.names && message.names.length) {
                object.names = [];
                for (var j = 0; j < message.names.length; ++j)
                    object.names[j] = message.names[j];
            }
            return object;
        };

        /**
         * Converts this GetCellInfoNamesResponse to JSON.
         * @function toJSON
         * @memberof vtctldata.GetCellInfoNamesResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetCellInfoNamesResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetCellInfoNamesResponse;
    })();

    vtctldata.GetCellInfoRequest = (function() {

        /**
         * Properties of a GetCellInfoRequest.
         * @memberof vtctldata
         * @interface IGetCellInfoRequest
         * @property {string|null} [cell] GetCellInfoRequest cell
         */

        /**
         * Constructs a new GetCellInfoRequest.
         * @memberof vtctldata
         * @classdesc Represents a GetCellInfoRequest.
         * @implements IGetCellInfoRequest
         * @constructor
         * @param {vtctldata.IGetCellInfoRequest=} [properties] Properties to set
         */
        function GetCellInfoRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetCellInfoRequest cell.
         * @member {string} cell
         * @memberof vtctldata.GetCellInfoRequest
         * @instance
         */
        GetCellInfoRequest.prototype.cell = "";

        /**
         * Creates a new GetCellInfoRequest instance using the specified properties.
         * @function create
         * @memberof vtctldata.GetCellInfoRequest
         * @static
         * @param {vtctldata.IGetCellInfoRequest=} [properties] Properties to set
         * @returns {vtctldata.GetCellInfoRequest} GetCellInfoRequest instance
         */
        GetCellInfoRequest.create = function create(properties) {
            return new GetCellInfoRequest(properties);
        };

        /**
         * Encodes the specified GetCellInfoRequest message. Does not implicitly {@link vtctldata.GetCellInfoRequest.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.GetCellInfoRequest
         * @static
         * @param {vtctldata.IGetCellInfoRequest} message GetCellInfoRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCellInfoRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cell != null && Object.hasOwnProperty.call(message, "cell"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.cell);
            return writer;
        };

        /**
         * Encodes the specified GetCellInfoRequest message, length delimited. Does not implicitly {@link vtctldata.GetCellInfoRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.GetCellInfoRequest
         * @static
         * @param {vtctldata.IGetCellInfoRequest} message GetCellInfoRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCellInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetCellInfoRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.GetCellInfoRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.GetCellInfoRequest} GetCellInfoRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCellInfoRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.GetCellInfoRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.cell = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetCellInfoRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.GetCellInfoRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.GetCellInfoRequest} GetCellInfoRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCellInfoRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetCellInfoRequest message.
         * @function verify
         * @memberof vtctldata.GetCellInfoRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetCellInfoRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cell != null && message.hasOwnProperty("cell"))
                if (!$util.isString(message.cell))
                    return "cell: string expected";
            return null;
        };

        /**
         * Creates a GetCellInfoRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.GetCellInfoRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.GetCellInfoRequest} GetCellInfoRequest
         */
        GetCellInfoRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.GetCellInfoRequest)
                return object;
            var message = new $root.vtctldata.GetCellInfoRequest();
            if (object.cell != null)
                message.cell = String(object.cell);
            return message;
        };

        /**
         * Creates a plain object from a GetCellInfoRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.GetCellInfoRequest
         * @static
         * @param {vtctldata.GetCellInfoRequest} message GetCellInfoRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetCellInfoRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.cell = "";
            if (message.cell != null && message.hasOwnProperty("cell"))
                object.cell = message.cell;
            return object;
        };

        /**
         * Converts this GetCellInfoRequest to JSON.
         * @function toJSON
         * @memberof vtctldata.GetCellInfoRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetCellInfoRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetCellInfoRequest;
    })();

    vtctldata.GetCellInfoResponse = (function() {

        /**
         * Properties of a GetCellInfoResponse.
         * @memberof vtctldata
         * @interface IGetCellInfoResponse
         * @property {topodata.ICellInfo|null} [cell_info] GetCellInfoResponse cell_info
         */

        /**
         * Constructs a new GetCellInfoResponse.
         * @memberof vtctldata
         * @classdesc Represents a GetCellInfoResponse.
         * @implements IGetCellInfoResponse
         * @constructor
         * @param {vtctldata.IGetCellInfoResponse=} [properties] Properties to set
         */
        function GetCellInfoResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetCellInfoResponse cell_info.
         * @member {topodata.ICellInfo|null|undefined} cell_info
         * @memberof vtctldata.GetCellInfoResponse
         * @instance
         */
        GetCellInfoResponse.prototype.cell_info = null;

        /**
         * Creates a new GetCellInfoResponse instance using the specified properties.
         * @function create
         * @memberof vtctldata.GetCellInfoResponse
         * @static
         * @param {vtctldata.IGetCellInfoResponse=} [properties] Properties to set
         * @returns {vtctldata.GetCellInfoResponse} GetCellInfoResponse instance
         */
        GetCellInfoResponse.create = function create(properties) {
            return new GetCellInfoResponse(properties);
        };

        /**
         * Encodes the specified GetCellInfoResponse message. Does not implicitly {@link vtctldata.GetCellInfoResponse.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.GetCellInfoResponse
         * @static
         * @param {vtctldata.IGetCellInfoResponse} message GetCellInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCellInfoResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cell_info != null && Object.hasOwnProperty.call(message, "cell_info"))
                $root.topodata.CellInfo.encode(message.cell_info, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetCellInfoResponse message, length delimited. Does not implicitly {@link vtctldata.GetCellInfoResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.GetCellInfoResponse
         * @static
         * @param {vtctldata.IGetCellInfoResponse} message GetCellInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCellInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetCellInfoResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.GetCellInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.GetCellInfoResponse} GetCellInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCellInfoResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.GetCellInfoResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.cell_info = $root.topodata.CellInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetCellInfoResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.GetCellInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.GetCellInfoResponse} GetCellInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCellInfoResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetCellInfoResponse message.
         * @function verify
         * @memberof vtctldata.GetCellInfoResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetCellInfoResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cell_info != null && message.hasOwnProperty("cell_info")) {
                var error = $root.topodata.CellInfo.verify(message.cell_info);
                if (error)
                    return "cell_info." + error;
            }
            return null;
        };

        /**
         * Creates a GetCellInfoResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.GetCellInfoResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.GetCellInfoResponse} GetCellInfoResponse
         */
        GetCellInfoResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.GetCellInfoResponse)
                return object;
            var message = new $root.vtctldata.GetCellInfoResponse();
            if (object.cell_info != null) {
                if (typeof object.cell_info !== "object")
                    throw TypeError(".vtctldata.GetCellInfoResponse.cell_info: object expected");
                message.cell_info = $root.topodata.CellInfo.fromObject(object.cell_info);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetCellInfoResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.GetCellInfoResponse
         * @static
         * @param {vtctldata.GetCellInfoResponse} message GetCellInfoResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetCellInfoResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.cell_info = null;
            if (message.cell_info != null && message.hasOwnProperty("cell_info"))
                object.cell_info = $root.topodata.CellInfo.toObject(message.cell_info, options);
            return object;
        };

        /**
         * Converts this GetCellInfoResponse to JSON.
         * @function toJSON
         * @memberof vtctldata.GetCellInfoResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetCellInfoResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetCellInfoResponse;
    })();

    vtctldata.GetCellsAliasesRequest = (function() {

        /**
         * Properties of a GetCellsAliasesRequest.
         * @memberof vtctldata
         * @interface IGetCellsAliasesRequest
         */

        /**
         * Constructs a new GetCellsAliasesRequest.
         * @memberof vtctldata
         * @classdesc Represents a GetCellsAliasesRequest.
         * @implements IGetCellsAliasesRequest
         * @constructor
         * @param {vtctldata.IGetCellsAliasesRequest=} [properties] Properties to set
         */
        function GetCellsAliasesRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new GetCellsAliasesRequest instance using the specified properties.
         * @function create
         * @memberof vtctldata.GetCellsAliasesRequest
         * @static
         * @param {vtctldata.IGetCellsAliasesRequest=} [properties] Properties to set
         * @returns {vtctldata.GetCellsAliasesRequest} GetCellsAliasesRequest instance
         */
        GetCellsAliasesRequest.create = function create(properties) {
            return new GetCellsAliasesRequest(properties);
        };

        /**
         * Encodes the specified GetCellsAliasesRequest message. Does not implicitly {@link vtctldata.GetCellsAliasesRequest.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.GetCellsAliasesRequest
         * @static
         * @param {vtctldata.IGetCellsAliasesRequest} message GetCellsAliasesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCellsAliasesRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified GetCellsAliasesRequest message, length delimited. Does not implicitly {@link vtctldata.GetCellsAliasesRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.GetCellsAliasesRequest
         * @static
         * @param {vtctldata.IGetCellsAliasesRequest} message GetCellsAliasesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCellsAliasesRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetCellsAliasesRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.GetCellsAliasesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.GetCellsAliasesRequest} GetCellsAliasesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCellsAliasesRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.GetCellsAliasesRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetCellsAliasesRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.GetCellsAliasesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.GetCellsAliasesRequest} GetCellsAliasesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCellsAliasesRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetCellsAliasesRequest message.
         * @function verify
         * @memberof vtctldata.GetCellsAliasesRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetCellsAliasesRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a GetCellsAliasesRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.GetCellsAliasesRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.GetCellsAliasesRequest} GetCellsAliasesRequest
         */
        GetCellsAliasesRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.GetCellsAliasesRequest)
                return object;
            return new $root.vtctldata.GetCellsAliasesRequest();
        };

        /**
         * Creates a plain object from a GetCellsAliasesRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.GetCellsAliasesRequest
         * @static
         * @param {vtctldata.GetCellsAliasesRequest} message GetCellsAliasesRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetCellsAliasesRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this GetCellsAliasesRequest to JSON.
         * @function toJSON
         * @memberof vtctldata.GetCellsAliasesRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetCellsAliasesRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetCellsAliasesRequest;
    })();

    vtctldata.GetCellsAliasesResponse = (function() {

        /**
         * Properties of a GetCellsAliasesResponse.
         * @memberof vtctldata
         * @interface IGetCellsAliasesResponse
         * @property {Object.<string,topodata.ICellsAlias>|null} [aliases] GetCellsAliasesResponse aliases
         */

        /**
         * Constructs a new GetCellsAliasesResponse.
         * @memberof vtctldata
         * @classdesc Represents a GetCellsAliasesResponse.
         * @implements IGetCellsAliasesResponse
         * @constructor
         * @param {vtctldata.IGetCellsAliasesResponse=} [properties] Properties to set
         */
        function GetCellsAliasesResponse(properties) {
            this.aliases = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetCellsAliasesResponse aliases.
         * @member {Object.<string,topodata.ICellsAlias>} aliases
         * @memberof vtctldata.GetCellsAliasesResponse
         * @instance
         */
        GetCellsAliasesResponse.prototype.aliases = $util.emptyObject;

        /**
         * Creates a new GetCellsAliasesResponse instance using the specified properties.
         * @function create
         * @memberof vtctldata.GetCellsAliasesResponse
         * @static
         * @param {vtctldata.IGetCellsAliasesResponse=} [properties] Properties to set
         * @returns {vtctldata.GetCellsAliasesResponse} GetCellsAliasesResponse instance
         */
        GetCellsAliasesResponse.create = function create(properties) {
            return new GetCellsAliasesResponse(properties);
        };

        /**
         * Encodes the specified GetCellsAliasesResponse message. Does not implicitly {@link vtctldata.GetCellsAliasesResponse.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.GetCellsAliasesResponse
         * @static
         * @param {vtctldata.IGetCellsAliasesResponse} message GetCellsAliasesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCellsAliasesResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.aliases != null && Object.hasOwnProperty.call(message, "aliases"))
                for (var keys = Object.keys(message.aliases), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.topodata.CellsAlias.encode(message.aliases[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            return writer;
        };

        /**
         * Encodes the specified GetCellsAliasesResponse message, length delimited. Does not implicitly {@link vtctldata.GetCellsAliasesResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.GetCellsAliasesResponse
         * @static
         * @param {vtctldata.IGetCellsAliasesResponse} message GetCellsAliasesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCellsAliasesResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetCellsAliasesResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.GetCellsAliasesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.GetCellsAliasesResponse} GetCellsAliasesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCellsAliasesResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.GetCellsAliasesResponse(), key, value;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (message.aliases === $util.emptyObject)
                        message.aliases = {};
                    var end2 = reader.uint32() + reader.pos;
                    key = "";
                    value = null;
                    while (reader.pos < end2) {
                        var tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.string();
                            break;
                        case 2:
                            value = $root.topodata.CellsAlias.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.aliases[key] = value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetCellsAliasesResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.GetCellsAliasesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.GetCellsAliasesResponse} GetCellsAliasesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCellsAliasesResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetCellsAliasesResponse message.
         * @function verify
         * @memberof vtctldata.GetCellsAliasesResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetCellsAliasesResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.aliases != null && message.hasOwnProperty("aliases")) {
                if (!$util.isObject(message.aliases))
                    return "aliases: object expected";
                var key = Object.keys(message.aliases);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.topodata.CellsAlias.verify(message.aliases[key[i]]);
                    if (error)
                        return "aliases." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetCellsAliasesResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.GetCellsAliasesResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.GetCellsAliasesResponse} GetCellsAliasesResponse
         */
        GetCellsAliasesResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.GetCellsAliasesResponse)
                return object;
            var message = new $root.vtctldata.GetCellsAliasesResponse();
            if (object.aliases) {
                if (typeof object.aliases !== "object")
                    throw TypeError(".vtctldata.GetCellsAliasesResponse.aliases: object expected");
                message.aliases = {};
                for (var keys = Object.keys(object.aliases), i = 0; i < keys.length; ++i) {
                    if (typeof object.aliases[keys[i]] !== "object")
                        throw TypeError(".vtctldata.GetCellsAliasesResponse.aliases: object expected");
                    message.aliases[keys[i]] = $root.topodata.CellsAlias.fromObject(object.aliases[keys[i]]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetCellsAliasesResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.GetCellsAliasesResponse
         * @static
         * @param {vtctldata.GetCellsAliasesResponse} message GetCellsAliasesResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetCellsAliasesResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults)
                object.aliases = {};
            var keys2;
            if (message.aliases && (keys2 = Object.keys(message.aliases)).length) {
                object.aliases = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.aliases[keys2[j]] = $root.topodata.CellsAlias.toObject(message.aliases[keys2[j]], options);
            }
            return object;
        };

        /**
         * Converts this GetCellsAliasesResponse to JSON.
         * @function toJSON
         * @memberof vtctldata.GetCellsAliasesResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetCellsAliasesResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetCellsAliasesResponse;
    })();

    vtctldata.GetKeyspacesRequest = (function() {

        /**
         * Properties of a GetKeyspacesRequest.
         * @memberof vtctldata
         * @interface IGetKeyspacesRequest
         */

        /**
         * Constructs a new GetKeyspacesRequest.
         * @memberof vtctldata
         * @classdesc Represents a GetKeyspacesRequest.
         * @implements IGetKeyspacesRequest
         * @constructor
         * @param {vtctldata.IGetKeyspacesRequest=} [properties] Properties to set
         */
        function GetKeyspacesRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new GetKeyspacesRequest instance using the specified properties.
         * @function create
         * @memberof vtctldata.GetKeyspacesRequest
         * @static
         * @param {vtctldata.IGetKeyspacesRequest=} [properties] Properties to set
         * @returns {vtctldata.GetKeyspacesRequest} GetKeyspacesRequest instance
         */
        GetKeyspacesRequest.create = function create(properties) {
            return new GetKeyspacesRequest(properties);
        };

        /**
         * Encodes the specified GetKeyspacesRequest message. Does not implicitly {@link vtctldata.GetKeyspacesRequest.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.GetKeyspacesRequest
         * @static
         * @param {vtctldata.IGetKeyspacesRequest} message GetKeyspacesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetKeyspacesRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified GetKeyspacesRequest message, length delimited. Does not implicitly {@link vtctldata.GetKeyspacesRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.GetKeyspacesRequest
         * @static
         * @param {vtctldata.IGetKeyspacesRequest} message GetKeyspacesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetKeyspacesRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetKeyspacesRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.GetKeyspacesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.GetKeyspacesRequest} GetKeyspacesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetKeyspacesRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.GetKeyspacesRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetKeyspacesRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.GetKeyspacesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.GetKeyspacesRequest} GetKeyspacesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetKeyspacesRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetKeyspacesRequest message.
         * @function verify
         * @memberof vtctldata.GetKeyspacesRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetKeyspacesRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a GetKeyspacesRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.GetKeyspacesRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.GetKeyspacesRequest} GetKeyspacesRequest
         */
        GetKeyspacesRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.GetKeyspacesRequest)
                return object;
            return new $root.vtctldata.GetKeyspacesRequest();
        };

        /**
         * Creates a plain object from a GetKeyspacesRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.GetKeyspacesRequest
         * @static
         * @param {vtctldata.GetKeyspacesRequest} message GetKeyspacesRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetKeyspacesRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this GetKeyspacesRequest to JSON.
         * @function toJSON
         * @memberof vtctldata.GetKeyspacesRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetKeyspacesRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetKeyspacesRequest;
    })();

    vtctldata.GetKeyspacesResponse = (function() {

        /**
         * Properties of a GetKeyspacesResponse.
         * @memberof vtctldata
         * @interface IGetKeyspacesResponse
         * @property {Array.<vtctldata.IKeyspace>|null} [keyspaces] GetKeyspacesResponse keyspaces
         */

        /**
         * Constructs a new GetKeyspacesResponse.
         * @memberof vtctldata
         * @classdesc Represents a GetKeyspacesResponse.
         * @implements IGetKeyspacesResponse
         * @constructor
         * @param {vtctldata.IGetKeyspacesResponse=} [properties] Properties to set
         */
        function GetKeyspacesResponse(properties) {
            this.keyspaces = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetKeyspacesResponse keyspaces.
         * @member {Array.<vtctldata.IKeyspace>} keyspaces
         * @memberof vtctldata.GetKeyspacesResponse
         * @instance
         */
        GetKeyspacesResponse.prototype.keyspaces = $util.emptyArray;

        /**
         * Creates a new GetKeyspacesResponse instance using the specified properties.
         * @function create
         * @memberof vtctldata.GetKeyspacesResponse
         * @static
         * @param {vtctldata.IGetKeyspacesResponse=} [properties] Properties to set
         * @returns {vtctldata.GetKeyspacesResponse} GetKeyspacesResponse instance
         */
        GetKeyspacesResponse.create = function create(properties) {
            return new GetKeyspacesResponse(properties);
        };

        /**
         * Encodes the specified GetKeyspacesResponse message. Does not implicitly {@link vtctldata.GetKeyspacesResponse.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.GetKeyspacesResponse
         * @static
         * @param {vtctldata.IGetKeyspacesResponse} message GetKeyspacesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetKeyspacesResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keyspaces != null && message.keyspaces.length)
                for (var i = 0; i < message.keyspaces.length; ++i)
                    $root.vtctldata.Keyspace.encode(message.keyspaces[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetKeyspacesResponse message, length delimited. Does not implicitly {@link vtctldata.GetKeyspacesResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.GetKeyspacesResponse
         * @static
         * @param {vtctldata.IGetKeyspacesResponse} message GetKeyspacesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetKeyspacesResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetKeyspacesResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.GetKeyspacesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.GetKeyspacesResponse} GetKeyspacesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetKeyspacesResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.GetKeyspacesResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.keyspaces && message.keyspaces.length))
                        message.keyspaces = [];
                    message.keyspaces.push($root.vtctldata.Keyspace.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetKeyspacesResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.GetKeyspacesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.GetKeyspacesResponse} GetKeyspacesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetKeyspacesResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetKeyspacesResponse message.
         * @function verify
         * @memberof vtctldata.GetKeyspacesResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetKeyspacesResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keyspaces != null && message.hasOwnProperty("keyspaces")) {
                if (!Array.isArray(message.keyspaces))
                    return "keyspaces: array expected";
                for (var i = 0; i < message.keyspaces.length; ++i) {
                    var error = $root.vtctldata.Keyspace.verify(message.keyspaces[i]);
                    if (error)
                        return "keyspaces." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetKeyspacesResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.GetKeyspacesResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.GetKeyspacesResponse} GetKeyspacesResponse
         */
        GetKeyspacesResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.GetKeyspacesResponse)
                return object;
            var message = new $root.vtctldata.GetKeyspacesResponse();
            if (object.keyspaces) {
                if (!Array.isArray(object.keyspaces))
                    throw TypeError(".vtctldata.GetKeyspacesResponse.keyspaces: array expected");
                message.keyspaces = [];
                for (var i = 0; i < object.keyspaces.length; ++i) {
                    if (typeof object.keyspaces[i] !== "object")
                        throw TypeError(".vtctldata.GetKeyspacesResponse.keyspaces: object expected");
                    message.keyspaces[i] = $root.vtctldata.Keyspace.fromObject(object.keyspaces[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetKeyspacesResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.GetKeyspacesResponse
         * @static
         * @param {vtctldata.GetKeyspacesResponse} message GetKeyspacesResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetKeyspacesResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.keyspaces = [];
            if (message.keyspaces && message.keyspaces.length) {
                object.keyspaces = [];
                for (var j = 0; j < message.keyspaces.length; ++j)
                    object.keyspaces[j] = $root.vtctldata.Keyspace.toObject(message.keyspaces[j], options);
            }
            return object;
        };

        /**
         * Converts this GetKeyspacesResponse to JSON.
         * @function toJSON
         * @memberof vtctldata.GetKeyspacesResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetKeyspacesResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetKeyspacesResponse;
    })();

    vtctldata.GetKeyspaceRequest = (function() {

        /**
         * Properties of a GetKeyspaceRequest.
         * @memberof vtctldata
         * @interface IGetKeyspaceRequest
         * @property {string|null} [keyspace] GetKeyspaceRequest keyspace
         */

        /**
         * Constructs a new GetKeyspaceRequest.
         * @memberof vtctldata
         * @classdesc Represents a GetKeyspaceRequest.
         * @implements IGetKeyspaceRequest
         * @constructor
         * @param {vtctldata.IGetKeyspaceRequest=} [properties] Properties to set
         */
        function GetKeyspaceRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetKeyspaceRequest keyspace.
         * @member {string} keyspace
         * @memberof vtctldata.GetKeyspaceRequest
         * @instance
         */
        GetKeyspaceRequest.prototype.keyspace = "";

        /**
         * Creates a new GetKeyspaceRequest instance using the specified properties.
         * @function create
         * @memberof vtctldata.GetKeyspaceRequest
         * @static
         * @param {vtctldata.IGetKeyspaceRequest=} [properties] Properties to set
         * @returns {vtctldata.GetKeyspaceRequest} GetKeyspaceRequest instance
         */
        GetKeyspaceRequest.create = function create(properties) {
            return new GetKeyspaceRequest(properties);
        };

        /**
         * Encodes the specified GetKeyspaceRequest message. Does not implicitly {@link vtctldata.GetKeyspaceRequest.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.GetKeyspaceRequest
         * @static
         * @param {vtctldata.IGetKeyspaceRequest} message GetKeyspaceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetKeyspaceRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keyspace != null && Object.hasOwnProperty.call(message, "keyspace"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.keyspace);
            return writer;
        };

        /**
         * Encodes the specified GetKeyspaceRequest message, length delimited. Does not implicitly {@link vtctldata.GetKeyspaceRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.GetKeyspaceRequest
         * @static
         * @param {vtctldata.IGetKeyspaceRequest} message GetKeyspaceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetKeyspaceRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetKeyspaceRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.GetKeyspaceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.GetKeyspaceRequest} GetKeyspaceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetKeyspaceRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.GetKeyspaceRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.keyspace = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetKeyspaceRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.GetKeyspaceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.GetKeyspaceRequest} GetKeyspaceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetKeyspaceRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetKeyspaceRequest message.
         * @function verify
         * @memberof vtctldata.GetKeyspaceRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetKeyspaceRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                if (!$util.isString(message.keyspace))
                    return "keyspace: string expected";
            return null;
        };

        /**
         * Creates a GetKeyspaceRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.GetKeyspaceRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.GetKeyspaceRequest} GetKeyspaceRequest
         */
        GetKeyspaceRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.GetKeyspaceRequest)
                return object;
            var message = new $root.vtctldata.GetKeyspaceRequest();
            if (object.keyspace != null)
                message.keyspace = String(object.keyspace);
            return message;
        };

        /**
         * Creates a plain object from a GetKeyspaceRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.GetKeyspaceRequest
         * @static
         * @param {vtctldata.GetKeyspaceRequest} message GetKeyspaceRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetKeyspaceRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.keyspace = "";
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                object.keyspace = message.keyspace;
            return object;
        };

        /**
         * Converts this GetKeyspaceRequest to JSON.
         * @function toJSON
         * @memberof vtctldata.GetKeyspaceRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetKeyspaceRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetKeyspaceRequest;
    })();

    vtctldata.GetKeyspaceResponse = (function() {

        /**
         * Properties of a GetKeyspaceResponse.
         * @memberof vtctldata
         * @interface IGetKeyspaceResponse
         * @property {vtctldata.IKeyspace|null} [keyspace] GetKeyspaceResponse keyspace
         */

        /**
         * Constructs a new GetKeyspaceResponse.
         * @memberof vtctldata
         * @classdesc Represents a GetKeyspaceResponse.
         * @implements IGetKeyspaceResponse
         * @constructor
         * @param {vtctldata.IGetKeyspaceResponse=} [properties] Properties to set
         */
        function GetKeyspaceResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetKeyspaceResponse keyspace.
         * @member {vtctldata.IKeyspace|null|undefined} keyspace
         * @memberof vtctldata.GetKeyspaceResponse
         * @instance
         */
        GetKeyspaceResponse.prototype.keyspace = null;

        /**
         * Creates a new GetKeyspaceResponse instance using the specified properties.
         * @function create
         * @memberof vtctldata.GetKeyspaceResponse
         * @static
         * @param {vtctldata.IGetKeyspaceResponse=} [properties] Properties to set
         * @returns {vtctldata.GetKeyspaceResponse} GetKeyspaceResponse instance
         */
        GetKeyspaceResponse.create = function create(properties) {
            return new GetKeyspaceResponse(properties);
        };

        /**
         * Encodes the specified GetKeyspaceResponse message. Does not implicitly {@link vtctldata.GetKeyspaceResponse.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.GetKeyspaceResponse
         * @static
         * @param {vtctldata.IGetKeyspaceResponse} message GetKeyspaceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetKeyspaceResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keyspace != null && Object.hasOwnProperty.call(message, "keyspace"))
                $root.vtctldata.Keyspace.encode(message.keyspace, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetKeyspaceResponse message, length delimited. Does not implicitly {@link vtctldata.GetKeyspaceResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.GetKeyspaceResponse
         * @static
         * @param {vtctldata.IGetKeyspaceResponse} message GetKeyspaceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetKeyspaceResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetKeyspaceResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.GetKeyspaceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.GetKeyspaceResponse} GetKeyspaceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetKeyspaceResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.GetKeyspaceResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.keyspace = $root.vtctldata.Keyspace.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetKeyspaceResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.GetKeyspaceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.GetKeyspaceResponse} GetKeyspaceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetKeyspaceResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetKeyspaceResponse message.
         * @function verify
         * @memberof vtctldata.GetKeyspaceResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetKeyspaceResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keyspace != null && message.hasOwnProperty("keyspace")) {
                var error = $root.vtctldata.Keyspace.verify(message.keyspace);
                if (error)
                    return "keyspace." + error;
            }
            return null;
        };

        /**
         * Creates a GetKeyspaceResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.GetKeyspaceResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.GetKeyspaceResponse} GetKeyspaceResponse
         */
        GetKeyspaceResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.GetKeyspaceResponse)
                return object;
            var message = new $root.vtctldata.GetKeyspaceResponse();
            if (object.keyspace != null) {
                if (typeof object.keyspace !== "object")
                    throw TypeError(".vtctldata.GetKeyspaceResponse.keyspace: object expected");
                message.keyspace = $root.vtctldata.Keyspace.fromObject(object.keyspace);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetKeyspaceResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.GetKeyspaceResponse
         * @static
         * @param {vtctldata.GetKeyspaceResponse} message GetKeyspaceResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetKeyspaceResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.keyspace = null;
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                object.keyspace = $root.vtctldata.Keyspace.toObject(message.keyspace, options);
            return object;
        };

        /**
         * Converts this GetKeyspaceResponse to JSON.
         * @function toJSON
         * @memberof vtctldata.GetKeyspaceResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetKeyspaceResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetKeyspaceResponse;
    })();

    vtctldata.GetSchemaRequest = (function() {

        /**
         * Properties of a GetSchemaRequest.
         * @memberof vtctldata
         * @interface IGetSchemaRequest
         * @property {topodata.ITabletAlias|null} [tablet_alias] GetSchemaRequest tablet_alias
         * @property {Array.<string>|null} [tables] GetSchemaRequest tables
         * @property {Array.<string>|null} [exclude_tables] GetSchemaRequest exclude_tables
         * @property {boolean|null} [include_views] GetSchemaRequest include_views
         * @property {boolean|null} [table_names_only] GetSchemaRequest table_names_only
         * @property {boolean|null} [table_sizes_only] GetSchemaRequest table_sizes_only
         */

        /**
         * Constructs a new GetSchemaRequest.
         * @memberof vtctldata
         * @classdesc Represents a GetSchemaRequest.
         * @implements IGetSchemaRequest
         * @constructor
         * @param {vtctldata.IGetSchemaRequest=} [properties] Properties to set
         */
        function GetSchemaRequest(properties) {
            this.tables = [];
            this.exclude_tables = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetSchemaRequest tablet_alias.
         * @member {topodata.ITabletAlias|null|undefined} tablet_alias
         * @memberof vtctldata.GetSchemaRequest
         * @instance
         */
        GetSchemaRequest.prototype.tablet_alias = null;

        /**
         * GetSchemaRequest tables.
         * @member {Array.<string>} tables
         * @memberof vtctldata.GetSchemaRequest
         * @instance
         */
        GetSchemaRequest.prototype.tables = $util.emptyArray;

        /**
         * GetSchemaRequest exclude_tables.
         * @member {Array.<string>} exclude_tables
         * @memberof vtctldata.GetSchemaRequest
         * @instance
         */
        GetSchemaRequest.prototype.exclude_tables = $util.emptyArray;

        /**
         * GetSchemaRequest include_views.
         * @member {boolean} include_views
         * @memberof vtctldata.GetSchemaRequest
         * @instance
         */
        GetSchemaRequest.prototype.include_views = false;

        /**
         * GetSchemaRequest table_names_only.
         * @member {boolean} table_names_only
         * @memberof vtctldata.GetSchemaRequest
         * @instance
         */
        GetSchemaRequest.prototype.table_names_only = false;

        /**
         * GetSchemaRequest table_sizes_only.
         * @member {boolean} table_sizes_only
         * @memberof vtctldata.GetSchemaRequest
         * @instance
         */
        GetSchemaRequest.prototype.table_sizes_only = false;

        /**
         * Creates a new GetSchemaRequest instance using the specified properties.
         * @function create
         * @memberof vtctldata.GetSchemaRequest
         * @static
         * @param {vtctldata.IGetSchemaRequest=} [properties] Properties to set
         * @returns {vtctldata.GetSchemaRequest} GetSchemaRequest instance
         */
        GetSchemaRequest.create = function create(properties) {
            return new GetSchemaRequest(properties);
        };

        /**
         * Encodes the specified GetSchemaRequest message. Does not implicitly {@link vtctldata.GetSchemaRequest.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.GetSchemaRequest
         * @static
         * @param {vtctldata.IGetSchemaRequest} message GetSchemaRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSchemaRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tablet_alias != null && Object.hasOwnProperty.call(message, "tablet_alias"))
                $root.topodata.TabletAlias.encode(message.tablet_alias, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.tables != null && message.tables.length)
                for (var i = 0; i < message.tables.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.tables[i]);
            if (message.exclude_tables != null && message.exclude_tables.length)
                for (var i = 0; i < message.exclude_tables.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.exclude_tables[i]);
            if (message.include_views != null && Object.hasOwnProperty.call(message, "include_views"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.include_views);
            if (message.table_names_only != null && Object.hasOwnProperty.call(message, "table_names_only"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.table_names_only);
            if (message.table_sizes_only != null && Object.hasOwnProperty.call(message, "table_sizes_only"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.table_sizes_only);
            return writer;
        };

        /**
         * Encodes the specified GetSchemaRequest message, length delimited. Does not implicitly {@link vtctldata.GetSchemaRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.GetSchemaRequest
         * @static
         * @param {vtctldata.IGetSchemaRequest} message GetSchemaRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSchemaRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetSchemaRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.GetSchemaRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.GetSchemaRequest} GetSchemaRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSchemaRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.GetSchemaRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tablet_alias = $root.topodata.TabletAlias.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.tables && message.tables.length))
                        message.tables = [];
                    message.tables.push(reader.string());
                    break;
                case 3:
                    if (!(message.exclude_tables && message.exclude_tables.length))
                        message.exclude_tables = [];
                    message.exclude_tables.push(reader.string());
                    break;
                case 4:
                    message.include_views = reader.bool();
                    break;
                case 5:
                    message.table_names_only = reader.bool();
                    break;
                case 6:
                    message.table_sizes_only = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetSchemaRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.GetSchemaRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.GetSchemaRequest} GetSchemaRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSchemaRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetSchemaRequest message.
         * @function verify
         * @memberof vtctldata.GetSchemaRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetSchemaRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tablet_alias != null && message.hasOwnProperty("tablet_alias")) {
                var error = $root.topodata.TabletAlias.verify(message.tablet_alias);
                if (error)
                    return "tablet_alias." + error;
            }
            if (message.tables != null && message.hasOwnProperty("tables")) {
                if (!Array.isArray(message.tables))
                    return "tables: array expected";
                for (var i = 0; i < message.tables.length; ++i)
                    if (!$util.isString(message.tables[i]))
                        return "tables: string[] expected";
            }
            if (message.exclude_tables != null && message.hasOwnProperty("exclude_tables")) {
                if (!Array.isArray(message.exclude_tables))
                    return "exclude_tables: array expected";
                for (var i = 0; i < message.exclude_tables.length; ++i)
                    if (!$util.isString(message.exclude_tables[i]))
                        return "exclude_tables: string[] expected";
            }
            if (message.include_views != null && message.hasOwnProperty("include_views"))
                if (typeof message.include_views !== "boolean")
                    return "include_views: boolean expected";
            if (message.table_names_only != null && message.hasOwnProperty("table_names_only"))
                if (typeof message.table_names_only !== "boolean")
                    return "table_names_only: boolean expected";
            if (message.table_sizes_only != null && message.hasOwnProperty("table_sizes_only"))
                if (typeof message.table_sizes_only !== "boolean")
                    return "table_sizes_only: boolean expected";
            return null;
        };

        /**
         * Creates a GetSchemaRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.GetSchemaRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.GetSchemaRequest} GetSchemaRequest
         */
        GetSchemaRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.GetSchemaRequest)
                return object;
            var message = new $root.vtctldata.GetSchemaRequest();
            if (object.tablet_alias != null) {
                if (typeof object.tablet_alias !== "object")
                    throw TypeError(".vtctldata.GetSchemaRequest.tablet_alias: object expected");
                message.tablet_alias = $root.topodata.TabletAlias.fromObject(object.tablet_alias);
            }
            if (object.tables) {
                if (!Array.isArray(object.tables))
                    throw TypeError(".vtctldata.GetSchemaRequest.tables: array expected");
                message.tables = [];
                for (var i = 0; i < object.tables.length; ++i)
                    message.tables[i] = String(object.tables[i]);
            }
            if (object.exclude_tables) {
                if (!Array.isArray(object.exclude_tables))
                    throw TypeError(".vtctldata.GetSchemaRequest.exclude_tables: array expected");
                message.exclude_tables = [];
                for (var i = 0; i < object.exclude_tables.length; ++i)
                    message.exclude_tables[i] = String(object.exclude_tables[i]);
            }
            if (object.include_views != null)
                message.include_views = Boolean(object.include_views);
            if (object.table_names_only != null)
                message.table_names_only = Boolean(object.table_names_only);
            if (object.table_sizes_only != null)
                message.table_sizes_only = Boolean(object.table_sizes_only);
            return message;
        };

        /**
         * Creates a plain object from a GetSchemaRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.GetSchemaRequest
         * @static
         * @param {vtctldata.GetSchemaRequest} message GetSchemaRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetSchemaRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.tables = [];
                object.exclude_tables = [];
            }
            if (options.defaults) {
                object.tablet_alias = null;
                object.include_views = false;
                object.table_names_only = false;
                object.table_sizes_only = false;
            }
            if (message.tablet_alias != null && message.hasOwnProperty("tablet_alias"))
                object.tablet_alias = $root.topodata.TabletAlias.toObject(message.tablet_alias, options);
            if (message.tables && message.tables.length) {
                object.tables = [];
                for (var j = 0; j < message.tables.length; ++j)
                    object.tables[j] = message.tables[j];
            }
            if (message.exclude_tables && message.exclude_tables.length) {
                object.exclude_tables = [];
                for (var j = 0; j < message.exclude_tables.length; ++j)
                    object.exclude_tables[j] = message.exclude_tables[j];
            }
            if (message.include_views != null && message.hasOwnProperty("include_views"))
                object.include_views = message.include_views;
            if (message.table_names_only != null && message.hasOwnProperty("table_names_only"))
                object.table_names_only = message.table_names_only;
            if (message.table_sizes_only != null && message.hasOwnProperty("table_sizes_only"))
                object.table_sizes_only = message.table_sizes_only;
            return object;
        };

        /**
         * Converts this GetSchemaRequest to JSON.
         * @function toJSON
         * @memberof vtctldata.GetSchemaRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetSchemaRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetSchemaRequest;
    })();

    vtctldata.GetSchemaResponse = (function() {

        /**
         * Properties of a GetSchemaResponse.
         * @memberof vtctldata
         * @interface IGetSchemaResponse
         * @property {tabletmanagerdata.ISchemaDefinition|null} [schema] GetSchemaResponse schema
         */

        /**
         * Constructs a new GetSchemaResponse.
         * @memberof vtctldata
         * @classdesc Represents a GetSchemaResponse.
         * @implements IGetSchemaResponse
         * @constructor
         * @param {vtctldata.IGetSchemaResponse=} [properties] Properties to set
         */
        function GetSchemaResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetSchemaResponse schema.
         * @member {tabletmanagerdata.ISchemaDefinition|null|undefined} schema
         * @memberof vtctldata.GetSchemaResponse
         * @instance
         */
        GetSchemaResponse.prototype.schema = null;

        /**
         * Creates a new GetSchemaResponse instance using the specified properties.
         * @function create
         * @memberof vtctldata.GetSchemaResponse
         * @static
         * @param {vtctldata.IGetSchemaResponse=} [properties] Properties to set
         * @returns {vtctldata.GetSchemaResponse} GetSchemaResponse instance
         */
        GetSchemaResponse.create = function create(properties) {
            return new GetSchemaResponse(properties);
        };

        /**
         * Encodes the specified GetSchemaResponse message. Does not implicitly {@link vtctldata.GetSchemaResponse.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.GetSchemaResponse
         * @static
         * @param {vtctldata.IGetSchemaResponse} message GetSchemaResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSchemaResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.schema != null && Object.hasOwnProperty.call(message, "schema"))
                $root.tabletmanagerdata.SchemaDefinition.encode(message.schema, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetSchemaResponse message, length delimited. Does not implicitly {@link vtctldata.GetSchemaResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.GetSchemaResponse
         * @static
         * @param {vtctldata.IGetSchemaResponse} message GetSchemaResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSchemaResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetSchemaResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.GetSchemaResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.GetSchemaResponse} GetSchemaResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSchemaResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.GetSchemaResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.schema = $root.tabletmanagerdata.SchemaDefinition.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetSchemaResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.GetSchemaResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.GetSchemaResponse} GetSchemaResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSchemaResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetSchemaResponse message.
         * @function verify
         * @memberof vtctldata.GetSchemaResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetSchemaResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.schema != null && message.hasOwnProperty("schema")) {
                var error = $root.tabletmanagerdata.SchemaDefinition.verify(message.schema);
                if (error)
                    return "schema." + error;
            }
            return null;
        };

        /**
         * Creates a GetSchemaResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.GetSchemaResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.GetSchemaResponse} GetSchemaResponse
         */
        GetSchemaResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.GetSchemaResponse)
                return object;
            var message = new $root.vtctldata.GetSchemaResponse();
            if (object.schema != null) {
                if (typeof object.schema !== "object")
                    throw TypeError(".vtctldata.GetSchemaResponse.schema: object expected");
                message.schema = $root.tabletmanagerdata.SchemaDefinition.fromObject(object.schema);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetSchemaResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.GetSchemaResponse
         * @static
         * @param {vtctldata.GetSchemaResponse} message GetSchemaResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetSchemaResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.schema = null;
            if (message.schema != null && message.hasOwnProperty("schema"))
                object.schema = $root.tabletmanagerdata.SchemaDefinition.toObject(message.schema, options);
            return object;
        };

        /**
         * Converts this GetSchemaResponse to JSON.
         * @function toJSON
         * @memberof vtctldata.GetSchemaResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetSchemaResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetSchemaResponse;
    })();

    vtctldata.GetShardRequest = (function() {

        /**
         * Properties of a GetShardRequest.
         * @memberof vtctldata
         * @interface IGetShardRequest
         * @property {string|null} [keyspace] GetShardRequest keyspace
         * @property {string|null} [shard_name] GetShardRequest shard_name
         */

        /**
         * Constructs a new GetShardRequest.
         * @memberof vtctldata
         * @classdesc Represents a GetShardRequest.
         * @implements IGetShardRequest
         * @constructor
         * @param {vtctldata.IGetShardRequest=} [properties] Properties to set
         */
        function GetShardRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetShardRequest keyspace.
         * @member {string} keyspace
         * @memberof vtctldata.GetShardRequest
         * @instance
         */
        GetShardRequest.prototype.keyspace = "";

        /**
         * GetShardRequest shard_name.
         * @member {string} shard_name
         * @memberof vtctldata.GetShardRequest
         * @instance
         */
        GetShardRequest.prototype.shard_name = "";

        /**
         * Creates a new GetShardRequest instance using the specified properties.
         * @function create
         * @memberof vtctldata.GetShardRequest
         * @static
         * @param {vtctldata.IGetShardRequest=} [properties] Properties to set
         * @returns {vtctldata.GetShardRequest} GetShardRequest instance
         */
        GetShardRequest.create = function create(properties) {
            return new GetShardRequest(properties);
        };

        /**
         * Encodes the specified GetShardRequest message. Does not implicitly {@link vtctldata.GetShardRequest.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.GetShardRequest
         * @static
         * @param {vtctldata.IGetShardRequest} message GetShardRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetShardRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keyspace != null && Object.hasOwnProperty.call(message, "keyspace"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.keyspace);
            if (message.shard_name != null && Object.hasOwnProperty.call(message, "shard_name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.shard_name);
            return writer;
        };

        /**
         * Encodes the specified GetShardRequest message, length delimited. Does not implicitly {@link vtctldata.GetShardRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.GetShardRequest
         * @static
         * @param {vtctldata.IGetShardRequest} message GetShardRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetShardRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetShardRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.GetShardRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.GetShardRequest} GetShardRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetShardRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.GetShardRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.keyspace = reader.string();
                    break;
                case 2:
                    message.shard_name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetShardRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.GetShardRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.GetShardRequest} GetShardRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetShardRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetShardRequest message.
         * @function verify
         * @memberof vtctldata.GetShardRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetShardRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                if (!$util.isString(message.keyspace))
                    return "keyspace: string expected";
            if (message.shard_name != null && message.hasOwnProperty("shard_name"))
                if (!$util.isString(message.shard_name))
                    return "shard_name: string expected";
            return null;
        };

        /**
         * Creates a GetShardRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.GetShardRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.GetShardRequest} GetShardRequest
         */
        GetShardRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.GetShardRequest)
                return object;
            var message = new $root.vtctldata.GetShardRequest();
            if (object.keyspace != null)
                message.keyspace = String(object.keyspace);
            if (object.shard_name != null)
                message.shard_name = String(object.shard_name);
            return message;
        };

        /**
         * Creates a plain object from a GetShardRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.GetShardRequest
         * @static
         * @param {vtctldata.GetShardRequest} message GetShardRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetShardRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.keyspace = "";
                object.shard_name = "";
            }
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                object.keyspace = message.keyspace;
            if (message.shard_name != null && message.hasOwnProperty("shard_name"))
                object.shard_name = message.shard_name;
            return object;
        };

        /**
         * Converts this GetShardRequest to JSON.
         * @function toJSON
         * @memberof vtctldata.GetShardRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetShardRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetShardRequest;
    })();

    vtctldata.GetShardResponse = (function() {

        /**
         * Properties of a GetShardResponse.
         * @memberof vtctldata
         * @interface IGetShardResponse
         * @property {vtctldata.IShard|null} [shard] GetShardResponse shard
         */

        /**
         * Constructs a new GetShardResponse.
         * @memberof vtctldata
         * @classdesc Represents a GetShardResponse.
         * @implements IGetShardResponse
         * @constructor
         * @param {vtctldata.IGetShardResponse=} [properties] Properties to set
         */
        function GetShardResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetShardResponse shard.
         * @member {vtctldata.IShard|null|undefined} shard
         * @memberof vtctldata.GetShardResponse
         * @instance
         */
        GetShardResponse.prototype.shard = null;

        /**
         * Creates a new GetShardResponse instance using the specified properties.
         * @function create
         * @memberof vtctldata.GetShardResponse
         * @static
         * @param {vtctldata.IGetShardResponse=} [properties] Properties to set
         * @returns {vtctldata.GetShardResponse} GetShardResponse instance
         */
        GetShardResponse.create = function create(properties) {
            return new GetShardResponse(properties);
        };

        /**
         * Encodes the specified GetShardResponse message. Does not implicitly {@link vtctldata.GetShardResponse.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.GetShardResponse
         * @static
         * @param {vtctldata.IGetShardResponse} message GetShardResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetShardResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.shard != null && Object.hasOwnProperty.call(message, "shard"))
                $root.vtctldata.Shard.encode(message.shard, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetShardResponse message, length delimited. Does not implicitly {@link vtctldata.GetShardResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.GetShardResponse
         * @static
         * @param {vtctldata.IGetShardResponse} message GetShardResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetShardResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetShardResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.GetShardResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.GetShardResponse} GetShardResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetShardResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.GetShardResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.shard = $root.vtctldata.Shard.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetShardResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.GetShardResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.GetShardResponse} GetShardResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetShardResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetShardResponse message.
         * @function verify
         * @memberof vtctldata.GetShardResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetShardResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.shard != null && message.hasOwnProperty("shard")) {
                var error = $root.vtctldata.Shard.verify(message.shard);
                if (error)
                    return "shard." + error;
            }
            return null;
        };

        /**
         * Creates a GetShardResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.GetShardResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.GetShardResponse} GetShardResponse
         */
        GetShardResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.GetShardResponse)
                return object;
            var message = new $root.vtctldata.GetShardResponse();
            if (object.shard != null) {
                if (typeof object.shard !== "object")
                    throw TypeError(".vtctldata.GetShardResponse.shard: object expected");
                message.shard = $root.vtctldata.Shard.fromObject(object.shard);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetShardResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.GetShardResponse
         * @static
         * @param {vtctldata.GetShardResponse} message GetShardResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetShardResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.shard = null;
            if (message.shard != null && message.hasOwnProperty("shard"))
                object.shard = $root.vtctldata.Shard.toObject(message.shard, options);
            return object;
        };

        /**
         * Converts this GetShardResponse to JSON.
         * @function toJSON
         * @memberof vtctldata.GetShardResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetShardResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetShardResponse;
    })();

    vtctldata.GetSrvKeyspacesRequest = (function() {

        /**
         * Properties of a GetSrvKeyspacesRequest.
         * @memberof vtctldata
         * @interface IGetSrvKeyspacesRequest
         * @property {string|null} [keyspace] GetSrvKeyspacesRequest keyspace
         * @property {Array.<string>|null} [cells] GetSrvKeyspacesRequest cells
         */

        /**
         * Constructs a new GetSrvKeyspacesRequest.
         * @memberof vtctldata
         * @classdesc Represents a GetSrvKeyspacesRequest.
         * @implements IGetSrvKeyspacesRequest
         * @constructor
         * @param {vtctldata.IGetSrvKeyspacesRequest=} [properties] Properties to set
         */
        function GetSrvKeyspacesRequest(properties) {
            this.cells = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetSrvKeyspacesRequest keyspace.
         * @member {string} keyspace
         * @memberof vtctldata.GetSrvKeyspacesRequest
         * @instance
         */
        GetSrvKeyspacesRequest.prototype.keyspace = "";

        /**
         * GetSrvKeyspacesRequest cells.
         * @member {Array.<string>} cells
         * @memberof vtctldata.GetSrvKeyspacesRequest
         * @instance
         */
        GetSrvKeyspacesRequest.prototype.cells = $util.emptyArray;

        /**
         * Creates a new GetSrvKeyspacesRequest instance using the specified properties.
         * @function create
         * @memberof vtctldata.GetSrvKeyspacesRequest
         * @static
         * @param {vtctldata.IGetSrvKeyspacesRequest=} [properties] Properties to set
         * @returns {vtctldata.GetSrvKeyspacesRequest} GetSrvKeyspacesRequest instance
         */
        GetSrvKeyspacesRequest.create = function create(properties) {
            return new GetSrvKeyspacesRequest(properties);
        };

        /**
         * Encodes the specified GetSrvKeyspacesRequest message. Does not implicitly {@link vtctldata.GetSrvKeyspacesRequest.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.GetSrvKeyspacesRequest
         * @static
         * @param {vtctldata.IGetSrvKeyspacesRequest} message GetSrvKeyspacesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSrvKeyspacesRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keyspace != null && Object.hasOwnProperty.call(message, "keyspace"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.keyspace);
            if (message.cells != null && message.cells.length)
                for (var i = 0; i < message.cells.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.cells[i]);
            return writer;
        };

        /**
         * Encodes the specified GetSrvKeyspacesRequest message, length delimited. Does not implicitly {@link vtctldata.GetSrvKeyspacesRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.GetSrvKeyspacesRequest
         * @static
         * @param {vtctldata.IGetSrvKeyspacesRequest} message GetSrvKeyspacesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSrvKeyspacesRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetSrvKeyspacesRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.GetSrvKeyspacesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.GetSrvKeyspacesRequest} GetSrvKeyspacesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSrvKeyspacesRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.GetSrvKeyspacesRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.keyspace = reader.string();
                    break;
                case 2:
                    if (!(message.cells && message.cells.length))
                        message.cells = [];
                    message.cells.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetSrvKeyspacesRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.GetSrvKeyspacesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.GetSrvKeyspacesRequest} GetSrvKeyspacesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSrvKeyspacesRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetSrvKeyspacesRequest message.
         * @function verify
         * @memberof vtctldata.GetSrvKeyspacesRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetSrvKeyspacesRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                if (!$util.isString(message.keyspace))
                    return "keyspace: string expected";
            if (message.cells != null && message.hasOwnProperty("cells")) {
                if (!Array.isArray(message.cells))
                    return "cells: array expected";
                for (var i = 0; i < message.cells.length; ++i)
                    if (!$util.isString(message.cells[i]))
                        return "cells: string[] expected";
            }
            return null;
        };

        /**
         * Creates a GetSrvKeyspacesRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.GetSrvKeyspacesRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.GetSrvKeyspacesRequest} GetSrvKeyspacesRequest
         */
        GetSrvKeyspacesRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.GetSrvKeyspacesRequest)
                return object;
            var message = new $root.vtctldata.GetSrvKeyspacesRequest();
            if (object.keyspace != null)
                message.keyspace = String(object.keyspace);
            if (object.cells) {
                if (!Array.isArray(object.cells))
                    throw TypeError(".vtctldata.GetSrvKeyspacesRequest.cells: array expected");
                message.cells = [];
                for (var i = 0; i < object.cells.length; ++i)
                    message.cells[i] = String(object.cells[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetSrvKeyspacesRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.GetSrvKeyspacesRequest
         * @static
         * @param {vtctldata.GetSrvKeyspacesRequest} message GetSrvKeyspacesRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetSrvKeyspacesRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.cells = [];
            if (options.defaults)
                object.keyspace = "";
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                object.keyspace = message.keyspace;
            if (message.cells && message.cells.length) {
                object.cells = [];
                for (var j = 0; j < message.cells.length; ++j)
                    object.cells[j] = message.cells[j];
            }
            return object;
        };

        /**
         * Converts this GetSrvKeyspacesRequest to JSON.
         * @function toJSON
         * @memberof vtctldata.GetSrvKeyspacesRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetSrvKeyspacesRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetSrvKeyspacesRequest;
    })();

    vtctldata.GetSrvKeyspacesResponse = (function() {

        /**
         * Properties of a GetSrvKeyspacesResponse.
         * @memberof vtctldata
         * @interface IGetSrvKeyspacesResponse
         * @property {Object.<string,topodata.ISrvKeyspace>|null} [srv_keyspaces] GetSrvKeyspacesResponse srv_keyspaces
         */

        /**
         * Constructs a new GetSrvKeyspacesResponse.
         * @memberof vtctldata
         * @classdesc Represents a GetSrvKeyspacesResponse.
         * @implements IGetSrvKeyspacesResponse
         * @constructor
         * @param {vtctldata.IGetSrvKeyspacesResponse=} [properties] Properties to set
         */
        function GetSrvKeyspacesResponse(properties) {
            this.srv_keyspaces = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetSrvKeyspacesResponse srv_keyspaces.
         * @member {Object.<string,topodata.ISrvKeyspace>} srv_keyspaces
         * @memberof vtctldata.GetSrvKeyspacesResponse
         * @instance
         */
        GetSrvKeyspacesResponse.prototype.srv_keyspaces = $util.emptyObject;

        /**
         * Creates a new GetSrvKeyspacesResponse instance using the specified properties.
         * @function create
         * @memberof vtctldata.GetSrvKeyspacesResponse
         * @static
         * @param {vtctldata.IGetSrvKeyspacesResponse=} [properties] Properties to set
         * @returns {vtctldata.GetSrvKeyspacesResponse} GetSrvKeyspacesResponse instance
         */
        GetSrvKeyspacesResponse.create = function create(properties) {
            return new GetSrvKeyspacesResponse(properties);
        };

        /**
         * Encodes the specified GetSrvKeyspacesResponse message. Does not implicitly {@link vtctldata.GetSrvKeyspacesResponse.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.GetSrvKeyspacesResponse
         * @static
         * @param {vtctldata.IGetSrvKeyspacesResponse} message GetSrvKeyspacesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSrvKeyspacesResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.srv_keyspaces != null && Object.hasOwnProperty.call(message, "srv_keyspaces"))
                for (var keys = Object.keys(message.srv_keyspaces), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.topodata.SrvKeyspace.encode(message.srv_keyspaces[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            return writer;
        };

        /**
         * Encodes the specified GetSrvKeyspacesResponse message, length delimited. Does not implicitly {@link vtctldata.GetSrvKeyspacesResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.GetSrvKeyspacesResponse
         * @static
         * @param {vtctldata.IGetSrvKeyspacesResponse} message GetSrvKeyspacesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSrvKeyspacesResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetSrvKeyspacesResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.GetSrvKeyspacesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.GetSrvKeyspacesResponse} GetSrvKeyspacesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSrvKeyspacesResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.GetSrvKeyspacesResponse(), key, value;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (message.srv_keyspaces === $util.emptyObject)
                        message.srv_keyspaces = {};
                    var end2 = reader.uint32() + reader.pos;
                    key = "";
                    value = null;
                    while (reader.pos < end2) {
                        var tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.string();
                            break;
                        case 2:
                            value = $root.topodata.SrvKeyspace.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.srv_keyspaces[key] = value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetSrvKeyspacesResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.GetSrvKeyspacesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.GetSrvKeyspacesResponse} GetSrvKeyspacesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSrvKeyspacesResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetSrvKeyspacesResponse message.
         * @function verify
         * @memberof vtctldata.GetSrvKeyspacesResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetSrvKeyspacesResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.srv_keyspaces != null && message.hasOwnProperty("srv_keyspaces")) {
                if (!$util.isObject(message.srv_keyspaces))
                    return "srv_keyspaces: object expected";
                var key = Object.keys(message.srv_keyspaces);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.topodata.SrvKeyspace.verify(message.srv_keyspaces[key[i]]);
                    if (error)
                        return "srv_keyspaces." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetSrvKeyspacesResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.GetSrvKeyspacesResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.GetSrvKeyspacesResponse} GetSrvKeyspacesResponse
         */
        GetSrvKeyspacesResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.GetSrvKeyspacesResponse)
                return object;
            var message = new $root.vtctldata.GetSrvKeyspacesResponse();
            if (object.srv_keyspaces) {
                if (typeof object.srv_keyspaces !== "object")
                    throw TypeError(".vtctldata.GetSrvKeyspacesResponse.srv_keyspaces: object expected");
                message.srv_keyspaces = {};
                for (var keys = Object.keys(object.srv_keyspaces), i = 0; i < keys.length; ++i) {
                    if (typeof object.srv_keyspaces[keys[i]] !== "object")
                        throw TypeError(".vtctldata.GetSrvKeyspacesResponse.srv_keyspaces: object expected");
                    message.srv_keyspaces[keys[i]] = $root.topodata.SrvKeyspace.fromObject(object.srv_keyspaces[keys[i]]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetSrvKeyspacesResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.GetSrvKeyspacesResponse
         * @static
         * @param {vtctldata.GetSrvKeyspacesResponse} message GetSrvKeyspacesResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetSrvKeyspacesResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults)
                object.srv_keyspaces = {};
            var keys2;
            if (message.srv_keyspaces && (keys2 = Object.keys(message.srv_keyspaces)).length) {
                object.srv_keyspaces = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.srv_keyspaces[keys2[j]] = $root.topodata.SrvKeyspace.toObject(message.srv_keyspaces[keys2[j]], options);
            }
            return object;
        };

        /**
         * Converts this GetSrvKeyspacesResponse to JSON.
         * @function toJSON
         * @memberof vtctldata.GetSrvKeyspacesResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetSrvKeyspacesResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetSrvKeyspacesResponse;
    })();

    vtctldata.GetSrvVSchemaRequest = (function() {

        /**
         * Properties of a GetSrvVSchemaRequest.
         * @memberof vtctldata
         * @interface IGetSrvVSchemaRequest
         * @property {string|null} [cell] GetSrvVSchemaRequest cell
         */

        /**
         * Constructs a new GetSrvVSchemaRequest.
         * @memberof vtctldata
         * @classdesc Represents a GetSrvVSchemaRequest.
         * @implements IGetSrvVSchemaRequest
         * @constructor
         * @param {vtctldata.IGetSrvVSchemaRequest=} [properties] Properties to set
         */
        function GetSrvVSchemaRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetSrvVSchemaRequest cell.
         * @member {string} cell
         * @memberof vtctldata.GetSrvVSchemaRequest
         * @instance
         */
        GetSrvVSchemaRequest.prototype.cell = "";

        /**
         * Creates a new GetSrvVSchemaRequest instance using the specified properties.
         * @function create
         * @memberof vtctldata.GetSrvVSchemaRequest
         * @static
         * @param {vtctldata.IGetSrvVSchemaRequest=} [properties] Properties to set
         * @returns {vtctldata.GetSrvVSchemaRequest} GetSrvVSchemaRequest instance
         */
        GetSrvVSchemaRequest.create = function create(properties) {
            return new GetSrvVSchemaRequest(properties);
        };

        /**
         * Encodes the specified GetSrvVSchemaRequest message. Does not implicitly {@link vtctldata.GetSrvVSchemaRequest.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.GetSrvVSchemaRequest
         * @static
         * @param {vtctldata.IGetSrvVSchemaRequest} message GetSrvVSchemaRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSrvVSchemaRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cell != null && Object.hasOwnProperty.call(message, "cell"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.cell);
            return writer;
        };

        /**
         * Encodes the specified GetSrvVSchemaRequest message, length delimited. Does not implicitly {@link vtctldata.GetSrvVSchemaRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.GetSrvVSchemaRequest
         * @static
         * @param {vtctldata.IGetSrvVSchemaRequest} message GetSrvVSchemaRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSrvVSchemaRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetSrvVSchemaRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.GetSrvVSchemaRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.GetSrvVSchemaRequest} GetSrvVSchemaRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSrvVSchemaRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.GetSrvVSchemaRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.cell = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetSrvVSchemaRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.GetSrvVSchemaRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.GetSrvVSchemaRequest} GetSrvVSchemaRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSrvVSchemaRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetSrvVSchemaRequest message.
         * @function verify
         * @memberof vtctldata.GetSrvVSchemaRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetSrvVSchemaRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cell != null && message.hasOwnProperty("cell"))
                if (!$util.isString(message.cell))
                    return "cell: string expected";
            return null;
        };

        /**
         * Creates a GetSrvVSchemaRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.GetSrvVSchemaRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.GetSrvVSchemaRequest} GetSrvVSchemaRequest
         */
        GetSrvVSchemaRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.GetSrvVSchemaRequest)
                return object;
            var message = new $root.vtctldata.GetSrvVSchemaRequest();
            if (object.cell != null)
                message.cell = String(object.cell);
            return message;
        };

        /**
         * Creates a plain object from a GetSrvVSchemaRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.GetSrvVSchemaRequest
         * @static
         * @param {vtctldata.GetSrvVSchemaRequest} message GetSrvVSchemaRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetSrvVSchemaRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.cell = "";
            if (message.cell != null && message.hasOwnProperty("cell"))
                object.cell = message.cell;
            return object;
        };

        /**
         * Converts this GetSrvVSchemaRequest to JSON.
         * @function toJSON
         * @memberof vtctldata.GetSrvVSchemaRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetSrvVSchemaRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetSrvVSchemaRequest;
    })();

    vtctldata.GetSrvVSchemaResponse = (function() {

        /**
         * Properties of a GetSrvVSchemaResponse.
         * @memberof vtctldata
         * @interface IGetSrvVSchemaResponse
         * @property {vschema.ISrvVSchema|null} [srv_v_schema] GetSrvVSchemaResponse srv_v_schema
         */

        /**
         * Constructs a new GetSrvVSchemaResponse.
         * @memberof vtctldata
         * @classdesc Represents a GetSrvVSchemaResponse.
         * @implements IGetSrvVSchemaResponse
         * @constructor
         * @param {vtctldata.IGetSrvVSchemaResponse=} [properties] Properties to set
         */
        function GetSrvVSchemaResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetSrvVSchemaResponse srv_v_schema.
         * @member {vschema.ISrvVSchema|null|undefined} srv_v_schema
         * @memberof vtctldata.GetSrvVSchemaResponse
         * @instance
         */
        GetSrvVSchemaResponse.prototype.srv_v_schema = null;

        /**
         * Creates a new GetSrvVSchemaResponse instance using the specified properties.
         * @function create
         * @memberof vtctldata.GetSrvVSchemaResponse
         * @static
         * @param {vtctldata.IGetSrvVSchemaResponse=} [properties] Properties to set
         * @returns {vtctldata.GetSrvVSchemaResponse} GetSrvVSchemaResponse instance
         */
        GetSrvVSchemaResponse.create = function create(properties) {
            return new GetSrvVSchemaResponse(properties);
        };

        /**
         * Encodes the specified GetSrvVSchemaResponse message. Does not implicitly {@link vtctldata.GetSrvVSchemaResponse.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.GetSrvVSchemaResponse
         * @static
         * @param {vtctldata.IGetSrvVSchemaResponse} message GetSrvVSchemaResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSrvVSchemaResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.srv_v_schema != null && Object.hasOwnProperty.call(message, "srv_v_schema"))
                $root.vschema.SrvVSchema.encode(message.srv_v_schema, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetSrvVSchemaResponse message, length delimited. Does not implicitly {@link vtctldata.GetSrvVSchemaResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.GetSrvVSchemaResponse
         * @static
         * @param {vtctldata.IGetSrvVSchemaResponse} message GetSrvVSchemaResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSrvVSchemaResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetSrvVSchemaResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.GetSrvVSchemaResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.GetSrvVSchemaResponse} GetSrvVSchemaResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSrvVSchemaResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.GetSrvVSchemaResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.srv_v_schema = $root.vschema.SrvVSchema.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetSrvVSchemaResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.GetSrvVSchemaResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.GetSrvVSchemaResponse} GetSrvVSchemaResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSrvVSchemaResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetSrvVSchemaResponse message.
         * @function verify
         * @memberof vtctldata.GetSrvVSchemaResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetSrvVSchemaResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.srv_v_schema != null && message.hasOwnProperty("srv_v_schema")) {
                var error = $root.vschema.SrvVSchema.verify(message.srv_v_schema);
                if (error)
                    return "srv_v_schema." + error;
            }
            return null;
        };

        /**
         * Creates a GetSrvVSchemaResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.GetSrvVSchemaResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.GetSrvVSchemaResponse} GetSrvVSchemaResponse
         */
        GetSrvVSchemaResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.GetSrvVSchemaResponse)
                return object;
            var message = new $root.vtctldata.GetSrvVSchemaResponse();
            if (object.srv_v_schema != null) {
                if (typeof object.srv_v_schema !== "object")
                    throw TypeError(".vtctldata.GetSrvVSchemaResponse.srv_v_schema: object expected");
                message.srv_v_schema = $root.vschema.SrvVSchema.fromObject(object.srv_v_schema);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetSrvVSchemaResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.GetSrvVSchemaResponse
         * @static
         * @param {vtctldata.GetSrvVSchemaResponse} message GetSrvVSchemaResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetSrvVSchemaResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.srv_v_schema = null;
            if (message.srv_v_schema != null && message.hasOwnProperty("srv_v_schema"))
                object.srv_v_schema = $root.vschema.SrvVSchema.toObject(message.srv_v_schema, options);
            return object;
        };

        /**
         * Converts this GetSrvVSchemaResponse to JSON.
         * @function toJSON
         * @memberof vtctldata.GetSrvVSchemaResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetSrvVSchemaResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetSrvVSchemaResponse;
    })();

    vtctldata.GetTabletRequest = (function() {

        /**
         * Properties of a GetTabletRequest.
         * @memberof vtctldata
         * @interface IGetTabletRequest
         * @property {topodata.ITabletAlias|null} [tablet_alias] GetTabletRequest tablet_alias
         */

        /**
         * Constructs a new GetTabletRequest.
         * @memberof vtctldata
         * @classdesc Represents a GetTabletRequest.
         * @implements IGetTabletRequest
         * @constructor
         * @param {vtctldata.IGetTabletRequest=} [properties] Properties to set
         */
        function GetTabletRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetTabletRequest tablet_alias.
         * @member {topodata.ITabletAlias|null|undefined} tablet_alias
         * @memberof vtctldata.GetTabletRequest
         * @instance
         */
        GetTabletRequest.prototype.tablet_alias = null;

        /**
         * Creates a new GetTabletRequest instance using the specified properties.
         * @function create
         * @memberof vtctldata.GetTabletRequest
         * @static
         * @param {vtctldata.IGetTabletRequest=} [properties] Properties to set
         * @returns {vtctldata.GetTabletRequest} GetTabletRequest instance
         */
        GetTabletRequest.create = function create(properties) {
            return new GetTabletRequest(properties);
        };

        /**
         * Encodes the specified GetTabletRequest message. Does not implicitly {@link vtctldata.GetTabletRequest.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.GetTabletRequest
         * @static
         * @param {vtctldata.IGetTabletRequest} message GetTabletRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTabletRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tablet_alias != null && Object.hasOwnProperty.call(message, "tablet_alias"))
                $root.topodata.TabletAlias.encode(message.tablet_alias, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetTabletRequest message, length delimited. Does not implicitly {@link vtctldata.GetTabletRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.GetTabletRequest
         * @static
         * @param {vtctldata.IGetTabletRequest} message GetTabletRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTabletRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetTabletRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.GetTabletRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.GetTabletRequest} GetTabletRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTabletRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.GetTabletRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tablet_alias = $root.topodata.TabletAlias.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetTabletRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.GetTabletRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.GetTabletRequest} GetTabletRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTabletRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetTabletRequest message.
         * @function verify
         * @memberof vtctldata.GetTabletRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetTabletRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tablet_alias != null && message.hasOwnProperty("tablet_alias")) {
                var error = $root.topodata.TabletAlias.verify(message.tablet_alias);
                if (error)
                    return "tablet_alias." + error;
            }
            return null;
        };

        /**
         * Creates a GetTabletRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.GetTabletRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.GetTabletRequest} GetTabletRequest
         */
        GetTabletRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.GetTabletRequest)
                return object;
            var message = new $root.vtctldata.GetTabletRequest();
            if (object.tablet_alias != null) {
                if (typeof object.tablet_alias !== "object")
                    throw TypeError(".vtctldata.GetTabletRequest.tablet_alias: object expected");
                message.tablet_alias = $root.topodata.TabletAlias.fromObject(object.tablet_alias);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetTabletRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.GetTabletRequest
         * @static
         * @param {vtctldata.GetTabletRequest} message GetTabletRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetTabletRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.tablet_alias = null;
            if (message.tablet_alias != null && message.hasOwnProperty("tablet_alias"))
                object.tablet_alias = $root.topodata.TabletAlias.toObject(message.tablet_alias, options);
            return object;
        };

        /**
         * Converts this GetTabletRequest to JSON.
         * @function toJSON
         * @memberof vtctldata.GetTabletRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetTabletRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetTabletRequest;
    })();

    vtctldata.GetTabletResponse = (function() {

        /**
         * Properties of a GetTabletResponse.
         * @memberof vtctldata
         * @interface IGetTabletResponse
         * @property {topodata.ITablet|null} [tablet] GetTabletResponse tablet
         */

        /**
         * Constructs a new GetTabletResponse.
         * @memberof vtctldata
         * @classdesc Represents a GetTabletResponse.
         * @implements IGetTabletResponse
         * @constructor
         * @param {vtctldata.IGetTabletResponse=} [properties] Properties to set
         */
        function GetTabletResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetTabletResponse tablet.
         * @member {topodata.ITablet|null|undefined} tablet
         * @memberof vtctldata.GetTabletResponse
         * @instance
         */
        GetTabletResponse.prototype.tablet = null;

        /**
         * Creates a new GetTabletResponse instance using the specified properties.
         * @function create
         * @memberof vtctldata.GetTabletResponse
         * @static
         * @param {vtctldata.IGetTabletResponse=} [properties] Properties to set
         * @returns {vtctldata.GetTabletResponse} GetTabletResponse instance
         */
        GetTabletResponse.create = function create(properties) {
            return new GetTabletResponse(properties);
        };

        /**
         * Encodes the specified GetTabletResponse message. Does not implicitly {@link vtctldata.GetTabletResponse.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.GetTabletResponse
         * @static
         * @param {vtctldata.IGetTabletResponse} message GetTabletResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTabletResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tablet != null && Object.hasOwnProperty.call(message, "tablet"))
                $root.topodata.Tablet.encode(message.tablet, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetTabletResponse message, length delimited. Does not implicitly {@link vtctldata.GetTabletResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.GetTabletResponse
         * @static
         * @param {vtctldata.IGetTabletResponse} message GetTabletResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTabletResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetTabletResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.GetTabletResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.GetTabletResponse} GetTabletResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTabletResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.GetTabletResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tablet = $root.topodata.Tablet.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetTabletResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.GetTabletResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.GetTabletResponse} GetTabletResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTabletResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetTabletResponse message.
         * @function verify
         * @memberof vtctldata.GetTabletResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetTabletResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tablet != null && message.hasOwnProperty("tablet")) {
                var error = $root.topodata.Tablet.verify(message.tablet);
                if (error)
                    return "tablet." + error;
            }
            return null;
        };

        /**
         * Creates a GetTabletResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.GetTabletResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.GetTabletResponse} GetTabletResponse
         */
        GetTabletResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.GetTabletResponse)
                return object;
            var message = new $root.vtctldata.GetTabletResponse();
            if (object.tablet != null) {
                if (typeof object.tablet !== "object")
                    throw TypeError(".vtctldata.GetTabletResponse.tablet: object expected");
                message.tablet = $root.topodata.Tablet.fromObject(object.tablet);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetTabletResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.GetTabletResponse
         * @static
         * @param {vtctldata.GetTabletResponse} message GetTabletResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetTabletResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.tablet = null;
            if (message.tablet != null && message.hasOwnProperty("tablet"))
                object.tablet = $root.topodata.Tablet.toObject(message.tablet, options);
            return object;
        };

        /**
         * Converts this GetTabletResponse to JSON.
         * @function toJSON
         * @memberof vtctldata.GetTabletResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetTabletResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetTabletResponse;
    })();

    vtctldata.GetTabletsRequest = (function() {

        /**
         * Properties of a GetTabletsRequest.
         * @memberof vtctldata
         * @interface IGetTabletsRequest
         * @property {string|null} [keyspace] GetTabletsRequest keyspace
         * @property {string|null} [shard] GetTabletsRequest shard
         * @property {Array.<string>|null} [cells] GetTabletsRequest cells
         * @property {boolean|null} [strict] GetTabletsRequest strict
         * @property {Array.<topodata.ITabletAlias>|null} [tablet_aliases] GetTabletsRequest tablet_aliases
         */

        /**
         * Constructs a new GetTabletsRequest.
         * @memberof vtctldata
         * @classdesc Represents a GetTabletsRequest.
         * @implements IGetTabletsRequest
         * @constructor
         * @param {vtctldata.IGetTabletsRequest=} [properties] Properties to set
         */
        function GetTabletsRequest(properties) {
            this.cells = [];
            this.tablet_aliases = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetTabletsRequest keyspace.
         * @member {string} keyspace
         * @memberof vtctldata.GetTabletsRequest
         * @instance
         */
        GetTabletsRequest.prototype.keyspace = "";

        /**
         * GetTabletsRequest shard.
         * @member {string} shard
         * @memberof vtctldata.GetTabletsRequest
         * @instance
         */
        GetTabletsRequest.prototype.shard = "";

        /**
         * GetTabletsRequest cells.
         * @member {Array.<string>} cells
         * @memberof vtctldata.GetTabletsRequest
         * @instance
         */
        GetTabletsRequest.prototype.cells = $util.emptyArray;

        /**
         * GetTabletsRequest strict.
         * @member {boolean} strict
         * @memberof vtctldata.GetTabletsRequest
         * @instance
         */
        GetTabletsRequest.prototype.strict = false;

        /**
         * GetTabletsRequest tablet_aliases.
         * @member {Array.<topodata.ITabletAlias>} tablet_aliases
         * @memberof vtctldata.GetTabletsRequest
         * @instance
         */
        GetTabletsRequest.prototype.tablet_aliases = $util.emptyArray;

        /**
         * Creates a new GetTabletsRequest instance using the specified properties.
         * @function create
         * @memberof vtctldata.GetTabletsRequest
         * @static
         * @param {vtctldata.IGetTabletsRequest=} [properties] Properties to set
         * @returns {vtctldata.GetTabletsRequest} GetTabletsRequest instance
         */
        GetTabletsRequest.create = function create(properties) {
            return new GetTabletsRequest(properties);
        };

        /**
         * Encodes the specified GetTabletsRequest message. Does not implicitly {@link vtctldata.GetTabletsRequest.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.GetTabletsRequest
         * @static
         * @param {vtctldata.IGetTabletsRequest} message GetTabletsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTabletsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keyspace != null && Object.hasOwnProperty.call(message, "keyspace"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.keyspace);
            if (message.shard != null && Object.hasOwnProperty.call(message, "shard"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.shard);
            if (message.cells != null && message.cells.length)
                for (var i = 0; i < message.cells.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.cells[i]);
            if (message.strict != null && Object.hasOwnProperty.call(message, "strict"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.strict);
            if (message.tablet_aliases != null && message.tablet_aliases.length)
                for (var i = 0; i < message.tablet_aliases.length; ++i)
                    $root.topodata.TabletAlias.encode(message.tablet_aliases[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetTabletsRequest message, length delimited. Does not implicitly {@link vtctldata.GetTabletsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.GetTabletsRequest
         * @static
         * @param {vtctldata.IGetTabletsRequest} message GetTabletsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTabletsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetTabletsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.GetTabletsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.GetTabletsRequest} GetTabletsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTabletsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.GetTabletsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.keyspace = reader.string();
                    break;
                case 2:
                    message.shard = reader.string();
                    break;
                case 3:
                    if (!(message.cells && message.cells.length))
                        message.cells = [];
                    message.cells.push(reader.string());
                    break;
                case 4:
                    message.strict = reader.bool();
                    break;
                case 5:
                    if (!(message.tablet_aliases && message.tablet_aliases.length))
                        message.tablet_aliases = [];
                    message.tablet_aliases.push($root.topodata.TabletAlias.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetTabletsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.GetTabletsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.GetTabletsRequest} GetTabletsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTabletsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetTabletsRequest message.
         * @function verify
         * @memberof vtctldata.GetTabletsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetTabletsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                if (!$util.isString(message.keyspace))
                    return "keyspace: string expected";
            if (message.shard != null && message.hasOwnProperty("shard"))
                if (!$util.isString(message.shard))
                    return "shard: string expected";
            if (message.cells != null && message.hasOwnProperty("cells")) {
                if (!Array.isArray(message.cells))
                    return "cells: array expected";
                for (var i = 0; i < message.cells.length; ++i)
                    if (!$util.isString(message.cells[i]))
                        return "cells: string[] expected";
            }
            if (message.strict != null && message.hasOwnProperty("strict"))
                if (typeof message.strict !== "boolean")
                    return "strict: boolean expected";
            if (message.tablet_aliases != null && message.hasOwnProperty("tablet_aliases")) {
                if (!Array.isArray(message.tablet_aliases))
                    return "tablet_aliases: array expected";
                for (var i = 0; i < message.tablet_aliases.length; ++i) {
                    var error = $root.topodata.TabletAlias.verify(message.tablet_aliases[i]);
                    if (error)
                        return "tablet_aliases." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetTabletsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.GetTabletsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.GetTabletsRequest} GetTabletsRequest
         */
        GetTabletsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.GetTabletsRequest)
                return object;
            var message = new $root.vtctldata.GetTabletsRequest();
            if (object.keyspace != null)
                message.keyspace = String(object.keyspace);
            if (object.shard != null)
                message.shard = String(object.shard);
            if (object.cells) {
                if (!Array.isArray(object.cells))
                    throw TypeError(".vtctldata.GetTabletsRequest.cells: array expected");
                message.cells = [];
                for (var i = 0; i < object.cells.length; ++i)
                    message.cells[i] = String(object.cells[i]);
            }
            if (object.strict != null)
                message.strict = Boolean(object.strict);
            if (object.tablet_aliases) {
                if (!Array.isArray(object.tablet_aliases))
                    throw TypeError(".vtctldata.GetTabletsRequest.tablet_aliases: array expected");
                message.tablet_aliases = [];
                for (var i = 0; i < object.tablet_aliases.length; ++i) {
                    if (typeof object.tablet_aliases[i] !== "object")
                        throw TypeError(".vtctldata.GetTabletsRequest.tablet_aliases: object expected");
                    message.tablet_aliases[i] = $root.topodata.TabletAlias.fromObject(object.tablet_aliases[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetTabletsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.GetTabletsRequest
         * @static
         * @param {vtctldata.GetTabletsRequest} message GetTabletsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetTabletsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.cells = [];
                object.tablet_aliases = [];
            }
            if (options.defaults) {
                object.keyspace = "";
                object.shard = "";
                object.strict = false;
            }
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                object.keyspace = message.keyspace;
            if (message.shard != null && message.hasOwnProperty("shard"))
                object.shard = message.shard;
            if (message.cells && message.cells.length) {
                object.cells = [];
                for (var j = 0; j < message.cells.length; ++j)
                    object.cells[j] = message.cells[j];
            }
            if (message.strict != null && message.hasOwnProperty("strict"))
                object.strict = message.strict;
            if (message.tablet_aliases && message.tablet_aliases.length) {
                object.tablet_aliases = [];
                for (var j = 0; j < message.tablet_aliases.length; ++j)
                    object.tablet_aliases[j] = $root.topodata.TabletAlias.toObject(message.tablet_aliases[j], options);
            }
            return object;
        };

        /**
         * Converts this GetTabletsRequest to JSON.
         * @function toJSON
         * @memberof vtctldata.GetTabletsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetTabletsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetTabletsRequest;
    })();

    vtctldata.GetTabletsResponse = (function() {

        /**
         * Properties of a GetTabletsResponse.
         * @memberof vtctldata
         * @interface IGetTabletsResponse
         * @property {Array.<topodata.ITablet>|null} [tablets] GetTabletsResponse tablets
         */

        /**
         * Constructs a new GetTabletsResponse.
         * @memberof vtctldata
         * @classdesc Represents a GetTabletsResponse.
         * @implements IGetTabletsResponse
         * @constructor
         * @param {vtctldata.IGetTabletsResponse=} [properties] Properties to set
         */
        function GetTabletsResponse(properties) {
            this.tablets = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetTabletsResponse tablets.
         * @member {Array.<topodata.ITablet>} tablets
         * @memberof vtctldata.GetTabletsResponse
         * @instance
         */
        GetTabletsResponse.prototype.tablets = $util.emptyArray;

        /**
         * Creates a new GetTabletsResponse instance using the specified properties.
         * @function create
         * @memberof vtctldata.GetTabletsResponse
         * @static
         * @param {vtctldata.IGetTabletsResponse=} [properties] Properties to set
         * @returns {vtctldata.GetTabletsResponse} GetTabletsResponse instance
         */
        GetTabletsResponse.create = function create(properties) {
            return new GetTabletsResponse(properties);
        };

        /**
         * Encodes the specified GetTabletsResponse message. Does not implicitly {@link vtctldata.GetTabletsResponse.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.GetTabletsResponse
         * @static
         * @param {vtctldata.IGetTabletsResponse} message GetTabletsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTabletsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tablets != null && message.tablets.length)
                for (var i = 0; i < message.tablets.length; ++i)
                    $root.topodata.Tablet.encode(message.tablets[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetTabletsResponse message, length delimited. Does not implicitly {@link vtctldata.GetTabletsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.GetTabletsResponse
         * @static
         * @param {vtctldata.IGetTabletsResponse} message GetTabletsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTabletsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetTabletsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.GetTabletsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.GetTabletsResponse} GetTabletsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTabletsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.GetTabletsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.tablets && message.tablets.length))
                        message.tablets = [];
                    message.tablets.push($root.topodata.Tablet.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetTabletsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.GetTabletsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.GetTabletsResponse} GetTabletsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTabletsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetTabletsResponse message.
         * @function verify
         * @memberof vtctldata.GetTabletsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetTabletsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tablets != null && message.hasOwnProperty("tablets")) {
                if (!Array.isArray(message.tablets))
                    return "tablets: array expected";
                for (var i = 0; i < message.tablets.length; ++i) {
                    var error = $root.topodata.Tablet.verify(message.tablets[i]);
                    if (error)
                        return "tablets." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetTabletsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.GetTabletsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.GetTabletsResponse} GetTabletsResponse
         */
        GetTabletsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.GetTabletsResponse)
                return object;
            var message = new $root.vtctldata.GetTabletsResponse();
            if (object.tablets) {
                if (!Array.isArray(object.tablets))
                    throw TypeError(".vtctldata.GetTabletsResponse.tablets: array expected");
                message.tablets = [];
                for (var i = 0; i < object.tablets.length; ++i) {
                    if (typeof object.tablets[i] !== "object")
                        throw TypeError(".vtctldata.GetTabletsResponse.tablets: object expected");
                    message.tablets[i] = $root.topodata.Tablet.fromObject(object.tablets[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetTabletsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.GetTabletsResponse
         * @static
         * @param {vtctldata.GetTabletsResponse} message GetTabletsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetTabletsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.tablets = [];
            if (message.tablets && message.tablets.length) {
                object.tablets = [];
                for (var j = 0; j < message.tablets.length; ++j)
                    object.tablets[j] = $root.topodata.Tablet.toObject(message.tablets[j], options);
            }
            return object;
        };

        /**
         * Converts this GetTabletsResponse to JSON.
         * @function toJSON
         * @memberof vtctldata.GetTabletsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetTabletsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetTabletsResponse;
    })();

    vtctldata.GetVSchemaRequest = (function() {

        /**
         * Properties of a GetVSchemaRequest.
         * @memberof vtctldata
         * @interface IGetVSchemaRequest
         * @property {string|null} [keyspace] GetVSchemaRequest keyspace
         */

        /**
         * Constructs a new GetVSchemaRequest.
         * @memberof vtctldata
         * @classdesc Represents a GetVSchemaRequest.
         * @implements IGetVSchemaRequest
         * @constructor
         * @param {vtctldata.IGetVSchemaRequest=} [properties] Properties to set
         */
        function GetVSchemaRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetVSchemaRequest keyspace.
         * @member {string} keyspace
         * @memberof vtctldata.GetVSchemaRequest
         * @instance
         */
        GetVSchemaRequest.prototype.keyspace = "";

        /**
         * Creates a new GetVSchemaRequest instance using the specified properties.
         * @function create
         * @memberof vtctldata.GetVSchemaRequest
         * @static
         * @param {vtctldata.IGetVSchemaRequest=} [properties] Properties to set
         * @returns {vtctldata.GetVSchemaRequest} GetVSchemaRequest instance
         */
        GetVSchemaRequest.create = function create(properties) {
            return new GetVSchemaRequest(properties);
        };

        /**
         * Encodes the specified GetVSchemaRequest message. Does not implicitly {@link vtctldata.GetVSchemaRequest.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.GetVSchemaRequest
         * @static
         * @param {vtctldata.IGetVSchemaRequest} message GetVSchemaRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetVSchemaRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keyspace != null && Object.hasOwnProperty.call(message, "keyspace"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.keyspace);
            return writer;
        };

        /**
         * Encodes the specified GetVSchemaRequest message, length delimited. Does not implicitly {@link vtctldata.GetVSchemaRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.GetVSchemaRequest
         * @static
         * @param {vtctldata.IGetVSchemaRequest} message GetVSchemaRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetVSchemaRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetVSchemaRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.GetVSchemaRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.GetVSchemaRequest} GetVSchemaRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetVSchemaRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.GetVSchemaRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.keyspace = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetVSchemaRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.GetVSchemaRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.GetVSchemaRequest} GetVSchemaRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetVSchemaRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetVSchemaRequest message.
         * @function verify
         * @memberof vtctldata.GetVSchemaRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetVSchemaRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                if (!$util.isString(message.keyspace))
                    return "keyspace: string expected";
            return null;
        };

        /**
         * Creates a GetVSchemaRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.GetVSchemaRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.GetVSchemaRequest} GetVSchemaRequest
         */
        GetVSchemaRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.GetVSchemaRequest)
                return object;
            var message = new $root.vtctldata.GetVSchemaRequest();
            if (object.keyspace != null)
                message.keyspace = String(object.keyspace);
            return message;
        };

        /**
         * Creates a plain object from a GetVSchemaRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.GetVSchemaRequest
         * @static
         * @param {vtctldata.GetVSchemaRequest} message GetVSchemaRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetVSchemaRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.keyspace = "";
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                object.keyspace = message.keyspace;
            return object;
        };

        /**
         * Converts this GetVSchemaRequest to JSON.
         * @function toJSON
         * @memberof vtctldata.GetVSchemaRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetVSchemaRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetVSchemaRequest;
    })();

    vtctldata.GetVSchemaResponse = (function() {

        /**
         * Properties of a GetVSchemaResponse.
         * @memberof vtctldata
         * @interface IGetVSchemaResponse
         * @property {vschema.IKeyspace|null} [v_schema] GetVSchemaResponse v_schema
         */

        /**
         * Constructs a new GetVSchemaResponse.
         * @memberof vtctldata
         * @classdesc Represents a GetVSchemaResponse.
         * @implements IGetVSchemaResponse
         * @constructor
         * @param {vtctldata.IGetVSchemaResponse=} [properties] Properties to set
         */
        function GetVSchemaResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetVSchemaResponse v_schema.
         * @member {vschema.IKeyspace|null|undefined} v_schema
         * @memberof vtctldata.GetVSchemaResponse
         * @instance
         */
        GetVSchemaResponse.prototype.v_schema = null;

        /**
         * Creates a new GetVSchemaResponse instance using the specified properties.
         * @function create
         * @memberof vtctldata.GetVSchemaResponse
         * @static
         * @param {vtctldata.IGetVSchemaResponse=} [properties] Properties to set
         * @returns {vtctldata.GetVSchemaResponse} GetVSchemaResponse instance
         */
        GetVSchemaResponse.create = function create(properties) {
            return new GetVSchemaResponse(properties);
        };

        /**
         * Encodes the specified GetVSchemaResponse message. Does not implicitly {@link vtctldata.GetVSchemaResponse.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.GetVSchemaResponse
         * @static
         * @param {vtctldata.IGetVSchemaResponse} message GetVSchemaResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetVSchemaResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.v_schema != null && Object.hasOwnProperty.call(message, "v_schema"))
                $root.vschema.Keyspace.encode(message.v_schema, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetVSchemaResponse message, length delimited. Does not implicitly {@link vtctldata.GetVSchemaResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.GetVSchemaResponse
         * @static
         * @param {vtctldata.IGetVSchemaResponse} message GetVSchemaResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetVSchemaResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetVSchemaResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.GetVSchemaResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.GetVSchemaResponse} GetVSchemaResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetVSchemaResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.GetVSchemaResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.v_schema = $root.vschema.Keyspace.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetVSchemaResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.GetVSchemaResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.GetVSchemaResponse} GetVSchemaResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetVSchemaResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetVSchemaResponse message.
         * @function verify
         * @memberof vtctldata.GetVSchemaResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetVSchemaResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.v_schema != null && message.hasOwnProperty("v_schema")) {
                var error = $root.vschema.Keyspace.verify(message.v_schema);
                if (error)
                    return "v_schema." + error;
            }
            return null;
        };

        /**
         * Creates a GetVSchemaResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.GetVSchemaResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.GetVSchemaResponse} GetVSchemaResponse
         */
        GetVSchemaResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.GetVSchemaResponse)
                return object;
            var message = new $root.vtctldata.GetVSchemaResponse();
            if (object.v_schema != null) {
                if (typeof object.v_schema !== "object")
                    throw TypeError(".vtctldata.GetVSchemaResponse.v_schema: object expected");
                message.v_schema = $root.vschema.Keyspace.fromObject(object.v_schema);
            }
            return message;
        };

        /**
         * Creates a plain object from a GetVSchemaResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.GetVSchemaResponse
         * @static
         * @param {vtctldata.GetVSchemaResponse} message GetVSchemaResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetVSchemaResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.v_schema = null;
            if (message.v_schema != null && message.hasOwnProperty("v_schema"))
                object.v_schema = $root.vschema.Keyspace.toObject(message.v_schema, options);
            return object;
        };

        /**
         * Converts this GetVSchemaResponse to JSON.
         * @function toJSON
         * @memberof vtctldata.GetVSchemaResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetVSchemaResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetVSchemaResponse;
    })();

    vtctldata.GetWorkflowsRequest = (function() {

        /**
         * Properties of a GetWorkflowsRequest.
         * @memberof vtctldata
         * @interface IGetWorkflowsRequest
         * @property {string|null} [keyspace] GetWorkflowsRequest keyspace
         * @property {boolean|null} [active_only] GetWorkflowsRequest active_only
         */

        /**
         * Constructs a new GetWorkflowsRequest.
         * @memberof vtctldata
         * @classdesc Represents a GetWorkflowsRequest.
         * @implements IGetWorkflowsRequest
         * @constructor
         * @param {vtctldata.IGetWorkflowsRequest=} [properties] Properties to set
         */
        function GetWorkflowsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetWorkflowsRequest keyspace.
         * @member {string} keyspace
         * @memberof vtctldata.GetWorkflowsRequest
         * @instance
         */
        GetWorkflowsRequest.prototype.keyspace = "";

        /**
         * GetWorkflowsRequest active_only.
         * @member {boolean} active_only
         * @memberof vtctldata.GetWorkflowsRequest
         * @instance
         */
        GetWorkflowsRequest.prototype.active_only = false;

        /**
         * Creates a new GetWorkflowsRequest instance using the specified properties.
         * @function create
         * @memberof vtctldata.GetWorkflowsRequest
         * @static
         * @param {vtctldata.IGetWorkflowsRequest=} [properties] Properties to set
         * @returns {vtctldata.GetWorkflowsRequest} GetWorkflowsRequest instance
         */
        GetWorkflowsRequest.create = function create(properties) {
            return new GetWorkflowsRequest(properties);
        };

        /**
         * Encodes the specified GetWorkflowsRequest message. Does not implicitly {@link vtctldata.GetWorkflowsRequest.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.GetWorkflowsRequest
         * @static
         * @param {vtctldata.IGetWorkflowsRequest} message GetWorkflowsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetWorkflowsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keyspace != null && Object.hasOwnProperty.call(message, "keyspace"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.keyspace);
            if (message.active_only != null && Object.hasOwnProperty.call(message, "active_only"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.active_only);
            return writer;
        };

        /**
         * Encodes the specified GetWorkflowsRequest message, length delimited. Does not implicitly {@link vtctldata.GetWorkflowsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.GetWorkflowsRequest
         * @static
         * @param {vtctldata.IGetWorkflowsRequest} message GetWorkflowsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetWorkflowsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetWorkflowsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.GetWorkflowsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.GetWorkflowsRequest} GetWorkflowsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetWorkflowsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.GetWorkflowsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.keyspace = reader.string();
                    break;
                case 2:
                    message.active_only = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetWorkflowsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.GetWorkflowsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.GetWorkflowsRequest} GetWorkflowsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetWorkflowsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetWorkflowsRequest message.
         * @function verify
         * @memberof vtctldata.GetWorkflowsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetWorkflowsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                if (!$util.isString(message.keyspace))
                    return "keyspace: string expected";
            if (message.active_only != null && message.hasOwnProperty("active_only"))
                if (typeof message.active_only !== "boolean")
                    return "active_only: boolean expected";
            return null;
        };

        /**
         * Creates a GetWorkflowsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.GetWorkflowsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.GetWorkflowsRequest} GetWorkflowsRequest
         */
        GetWorkflowsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.GetWorkflowsRequest)
                return object;
            var message = new $root.vtctldata.GetWorkflowsRequest();
            if (object.keyspace != null)
                message.keyspace = String(object.keyspace);
            if (object.active_only != null)
                message.active_only = Boolean(object.active_only);
            return message;
        };

        /**
         * Creates a plain object from a GetWorkflowsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.GetWorkflowsRequest
         * @static
         * @param {vtctldata.GetWorkflowsRequest} message GetWorkflowsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetWorkflowsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.keyspace = "";
                object.active_only = false;
            }
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                object.keyspace = message.keyspace;
            if (message.active_only != null && message.hasOwnProperty("active_only"))
                object.active_only = message.active_only;
            return object;
        };

        /**
         * Converts this GetWorkflowsRequest to JSON.
         * @function toJSON
         * @memberof vtctldata.GetWorkflowsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetWorkflowsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetWorkflowsRequest;
    })();

    vtctldata.GetWorkflowsResponse = (function() {

        /**
         * Properties of a GetWorkflowsResponse.
         * @memberof vtctldata
         * @interface IGetWorkflowsResponse
         * @property {Array.<vtctldata.IWorkflow>|null} [workflows] GetWorkflowsResponse workflows
         */

        /**
         * Constructs a new GetWorkflowsResponse.
         * @memberof vtctldata
         * @classdesc Represents a GetWorkflowsResponse.
         * @implements IGetWorkflowsResponse
         * @constructor
         * @param {vtctldata.IGetWorkflowsResponse=} [properties] Properties to set
         */
        function GetWorkflowsResponse(properties) {
            this.workflows = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetWorkflowsResponse workflows.
         * @member {Array.<vtctldata.IWorkflow>} workflows
         * @memberof vtctldata.GetWorkflowsResponse
         * @instance
         */
        GetWorkflowsResponse.prototype.workflows = $util.emptyArray;

        /**
         * Creates a new GetWorkflowsResponse instance using the specified properties.
         * @function create
         * @memberof vtctldata.GetWorkflowsResponse
         * @static
         * @param {vtctldata.IGetWorkflowsResponse=} [properties] Properties to set
         * @returns {vtctldata.GetWorkflowsResponse} GetWorkflowsResponse instance
         */
        GetWorkflowsResponse.create = function create(properties) {
            return new GetWorkflowsResponse(properties);
        };

        /**
         * Encodes the specified GetWorkflowsResponse message. Does not implicitly {@link vtctldata.GetWorkflowsResponse.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.GetWorkflowsResponse
         * @static
         * @param {vtctldata.IGetWorkflowsResponse} message GetWorkflowsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetWorkflowsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.workflows != null && message.workflows.length)
                for (var i = 0; i < message.workflows.length; ++i)
                    $root.vtctldata.Workflow.encode(message.workflows[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetWorkflowsResponse message, length delimited. Does not implicitly {@link vtctldata.GetWorkflowsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.GetWorkflowsResponse
         * @static
         * @param {vtctldata.IGetWorkflowsResponse} message GetWorkflowsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetWorkflowsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetWorkflowsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.GetWorkflowsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.GetWorkflowsResponse} GetWorkflowsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetWorkflowsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.GetWorkflowsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.workflows && message.workflows.length))
                        message.workflows = [];
                    message.workflows.push($root.vtctldata.Workflow.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetWorkflowsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.GetWorkflowsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.GetWorkflowsResponse} GetWorkflowsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetWorkflowsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetWorkflowsResponse message.
         * @function verify
         * @memberof vtctldata.GetWorkflowsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetWorkflowsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.workflows != null && message.hasOwnProperty("workflows")) {
                if (!Array.isArray(message.workflows))
                    return "workflows: array expected";
                for (var i = 0; i < message.workflows.length; ++i) {
                    var error = $root.vtctldata.Workflow.verify(message.workflows[i]);
                    if (error)
                        return "workflows." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetWorkflowsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.GetWorkflowsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.GetWorkflowsResponse} GetWorkflowsResponse
         */
        GetWorkflowsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.GetWorkflowsResponse)
                return object;
            var message = new $root.vtctldata.GetWorkflowsResponse();
            if (object.workflows) {
                if (!Array.isArray(object.workflows))
                    throw TypeError(".vtctldata.GetWorkflowsResponse.workflows: array expected");
                message.workflows = [];
                for (var i = 0; i < object.workflows.length; ++i) {
                    if (typeof object.workflows[i] !== "object")
                        throw TypeError(".vtctldata.GetWorkflowsResponse.workflows: object expected");
                    message.workflows[i] = $root.vtctldata.Workflow.fromObject(object.workflows[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetWorkflowsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.GetWorkflowsResponse
         * @static
         * @param {vtctldata.GetWorkflowsResponse} message GetWorkflowsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetWorkflowsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.workflows = [];
            if (message.workflows && message.workflows.length) {
                object.workflows = [];
                for (var j = 0; j < message.workflows.length; ++j)
                    object.workflows[j] = $root.vtctldata.Workflow.toObject(message.workflows[j], options);
            }
            return object;
        };

        /**
         * Converts this GetWorkflowsResponse to JSON.
         * @function toJSON
         * @memberof vtctldata.GetWorkflowsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetWorkflowsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetWorkflowsResponse;
    })();

    vtctldata.InitShardPrimaryRequest = (function() {

        /**
         * Properties of an InitShardPrimaryRequest.
         * @memberof vtctldata
         * @interface IInitShardPrimaryRequest
         * @property {string|null} [keyspace] InitShardPrimaryRequest keyspace
         * @property {string|null} [shard] InitShardPrimaryRequest shard
         * @property {topodata.ITabletAlias|null} [primary_elect_tablet_alias] InitShardPrimaryRequest primary_elect_tablet_alias
         * @property {boolean|null} [force] InitShardPrimaryRequest force
         * @property {vttime.IDuration|null} [wait_replicas_timeout] InitShardPrimaryRequest wait_replicas_timeout
         */

        /**
         * Constructs a new InitShardPrimaryRequest.
         * @memberof vtctldata
         * @classdesc Represents an InitShardPrimaryRequest.
         * @implements IInitShardPrimaryRequest
         * @constructor
         * @param {vtctldata.IInitShardPrimaryRequest=} [properties] Properties to set
         */
        function InitShardPrimaryRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InitShardPrimaryRequest keyspace.
         * @member {string} keyspace
         * @memberof vtctldata.InitShardPrimaryRequest
         * @instance
         */
        InitShardPrimaryRequest.prototype.keyspace = "";

        /**
         * InitShardPrimaryRequest shard.
         * @member {string} shard
         * @memberof vtctldata.InitShardPrimaryRequest
         * @instance
         */
        InitShardPrimaryRequest.prototype.shard = "";

        /**
         * InitShardPrimaryRequest primary_elect_tablet_alias.
         * @member {topodata.ITabletAlias|null|undefined} primary_elect_tablet_alias
         * @memberof vtctldata.InitShardPrimaryRequest
         * @instance
         */
        InitShardPrimaryRequest.prototype.primary_elect_tablet_alias = null;

        /**
         * InitShardPrimaryRequest force.
         * @member {boolean} force
         * @memberof vtctldata.InitShardPrimaryRequest
         * @instance
         */
        InitShardPrimaryRequest.prototype.force = false;

        /**
         * InitShardPrimaryRequest wait_replicas_timeout.
         * @member {vttime.IDuration|null|undefined} wait_replicas_timeout
         * @memberof vtctldata.InitShardPrimaryRequest
         * @instance
         */
        InitShardPrimaryRequest.prototype.wait_replicas_timeout = null;

        /**
         * Creates a new InitShardPrimaryRequest instance using the specified properties.
         * @function create
         * @memberof vtctldata.InitShardPrimaryRequest
         * @static
         * @param {vtctldata.IInitShardPrimaryRequest=} [properties] Properties to set
         * @returns {vtctldata.InitShardPrimaryRequest} InitShardPrimaryRequest instance
         */
        InitShardPrimaryRequest.create = function create(properties) {
            return new InitShardPrimaryRequest(properties);
        };

        /**
         * Encodes the specified InitShardPrimaryRequest message. Does not implicitly {@link vtctldata.InitShardPrimaryRequest.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.InitShardPrimaryRequest
         * @static
         * @param {vtctldata.IInitShardPrimaryRequest} message InitShardPrimaryRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InitShardPrimaryRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keyspace != null && Object.hasOwnProperty.call(message, "keyspace"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.keyspace);
            if (message.shard != null && Object.hasOwnProperty.call(message, "shard"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.shard);
            if (message.primary_elect_tablet_alias != null && Object.hasOwnProperty.call(message, "primary_elect_tablet_alias"))
                $root.topodata.TabletAlias.encode(message.primary_elect_tablet_alias, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.force != null && Object.hasOwnProperty.call(message, "force"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.force);
            if (message.wait_replicas_timeout != null && Object.hasOwnProperty.call(message, "wait_replicas_timeout"))
                $root.vttime.Duration.encode(message.wait_replicas_timeout, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified InitShardPrimaryRequest message, length delimited. Does not implicitly {@link vtctldata.InitShardPrimaryRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.InitShardPrimaryRequest
         * @static
         * @param {vtctldata.IInitShardPrimaryRequest} message InitShardPrimaryRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InitShardPrimaryRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InitShardPrimaryRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.InitShardPrimaryRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.InitShardPrimaryRequest} InitShardPrimaryRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InitShardPrimaryRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.InitShardPrimaryRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.keyspace = reader.string();
                    break;
                case 2:
                    message.shard = reader.string();
                    break;
                case 3:
                    message.primary_elect_tablet_alias = $root.topodata.TabletAlias.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.force = reader.bool();
                    break;
                case 5:
                    message.wait_replicas_timeout = $root.vttime.Duration.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InitShardPrimaryRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.InitShardPrimaryRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.InitShardPrimaryRequest} InitShardPrimaryRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InitShardPrimaryRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InitShardPrimaryRequest message.
         * @function verify
         * @memberof vtctldata.InitShardPrimaryRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InitShardPrimaryRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                if (!$util.isString(message.keyspace))
                    return "keyspace: string expected";
            if (message.shard != null && message.hasOwnProperty("shard"))
                if (!$util.isString(message.shard))
                    return "shard: string expected";
            if (message.primary_elect_tablet_alias != null && message.hasOwnProperty("primary_elect_tablet_alias")) {
                var error = $root.topodata.TabletAlias.verify(message.primary_elect_tablet_alias);
                if (error)
                    return "primary_elect_tablet_alias." + error;
            }
            if (message.force != null && message.hasOwnProperty("force"))
                if (typeof message.force !== "boolean")
                    return "force: boolean expected";
            if (message.wait_replicas_timeout != null && message.hasOwnProperty("wait_replicas_timeout")) {
                var error = $root.vttime.Duration.verify(message.wait_replicas_timeout);
                if (error)
                    return "wait_replicas_timeout." + error;
            }
            return null;
        };

        /**
         * Creates an InitShardPrimaryRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.InitShardPrimaryRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.InitShardPrimaryRequest} InitShardPrimaryRequest
         */
        InitShardPrimaryRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.InitShardPrimaryRequest)
                return object;
            var message = new $root.vtctldata.InitShardPrimaryRequest();
            if (object.keyspace != null)
                message.keyspace = String(object.keyspace);
            if (object.shard != null)
                message.shard = String(object.shard);
            if (object.primary_elect_tablet_alias != null) {
                if (typeof object.primary_elect_tablet_alias !== "object")
                    throw TypeError(".vtctldata.InitShardPrimaryRequest.primary_elect_tablet_alias: object expected");
                message.primary_elect_tablet_alias = $root.topodata.TabletAlias.fromObject(object.primary_elect_tablet_alias);
            }
            if (object.force != null)
                message.force = Boolean(object.force);
            if (object.wait_replicas_timeout != null) {
                if (typeof object.wait_replicas_timeout !== "object")
                    throw TypeError(".vtctldata.InitShardPrimaryRequest.wait_replicas_timeout: object expected");
                message.wait_replicas_timeout = $root.vttime.Duration.fromObject(object.wait_replicas_timeout);
            }
            return message;
        };

        /**
         * Creates a plain object from an InitShardPrimaryRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.InitShardPrimaryRequest
         * @static
         * @param {vtctldata.InitShardPrimaryRequest} message InitShardPrimaryRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InitShardPrimaryRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.keyspace = "";
                object.shard = "";
                object.primary_elect_tablet_alias = null;
                object.force = false;
                object.wait_replicas_timeout = null;
            }
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                object.keyspace = message.keyspace;
            if (message.shard != null && message.hasOwnProperty("shard"))
                object.shard = message.shard;
            if (message.primary_elect_tablet_alias != null && message.hasOwnProperty("primary_elect_tablet_alias"))
                object.primary_elect_tablet_alias = $root.topodata.TabletAlias.toObject(message.primary_elect_tablet_alias, options);
            if (message.force != null && message.hasOwnProperty("force"))
                object.force = message.force;
            if (message.wait_replicas_timeout != null && message.hasOwnProperty("wait_replicas_timeout"))
                object.wait_replicas_timeout = $root.vttime.Duration.toObject(message.wait_replicas_timeout, options);
            return object;
        };

        /**
         * Converts this InitShardPrimaryRequest to JSON.
         * @function toJSON
         * @memberof vtctldata.InitShardPrimaryRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InitShardPrimaryRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return InitShardPrimaryRequest;
    })();

    vtctldata.InitShardPrimaryResponse = (function() {

        /**
         * Properties of an InitShardPrimaryResponse.
         * @memberof vtctldata
         * @interface IInitShardPrimaryResponse
         * @property {Array.<logutil.IEvent>|null} [events] InitShardPrimaryResponse events
         */

        /**
         * Constructs a new InitShardPrimaryResponse.
         * @memberof vtctldata
         * @classdesc Represents an InitShardPrimaryResponse.
         * @implements IInitShardPrimaryResponse
         * @constructor
         * @param {vtctldata.IInitShardPrimaryResponse=} [properties] Properties to set
         */
        function InitShardPrimaryResponse(properties) {
            this.events = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InitShardPrimaryResponse events.
         * @member {Array.<logutil.IEvent>} events
         * @memberof vtctldata.InitShardPrimaryResponse
         * @instance
         */
        InitShardPrimaryResponse.prototype.events = $util.emptyArray;

        /**
         * Creates a new InitShardPrimaryResponse instance using the specified properties.
         * @function create
         * @memberof vtctldata.InitShardPrimaryResponse
         * @static
         * @param {vtctldata.IInitShardPrimaryResponse=} [properties] Properties to set
         * @returns {vtctldata.InitShardPrimaryResponse} InitShardPrimaryResponse instance
         */
        InitShardPrimaryResponse.create = function create(properties) {
            return new InitShardPrimaryResponse(properties);
        };

        /**
         * Encodes the specified InitShardPrimaryResponse message. Does not implicitly {@link vtctldata.InitShardPrimaryResponse.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.InitShardPrimaryResponse
         * @static
         * @param {vtctldata.IInitShardPrimaryResponse} message InitShardPrimaryResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InitShardPrimaryResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.events != null && message.events.length)
                for (var i = 0; i < message.events.length; ++i)
                    $root.logutil.Event.encode(message.events[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified InitShardPrimaryResponse message, length delimited. Does not implicitly {@link vtctldata.InitShardPrimaryResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.InitShardPrimaryResponse
         * @static
         * @param {vtctldata.IInitShardPrimaryResponse} message InitShardPrimaryResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InitShardPrimaryResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InitShardPrimaryResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.InitShardPrimaryResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.InitShardPrimaryResponse} InitShardPrimaryResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InitShardPrimaryResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.InitShardPrimaryResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.events && message.events.length))
                        message.events = [];
                    message.events.push($root.logutil.Event.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InitShardPrimaryResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.InitShardPrimaryResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.InitShardPrimaryResponse} InitShardPrimaryResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InitShardPrimaryResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InitShardPrimaryResponse message.
         * @function verify
         * @memberof vtctldata.InitShardPrimaryResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InitShardPrimaryResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.events != null && message.hasOwnProperty("events")) {
                if (!Array.isArray(message.events))
                    return "events: array expected";
                for (var i = 0; i < message.events.length; ++i) {
                    var error = $root.logutil.Event.verify(message.events[i]);
                    if (error)
                        return "events." + error;
                }
            }
            return null;
        };

        /**
         * Creates an InitShardPrimaryResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.InitShardPrimaryResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.InitShardPrimaryResponse} InitShardPrimaryResponse
         */
        InitShardPrimaryResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.InitShardPrimaryResponse)
                return object;
            var message = new $root.vtctldata.InitShardPrimaryResponse();
            if (object.events) {
                if (!Array.isArray(object.events))
                    throw TypeError(".vtctldata.InitShardPrimaryResponse.events: array expected");
                message.events = [];
                for (var i = 0; i < object.events.length; ++i) {
                    if (typeof object.events[i] !== "object")
                        throw TypeError(".vtctldata.InitShardPrimaryResponse.events: object expected");
                    message.events[i] = $root.logutil.Event.fromObject(object.events[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an InitShardPrimaryResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.InitShardPrimaryResponse
         * @static
         * @param {vtctldata.InitShardPrimaryResponse} message InitShardPrimaryResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InitShardPrimaryResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.events = [];
            if (message.events && message.events.length) {
                object.events = [];
                for (var j = 0; j < message.events.length; ++j)
                    object.events[j] = $root.logutil.Event.toObject(message.events[j], options);
            }
            return object;
        };

        /**
         * Converts this InitShardPrimaryResponse to JSON.
         * @function toJSON
         * @memberof vtctldata.InitShardPrimaryResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InitShardPrimaryResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return InitShardPrimaryResponse;
    })();

    vtctldata.PlannedReparentShardRequest = (function() {

        /**
         * Properties of a PlannedReparentShardRequest.
         * @memberof vtctldata
         * @interface IPlannedReparentShardRequest
         * @property {string|null} [keyspace] PlannedReparentShardRequest keyspace
         * @property {string|null} [shard] PlannedReparentShardRequest shard
         * @property {topodata.ITabletAlias|null} [new_primary] PlannedReparentShardRequest new_primary
         * @property {topodata.ITabletAlias|null} [avoid_primary] PlannedReparentShardRequest avoid_primary
         * @property {vttime.IDuration|null} [wait_replicas_timeout] PlannedReparentShardRequest wait_replicas_timeout
         */

        /**
         * Constructs a new PlannedReparentShardRequest.
         * @memberof vtctldata
         * @classdesc Represents a PlannedReparentShardRequest.
         * @implements IPlannedReparentShardRequest
         * @constructor
         * @param {vtctldata.IPlannedReparentShardRequest=} [properties] Properties to set
         */
        function PlannedReparentShardRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PlannedReparentShardRequest keyspace.
         * @member {string} keyspace
         * @memberof vtctldata.PlannedReparentShardRequest
         * @instance
         */
        PlannedReparentShardRequest.prototype.keyspace = "";

        /**
         * PlannedReparentShardRequest shard.
         * @member {string} shard
         * @memberof vtctldata.PlannedReparentShardRequest
         * @instance
         */
        PlannedReparentShardRequest.prototype.shard = "";

        /**
         * PlannedReparentShardRequest new_primary.
         * @member {topodata.ITabletAlias|null|undefined} new_primary
         * @memberof vtctldata.PlannedReparentShardRequest
         * @instance
         */
        PlannedReparentShardRequest.prototype.new_primary = null;

        /**
         * PlannedReparentShardRequest avoid_primary.
         * @member {topodata.ITabletAlias|null|undefined} avoid_primary
         * @memberof vtctldata.PlannedReparentShardRequest
         * @instance
         */
        PlannedReparentShardRequest.prototype.avoid_primary = null;

        /**
         * PlannedReparentShardRequest wait_replicas_timeout.
         * @member {vttime.IDuration|null|undefined} wait_replicas_timeout
         * @memberof vtctldata.PlannedReparentShardRequest
         * @instance
         */
        PlannedReparentShardRequest.prototype.wait_replicas_timeout = null;

        /**
         * Creates a new PlannedReparentShardRequest instance using the specified properties.
         * @function create
         * @memberof vtctldata.PlannedReparentShardRequest
         * @static
         * @param {vtctldata.IPlannedReparentShardRequest=} [properties] Properties to set
         * @returns {vtctldata.PlannedReparentShardRequest} PlannedReparentShardRequest instance
         */
        PlannedReparentShardRequest.create = function create(properties) {
            return new PlannedReparentShardRequest(properties);
        };

        /**
         * Encodes the specified PlannedReparentShardRequest message. Does not implicitly {@link vtctldata.PlannedReparentShardRequest.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.PlannedReparentShardRequest
         * @static
         * @param {vtctldata.IPlannedReparentShardRequest} message PlannedReparentShardRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlannedReparentShardRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keyspace != null && Object.hasOwnProperty.call(message, "keyspace"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.keyspace);
            if (message.shard != null && Object.hasOwnProperty.call(message, "shard"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.shard);
            if (message.new_primary != null && Object.hasOwnProperty.call(message, "new_primary"))
                $root.topodata.TabletAlias.encode(message.new_primary, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.avoid_primary != null && Object.hasOwnProperty.call(message, "avoid_primary"))
                $root.topodata.TabletAlias.encode(message.avoid_primary, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.wait_replicas_timeout != null && Object.hasOwnProperty.call(message, "wait_replicas_timeout"))
                $root.vttime.Duration.encode(message.wait_replicas_timeout, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PlannedReparentShardRequest message, length delimited. Does not implicitly {@link vtctldata.PlannedReparentShardRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.PlannedReparentShardRequest
         * @static
         * @param {vtctldata.IPlannedReparentShardRequest} message PlannedReparentShardRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlannedReparentShardRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PlannedReparentShardRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.PlannedReparentShardRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.PlannedReparentShardRequest} PlannedReparentShardRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlannedReparentShardRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.PlannedReparentShardRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.keyspace = reader.string();
                    break;
                case 2:
                    message.shard = reader.string();
                    break;
                case 3:
                    message.new_primary = $root.topodata.TabletAlias.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.avoid_primary = $root.topodata.TabletAlias.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.wait_replicas_timeout = $root.vttime.Duration.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PlannedReparentShardRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.PlannedReparentShardRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.PlannedReparentShardRequest} PlannedReparentShardRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlannedReparentShardRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PlannedReparentShardRequest message.
         * @function verify
         * @memberof vtctldata.PlannedReparentShardRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PlannedReparentShardRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                if (!$util.isString(message.keyspace))
                    return "keyspace: string expected";
            if (message.shard != null && message.hasOwnProperty("shard"))
                if (!$util.isString(message.shard))
                    return "shard: string expected";
            if (message.new_primary != null && message.hasOwnProperty("new_primary")) {
                var error = $root.topodata.TabletAlias.verify(message.new_primary);
                if (error)
                    return "new_primary." + error;
            }
            if (message.avoid_primary != null && message.hasOwnProperty("avoid_primary")) {
                var error = $root.topodata.TabletAlias.verify(message.avoid_primary);
                if (error)
                    return "avoid_primary." + error;
            }
            if (message.wait_replicas_timeout != null && message.hasOwnProperty("wait_replicas_timeout")) {
                var error = $root.vttime.Duration.verify(message.wait_replicas_timeout);
                if (error)
                    return "wait_replicas_timeout." + error;
            }
            return null;
        };

        /**
         * Creates a PlannedReparentShardRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.PlannedReparentShardRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.PlannedReparentShardRequest} PlannedReparentShardRequest
         */
        PlannedReparentShardRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.PlannedReparentShardRequest)
                return object;
            var message = new $root.vtctldata.PlannedReparentShardRequest();
            if (object.keyspace != null)
                message.keyspace = String(object.keyspace);
            if (object.shard != null)
                message.shard = String(object.shard);
            if (object.new_primary != null) {
                if (typeof object.new_primary !== "object")
                    throw TypeError(".vtctldata.PlannedReparentShardRequest.new_primary: object expected");
                message.new_primary = $root.topodata.TabletAlias.fromObject(object.new_primary);
            }
            if (object.avoid_primary != null) {
                if (typeof object.avoid_primary !== "object")
                    throw TypeError(".vtctldata.PlannedReparentShardRequest.avoid_primary: object expected");
                message.avoid_primary = $root.topodata.TabletAlias.fromObject(object.avoid_primary);
            }
            if (object.wait_replicas_timeout != null) {
                if (typeof object.wait_replicas_timeout !== "object")
                    throw TypeError(".vtctldata.PlannedReparentShardRequest.wait_replicas_timeout: object expected");
                message.wait_replicas_timeout = $root.vttime.Duration.fromObject(object.wait_replicas_timeout);
            }
            return message;
        };

        /**
         * Creates a plain object from a PlannedReparentShardRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.PlannedReparentShardRequest
         * @static
         * @param {vtctldata.PlannedReparentShardRequest} message PlannedReparentShardRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PlannedReparentShardRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.keyspace = "";
                object.shard = "";
                object.new_primary = null;
                object.avoid_primary = null;
                object.wait_replicas_timeout = null;
            }
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                object.keyspace = message.keyspace;
            if (message.shard != null && message.hasOwnProperty("shard"))
                object.shard = message.shard;
            if (message.new_primary != null && message.hasOwnProperty("new_primary"))
                object.new_primary = $root.topodata.TabletAlias.toObject(message.new_primary, options);
            if (message.avoid_primary != null && message.hasOwnProperty("avoid_primary"))
                object.avoid_primary = $root.topodata.TabletAlias.toObject(message.avoid_primary, options);
            if (message.wait_replicas_timeout != null && message.hasOwnProperty("wait_replicas_timeout"))
                object.wait_replicas_timeout = $root.vttime.Duration.toObject(message.wait_replicas_timeout, options);
            return object;
        };

        /**
         * Converts this PlannedReparentShardRequest to JSON.
         * @function toJSON
         * @memberof vtctldata.PlannedReparentShardRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PlannedReparentShardRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PlannedReparentShardRequest;
    })();

    vtctldata.PlannedReparentShardResponse = (function() {

        /**
         * Properties of a PlannedReparentShardResponse.
         * @memberof vtctldata
         * @interface IPlannedReparentShardResponse
         * @property {string|null} [keyspace] PlannedReparentShardResponse keyspace
         * @property {string|null} [shard] PlannedReparentShardResponse shard
         * @property {topodata.ITabletAlias|null} [promoted_primary] PlannedReparentShardResponse promoted_primary
         * @property {Array.<logutil.IEvent>|null} [events] PlannedReparentShardResponse events
         */

        /**
         * Constructs a new PlannedReparentShardResponse.
         * @memberof vtctldata
         * @classdesc Represents a PlannedReparentShardResponse.
         * @implements IPlannedReparentShardResponse
         * @constructor
         * @param {vtctldata.IPlannedReparentShardResponse=} [properties] Properties to set
         */
        function PlannedReparentShardResponse(properties) {
            this.events = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PlannedReparentShardResponse keyspace.
         * @member {string} keyspace
         * @memberof vtctldata.PlannedReparentShardResponse
         * @instance
         */
        PlannedReparentShardResponse.prototype.keyspace = "";

        /**
         * PlannedReparentShardResponse shard.
         * @member {string} shard
         * @memberof vtctldata.PlannedReparentShardResponse
         * @instance
         */
        PlannedReparentShardResponse.prototype.shard = "";

        /**
         * PlannedReparentShardResponse promoted_primary.
         * @member {topodata.ITabletAlias|null|undefined} promoted_primary
         * @memberof vtctldata.PlannedReparentShardResponse
         * @instance
         */
        PlannedReparentShardResponse.prototype.promoted_primary = null;

        /**
         * PlannedReparentShardResponse events.
         * @member {Array.<logutil.IEvent>} events
         * @memberof vtctldata.PlannedReparentShardResponse
         * @instance
         */
        PlannedReparentShardResponse.prototype.events = $util.emptyArray;

        /**
         * Creates a new PlannedReparentShardResponse instance using the specified properties.
         * @function create
         * @memberof vtctldata.PlannedReparentShardResponse
         * @static
         * @param {vtctldata.IPlannedReparentShardResponse=} [properties] Properties to set
         * @returns {vtctldata.PlannedReparentShardResponse} PlannedReparentShardResponse instance
         */
        PlannedReparentShardResponse.create = function create(properties) {
            return new PlannedReparentShardResponse(properties);
        };

        /**
         * Encodes the specified PlannedReparentShardResponse message. Does not implicitly {@link vtctldata.PlannedReparentShardResponse.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.PlannedReparentShardResponse
         * @static
         * @param {vtctldata.IPlannedReparentShardResponse} message PlannedReparentShardResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlannedReparentShardResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keyspace != null && Object.hasOwnProperty.call(message, "keyspace"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.keyspace);
            if (message.shard != null && Object.hasOwnProperty.call(message, "shard"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.shard);
            if (message.promoted_primary != null && Object.hasOwnProperty.call(message, "promoted_primary"))
                $root.topodata.TabletAlias.encode(message.promoted_primary, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.events != null && message.events.length)
                for (var i = 0; i < message.events.length; ++i)
                    $root.logutil.Event.encode(message.events[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PlannedReparentShardResponse message, length delimited. Does not implicitly {@link vtctldata.PlannedReparentShardResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.PlannedReparentShardResponse
         * @static
         * @param {vtctldata.IPlannedReparentShardResponse} message PlannedReparentShardResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlannedReparentShardResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PlannedReparentShardResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.PlannedReparentShardResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.PlannedReparentShardResponse} PlannedReparentShardResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlannedReparentShardResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.PlannedReparentShardResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.keyspace = reader.string();
                    break;
                case 2:
                    message.shard = reader.string();
                    break;
                case 3:
                    message.promoted_primary = $root.topodata.TabletAlias.decode(reader, reader.uint32());
                    break;
                case 4:
                    if (!(message.events && message.events.length))
                        message.events = [];
                    message.events.push($root.logutil.Event.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PlannedReparentShardResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.PlannedReparentShardResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.PlannedReparentShardResponse} PlannedReparentShardResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlannedReparentShardResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PlannedReparentShardResponse message.
         * @function verify
         * @memberof vtctldata.PlannedReparentShardResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PlannedReparentShardResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                if (!$util.isString(message.keyspace))
                    return "keyspace: string expected";
            if (message.shard != null && message.hasOwnProperty("shard"))
                if (!$util.isString(message.shard))
                    return "shard: string expected";
            if (message.promoted_primary != null && message.hasOwnProperty("promoted_primary")) {
                var error = $root.topodata.TabletAlias.verify(message.promoted_primary);
                if (error)
                    return "promoted_primary." + error;
            }
            if (message.events != null && message.hasOwnProperty("events")) {
                if (!Array.isArray(message.events))
                    return "events: array expected";
                for (var i = 0; i < message.events.length; ++i) {
                    var error = $root.logutil.Event.verify(message.events[i]);
                    if (error)
                        return "events." + error;
                }
            }
            return null;
        };

        /**
         * Creates a PlannedReparentShardResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.PlannedReparentShardResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.PlannedReparentShardResponse} PlannedReparentShardResponse
         */
        PlannedReparentShardResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.PlannedReparentShardResponse)
                return object;
            var message = new $root.vtctldata.PlannedReparentShardResponse();
            if (object.keyspace != null)
                message.keyspace = String(object.keyspace);
            if (object.shard != null)
                message.shard = String(object.shard);
            if (object.promoted_primary != null) {
                if (typeof object.promoted_primary !== "object")
                    throw TypeError(".vtctldata.PlannedReparentShardResponse.promoted_primary: object expected");
                message.promoted_primary = $root.topodata.TabletAlias.fromObject(object.promoted_primary);
            }
            if (object.events) {
                if (!Array.isArray(object.events))
                    throw TypeError(".vtctldata.PlannedReparentShardResponse.events: array expected");
                message.events = [];
                for (var i = 0; i < object.events.length; ++i) {
                    if (typeof object.events[i] !== "object")
                        throw TypeError(".vtctldata.PlannedReparentShardResponse.events: object expected");
                    message.events[i] = $root.logutil.Event.fromObject(object.events[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a PlannedReparentShardResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.PlannedReparentShardResponse
         * @static
         * @param {vtctldata.PlannedReparentShardResponse} message PlannedReparentShardResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PlannedReparentShardResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.events = [];
            if (options.defaults) {
                object.keyspace = "";
                object.shard = "";
                object.promoted_primary = null;
            }
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                object.keyspace = message.keyspace;
            if (message.shard != null && message.hasOwnProperty("shard"))
                object.shard = message.shard;
            if (message.promoted_primary != null && message.hasOwnProperty("promoted_primary"))
                object.promoted_primary = $root.topodata.TabletAlias.toObject(message.promoted_primary, options);
            if (message.events && message.events.length) {
                object.events = [];
                for (var j = 0; j < message.events.length; ++j)
                    object.events[j] = $root.logutil.Event.toObject(message.events[j], options);
            }
            return object;
        };

        /**
         * Converts this PlannedReparentShardResponse to JSON.
         * @function toJSON
         * @memberof vtctldata.PlannedReparentShardResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PlannedReparentShardResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PlannedReparentShardResponse;
    })();

    vtctldata.RemoveKeyspaceCellRequest = (function() {

        /**
         * Properties of a RemoveKeyspaceCellRequest.
         * @memberof vtctldata
         * @interface IRemoveKeyspaceCellRequest
         * @property {string|null} [keyspace] RemoveKeyspaceCellRequest keyspace
         * @property {string|null} [cell] RemoveKeyspaceCellRequest cell
         * @property {boolean|null} [force] RemoveKeyspaceCellRequest force
         * @property {boolean|null} [recursive] RemoveKeyspaceCellRequest recursive
         */

        /**
         * Constructs a new RemoveKeyspaceCellRequest.
         * @memberof vtctldata
         * @classdesc Represents a RemoveKeyspaceCellRequest.
         * @implements IRemoveKeyspaceCellRequest
         * @constructor
         * @param {vtctldata.IRemoveKeyspaceCellRequest=} [properties] Properties to set
         */
        function RemoveKeyspaceCellRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RemoveKeyspaceCellRequest keyspace.
         * @member {string} keyspace
         * @memberof vtctldata.RemoveKeyspaceCellRequest
         * @instance
         */
        RemoveKeyspaceCellRequest.prototype.keyspace = "";

        /**
         * RemoveKeyspaceCellRequest cell.
         * @member {string} cell
         * @memberof vtctldata.RemoveKeyspaceCellRequest
         * @instance
         */
        RemoveKeyspaceCellRequest.prototype.cell = "";

        /**
         * RemoveKeyspaceCellRequest force.
         * @member {boolean} force
         * @memberof vtctldata.RemoveKeyspaceCellRequest
         * @instance
         */
        RemoveKeyspaceCellRequest.prototype.force = false;

        /**
         * RemoveKeyspaceCellRequest recursive.
         * @member {boolean} recursive
         * @memberof vtctldata.RemoveKeyspaceCellRequest
         * @instance
         */
        RemoveKeyspaceCellRequest.prototype.recursive = false;

        /**
         * Creates a new RemoveKeyspaceCellRequest instance using the specified properties.
         * @function create
         * @memberof vtctldata.RemoveKeyspaceCellRequest
         * @static
         * @param {vtctldata.IRemoveKeyspaceCellRequest=} [properties] Properties to set
         * @returns {vtctldata.RemoveKeyspaceCellRequest} RemoveKeyspaceCellRequest instance
         */
        RemoveKeyspaceCellRequest.create = function create(properties) {
            return new RemoveKeyspaceCellRequest(properties);
        };

        /**
         * Encodes the specified RemoveKeyspaceCellRequest message. Does not implicitly {@link vtctldata.RemoveKeyspaceCellRequest.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.RemoveKeyspaceCellRequest
         * @static
         * @param {vtctldata.IRemoveKeyspaceCellRequest} message RemoveKeyspaceCellRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RemoveKeyspaceCellRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keyspace != null && Object.hasOwnProperty.call(message, "keyspace"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.keyspace);
            if (message.cell != null && Object.hasOwnProperty.call(message, "cell"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.cell);
            if (message.force != null && Object.hasOwnProperty.call(message, "force"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.force);
            if (message.recursive != null && Object.hasOwnProperty.call(message, "recursive"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.recursive);
            return writer;
        };

        /**
         * Encodes the specified RemoveKeyspaceCellRequest message, length delimited. Does not implicitly {@link vtctldata.RemoveKeyspaceCellRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.RemoveKeyspaceCellRequest
         * @static
         * @param {vtctldata.IRemoveKeyspaceCellRequest} message RemoveKeyspaceCellRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RemoveKeyspaceCellRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RemoveKeyspaceCellRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.RemoveKeyspaceCellRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.RemoveKeyspaceCellRequest} RemoveKeyspaceCellRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RemoveKeyspaceCellRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.RemoveKeyspaceCellRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.keyspace = reader.string();
                    break;
                case 2:
                    message.cell = reader.string();
                    break;
                case 3:
                    message.force = reader.bool();
                    break;
                case 4:
                    message.recursive = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RemoveKeyspaceCellRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.RemoveKeyspaceCellRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.RemoveKeyspaceCellRequest} RemoveKeyspaceCellRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RemoveKeyspaceCellRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RemoveKeyspaceCellRequest message.
         * @function verify
         * @memberof vtctldata.RemoveKeyspaceCellRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RemoveKeyspaceCellRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                if (!$util.isString(message.keyspace))
                    return "keyspace: string expected";
            if (message.cell != null && message.hasOwnProperty("cell"))
                if (!$util.isString(message.cell))
                    return "cell: string expected";
            if (message.force != null && message.hasOwnProperty("force"))
                if (typeof message.force !== "boolean")
                    return "force: boolean expected";
            if (message.recursive != null && message.hasOwnProperty("recursive"))
                if (typeof message.recursive !== "boolean")
                    return "recursive: boolean expected";
            return null;
        };

        /**
         * Creates a RemoveKeyspaceCellRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.RemoveKeyspaceCellRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.RemoveKeyspaceCellRequest} RemoveKeyspaceCellRequest
         */
        RemoveKeyspaceCellRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.RemoveKeyspaceCellRequest)
                return object;
            var message = new $root.vtctldata.RemoveKeyspaceCellRequest();
            if (object.keyspace != null)
                message.keyspace = String(object.keyspace);
            if (object.cell != null)
                message.cell = String(object.cell);
            if (object.force != null)
                message.force = Boolean(object.force);
            if (object.recursive != null)
                message.recursive = Boolean(object.recursive);
            return message;
        };

        /**
         * Creates a plain object from a RemoveKeyspaceCellRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.RemoveKeyspaceCellRequest
         * @static
         * @param {vtctldata.RemoveKeyspaceCellRequest} message RemoveKeyspaceCellRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RemoveKeyspaceCellRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.keyspace = "";
                object.cell = "";
                object.force = false;
                object.recursive = false;
            }
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                object.keyspace = message.keyspace;
            if (message.cell != null && message.hasOwnProperty("cell"))
                object.cell = message.cell;
            if (message.force != null && message.hasOwnProperty("force"))
                object.force = message.force;
            if (message.recursive != null && message.hasOwnProperty("recursive"))
                object.recursive = message.recursive;
            return object;
        };

        /**
         * Converts this RemoveKeyspaceCellRequest to JSON.
         * @function toJSON
         * @memberof vtctldata.RemoveKeyspaceCellRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RemoveKeyspaceCellRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RemoveKeyspaceCellRequest;
    })();

    vtctldata.RemoveKeyspaceCellResponse = (function() {

        /**
         * Properties of a RemoveKeyspaceCellResponse.
         * @memberof vtctldata
         * @interface IRemoveKeyspaceCellResponse
         */

        /**
         * Constructs a new RemoveKeyspaceCellResponse.
         * @memberof vtctldata
         * @classdesc Represents a RemoveKeyspaceCellResponse.
         * @implements IRemoveKeyspaceCellResponse
         * @constructor
         * @param {vtctldata.IRemoveKeyspaceCellResponse=} [properties] Properties to set
         */
        function RemoveKeyspaceCellResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new RemoveKeyspaceCellResponse instance using the specified properties.
         * @function create
         * @memberof vtctldata.RemoveKeyspaceCellResponse
         * @static
         * @param {vtctldata.IRemoveKeyspaceCellResponse=} [properties] Properties to set
         * @returns {vtctldata.RemoveKeyspaceCellResponse} RemoveKeyspaceCellResponse instance
         */
        RemoveKeyspaceCellResponse.create = function create(properties) {
            return new RemoveKeyspaceCellResponse(properties);
        };

        /**
         * Encodes the specified RemoveKeyspaceCellResponse message. Does not implicitly {@link vtctldata.RemoveKeyspaceCellResponse.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.RemoveKeyspaceCellResponse
         * @static
         * @param {vtctldata.IRemoveKeyspaceCellResponse} message RemoveKeyspaceCellResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RemoveKeyspaceCellResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified RemoveKeyspaceCellResponse message, length delimited. Does not implicitly {@link vtctldata.RemoveKeyspaceCellResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.RemoveKeyspaceCellResponse
         * @static
         * @param {vtctldata.IRemoveKeyspaceCellResponse} message RemoveKeyspaceCellResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RemoveKeyspaceCellResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RemoveKeyspaceCellResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.RemoveKeyspaceCellResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.RemoveKeyspaceCellResponse} RemoveKeyspaceCellResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RemoveKeyspaceCellResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.RemoveKeyspaceCellResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RemoveKeyspaceCellResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.RemoveKeyspaceCellResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.RemoveKeyspaceCellResponse} RemoveKeyspaceCellResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RemoveKeyspaceCellResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RemoveKeyspaceCellResponse message.
         * @function verify
         * @memberof vtctldata.RemoveKeyspaceCellResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RemoveKeyspaceCellResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a RemoveKeyspaceCellResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.RemoveKeyspaceCellResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.RemoveKeyspaceCellResponse} RemoveKeyspaceCellResponse
         */
        RemoveKeyspaceCellResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.RemoveKeyspaceCellResponse)
                return object;
            return new $root.vtctldata.RemoveKeyspaceCellResponse();
        };

        /**
         * Creates a plain object from a RemoveKeyspaceCellResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.RemoveKeyspaceCellResponse
         * @static
         * @param {vtctldata.RemoveKeyspaceCellResponse} message RemoveKeyspaceCellResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RemoveKeyspaceCellResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this RemoveKeyspaceCellResponse to JSON.
         * @function toJSON
         * @memberof vtctldata.RemoveKeyspaceCellResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RemoveKeyspaceCellResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RemoveKeyspaceCellResponse;
    })();

    vtctldata.RemoveShardCellRequest = (function() {

        /**
         * Properties of a RemoveShardCellRequest.
         * @memberof vtctldata
         * @interface IRemoveShardCellRequest
         * @property {string|null} [keyspace] RemoveShardCellRequest keyspace
         * @property {string|null} [shard_name] RemoveShardCellRequest shard_name
         * @property {string|null} [cell] RemoveShardCellRequest cell
         * @property {boolean|null} [force] RemoveShardCellRequest force
         * @property {boolean|null} [recursive] RemoveShardCellRequest recursive
         */

        /**
         * Constructs a new RemoveShardCellRequest.
         * @memberof vtctldata
         * @classdesc Represents a RemoveShardCellRequest.
         * @implements IRemoveShardCellRequest
         * @constructor
         * @param {vtctldata.IRemoveShardCellRequest=} [properties] Properties to set
         */
        function RemoveShardCellRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RemoveShardCellRequest keyspace.
         * @member {string} keyspace
         * @memberof vtctldata.RemoveShardCellRequest
         * @instance
         */
        RemoveShardCellRequest.prototype.keyspace = "";

        /**
         * RemoveShardCellRequest shard_name.
         * @member {string} shard_name
         * @memberof vtctldata.RemoveShardCellRequest
         * @instance
         */
        RemoveShardCellRequest.prototype.shard_name = "";

        /**
         * RemoveShardCellRequest cell.
         * @member {string} cell
         * @memberof vtctldata.RemoveShardCellRequest
         * @instance
         */
        RemoveShardCellRequest.prototype.cell = "";

        /**
         * RemoveShardCellRequest force.
         * @member {boolean} force
         * @memberof vtctldata.RemoveShardCellRequest
         * @instance
         */
        RemoveShardCellRequest.prototype.force = false;

        /**
         * RemoveShardCellRequest recursive.
         * @member {boolean} recursive
         * @memberof vtctldata.RemoveShardCellRequest
         * @instance
         */
        RemoveShardCellRequest.prototype.recursive = false;

        /**
         * Creates a new RemoveShardCellRequest instance using the specified properties.
         * @function create
         * @memberof vtctldata.RemoveShardCellRequest
         * @static
         * @param {vtctldata.IRemoveShardCellRequest=} [properties] Properties to set
         * @returns {vtctldata.RemoveShardCellRequest} RemoveShardCellRequest instance
         */
        RemoveShardCellRequest.create = function create(properties) {
            return new RemoveShardCellRequest(properties);
        };

        /**
         * Encodes the specified RemoveShardCellRequest message. Does not implicitly {@link vtctldata.RemoveShardCellRequest.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.RemoveShardCellRequest
         * @static
         * @param {vtctldata.IRemoveShardCellRequest} message RemoveShardCellRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RemoveShardCellRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keyspace != null && Object.hasOwnProperty.call(message, "keyspace"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.keyspace);
            if (message.shard_name != null && Object.hasOwnProperty.call(message, "shard_name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.shard_name);
            if (message.cell != null && Object.hasOwnProperty.call(message, "cell"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.cell);
            if (message.force != null && Object.hasOwnProperty.call(message, "force"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.force);
            if (message.recursive != null && Object.hasOwnProperty.call(message, "recursive"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.recursive);
            return writer;
        };

        /**
         * Encodes the specified RemoveShardCellRequest message, length delimited. Does not implicitly {@link vtctldata.RemoveShardCellRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.RemoveShardCellRequest
         * @static
         * @param {vtctldata.IRemoveShardCellRequest} message RemoveShardCellRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RemoveShardCellRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RemoveShardCellRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.RemoveShardCellRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.RemoveShardCellRequest} RemoveShardCellRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RemoveShardCellRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.RemoveShardCellRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.keyspace = reader.string();
                    break;
                case 2:
                    message.shard_name = reader.string();
                    break;
                case 3:
                    message.cell = reader.string();
                    break;
                case 4:
                    message.force = reader.bool();
                    break;
                case 5:
                    message.recursive = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RemoveShardCellRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.RemoveShardCellRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.RemoveShardCellRequest} RemoveShardCellRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RemoveShardCellRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RemoveShardCellRequest message.
         * @function verify
         * @memberof vtctldata.RemoveShardCellRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RemoveShardCellRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                if (!$util.isString(message.keyspace))
                    return "keyspace: string expected";
            if (message.shard_name != null && message.hasOwnProperty("shard_name"))
                if (!$util.isString(message.shard_name))
                    return "shard_name: string expected";
            if (message.cell != null && message.hasOwnProperty("cell"))
                if (!$util.isString(message.cell))
                    return "cell: string expected";
            if (message.force != null && message.hasOwnProperty("force"))
                if (typeof message.force !== "boolean")
                    return "force: boolean expected";
            if (message.recursive != null && message.hasOwnProperty("recursive"))
                if (typeof message.recursive !== "boolean")
                    return "recursive: boolean expected";
            return null;
        };

        /**
         * Creates a RemoveShardCellRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.RemoveShardCellRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.RemoveShardCellRequest} RemoveShardCellRequest
         */
        RemoveShardCellRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.RemoveShardCellRequest)
                return object;
            var message = new $root.vtctldata.RemoveShardCellRequest();
            if (object.keyspace != null)
                message.keyspace = String(object.keyspace);
            if (object.shard_name != null)
                message.shard_name = String(object.shard_name);
            if (object.cell != null)
                message.cell = String(object.cell);
            if (object.force != null)
                message.force = Boolean(object.force);
            if (object.recursive != null)
                message.recursive = Boolean(object.recursive);
            return message;
        };

        /**
         * Creates a plain object from a RemoveShardCellRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.RemoveShardCellRequest
         * @static
         * @param {vtctldata.RemoveShardCellRequest} message RemoveShardCellRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RemoveShardCellRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.keyspace = "";
                object.shard_name = "";
                object.cell = "";
                object.force = false;
                object.recursive = false;
            }
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                object.keyspace = message.keyspace;
            if (message.shard_name != null && message.hasOwnProperty("shard_name"))
                object.shard_name = message.shard_name;
            if (message.cell != null && message.hasOwnProperty("cell"))
                object.cell = message.cell;
            if (message.force != null && message.hasOwnProperty("force"))
                object.force = message.force;
            if (message.recursive != null && message.hasOwnProperty("recursive"))
                object.recursive = message.recursive;
            return object;
        };

        /**
         * Converts this RemoveShardCellRequest to JSON.
         * @function toJSON
         * @memberof vtctldata.RemoveShardCellRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RemoveShardCellRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RemoveShardCellRequest;
    })();

    vtctldata.RemoveShardCellResponse = (function() {

        /**
         * Properties of a RemoveShardCellResponse.
         * @memberof vtctldata
         * @interface IRemoveShardCellResponse
         */

        /**
         * Constructs a new RemoveShardCellResponse.
         * @memberof vtctldata
         * @classdesc Represents a RemoveShardCellResponse.
         * @implements IRemoveShardCellResponse
         * @constructor
         * @param {vtctldata.IRemoveShardCellResponse=} [properties] Properties to set
         */
        function RemoveShardCellResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new RemoveShardCellResponse instance using the specified properties.
         * @function create
         * @memberof vtctldata.RemoveShardCellResponse
         * @static
         * @param {vtctldata.IRemoveShardCellResponse=} [properties] Properties to set
         * @returns {vtctldata.RemoveShardCellResponse} RemoveShardCellResponse instance
         */
        RemoveShardCellResponse.create = function create(properties) {
            return new RemoveShardCellResponse(properties);
        };

        /**
         * Encodes the specified RemoveShardCellResponse message. Does not implicitly {@link vtctldata.RemoveShardCellResponse.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.RemoveShardCellResponse
         * @static
         * @param {vtctldata.IRemoveShardCellResponse} message RemoveShardCellResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RemoveShardCellResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified RemoveShardCellResponse message, length delimited. Does not implicitly {@link vtctldata.RemoveShardCellResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.RemoveShardCellResponse
         * @static
         * @param {vtctldata.IRemoveShardCellResponse} message RemoveShardCellResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RemoveShardCellResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RemoveShardCellResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.RemoveShardCellResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.RemoveShardCellResponse} RemoveShardCellResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RemoveShardCellResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.RemoveShardCellResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RemoveShardCellResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.RemoveShardCellResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.RemoveShardCellResponse} RemoveShardCellResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RemoveShardCellResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RemoveShardCellResponse message.
         * @function verify
         * @memberof vtctldata.RemoveShardCellResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RemoveShardCellResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a RemoveShardCellResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.RemoveShardCellResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.RemoveShardCellResponse} RemoveShardCellResponse
         */
        RemoveShardCellResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.RemoveShardCellResponse)
                return object;
            return new $root.vtctldata.RemoveShardCellResponse();
        };

        /**
         * Creates a plain object from a RemoveShardCellResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.RemoveShardCellResponse
         * @static
         * @param {vtctldata.RemoveShardCellResponse} message RemoveShardCellResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RemoveShardCellResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this RemoveShardCellResponse to JSON.
         * @function toJSON
         * @memberof vtctldata.RemoveShardCellResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RemoveShardCellResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RemoveShardCellResponse;
    })();

    vtctldata.ReparentTabletRequest = (function() {

        /**
         * Properties of a ReparentTabletRequest.
         * @memberof vtctldata
         * @interface IReparentTabletRequest
         * @property {topodata.ITabletAlias|null} [tablet] ReparentTabletRequest tablet
         */

        /**
         * Constructs a new ReparentTabletRequest.
         * @memberof vtctldata
         * @classdesc Represents a ReparentTabletRequest.
         * @implements IReparentTabletRequest
         * @constructor
         * @param {vtctldata.IReparentTabletRequest=} [properties] Properties to set
         */
        function ReparentTabletRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReparentTabletRequest tablet.
         * @member {topodata.ITabletAlias|null|undefined} tablet
         * @memberof vtctldata.ReparentTabletRequest
         * @instance
         */
        ReparentTabletRequest.prototype.tablet = null;

        /**
         * Creates a new ReparentTabletRequest instance using the specified properties.
         * @function create
         * @memberof vtctldata.ReparentTabletRequest
         * @static
         * @param {vtctldata.IReparentTabletRequest=} [properties] Properties to set
         * @returns {vtctldata.ReparentTabletRequest} ReparentTabletRequest instance
         */
        ReparentTabletRequest.create = function create(properties) {
            return new ReparentTabletRequest(properties);
        };

        /**
         * Encodes the specified ReparentTabletRequest message. Does not implicitly {@link vtctldata.ReparentTabletRequest.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.ReparentTabletRequest
         * @static
         * @param {vtctldata.IReparentTabletRequest} message ReparentTabletRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReparentTabletRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tablet != null && Object.hasOwnProperty.call(message, "tablet"))
                $root.topodata.TabletAlias.encode(message.tablet, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ReparentTabletRequest message, length delimited. Does not implicitly {@link vtctldata.ReparentTabletRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.ReparentTabletRequest
         * @static
         * @param {vtctldata.IReparentTabletRequest} message ReparentTabletRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReparentTabletRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReparentTabletRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.ReparentTabletRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.ReparentTabletRequest} ReparentTabletRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReparentTabletRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.ReparentTabletRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tablet = $root.topodata.TabletAlias.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReparentTabletRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.ReparentTabletRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.ReparentTabletRequest} ReparentTabletRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReparentTabletRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReparentTabletRequest message.
         * @function verify
         * @memberof vtctldata.ReparentTabletRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReparentTabletRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tablet != null && message.hasOwnProperty("tablet")) {
                var error = $root.topodata.TabletAlias.verify(message.tablet);
                if (error)
                    return "tablet." + error;
            }
            return null;
        };

        /**
         * Creates a ReparentTabletRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.ReparentTabletRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.ReparentTabletRequest} ReparentTabletRequest
         */
        ReparentTabletRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.ReparentTabletRequest)
                return object;
            var message = new $root.vtctldata.ReparentTabletRequest();
            if (object.tablet != null) {
                if (typeof object.tablet !== "object")
                    throw TypeError(".vtctldata.ReparentTabletRequest.tablet: object expected");
                message.tablet = $root.topodata.TabletAlias.fromObject(object.tablet);
            }
            return message;
        };

        /**
         * Creates a plain object from a ReparentTabletRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.ReparentTabletRequest
         * @static
         * @param {vtctldata.ReparentTabletRequest} message ReparentTabletRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReparentTabletRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.tablet = null;
            if (message.tablet != null && message.hasOwnProperty("tablet"))
                object.tablet = $root.topodata.TabletAlias.toObject(message.tablet, options);
            return object;
        };

        /**
         * Converts this ReparentTabletRequest to JSON.
         * @function toJSON
         * @memberof vtctldata.ReparentTabletRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReparentTabletRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ReparentTabletRequest;
    })();

    vtctldata.ReparentTabletResponse = (function() {

        /**
         * Properties of a ReparentTabletResponse.
         * @memberof vtctldata
         * @interface IReparentTabletResponse
         * @property {string|null} [keyspace] ReparentTabletResponse keyspace
         * @property {string|null} [shard] ReparentTabletResponse shard
         * @property {topodata.ITabletAlias|null} [primary] ReparentTabletResponse primary
         */

        /**
         * Constructs a new ReparentTabletResponse.
         * @memberof vtctldata
         * @classdesc Represents a ReparentTabletResponse.
         * @implements IReparentTabletResponse
         * @constructor
         * @param {vtctldata.IReparentTabletResponse=} [properties] Properties to set
         */
        function ReparentTabletResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReparentTabletResponse keyspace.
         * @member {string} keyspace
         * @memberof vtctldata.ReparentTabletResponse
         * @instance
         */
        ReparentTabletResponse.prototype.keyspace = "";

        /**
         * ReparentTabletResponse shard.
         * @member {string} shard
         * @memberof vtctldata.ReparentTabletResponse
         * @instance
         */
        ReparentTabletResponse.prototype.shard = "";

        /**
         * ReparentTabletResponse primary.
         * @member {topodata.ITabletAlias|null|undefined} primary
         * @memberof vtctldata.ReparentTabletResponse
         * @instance
         */
        ReparentTabletResponse.prototype.primary = null;

        /**
         * Creates a new ReparentTabletResponse instance using the specified properties.
         * @function create
         * @memberof vtctldata.ReparentTabletResponse
         * @static
         * @param {vtctldata.IReparentTabletResponse=} [properties] Properties to set
         * @returns {vtctldata.ReparentTabletResponse} ReparentTabletResponse instance
         */
        ReparentTabletResponse.create = function create(properties) {
            return new ReparentTabletResponse(properties);
        };

        /**
         * Encodes the specified ReparentTabletResponse message. Does not implicitly {@link vtctldata.ReparentTabletResponse.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.ReparentTabletResponse
         * @static
         * @param {vtctldata.IReparentTabletResponse} message ReparentTabletResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReparentTabletResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keyspace != null && Object.hasOwnProperty.call(message, "keyspace"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.keyspace);
            if (message.shard != null && Object.hasOwnProperty.call(message, "shard"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.shard);
            if (message.primary != null && Object.hasOwnProperty.call(message, "primary"))
                $root.topodata.TabletAlias.encode(message.primary, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ReparentTabletResponse message, length delimited. Does not implicitly {@link vtctldata.ReparentTabletResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.ReparentTabletResponse
         * @static
         * @param {vtctldata.IReparentTabletResponse} message ReparentTabletResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReparentTabletResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReparentTabletResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.ReparentTabletResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.ReparentTabletResponse} ReparentTabletResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReparentTabletResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.ReparentTabletResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.keyspace = reader.string();
                    break;
                case 2:
                    message.shard = reader.string();
                    break;
                case 3:
                    message.primary = $root.topodata.TabletAlias.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReparentTabletResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.ReparentTabletResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.ReparentTabletResponse} ReparentTabletResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReparentTabletResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReparentTabletResponse message.
         * @function verify
         * @memberof vtctldata.ReparentTabletResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReparentTabletResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                if (!$util.isString(message.keyspace))
                    return "keyspace: string expected";
            if (message.shard != null && message.hasOwnProperty("shard"))
                if (!$util.isString(message.shard))
                    return "shard: string expected";
            if (message.primary != null && message.hasOwnProperty("primary")) {
                var error = $root.topodata.TabletAlias.verify(message.primary);
                if (error)
                    return "primary." + error;
            }
            return null;
        };

        /**
         * Creates a ReparentTabletResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.ReparentTabletResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.ReparentTabletResponse} ReparentTabletResponse
         */
        ReparentTabletResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.ReparentTabletResponse)
                return object;
            var message = new $root.vtctldata.ReparentTabletResponse();
            if (object.keyspace != null)
                message.keyspace = String(object.keyspace);
            if (object.shard != null)
                message.shard = String(object.shard);
            if (object.primary != null) {
                if (typeof object.primary !== "object")
                    throw TypeError(".vtctldata.ReparentTabletResponse.primary: object expected");
                message.primary = $root.topodata.TabletAlias.fromObject(object.primary);
            }
            return message;
        };

        /**
         * Creates a plain object from a ReparentTabletResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.ReparentTabletResponse
         * @static
         * @param {vtctldata.ReparentTabletResponse} message ReparentTabletResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReparentTabletResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.keyspace = "";
                object.shard = "";
                object.primary = null;
            }
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                object.keyspace = message.keyspace;
            if (message.shard != null && message.hasOwnProperty("shard"))
                object.shard = message.shard;
            if (message.primary != null && message.hasOwnProperty("primary"))
                object.primary = $root.topodata.TabletAlias.toObject(message.primary, options);
            return object;
        };

        /**
         * Converts this ReparentTabletResponse to JSON.
         * @function toJSON
         * @memberof vtctldata.ReparentTabletResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReparentTabletResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ReparentTabletResponse;
    })();

    vtctldata.ShardReplicationPositionsRequest = (function() {

        /**
         * Properties of a ShardReplicationPositionsRequest.
         * @memberof vtctldata
         * @interface IShardReplicationPositionsRequest
         * @property {string|null} [keyspace] ShardReplicationPositionsRequest keyspace
         * @property {string|null} [shard] ShardReplicationPositionsRequest shard
         */

        /**
         * Constructs a new ShardReplicationPositionsRequest.
         * @memberof vtctldata
         * @classdesc Represents a ShardReplicationPositionsRequest.
         * @implements IShardReplicationPositionsRequest
         * @constructor
         * @param {vtctldata.IShardReplicationPositionsRequest=} [properties] Properties to set
         */
        function ShardReplicationPositionsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ShardReplicationPositionsRequest keyspace.
         * @member {string} keyspace
         * @memberof vtctldata.ShardReplicationPositionsRequest
         * @instance
         */
        ShardReplicationPositionsRequest.prototype.keyspace = "";

        /**
         * ShardReplicationPositionsRequest shard.
         * @member {string} shard
         * @memberof vtctldata.ShardReplicationPositionsRequest
         * @instance
         */
        ShardReplicationPositionsRequest.prototype.shard = "";

        /**
         * Creates a new ShardReplicationPositionsRequest instance using the specified properties.
         * @function create
         * @memberof vtctldata.ShardReplicationPositionsRequest
         * @static
         * @param {vtctldata.IShardReplicationPositionsRequest=} [properties] Properties to set
         * @returns {vtctldata.ShardReplicationPositionsRequest} ShardReplicationPositionsRequest instance
         */
        ShardReplicationPositionsRequest.create = function create(properties) {
            return new ShardReplicationPositionsRequest(properties);
        };

        /**
         * Encodes the specified ShardReplicationPositionsRequest message. Does not implicitly {@link vtctldata.ShardReplicationPositionsRequest.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.ShardReplicationPositionsRequest
         * @static
         * @param {vtctldata.IShardReplicationPositionsRequest} message ShardReplicationPositionsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShardReplicationPositionsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keyspace != null && Object.hasOwnProperty.call(message, "keyspace"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.keyspace);
            if (message.shard != null && Object.hasOwnProperty.call(message, "shard"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.shard);
            return writer;
        };

        /**
         * Encodes the specified ShardReplicationPositionsRequest message, length delimited. Does not implicitly {@link vtctldata.ShardReplicationPositionsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.ShardReplicationPositionsRequest
         * @static
         * @param {vtctldata.IShardReplicationPositionsRequest} message ShardReplicationPositionsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShardReplicationPositionsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ShardReplicationPositionsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.ShardReplicationPositionsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.ShardReplicationPositionsRequest} ShardReplicationPositionsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShardReplicationPositionsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.ShardReplicationPositionsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.keyspace = reader.string();
                    break;
                case 2:
                    message.shard = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ShardReplicationPositionsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.ShardReplicationPositionsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.ShardReplicationPositionsRequest} ShardReplicationPositionsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShardReplicationPositionsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ShardReplicationPositionsRequest message.
         * @function verify
         * @memberof vtctldata.ShardReplicationPositionsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ShardReplicationPositionsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                if (!$util.isString(message.keyspace))
                    return "keyspace: string expected";
            if (message.shard != null && message.hasOwnProperty("shard"))
                if (!$util.isString(message.shard))
                    return "shard: string expected";
            return null;
        };

        /**
         * Creates a ShardReplicationPositionsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.ShardReplicationPositionsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.ShardReplicationPositionsRequest} ShardReplicationPositionsRequest
         */
        ShardReplicationPositionsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.ShardReplicationPositionsRequest)
                return object;
            var message = new $root.vtctldata.ShardReplicationPositionsRequest();
            if (object.keyspace != null)
                message.keyspace = String(object.keyspace);
            if (object.shard != null)
                message.shard = String(object.shard);
            return message;
        };

        /**
         * Creates a plain object from a ShardReplicationPositionsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.ShardReplicationPositionsRequest
         * @static
         * @param {vtctldata.ShardReplicationPositionsRequest} message ShardReplicationPositionsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ShardReplicationPositionsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.keyspace = "";
                object.shard = "";
            }
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                object.keyspace = message.keyspace;
            if (message.shard != null && message.hasOwnProperty("shard"))
                object.shard = message.shard;
            return object;
        };

        /**
         * Converts this ShardReplicationPositionsRequest to JSON.
         * @function toJSON
         * @memberof vtctldata.ShardReplicationPositionsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ShardReplicationPositionsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ShardReplicationPositionsRequest;
    })();

    vtctldata.ShardReplicationPositionsResponse = (function() {

        /**
         * Properties of a ShardReplicationPositionsResponse.
         * @memberof vtctldata
         * @interface IShardReplicationPositionsResponse
         * @property {Object.<string,replicationdata.IStatus>|null} [replication_statuses] ShardReplicationPositionsResponse replication_statuses
         * @property {Object.<string,topodata.ITablet>|null} [tablet_map] ShardReplicationPositionsResponse tablet_map
         */

        /**
         * Constructs a new ShardReplicationPositionsResponse.
         * @memberof vtctldata
         * @classdesc Represents a ShardReplicationPositionsResponse.
         * @implements IShardReplicationPositionsResponse
         * @constructor
         * @param {vtctldata.IShardReplicationPositionsResponse=} [properties] Properties to set
         */
        function ShardReplicationPositionsResponse(properties) {
            this.replication_statuses = {};
            this.tablet_map = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ShardReplicationPositionsResponse replication_statuses.
         * @member {Object.<string,replicationdata.IStatus>} replication_statuses
         * @memberof vtctldata.ShardReplicationPositionsResponse
         * @instance
         */
        ShardReplicationPositionsResponse.prototype.replication_statuses = $util.emptyObject;

        /**
         * ShardReplicationPositionsResponse tablet_map.
         * @member {Object.<string,topodata.ITablet>} tablet_map
         * @memberof vtctldata.ShardReplicationPositionsResponse
         * @instance
         */
        ShardReplicationPositionsResponse.prototype.tablet_map = $util.emptyObject;

        /**
         * Creates a new ShardReplicationPositionsResponse instance using the specified properties.
         * @function create
         * @memberof vtctldata.ShardReplicationPositionsResponse
         * @static
         * @param {vtctldata.IShardReplicationPositionsResponse=} [properties] Properties to set
         * @returns {vtctldata.ShardReplicationPositionsResponse} ShardReplicationPositionsResponse instance
         */
        ShardReplicationPositionsResponse.create = function create(properties) {
            return new ShardReplicationPositionsResponse(properties);
        };

        /**
         * Encodes the specified ShardReplicationPositionsResponse message. Does not implicitly {@link vtctldata.ShardReplicationPositionsResponse.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.ShardReplicationPositionsResponse
         * @static
         * @param {vtctldata.IShardReplicationPositionsResponse} message ShardReplicationPositionsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShardReplicationPositionsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.replication_statuses != null && Object.hasOwnProperty.call(message, "replication_statuses"))
                for (var keys = Object.keys(message.replication_statuses), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.replicationdata.Status.encode(message.replication_statuses[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            if (message.tablet_map != null && Object.hasOwnProperty.call(message, "tablet_map"))
                for (var keys = Object.keys(message.tablet_map), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.topodata.Tablet.encode(message.tablet_map[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            return writer;
        };

        /**
         * Encodes the specified ShardReplicationPositionsResponse message, length delimited. Does not implicitly {@link vtctldata.ShardReplicationPositionsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.ShardReplicationPositionsResponse
         * @static
         * @param {vtctldata.IShardReplicationPositionsResponse} message ShardReplicationPositionsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShardReplicationPositionsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ShardReplicationPositionsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.ShardReplicationPositionsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.ShardReplicationPositionsResponse} ShardReplicationPositionsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShardReplicationPositionsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.ShardReplicationPositionsResponse(), key, value;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (message.replication_statuses === $util.emptyObject)
                        message.replication_statuses = {};
                    var end2 = reader.uint32() + reader.pos;
                    key = "";
                    value = null;
                    while (reader.pos < end2) {
                        var tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.string();
                            break;
                        case 2:
                            value = $root.replicationdata.Status.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.replication_statuses[key] = value;
                    break;
                case 2:
                    if (message.tablet_map === $util.emptyObject)
                        message.tablet_map = {};
                    var end2 = reader.uint32() + reader.pos;
                    key = "";
                    value = null;
                    while (reader.pos < end2) {
                        var tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.string();
                            break;
                        case 2:
                            value = $root.topodata.Tablet.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.tablet_map[key] = value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ShardReplicationPositionsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.ShardReplicationPositionsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.ShardReplicationPositionsResponse} ShardReplicationPositionsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShardReplicationPositionsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ShardReplicationPositionsResponse message.
         * @function verify
         * @memberof vtctldata.ShardReplicationPositionsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ShardReplicationPositionsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.replication_statuses != null && message.hasOwnProperty("replication_statuses")) {
                if (!$util.isObject(message.replication_statuses))
                    return "replication_statuses: object expected";
                var key = Object.keys(message.replication_statuses);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.replicationdata.Status.verify(message.replication_statuses[key[i]]);
                    if (error)
                        return "replication_statuses." + error;
                }
            }
            if (message.tablet_map != null && message.hasOwnProperty("tablet_map")) {
                if (!$util.isObject(message.tablet_map))
                    return "tablet_map: object expected";
                var key = Object.keys(message.tablet_map);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.topodata.Tablet.verify(message.tablet_map[key[i]]);
                    if (error)
                        return "tablet_map." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ShardReplicationPositionsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.ShardReplicationPositionsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.ShardReplicationPositionsResponse} ShardReplicationPositionsResponse
         */
        ShardReplicationPositionsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.ShardReplicationPositionsResponse)
                return object;
            var message = new $root.vtctldata.ShardReplicationPositionsResponse();
            if (object.replication_statuses) {
                if (typeof object.replication_statuses !== "object")
                    throw TypeError(".vtctldata.ShardReplicationPositionsResponse.replication_statuses: object expected");
                message.replication_statuses = {};
                for (var keys = Object.keys(object.replication_statuses), i = 0; i < keys.length; ++i) {
                    if (typeof object.replication_statuses[keys[i]] !== "object")
                        throw TypeError(".vtctldata.ShardReplicationPositionsResponse.replication_statuses: object expected");
                    message.replication_statuses[keys[i]] = $root.replicationdata.Status.fromObject(object.replication_statuses[keys[i]]);
                }
            }
            if (object.tablet_map) {
                if (typeof object.tablet_map !== "object")
                    throw TypeError(".vtctldata.ShardReplicationPositionsResponse.tablet_map: object expected");
                message.tablet_map = {};
                for (var keys = Object.keys(object.tablet_map), i = 0; i < keys.length; ++i) {
                    if (typeof object.tablet_map[keys[i]] !== "object")
                        throw TypeError(".vtctldata.ShardReplicationPositionsResponse.tablet_map: object expected");
                    message.tablet_map[keys[i]] = $root.topodata.Tablet.fromObject(object.tablet_map[keys[i]]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ShardReplicationPositionsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.ShardReplicationPositionsResponse
         * @static
         * @param {vtctldata.ShardReplicationPositionsResponse} message ShardReplicationPositionsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ShardReplicationPositionsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults) {
                object.replication_statuses = {};
                object.tablet_map = {};
            }
            var keys2;
            if (message.replication_statuses && (keys2 = Object.keys(message.replication_statuses)).length) {
                object.replication_statuses = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.replication_statuses[keys2[j]] = $root.replicationdata.Status.toObject(message.replication_statuses[keys2[j]], options);
            }
            if (message.tablet_map && (keys2 = Object.keys(message.tablet_map)).length) {
                object.tablet_map = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.tablet_map[keys2[j]] = $root.topodata.Tablet.toObject(message.tablet_map[keys2[j]], options);
            }
            return object;
        };

        /**
         * Converts this ShardReplicationPositionsResponse to JSON.
         * @function toJSON
         * @memberof vtctldata.ShardReplicationPositionsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ShardReplicationPositionsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ShardReplicationPositionsResponse;
    })();

    vtctldata.TabletExternallyReparentedRequest = (function() {

        /**
         * Properties of a TabletExternallyReparentedRequest.
         * @memberof vtctldata
         * @interface ITabletExternallyReparentedRequest
         * @property {topodata.ITabletAlias|null} [tablet] TabletExternallyReparentedRequest tablet
         */

        /**
         * Constructs a new TabletExternallyReparentedRequest.
         * @memberof vtctldata
         * @classdesc Represents a TabletExternallyReparentedRequest.
         * @implements ITabletExternallyReparentedRequest
         * @constructor
         * @param {vtctldata.ITabletExternallyReparentedRequest=} [properties] Properties to set
         */
        function TabletExternallyReparentedRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TabletExternallyReparentedRequest tablet.
         * @member {topodata.ITabletAlias|null|undefined} tablet
         * @memberof vtctldata.TabletExternallyReparentedRequest
         * @instance
         */
        TabletExternallyReparentedRequest.prototype.tablet = null;

        /**
         * Creates a new TabletExternallyReparentedRequest instance using the specified properties.
         * @function create
         * @memberof vtctldata.TabletExternallyReparentedRequest
         * @static
         * @param {vtctldata.ITabletExternallyReparentedRequest=} [properties] Properties to set
         * @returns {vtctldata.TabletExternallyReparentedRequest} TabletExternallyReparentedRequest instance
         */
        TabletExternallyReparentedRequest.create = function create(properties) {
            return new TabletExternallyReparentedRequest(properties);
        };

        /**
         * Encodes the specified TabletExternallyReparentedRequest message. Does not implicitly {@link vtctldata.TabletExternallyReparentedRequest.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.TabletExternallyReparentedRequest
         * @static
         * @param {vtctldata.ITabletExternallyReparentedRequest} message TabletExternallyReparentedRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TabletExternallyReparentedRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tablet != null && Object.hasOwnProperty.call(message, "tablet"))
                $root.topodata.TabletAlias.encode(message.tablet, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TabletExternallyReparentedRequest message, length delimited. Does not implicitly {@link vtctldata.TabletExternallyReparentedRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.TabletExternallyReparentedRequest
         * @static
         * @param {vtctldata.ITabletExternallyReparentedRequest} message TabletExternallyReparentedRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TabletExternallyReparentedRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TabletExternallyReparentedRequest message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.TabletExternallyReparentedRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.TabletExternallyReparentedRequest} TabletExternallyReparentedRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TabletExternallyReparentedRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.TabletExternallyReparentedRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tablet = $root.topodata.TabletAlias.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TabletExternallyReparentedRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.TabletExternallyReparentedRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.TabletExternallyReparentedRequest} TabletExternallyReparentedRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TabletExternallyReparentedRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TabletExternallyReparentedRequest message.
         * @function verify
         * @memberof vtctldata.TabletExternallyReparentedRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TabletExternallyReparentedRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tablet != null && message.hasOwnProperty("tablet")) {
                var error = $root.topodata.TabletAlias.verify(message.tablet);
                if (error)
                    return "tablet." + error;
            }
            return null;
        };

        /**
         * Creates a TabletExternallyReparentedRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.TabletExternallyReparentedRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.TabletExternallyReparentedRequest} TabletExternallyReparentedRequest
         */
        TabletExternallyReparentedRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.TabletExternallyReparentedRequest)
                return object;
            var message = new $root.vtctldata.TabletExternallyReparentedRequest();
            if (object.tablet != null) {
                if (typeof object.tablet !== "object")
                    throw TypeError(".vtctldata.TabletExternallyReparentedRequest.tablet: object expected");
                message.tablet = $root.topodata.TabletAlias.fromObject(object.tablet);
            }
            return message;
        };

        /**
         * Creates a plain object from a TabletExternallyReparentedRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.TabletExternallyReparentedRequest
         * @static
         * @param {vtctldata.TabletExternallyReparentedRequest} message TabletExternallyReparentedRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TabletExternallyReparentedRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.tablet = null;
            if (message.tablet != null && message.hasOwnProperty("tablet"))
                object.tablet = $root.topodata.TabletAlias.toObject(message.tablet, options);
            return object;
        };

        /**
         * Converts this TabletExternallyReparentedRequest to JSON.
         * @function toJSON
         * @memberof vtctldata.TabletExternallyReparentedRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TabletExternallyReparentedRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TabletExternallyReparentedRequest;
    })();

    vtctldata.TabletExternallyReparentedResponse = (function() {

        /**
         * Properties of a TabletExternallyReparentedResponse.
         * @memberof vtctldata
         * @interface ITabletExternallyReparentedResponse
         * @property {string|null} [keyspace] TabletExternallyReparentedResponse keyspace
         * @property {string|null} [shard] TabletExternallyReparentedResponse shard
         * @property {topodata.ITabletAlias|null} [new_primary] TabletExternallyReparentedResponse new_primary
         * @property {topodata.ITabletAlias|null} [old_primary] TabletExternallyReparentedResponse old_primary
         */

        /**
         * Constructs a new TabletExternallyReparentedResponse.
         * @memberof vtctldata
         * @classdesc Represents a TabletExternallyReparentedResponse.
         * @implements ITabletExternallyReparentedResponse
         * @constructor
         * @param {vtctldata.ITabletExternallyReparentedResponse=} [properties] Properties to set
         */
        function TabletExternallyReparentedResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TabletExternallyReparentedResponse keyspace.
         * @member {string} keyspace
         * @memberof vtctldata.TabletExternallyReparentedResponse
         * @instance
         */
        TabletExternallyReparentedResponse.prototype.keyspace = "";

        /**
         * TabletExternallyReparentedResponse shard.
         * @member {string} shard
         * @memberof vtctldata.TabletExternallyReparentedResponse
         * @instance
         */
        TabletExternallyReparentedResponse.prototype.shard = "";

        /**
         * TabletExternallyReparentedResponse new_primary.
         * @member {topodata.ITabletAlias|null|undefined} new_primary
         * @memberof vtctldata.TabletExternallyReparentedResponse
         * @instance
         */
        TabletExternallyReparentedResponse.prototype.new_primary = null;

        /**
         * TabletExternallyReparentedResponse old_primary.
         * @member {topodata.ITabletAlias|null|undefined} old_primary
         * @memberof vtctldata.TabletExternallyReparentedResponse
         * @instance
         */
        TabletExternallyReparentedResponse.prototype.old_primary = null;

        /**
         * Creates a new TabletExternallyReparentedResponse instance using the specified properties.
         * @function create
         * @memberof vtctldata.TabletExternallyReparentedResponse
         * @static
         * @param {vtctldata.ITabletExternallyReparentedResponse=} [properties] Properties to set
         * @returns {vtctldata.TabletExternallyReparentedResponse} TabletExternallyReparentedResponse instance
         */
        TabletExternallyReparentedResponse.create = function create(properties) {
            return new TabletExternallyReparentedResponse(properties);
        };

        /**
         * Encodes the specified TabletExternallyReparentedResponse message. Does not implicitly {@link vtctldata.TabletExternallyReparentedResponse.verify|verify} messages.
         * @function encode
         * @memberof vtctldata.TabletExternallyReparentedResponse
         * @static
         * @param {vtctldata.ITabletExternallyReparentedResponse} message TabletExternallyReparentedResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TabletExternallyReparentedResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keyspace != null && Object.hasOwnProperty.call(message, "keyspace"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.keyspace);
            if (message.shard != null && Object.hasOwnProperty.call(message, "shard"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.shard);
            if (message.new_primary != null && Object.hasOwnProperty.call(message, "new_primary"))
                $root.topodata.TabletAlias.encode(message.new_primary, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.old_primary != null && Object.hasOwnProperty.call(message, "old_primary"))
                $root.topodata.TabletAlias.encode(message.old_primary, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TabletExternallyReparentedResponse message, length delimited. Does not implicitly {@link vtctldata.TabletExternallyReparentedResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof vtctldata.TabletExternallyReparentedResponse
         * @static
         * @param {vtctldata.ITabletExternallyReparentedResponse} message TabletExternallyReparentedResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TabletExternallyReparentedResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TabletExternallyReparentedResponse message from the specified reader or buffer.
         * @function decode
         * @memberof vtctldata.TabletExternallyReparentedResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {vtctldata.TabletExternallyReparentedResponse} TabletExternallyReparentedResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TabletExternallyReparentedResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vtctldata.TabletExternallyReparentedResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.keyspace = reader.string();
                    break;
                case 2:
                    message.shard = reader.string();
                    break;
                case 3:
                    message.new_primary = $root.topodata.TabletAlias.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.old_primary = $root.topodata.TabletAlias.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TabletExternallyReparentedResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof vtctldata.TabletExternallyReparentedResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {vtctldata.TabletExternallyReparentedResponse} TabletExternallyReparentedResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TabletExternallyReparentedResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TabletExternallyReparentedResponse message.
         * @function verify
         * @memberof vtctldata.TabletExternallyReparentedResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TabletExternallyReparentedResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                if (!$util.isString(message.keyspace))
                    return "keyspace: string expected";
            if (message.shard != null && message.hasOwnProperty("shard"))
                if (!$util.isString(message.shard))
                    return "shard: string expected";
            if (message.new_primary != null && message.hasOwnProperty("new_primary")) {
                var error = $root.topodata.TabletAlias.verify(message.new_primary);
                if (error)
                    return "new_primary." + error;
            }
            if (message.old_primary != null && message.hasOwnProperty("old_primary")) {
                var error = $root.topodata.TabletAlias.verify(message.old_primary);
                if (error)
                    return "old_primary." + error;
            }
            return null;
        };

        /**
         * Creates a TabletExternallyReparentedResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof vtctldata.TabletExternallyReparentedResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {vtctldata.TabletExternallyReparentedResponse} TabletExternallyReparentedResponse
         */
        TabletExternallyReparentedResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.vtctldata.TabletExternallyReparentedResponse)
                return object;
            var message = new $root.vtctldata.TabletExternallyReparentedResponse();
            if (object.keyspace != null)
                message.keyspace = String(object.keyspace);
            if (object.shard != null)
                message.shard = String(object.shard);
            if (object.new_primary != null) {
                if (typeof object.new_primary !== "object")
                    throw TypeError(".vtctldata.TabletExternallyReparentedResponse.new_primary: object expected");
                message.new_primary = $root.topodata.TabletAlias.fromObject(object.new_primary);
            }
            if (object.old_primary != null) {
                if (typeof object.old_primary !== "object")
                    throw TypeError(".vtctldata.TabletExternallyReparentedResponse.old_primary: object expected");
                message.old_primary = $root.topodata.TabletAlias.fromObject(object.old_primary);
            }
            return message;
        };

        /**
         * Creates a plain object from a TabletExternallyReparentedResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof vtctldata.TabletExternallyReparentedResponse
         * @static
         * @param {vtctldata.TabletExternallyReparentedResponse} message TabletExternallyReparentedResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TabletExternallyReparentedResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.keyspace = "";
                object.shard = "";
                object.new_primary = null;
                object.old_primary = null;
            }
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                object.keyspace = message.keyspace;
            if (message.shard != null && message.hasOwnProperty("shard"))
                object.shard = message.shard;
            if (message.new_primary != null && message.hasOwnProperty("new_primary"))
                object.new_primary = $root.topodata.TabletAlias.toObject(message.new_primary, options);
            if (message.old_primary != null && message.hasOwnProperty("old_primary"))
                object.old_primary = $root.topodata.TabletAlias.toObject(message.old_primary, options);
            return object;
        };

        /**
         * Converts this TabletExternallyReparentedResponse to JSON.
         * @function toJSON
         * @memberof vtctldata.TabletExternallyReparentedResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TabletExternallyReparentedResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TabletExternallyReparentedResponse;
    })();

    return vtctldata;
})();

$root.binlogdata = (function() {

    /**
     * Namespace binlogdata.
     * @exports binlogdata
     * @namespace
     */
    var binlogdata = {};

    binlogdata.Charset = (function() {

        /**
         * Properties of a Charset.
         * @memberof binlogdata
         * @interface ICharset
         * @property {number|null} [client] Charset client
         * @property {number|null} [conn] Charset conn
         * @property {number|null} [server] Charset server
         */

        /**
         * Constructs a new Charset.
         * @memberof binlogdata
         * @classdesc Represents a Charset.
         * @implements ICharset
         * @constructor
         * @param {binlogdata.ICharset=} [properties] Properties to set
         */
        function Charset(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Charset client.
         * @member {number} client
         * @memberof binlogdata.Charset
         * @instance
         */
        Charset.prototype.client = 0;

        /**
         * Charset conn.
         * @member {number} conn
         * @memberof binlogdata.Charset
         * @instance
         */
        Charset.prototype.conn = 0;

        /**
         * Charset server.
         * @member {number} server
         * @memberof binlogdata.Charset
         * @instance
         */
        Charset.prototype.server = 0;

        /**
         * Creates a new Charset instance using the specified properties.
         * @function create
         * @memberof binlogdata.Charset
         * @static
         * @param {binlogdata.ICharset=} [properties] Properties to set
         * @returns {binlogdata.Charset} Charset instance
         */
        Charset.create = function create(properties) {
            return new Charset(properties);
        };

        /**
         * Encodes the specified Charset message. Does not implicitly {@link binlogdata.Charset.verify|verify} messages.
         * @function encode
         * @memberof binlogdata.Charset
         * @static
         * @param {binlogdata.ICharset} message Charset message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Charset.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.client != null && Object.hasOwnProperty.call(message, "client"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.client);
            if (message.conn != null && Object.hasOwnProperty.call(message, "conn"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.conn);
            if (message.server != null && Object.hasOwnProperty.call(message, "server"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.server);
            return writer;
        };

        /**
         * Encodes the specified Charset message, length delimited. Does not implicitly {@link binlogdata.Charset.verify|verify} messages.
         * @function encodeDelimited
         * @memberof binlogdata.Charset
         * @static
         * @param {binlogdata.ICharset} message Charset message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Charset.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Charset message from the specified reader or buffer.
         * @function decode
         * @memberof binlogdata.Charset
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {binlogdata.Charset} Charset
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Charset.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.binlogdata.Charset();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.client = reader.int32();
                    break;
                case 2:
                    message.conn = reader.int32();
                    break;
                case 3:
                    message.server = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Charset message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof binlogdata.Charset
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {binlogdata.Charset} Charset
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Charset.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Charset message.
         * @function verify
         * @memberof binlogdata.Charset
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Charset.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.client != null && message.hasOwnProperty("client"))
                if (!$util.isInteger(message.client))
                    return "client: integer expected";
            if (message.conn != null && message.hasOwnProperty("conn"))
                if (!$util.isInteger(message.conn))
                    return "conn: integer expected";
            if (message.server != null && message.hasOwnProperty("server"))
                if (!$util.isInteger(message.server))
                    return "server: integer expected";
            return null;
        };

        /**
         * Creates a Charset message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof binlogdata.Charset
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {binlogdata.Charset} Charset
         */
        Charset.fromObject = function fromObject(object) {
            if (object instanceof $root.binlogdata.Charset)
                return object;
            var message = new $root.binlogdata.Charset();
            if (object.client != null)
                message.client = object.client | 0;
            if (object.conn != null)
                message.conn = object.conn | 0;
            if (object.server != null)
                message.server = object.server | 0;
            return message;
        };

        /**
         * Creates a plain object from a Charset message. Also converts values to other types if specified.
         * @function toObject
         * @memberof binlogdata.Charset
         * @static
         * @param {binlogdata.Charset} message Charset
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Charset.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.client = 0;
                object.conn = 0;
                object.server = 0;
            }
            if (message.client != null && message.hasOwnProperty("client"))
                object.client = message.client;
            if (message.conn != null && message.hasOwnProperty("conn"))
                object.conn = message.conn;
            if (message.server != null && message.hasOwnProperty("server"))
                object.server = message.server;
            return object;
        };

        /**
         * Converts this Charset to JSON.
         * @function toJSON
         * @memberof binlogdata.Charset
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Charset.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Charset;
    })();

    binlogdata.BinlogTransaction = (function() {

        /**
         * Properties of a BinlogTransaction.
         * @memberof binlogdata
         * @interface IBinlogTransaction
         * @property {Array.<binlogdata.BinlogTransaction.IStatement>|null} [statements] BinlogTransaction statements
         * @property {query.IEventToken|null} [event_token] BinlogTransaction event_token
         */

        /**
         * Constructs a new BinlogTransaction.
         * @memberof binlogdata
         * @classdesc Represents a BinlogTransaction.
         * @implements IBinlogTransaction
         * @constructor
         * @param {binlogdata.IBinlogTransaction=} [properties] Properties to set
         */
        function BinlogTransaction(properties) {
            this.statements = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BinlogTransaction statements.
         * @member {Array.<binlogdata.BinlogTransaction.IStatement>} statements
         * @memberof binlogdata.BinlogTransaction
         * @instance
         */
        BinlogTransaction.prototype.statements = $util.emptyArray;

        /**
         * BinlogTransaction event_token.
         * @member {query.IEventToken|null|undefined} event_token
         * @memberof binlogdata.BinlogTransaction
         * @instance
         */
        BinlogTransaction.prototype.event_token = null;

        /**
         * Creates a new BinlogTransaction instance using the specified properties.
         * @function create
         * @memberof binlogdata.BinlogTransaction
         * @static
         * @param {binlogdata.IBinlogTransaction=} [properties] Properties to set
         * @returns {binlogdata.BinlogTransaction} BinlogTransaction instance
         */
        BinlogTransaction.create = function create(properties) {
            return new BinlogTransaction(properties);
        };

        /**
         * Encodes the specified BinlogTransaction message. Does not implicitly {@link binlogdata.BinlogTransaction.verify|verify} messages.
         * @function encode
         * @memberof binlogdata.BinlogTransaction
         * @static
         * @param {binlogdata.IBinlogTransaction} message BinlogTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BinlogTransaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.statements != null && message.statements.length)
                for (var i = 0; i < message.statements.length; ++i)
                    $root.binlogdata.BinlogTransaction.Statement.encode(message.statements[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.event_token != null && Object.hasOwnProperty.call(message, "event_token"))
                $root.query.EventToken.encode(message.event_token, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BinlogTransaction message, length delimited. Does not implicitly {@link binlogdata.BinlogTransaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof binlogdata.BinlogTransaction
         * @static
         * @param {binlogdata.IBinlogTransaction} message BinlogTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BinlogTransaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BinlogTransaction message from the specified reader or buffer.
         * @function decode
         * @memberof binlogdata.BinlogTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {binlogdata.BinlogTransaction} BinlogTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BinlogTransaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.binlogdata.BinlogTransaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.statements && message.statements.length))
                        message.statements = [];
                    message.statements.push($root.binlogdata.BinlogTransaction.Statement.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.event_token = $root.query.EventToken.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BinlogTransaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof binlogdata.BinlogTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {binlogdata.BinlogTransaction} BinlogTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BinlogTransaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BinlogTransaction message.
         * @function verify
         * @memberof binlogdata.BinlogTransaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BinlogTransaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.statements != null && message.hasOwnProperty("statements")) {
                if (!Array.isArray(message.statements))
                    return "statements: array expected";
                for (var i = 0; i < message.statements.length; ++i) {
                    var error = $root.binlogdata.BinlogTransaction.Statement.verify(message.statements[i]);
                    if (error)
                        return "statements." + error;
                }
            }
            if (message.event_token != null && message.hasOwnProperty("event_token")) {
                var error = $root.query.EventToken.verify(message.event_token);
                if (error)
                    return "event_token." + error;
            }
            return null;
        };

        /**
         * Creates a BinlogTransaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof binlogdata.BinlogTransaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {binlogdata.BinlogTransaction} BinlogTransaction
         */
        BinlogTransaction.fromObject = function fromObject(object) {
            if (object instanceof $root.binlogdata.BinlogTransaction)
                return object;
            var message = new $root.binlogdata.BinlogTransaction();
            if (object.statements) {
                if (!Array.isArray(object.statements))
                    throw TypeError(".binlogdata.BinlogTransaction.statements: array expected");
                message.statements = [];
                for (var i = 0; i < object.statements.length; ++i) {
                    if (typeof object.statements[i] !== "object")
                        throw TypeError(".binlogdata.BinlogTransaction.statements: object expected");
                    message.statements[i] = $root.binlogdata.BinlogTransaction.Statement.fromObject(object.statements[i]);
                }
            }
            if (object.event_token != null) {
                if (typeof object.event_token !== "object")
                    throw TypeError(".binlogdata.BinlogTransaction.event_token: object expected");
                message.event_token = $root.query.EventToken.fromObject(object.event_token);
            }
            return message;
        };

        /**
         * Creates a plain object from a BinlogTransaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof binlogdata.BinlogTransaction
         * @static
         * @param {binlogdata.BinlogTransaction} message BinlogTransaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BinlogTransaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.statements = [];
            if (options.defaults)
                object.event_token = null;
            if (message.statements && message.statements.length) {
                object.statements = [];
                for (var j = 0; j < message.statements.length; ++j)
                    object.statements[j] = $root.binlogdata.BinlogTransaction.Statement.toObject(message.statements[j], options);
            }
            if (message.event_token != null && message.hasOwnProperty("event_token"))
                object.event_token = $root.query.EventToken.toObject(message.event_token, options);
            return object;
        };

        /**
         * Converts this BinlogTransaction to JSON.
         * @function toJSON
         * @memberof binlogdata.BinlogTransaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BinlogTransaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        BinlogTransaction.Statement = (function() {

            /**
             * Properties of a Statement.
             * @memberof binlogdata.BinlogTransaction
             * @interface IStatement
             * @property {binlogdata.BinlogTransaction.Statement.Category|null} [category] Statement category
             * @property {binlogdata.ICharset|null} [charset] Statement charset
             * @property {Uint8Array|null} [sql] Statement sql
             */

            /**
             * Constructs a new Statement.
             * @memberof binlogdata.BinlogTransaction
             * @classdesc Represents a Statement.
             * @implements IStatement
             * @constructor
             * @param {binlogdata.BinlogTransaction.IStatement=} [properties] Properties to set
             */
            function Statement(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Statement category.
             * @member {binlogdata.BinlogTransaction.Statement.Category} category
             * @memberof binlogdata.BinlogTransaction.Statement
             * @instance
             */
            Statement.prototype.category = 0;

            /**
             * Statement charset.
             * @member {binlogdata.ICharset|null|undefined} charset
             * @memberof binlogdata.BinlogTransaction.Statement
             * @instance
             */
            Statement.prototype.charset = null;

            /**
             * Statement sql.
             * @member {Uint8Array} sql
             * @memberof binlogdata.BinlogTransaction.Statement
             * @instance
             */
            Statement.prototype.sql = $util.newBuffer([]);

            /**
             * Creates a new Statement instance using the specified properties.
             * @function create
             * @memberof binlogdata.BinlogTransaction.Statement
             * @static
             * @param {binlogdata.BinlogTransaction.IStatement=} [properties] Properties to set
             * @returns {binlogdata.BinlogTransaction.Statement} Statement instance
             */
            Statement.create = function create(properties) {
                return new Statement(properties);
            };

            /**
             * Encodes the specified Statement message. Does not implicitly {@link binlogdata.BinlogTransaction.Statement.verify|verify} messages.
             * @function encode
             * @memberof binlogdata.BinlogTransaction.Statement
             * @static
             * @param {binlogdata.BinlogTransaction.IStatement} message Statement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Statement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.category != null && Object.hasOwnProperty.call(message, "category"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.category);
                if (message.charset != null && Object.hasOwnProperty.call(message, "charset"))
                    $root.binlogdata.Charset.encode(message.charset, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.sql != null && Object.hasOwnProperty.call(message, "sql"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.sql);
                return writer;
            };

            /**
             * Encodes the specified Statement message, length delimited. Does not implicitly {@link binlogdata.BinlogTransaction.Statement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof binlogdata.BinlogTransaction.Statement
             * @static
             * @param {binlogdata.BinlogTransaction.IStatement} message Statement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Statement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Statement message from the specified reader or buffer.
             * @function decode
             * @memberof binlogdata.BinlogTransaction.Statement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {binlogdata.BinlogTransaction.Statement} Statement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Statement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.binlogdata.BinlogTransaction.Statement();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.category = reader.int32();
                        break;
                    case 2:
                        message.charset = $root.binlogdata.Charset.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.sql = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Statement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof binlogdata.BinlogTransaction.Statement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {binlogdata.BinlogTransaction.Statement} Statement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Statement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Statement message.
             * @function verify
             * @memberof binlogdata.BinlogTransaction.Statement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Statement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.category != null && message.hasOwnProperty("category"))
                    switch (message.category) {
                    default:
                        return "category: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                        break;
                    }
                if (message.charset != null && message.hasOwnProperty("charset")) {
                    var error = $root.binlogdata.Charset.verify(message.charset);
                    if (error)
                        return "charset." + error;
                }
                if (message.sql != null && message.hasOwnProperty("sql"))
                    if (!(message.sql && typeof message.sql.length === "number" || $util.isString(message.sql)))
                        return "sql: buffer expected";
                return null;
            };

            /**
             * Creates a Statement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof binlogdata.BinlogTransaction.Statement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {binlogdata.BinlogTransaction.Statement} Statement
             */
            Statement.fromObject = function fromObject(object) {
                if (object instanceof $root.binlogdata.BinlogTransaction.Statement)
                    return object;
                var message = new $root.binlogdata.BinlogTransaction.Statement();
                switch (object.category) {
                case "BL_UNRECOGNIZED":
                case 0:
                    message.category = 0;
                    break;
                case "BL_BEGIN":
                case 1:
                    message.category = 1;
                    break;
                case "BL_COMMIT":
                case 2:
                    message.category = 2;
                    break;
                case "BL_ROLLBACK":
                case 3:
                    message.category = 3;
                    break;
                case "BL_DML_DEPRECATED":
                case 4:
                    message.category = 4;
                    break;
                case "BL_DDL":
                case 5:
                    message.category = 5;
                    break;
                case "BL_SET":
                case 6:
                    message.category = 6;
                    break;
                case "BL_INSERT":
                case 7:
                    message.category = 7;
                    break;
                case "BL_UPDATE":
                case 8:
                    message.category = 8;
                    break;
                case "BL_DELETE":
                case 9:
                    message.category = 9;
                    break;
                }
                if (object.charset != null) {
                    if (typeof object.charset !== "object")
                        throw TypeError(".binlogdata.BinlogTransaction.Statement.charset: object expected");
                    message.charset = $root.binlogdata.Charset.fromObject(object.charset);
                }
                if (object.sql != null)
                    if (typeof object.sql === "string")
                        $util.base64.decode(object.sql, message.sql = $util.newBuffer($util.base64.length(object.sql)), 0);
                    else if (object.sql.length)
                        message.sql = object.sql;
                return message;
            };

            /**
             * Creates a plain object from a Statement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof binlogdata.BinlogTransaction.Statement
             * @static
             * @param {binlogdata.BinlogTransaction.Statement} message Statement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Statement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.category = options.enums === String ? "BL_UNRECOGNIZED" : 0;
                    object.charset = null;
                    if (options.bytes === String)
                        object.sql = "";
                    else {
                        object.sql = [];
                        if (options.bytes !== Array)
                            object.sql = $util.newBuffer(object.sql);
                    }
                }
                if (message.category != null && message.hasOwnProperty("category"))
                    object.category = options.enums === String ? $root.binlogdata.BinlogTransaction.Statement.Category[message.category] : message.category;
                if (message.charset != null && message.hasOwnProperty("charset"))
                    object.charset = $root.binlogdata.Charset.toObject(message.charset, options);
                if (message.sql != null && message.hasOwnProperty("sql"))
                    object.sql = options.bytes === String ? $util.base64.encode(message.sql, 0, message.sql.length) : options.bytes === Array ? Array.prototype.slice.call(message.sql) : message.sql;
                return object;
            };

            /**
             * Converts this Statement to JSON.
             * @function toJSON
             * @memberof binlogdata.BinlogTransaction.Statement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Statement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Category enum.
             * @name binlogdata.BinlogTransaction.Statement.Category
             * @enum {number}
             * @property {number} BL_UNRECOGNIZED=0 BL_UNRECOGNIZED value
             * @property {number} BL_BEGIN=1 BL_BEGIN value
             * @property {number} BL_COMMIT=2 BL_COMMIT value
             * @property {number} BL_ROLLBACK=3 BL_ROLLBACK value
             * @property {number} BL_DML_DEPRECATED=4 BL_DML_DEPRECATED value
             * @property {number} BL_DDL=5 BL_DDL value
             * @property {number} BL_SET=6 BL_SET value
             * @property {number} BL_INSERT=7 BL_INSERT value
             * @property {number} BL_UPDATE=8 BL_UPDATE value
             * @property {number} BL_DELETE=9 BL_DELETE value
             */
            Statement.Category = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "BL_UNRECOGNIZED"] = 0;
                values[valuesById[1] = "BL_BEGIN"] = 1;
                values[valuesById[2] = "BL_COMMIT"] = 2;
                values[valuesById[3] = "BL_ROLLBACK"] = 3;
                values[valuesById[4] = "BL_DML_DEPRECATED"] = 4;
                values[valuesById[5] = "BL_DDL"] = 5;
                values[valuesById[6] = "BL_SET"] = 6;
                values[valuesById[7] = "BL_INSERT"] = 7;
                values[valuesById[8] = "BL_UPDATE"] = 8;
                values[valuesById[9] = "BL_DELETE"] = 9;
                return values;
            })();

            return Statement;
        })();

        return BinlogTransaction;
    })();

    binlogdata.StreamKeyRangeRequest = (function() {

        /**
         * Properties of a StreamKeyRangeRequest.
         * @memberof binlogdata
         * @interface IStreamKeyRangeRequest
         * @property {string|null} [position] StreamKeyRangeRequest position
         * @property {topodata.IKeyRange|null} [key_range] StreamKeyRangeRequest key_range
         * @property {binlogdata.ICharset|null} [charset] StreamKeyRangeRequest charset
         */

        /**
         * Constructs a new StreamKeyRangeRequest.
         * @memberof binlogdata
         * @classdesc Represents a StreamKeyRangeRequest.
         * @implements IStreamKeyRangeRequest
         * @constructor
         * @param {binlogdata.IStreamKeyRangeRequest=} [properties] Properties to set
         */
        function StreamKeyRangeRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StreamKeyRangeRequest position.
         * @member {string} position
         * @memberof binlogdata.StreamKeyRangeRequest
         * @instance
         */
        StreamKeyRangeRequest.prototype.position = "";

        /**
         * StreamKeyRangeRequest key_range.
         * @member {topodata.IKeyRange|null|undefined} key_range
         * @memberof binlogdata.StreamKeyRangeRequest
         * @instance
         */
        StreamKeyRangeRequest.prototype.key_range = null;

        /**
         * StreamKeyRangeRequest charset.
         * @member {binlogdata.ICharset|null|undefined} charset
         * @memberof binlogdata.StreamKeyRangeRequest
         * @instance
         */
        StreamKeyRangeRequest.prototype.charset = null;

        /**
         * Creates a new StreamKeyRangeRequest instance using the specified properties.
         * @function create
         * @memberof binlogdata.StreamKeyRangeRequest
         * @static
         * @param {binlogdata.IStreamKeyRangeRequest=} [properties] Properties to set
         * @returns {binlogdata.StreamKeyRangeRequest} StreamKeyRangeRequest instance
         */
        StreamKeyRangeRequest.create = function create(properties) {
            return new StreamKeyRangeRequest(properties);
        };

        /**
         * Encodes the specified StreamKeyRangeRequest message. Does not implicitly {@link binlogdata.StreamKeyRangeRequest.verify|verify} messages.
         * @function encode
         * @memberof binlogdata.StreamKeyRangeRequest
         * @static
         * @param {binlogdata.IStreamKeyRangeRequest} message StreamKeyRangeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamKeyRangeRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.position);
            if (message.key_range != null && Object.hasOwnProperty.call(message, "key_range"))
                $root.topodata.KeyRange.encode(message.key_range, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.charset != null && Object.hasOwnProperty.call(message, "charset"))
                $root.binlogdata.Charset.encode(message.charset, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified StreamKeyRangeRequest message, length delimited. Does not implicitly {@link binlogdata.StreamKeyRangeRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof binlogdata.StreamKeyRangeRequest
         * @static
         * @param {binlogdata.IStreamKeyRangeRequest} message StreamKeyRangeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamKeyRangeRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StreamKeyRangeRequest message from the specified reader or buffer.
         * @function decode
         * @memberof binlogdata.StreamKeyRangeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {binlogdata.StreamKeyRangeRequest} StreamKeyRangeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamKeyRangeRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.binlogdata.StreamKeyRangeRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.position = reader.string();
                    break;
                case 2:
                    message.key_range = $root.topodata.KeyRange.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.charset = $root.binlogdata.Charset.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StreamKeyRangeRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof binlogdata.StreamKeyRangeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {binlogdata.StreamKeyRangeRequest} StreamKeyRangeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamKeyRangeRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StreamKeyRangeRequest message.
         * @function verify
         * @memberof binlogdata.StreamKeyRangeRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StreamKeyRangeRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.position != null && message.hasOwnProperty("position"))
                if (!$util.isString(message.position))
                    return "position: string expected";
            if (message.key_range != null && message.hasOwnProperty("key_range")) {
                var error = $root.topodata.KeyRange.verify(message.key_range);
                if (error)
                    return "key_range." + error;
            }
            if (message.charset != null && message.hasOwnProperty("charset")) {
                var error = $root.binlogdata.Charset.verify(message.charset);
                if (error)
                    return "charset." + error;
            }
            return null;
        };

        /**
         * Creates a StreamKeyRangeRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof binlogdata.StreamKeyRangeRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {binlogdata.StreamKeyRangeRequest} StreamKeyRangeRequest
         */
        StreamKeyRangeRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.binlogdata.StreamKeyRangeRequest)
                return object;
            var message = new $root.binlogdata.StreamKeyRangeRequest();
            if (object.position != null)
                message.position = String(object.position);
            if (object.key_range != null) {
                if (typeof object.key_range !== "object")
                    throw TypeError(".binlogdata.StreamKeyRangeRequest.key_range: object expected");
                message.key_range = $root.topodata.KeyRange.fromObject(object.key_range);
            }
            if (object.charset != null) {
                if (typeof object.charset !== "object")
                    throw TypeError(".binlogdata.StreamKeyRangeRequest.charset: object expected");
                message.charset = $root.binlogdata.Charset.fromObject(object.charset);
            }
            return message;
        };

        /**
         * Creates a plain object from a StreamKeyRangeRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof binlogdata.StreamKeyRangeRequest
         * @static
         * @param {binlogdata.StreamKeyRangeRequest} message StreamKeyRangeRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StreamKeyRangeRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.position = "";
                object.key_range = null;
                object.charset = null;
            }
            if (message.position != null && message.hasOwnProperty("position"))
                object.position = message.position;
            if (message.key_range != null && message.hasOwnProperty("key_range"))
                object.key_range = $root.topodata.KeyRange.toObject(message.key_range, options);
            if (message.charset != null && message.hasOwnProperty("charset"))
                object.charset = $root.binlogdata.Charset.toObject(message.charset, options);
            return object;
        };

        /**
         * Converts this StreamKeyRangeRequest to JSON.
         * @function toJSON
         * @memberof binlogdata.StreamKeyRangeRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StreamKeyRangeRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StreamKeyRangeRequest;
    })();

    binlogdata.StreamKeyRangeResponse = (function() {

        /**
         * Properties of a StreamKeyRangeResponse.
         * @memberof binlogdata
         * @interface IStreamKeyRangeResponse
         * @property {binlogdata.IBinlogTransaction|null} [binlog_transaction] StreamKeyRangeResponse binlog_transaction
         */

        /**
         * Constructs a new StreamKeyRangeResponse.
         * @memberof binlogdata
         * @classdesc Represents a StreamKeyRangeResponse.
         * @implements IStreamKeyRangeResponse
         * @constructor
         * @param {binlogdata.IStreamKeyRangeResponse=} [properties] Properties to set
         */
        function StreamKeyRangeResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StreamKeyRangeResponse binlog_transaction.
         * @member {binlogdata.IBinlogTransaction|null|undefined} binlog_transaction
         * @memberof binlogdata.StreamKeyRangeResponse
         * @instance
         */
        StreamKeyRangeResponse.prototype.binlog_transaction = null;

        /**
         * Creates a new StreamKeyRangeResponse instance using the specified properties.
         * @function create
         * @memberof binlogdata.StreamKeyRangeResponse
         * @static
         * @param {binlogdata.IStreamKeyRangeResponse=} [properties] Properties to set
         * @returns {binlogdata.StreamKeyRangeResponse} StreamKeyRangeResponse instance
         */
        StreamKeyRangeResponse.create = function create(properties) {
            return new StreamKeyRangeResponse(properties);
        };

        /**
         * Encodes the specified StreamKeyRangeResponse message. Does not implicitly {@link binlogdata.StreamKeyRangeResponse.verify|verify} messages.
         * @function encode
         * @memberof binlogdata.StreamKeyRangeResponse
         * @static
         * @param {binlogdata.IStreamKeyRangeResponse} message StreamKeyRangeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamKeyRangeResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.binlog_transaction != null && Object.hasOwnProperty.call(message, "binlog_transaction"))
                $root.binlogdata.BinlogTransaction.encode(message.binlog_transaction, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified StreamKeyRangeResponse message, length delimited. Does not implicitly {@link binlogdata.StreamKeyRangeResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof binlogdata.StreamKeyRangeResponse
         * @static
         * @param {binlogdata.IStreamKeyRangeResponse} message StreamKeyRangeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamKeyRangeResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StreamKeyRangeResponse message from the specified reader or buffer.
         * @function decode
         * @memberof binlogdata.StreamKeyRangeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {binlogdata.StreamKeyRangeResponse} StreamKeyRangeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamKeyRangeResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.binlogdata.StreamKeyRangeResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.binlog_transaction = $root.binlogdata.BinlogTransaction.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StreamKeyRangeResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof binlogdata.StreamKeyRangeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {binlogdata.StreamKeyRangeResponse} StreamKeyRangeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamKeyRangeResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StreamKeyRangeResponse message.
         * @function verify
         * @memberof binlogdata.StreamKeyRangeResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StreamKeyRangeResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.binlog_transaction != null && message.hasOwnProperty("binlog_transaction")) {
                var error = $root.binlogdata.BinlogTransaction.verify(message.binlog_transaction);
                if (error)
                    return "binlog_transaction." + error;
            }
            return null;
        };

        /**
         * Creates a StreamKeyRangeResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof binlogdata.StreamKeyRangeResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {binlogdata.StreamKeyRangeResponse} StreamKeyRangeResponse
         */
        StreamKeyRangeResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.binlogdata.StreamKeyRangeResponse)
                return object;
            var message = new $root.binlogdata.StreamKeyRangeResponse();
            if (object.binlog_transaction != null) {
                if (typeof object.binlog_transaction !== "object")
                    throw TypeError(".binlogdata.StreamKeyRangeResponse.binlog_transaction: object expected");
                message.binlog_transaction = $root.binlogdata.BinlogTransaction.fromObject(object.binlog_transaction);
            }
            return message;
        };

        /**
         * Creates a plain object from a StreamKeyRangeResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof binlogdata.StreamKeyRangeResponse
         * @static
         * @param {binlogdata.StreamKeyRangeResponse} message StreamKeyRangeResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StreamKeyRangeResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.binlog_transaction = null;
            if (message.binlog_transaction != null && message.hasOwnProperty("binlog_transaction"))
                object.binlog_transaction = $root.binlogdata.BinlogTransaction.toObject(message.binlog_transaction, options);
            return object;
        };

        /**
         * Converts this StreamKeyRangeResponse to JSON.
         * @function toJSON
         * @memberof binlogdata.StreamKeyRangeResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StreamKeyRangeResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StreamKeyRangeResponse;
    })();

    binlogdata.StreamTablesRequest = (function() {

        /**
         * Properties of a StreamTablesRequest.
         * @memberof binlogdata
         * @interface IStreamTablesRequest
         * @property {string|null} [position] StreamTablesRequest position
         * @property {Array.<string>|null} [tables] StreamTablesRequest tables
         * @property {binlogdata.ICharset|null} [charset] StreamTablesRequest charset
         */

        /**
         * Constructs a new StreamTablesRequest.
         * @memberof binlogdata
         * @classdesc Represents a StreamTablesRequest.
         * @implements IStreamTablesRequest
         * @constructor
         * @param {binlogdata.IStreamTablesRequest=} [properties] Properties to set
         */
        function StreamTablesRequest(properties) {
            this.tables = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StreamTablesRequest position.
         * @member {string} position
         * @memberof binlogdata.StreamTablesRequest
         * @instance
         */
        StreamTablesRequest.prototype.position = "";

        /**
         * StreamTablesRequest tables.
         * @member {Array.<string>} tables
         * @memberof binlogdata.StreamTablesRequest
         * @instance
         */
        StreamTablesRequest.prototype.tables = $util.emptyArray;

        /**
         * StreamTablesRequest charset.
         * @member {binlogdata.ICharset|null|undefined} charset
         * @memberof binlogdata.StreamTablesRequest
         * @instance
         */
        StreamTablesRequest.prototype.charset = null;

        /**
         * Creates a new StreamTablesRequest instance using the specified properties.
         * @function create
         * @memberof binlogdata.StreamTablesRequest
         * @static
         * @param {binlogdata.IStreamTablesRequest=} [properties] Properties to set
         * @returns {binlogdata.StreamTablesRequest} StreamTablesRequest instance
         */
        StreamTablesRequest.create = function create(properties) {
            return new StreamTablesRequest(properties);
        };

        /**
         * Encodes the specified StreamTablesRequest message. Does not implicitly {@link binlogdata.StreamTablesRequest.verify|verify} messages.
         * @function encode
         * @memberof binlogdata.StreamTablesRequest
         * @static
         * @param {binlogdata.IStreamTablesRequest} message StreamTablesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamTablesRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.position);
            if (message.tables != null && message.tables.length)
                for (var i = 0; i < message.tables.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.tables[i]);
            if (message.charset != null && Object.hasOwnProperty.call(message, "charset"))
                $root.binlogdata.Charset.encode(message.charset, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified StreamTablesRequest message, length delimited. Does not implicitly {@link binlogdata.StreamTablesRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof binlogdata.StreamTablesRequest
         * @static
         * @param {binlogdata.IStreamTablesRequest} message StreamTablesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamTablesRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StreamTablesRequest message from the specified reader or buffer.
         * @function decode
         * @memberof binlogdata.StreamTablesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {binlogdata.StreamTablesRequest} StreamTablesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamTablesRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.binlogdata.StreamTablesRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.position = reader.string();
                    break;
                case 2:
                    if (!(message.tables && message.tables.length))
                        message.tables = [];
                    message.tables.push(reader.string());
                    break;
                case 3:
                    message.charset = $root.binlogdata.Charset.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StreamTablesRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof binlogdata.StreamTablesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {binlogdata.StreamTablesRequest} StreamTablesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamTablesRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StreamTablesRequest message.
         * @function verify
         * @memberof binlogdata.StreamTablesRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StreamTablesRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.position != null && message.hasOwnProperty("position"))
                if (!$util.isString(message.position))
                    return "position: string expected";
            if (message.tables != null && message.hasOwnProperty("tables")) {
                if (!Array.isArray(message.tables))
                    return "tables: array expected";
                for (var i = 0; i < message.tables.length; ++i)
                    if (!$util.isString(message.tables[i]))
                        return "tables: string[] expected";
            }
            if (message.charset != null && message.hasOwnProperty("charset")) {
                var error = $root.binlogdata.Charset.verify(message.charset);
                if (error)
                    return "charset." + error;
            }
            return null;
        };

        /**
         * Creates a StreamTablesRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof binlogdata.StreamTablesRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {binlogdata.StreamTablesRequest} StreamTablesRequest
         */
        StreamTablesRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.binlogdata.StreamTablesRequest)
                return object;
            var message = new $root.binlogdata.StreamTablesRequest();
            if (object.position != null)
                message.position = String(object.position);
            if (object.tables) {
                if (!Array.isArray(object.tables))
                    throw TypeError(".binlogdata.StreamTablesRequest.tables: array expected");
                message.tables = [];
                for (var i = 0; i < object.tables.length; ++i)
                    message.tables[i] = String(object.tables[i]);
            }
            if (object.charset != null) {
                if (typeof object.charset !== "object")
                    throw TypeError(".binlogdata.StreamTablesRequest.charset: object expected");
                message.charset = $root.binlogdata.Charset.fromObject(object.charset);
            }
            return message;
        };

        /**
         * Creates a plain object from a StreamTablesRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof binlogdata.StreamTablesRequest
         * @static
         * @param {binlogdata.StreamTablesRequest} message StreamTablesRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StreamTablesRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.tables = [];
            if (options.defaults) {
                object.position = "";
                object.charset = null;
            }
            if (message.position != null && message.hasOwnProperty("position"))
                object.position = message.position;
            if (message.tables && message.tables.length) {
                object.tables = [];
                for (var j = 0; j < message.tables.length; ++j)
                    object.tables[j] = message.tables[j];
            }
            if (message.charset != null && message.hasOwnProperty("charset"))
                object.charset = $root.binlogdata.Charset.toObject(message.charset, options);
            return object;
        };

        /**
         * Converts this StreamTablesRequest to JSON.
         * @function toJSON
         * @memberof binlogdata.StreamTablesRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StreamTablesRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StreamTablesRequest;
    })();

    binlogdata.StreamTablesResponse = (function() {

        /**
         * Properties of a StreamTablesResponse.
         * @memberof binlogdata
         * @interface IStreamTablesResponse
         * @property {binlogdata.IBinlogTransaction|null} [binlog_transaction] StreamTablesResponse binlog_transaction
         */

        /**
         * Constructs a new StreamTablesResponse.
         * @memberof binlogdata
         * @classdesc Represents a StreamTablesResponse.
         * @implements IStreamTablesResponse
         * @constructor
         * @param {binlogdata.IStreamTablesResponse=} [properties] Properties to set
         */
        function StreamTablesResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StreamTablesResponse binlog_transaction.
         * @member {binlogdata.IBinlogTransaction|null|undefined} binlog_transaction
         * @memberof binlogdata.StreamTablesResponse
         * @instance
         */
        StreamTablesResponse.prototype.binlog_transaction = null;

        /**
         * Creates a new StreamTablesResponse instance using the specified properties.
         * @function create
         * @memberof binlogdata.StreamTablesResponse
         * @static
         * @param {binlogdata.IStreamTablesResponse=} [properties] Properties to set
         * @returns {binlogdata.StreamTablesResponse} StreamTablesResponse instance
         */
        StreamTablesResponse.create = function create(properties) {
            return new StreamTablesResponse(properties);
        };

        /**
         * Encodes the specified StreamTablesResponse message. Does not implicitly {@link binlogdata.StreamTablesResponse.verify|verify} messages.
         * @function encode
         * @memberof binlogdata.StreamTablesResponse
         * @static
         * @param {binlogdata.IStreamTablesResponse} message StreamTablesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamTablesResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.binlog_transaction != null && Object.hasOwnProperty.call(message, "binlog_transaction"))
                $root.binlogdata.BinlogTransaction.encode(message.binlog_transaction, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified StreamTablesResponse message, length delimited. Does not implicitly {@link binlogdata.StreamTablesResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof binlogdata.StreamTablesResponse
         * @static
         * @param {binlogdata.IStreamTablesResponse} message StreamTablesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamTablesResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StreamTablesResponse message from the specified reader or buffer.
         * @function decode
         * @memberof binlogdata.StreamTablesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {binlogdata.StreamTablesResponse} StreamTablesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamTablesResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.binlogdata.StreamTablesResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.binlog_transaction = $root.binlogdata.BinlogTransaction.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StreamTablesResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof binlogdata.StreamTablesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {binlogdata.StreamTablesResponse} StreamTablesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamTablesResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StreamTablesResponse message.
         * @function verify
         * @memberof binlogdata.StreamTablesResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StreamTablesResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.binlog_transaction != null && message.hasOwnProperty("binlog_transaction")) {
                var error = $root.binlogdata.BinlogTransaction.verify(message.binlog_transaction);
                if (error)
                    return "binlog_transaction." + error;
            }
            return null;
        };

        /**
         * Creates a StreamTablesResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof binlogdata.StreamTablesResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {binlogdata.StreamTablesResponse} StreamTablesResponse
         */
        StreamTablesResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.binlogdata.StreamTablesResponse)
                return object;
            var message = new $root.binlogdata.StreamTablesResponse();
            if (object.binlog_transaction != null) {
                if (typeof object.binlog_transaction !== "object")
                    throw TypeError(".binlogdata.StreamTablesResponse.binlog_transaction: object expected");
                message.binlog_transaction = $root.binlogdata.BinlogTransaction.fromObject(object.binlog_transaction);
            }
            return message;
        };

        /**
         * Creates a plain object from a StreamTablesResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof binlogdata.StreamTablesResponse
         * @static
         * @param {binlogdata.StreamTablesResponse} message StreamTablesResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StreamTablesResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.binlog_transaction = null;
            if (message.binlog_transaction != null && message.hasOwnProperty("binlog_transaction"))
                object.binlog_transaction = $root.binlogdata.BinlogTransaction.toObject(message.binlog_transaction, options);
            return object;
        };

        /**
         * Converts this StreamTablesResponse to JSON.
         * @function toJSON
         * @memberof binlogdata.StreamTablesResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StreamTablesResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StreamTablesResponse;
    })();

    binlogdata.Rule = (function() {

        /**
         * Properties of a Rule.
         * @memberof binlogdata
         * @interface IRule
         * @property {string|null} [match] Rule match
         * @property {string|null} [filter] Rule filter
         */

        /**
         * Constructs a new Rule.
         * @memberof binlogdata
         * @classdesc Represents a Rule.
         * @implements IRule
         * @constructor
         * @param {binlogdata.IRule=} [properties] Properties to set
         */
        function Rule(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Rule match.
         * @member {string} match
         * @memberof binlogdata.Rule
         * @instance
         */
        Rule.prototype.match = "";

        /**
         * Rule filter.
         * @member {string} filter
         * @memberof binlogdata.Rule
         * @instance
         */
        Rule.prototype.filter = "";

        /**
         * Creates a new Rule instance using the specified properties.
         * @function create
         * @memberof binlogdata.Rule
         * @static
         * @param {binlogdata.IRule=} [properties] Properties to set
         * @returns {binlogdata.Rule} Rule instance
         */
        Rule.create = function create(properties) {
            return new Rule(properties);
        };

        /**
         * Encodes the specified Rule message. Does not implicitly {@link binlogdata.Rule.verify|verify} messages.
         * @function encode
         * @memberof binlogdata.Rule
         * @static
         * @param {binlogdata.IRule} message Rule message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Rule.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.match != null && Object.hasOwnProperty.call(message, "match"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.match);
            if (message.filter != null && Object.hasOwnProperty.call(message, "filter"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.filter);
            return writer;
        };

        /**
         * Encodes the specified Rule message, length delimited. Does not implicitly {@link binlogdata.Rule.verify|verify} messages.
         * @function encodeDelimited
         * @memberof binlogdata.Rule
         * @static
         * @param {binlogdata.IRule} message Rule message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Rule.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Rule message from the specified reader or buffer.
         * @function decode
         * @memberof binlogdata.Rule
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {binlogdata.Rule} Rule
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Rule.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.binlogdata.Rule();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.match = reader.string();
                    break;
                case 2:
                    message.filter = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Rule message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof binlogdata.Rule
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {binlogdata.Rule} Rule
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Rule.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Rule message.
         * @function verify
         * @memberof binlogdata.Rule
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Rule.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.match != null && message.hasOwnProperty("match"))
                if (!$util.isString(message.match))
                    return "match: string expected";
            if (message.filter != null && message.hasOwnProperty("filter"))
                if (!$util.isString(message.filter))
                    return "filter: string expected";
            return null;
        };

        /**
         * Creates a Rule message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof binlogdata.Rule
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {binlogdata.Rule} Rule
         */
        Rule.fromObject = function fromObject(object) {
            if (object instanceof $root.binlogdata.Rule)
                return object;
            var message = new $root.binlogdata.Rule();
            if (object.match != null)
                message.match = String(object.match);
            if (object.filter != null)
                message.filter = String(object.filter);
            return message;
        };

        /**
         * Creates a plain object from a Rule message. Also converts values to other types if specified.
         * @function toObject
         * @memberof binlogdata.Rule
         * @static
         * @param {binlogdata.Rule} message Rule
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Rule.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.match = "";
                object.filter = "";
            }
            if (message.match != null && message.hasOwnProperty("match"))
                object.match = message.match;
            if (message.filter != null && message.hasOwnProperty("filter"))
                object.filter = message.filter;
            return object;
        };

        /**
         * Converts this Rule to JSON.
         * @function toJSON
         * @memberof binlogdata.Rule
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Rule.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Rule;
    })();

    binlogdata.Filter = (function() {

        /**
         * Properties of a Filter.
         * @memberof binlogdata
         * @interface IFilter
         * @property {Array.<binlogdata.IRule>|null} [rules] Filter rules
         * @property {binlogdata.Filter.FieldEventMode|null} [fieldEventMode] Filter fieldEventMode
         */

        /**
         * Constructs a new Filter.
         * @memberof binlogdata
         * @classdesc Represents a Filter.
         * @implements IFilter
         * @constructor
         * @param {binlogdata.IFilter=} [properties] Properties to set
         */
        function Filter(properties) {
            this.rules = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Filter rules.
         * @member {Array.<binlogdata.IRule>} rules
         * @memberof binlogdata.Filter
         * @instance
         */
        Filter.prototype.rules = $util.emptyArray;

        /**
         * Filter fieldEventMode.
         * @member {binlogdata.Filter.FieldEventMode} fieldEventMode
         * @memberof binlogdata.Filter
         * @instance
         */
        Filter.prototype.fieldEventMode = 0;

        /**
         * Creates a new Filter instance using the specified properties.
         * @function create
         * @memberof binlogdata.Filter
         * @static
         * @param {binlogdata.IFilter=} [properties] Properties to set
         * @returns {binlogdata.Filter} Filter instance
         */
        Filter.create = function create(properties) {
            return new Filter(properties);
        };

        /**
         * Encodes the specified Filter message. Does not implicitly {@link binlogdata.Filter.verify|verify} messages.
         * @function encode
         * @memberof binlogdata.Filter
         * @static
         * @param {binlogdata.IFilter} message Filter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Filter.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rules != null && message.rules.length)
                for (var i = 0; i < message.rules.length; ++i)
                    $root.binlogdata.Rule.encode(message.rules[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.fieldEventMode != null && Object.hasOwnProperty.call(message, "fieldEventMode"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.fieldEventMode);
            return writer;
        };

        /**
         * Encodes the specified Filter message, length delimited. Does not implicitly {@link binlogdata.Filter.verify|verify} messages.
         * @function encodeDelimited
         * @memberof binlogdata.Filter
         * @static
         * @param {binlogdata.IFilter} message Filter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Filter.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Filter message from the specified reader or buffer.
         * @function decode
         * @memberof binlogdata.Filter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {binlogdata.Filter} Filter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Filter.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.binlogdata.Filter();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.rules && message.rules.length))
                        message.rules = [];
                    message.rules.push($root.binlogdata.Rule.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.fieldEventMode = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Filter message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof binlogdata.Filter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {binlogdata.Filter} Filter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Filter.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Filter message.
         * @function verify
         * @memberof binlogdata.Filter
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Filter.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rules != null && message.hasOwnProperty("rules")) {
                if (!Array.isArray(message.rules))
                    return "rules: array expected";
                for (var i = 0; i < message.rules.length; ++i) {
                    var error = $root.binlogdata.Rule.verify(message.rules[i]);
                    if (error)
                        return "rules." + error;
                }
            }
            if (message.fieldEventMode != null && message.hasOwnProperty("fieldEventMode"))
                switch (message.fieldEventMode) {
                default:
                    return "fieldEventMode: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a Filter message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof binlogdata.Filter
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {binlogdata.Filter} Filter
         */
        Filter.fromObject = function fromObject(object) {
            if (object instanceof $root.binlogdata.Filter)
                return object;
            var message = new $root.binlogdata.Filter();
            if (object.rules) {
                if (!Array.isArray(object.rules))
                    throw TypeError(".binlogdata.Filter.rules: array expected");
                message.rules = [];
                for (var i = 0; i < object.rules.length; ++i) {
                    if (typeof object.rules[i] !== "object")
                        throw TypeError(".binlogdata.Filter.rules: object expected");
                    message.rules[i] = $root.binlogdata.Rule.fromObject(object.rules[i]);
                }
            }
            switch (object.fieldEventMode) {
            case "ERR_ON_MISMATCH":
            case 0:
                message.fieldEventMode = 0;
                break;
            case "BEST_EFFORT":
            case 1:
                message.fieldEventMode = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a Filter message. Also converts values to other types if specified.
         * @function toObject
         * @memberof binlogdata.Filter
         * @static
         * @param {binlogdata.Filter} message Filter
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Filter.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.rules = [];
            if (options.defaults)
                object.fieldEventMode = options.enums === String ? "ERR_ON_MISMATCH" : 0;
            if (message.rules && message.rules.length) {
                object.rules = [];
                for (var j = 0; j < message.rules.length; ++j)
                    object.rules[j] = $root.binlogdata.Rule.toObject(message.rules[j], options);
            }
            if (message.fieldEventMode != null && message.hasOwnProperty("fieldEventMode"))
                object.fieldEventMode = options.enums === String ? $root.binlogdata.Filter.FieldEventMode[message.fieldEventMode] : message.fieldEventMode;
            return object;
        };

        /**
         * Converts this Filter to JSON.
         * @function toJSON
         * @memberof binlogdata.Filter
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Filter.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * FieldEventMode enum.
         * @name binlogdata.Filter.FieldEventMode
         * @enum {number}
         * @property {number} ERR_ON_MISMATCH=0 ERR_ON_MISMATCH value
         * @property {number} BEST_EFFORT=1 BEST_EFFORT value
         */
        Filter.FieldEventMode = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ERR_ON_MISMATCH"] = 0;
            values[valuesById[1] = "BEST_EFFORT"] = 1;
            return values;
        })();

        return Filter;
    })();

    /**
     * OnDDLAction enum.
     * @name binlogdata.OnDDLAction
     * @enum {number}
     * @property {number} IGNORE=0 IGNORE value
     * @property {number} STOP=1 STOP value
     * @property {number} EXEC=2 EXEC value
     * @property {number} EXEC_IGNORE=3 EXEC_IGNORE value
     */
    binlogdata.OnDDLAction = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "IGNORE"] = 0;
        values[valuesById[1] = "STOP"] = 1;
        values[valuesById[2] = "EXEC"] = 2;
        values[valuesById[3] = "EXEC_IGNORE"] = 3;
        return values;
    })();

    binlogdata.BinlogSource = (function() {

        /**
         * Properties of a BinlogSource.
         * @memberof binlogdata
         * @interface IBinlogSource
         * @property {string|null} [keyspace] BinlogSource keyspace
         * @property {string|null} [shard] BinlogSource shard
         * @property {topodata.TabletType|null} [tablet_type] BinlogSource tablet_type
         * @property {topodata.IKeyRange|null} [key_range] BinlogSource key_range
         * @property {Array.<string>|null} [tables] BinlogSource tables
         * @property {binlogdata.IFilter|null} [filter] BinlogSource filter
         * @property {binlogdata.OnDDLAction|null} [on_ddl] BinlogSource on_ddl
         * @property {string|null} [external_mysql] BinlogSource external_mysql
         * @property {boolean|null} [stop_after_copy] BinlogSource stop_after_copy
         * @property {string|null} [external_cluster] BinlogSource external_cluster
         */

        /**
         * Constructs a new BinlogSource.
         * @memberof binlogdata
         * @classdesc Represents a BinlogSource.
         * @implements IBinlogSource
         * @constructor
         * @param {binlogdata.IBinlogSource=} [properties] Properties to set
         */
        function BinlogSource(properties) {
            this.tables = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BinlogSource keyspace.
         * @member {string} keyspace
         * @memberof binlogdata.BinlogSource
         * @instance
         */
        BinlogSource.prototype.keyspace = "";

        /**
         * BinlogSource shard.
         * @member {string} shard
         * @memberof binlogdata.BinlogSource
         * @instance
         */
        BinlogSource.prototype.shard = "";

        /**
         * BinlogSource tablet_type.
         * @member {topodata.TabletType} tablet_type
         * @memberof binlogdata.BinlogSource
         * @instance
         */
        BinlogSource.prototype.tablet_type = 0;

        /**
         * BinlogSource key_range.
         * @member {topodata.IKeyRange|null|undefined} key_range
         * @memberof binlogdata.BinlogSource
         * @instance
         */
        BinlogSource.prototype.key_range = null;

        /**
         * BinlogSource tables.
         * @member {Array.<string>} tables
         * @memberof binlogdata.BinlogSource
         * @instance
         */
        BinlogSource.prototype.tables = $util.emptyArray;

        /**
         * BinlogSource filter.
         * @member {binlogdata.IFilter|null|undefined} filter
         * @memberof binlogdata.BinlogSource
         * @instance
         */
        BinlogSource.prototype.filter = null;

        /**
         * BinlogSource on_ddl.
         * @member {binlogdata.OnDDLAction} on_ddl
         * @memberof binlogdata.BinlogSource
         * @instance
         */
        BinlogSource.prototype.on_ddl = 0;

        /**
         * BinlogSource external_mysql.
         * @member {string} external_mysql
         * @memberof binlogdata.BinlogSource
         * @instance
         */
        BinlogSource.prototype.external_mysql = "";

        /**
         * BinlogSource stop_after_copy.
         * @member {boolean} stop_after_copy
         * @memberof binlogdata.BinlogSource
         * @instance
         */
        BinlogSource.prototype.stop_after_copy = false;

        /**
         * BinlogSource external_cluster.
         * @member {string} external_cluster
         * @memberof binlogdata.BinlogSource
         * @instance
         */
        BinlogSource.prototype.external_cluster = "";

        /**
         * Creates a new BinlogSource instance using the specified properties.
         * @function create
         * @memberof binlogdata.BinlogSource
         * @static
         * @param {binlogdata.IBinlogSource=} [properties] Properties to set
         * @returns {binlogdata.BinlogSource} BinlogSource instance
         */
        BinlogSource.create = function create(properties) {
            return new BinlogSource(properties);
        };

        /**
         * Encodes the specified BinlogSource message. Does not implicitly {@link binlogdata.BinlogSource.verify|verify} messages.
         * @function encode
         * @memberof binlogdata.BinlogSource
         * @static
         * @param {binlogdata.IBinlogSource} message BinlogSource message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BinlogSource.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keyspace != null && Object.hasOwnProperty.call(message, "keyspace"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.keyspace);
            if (message.shard != null && Object.hasOwnProperty.call(message, "shard"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.shard);
            if (message.tablet_type != null && Object.hasOwnProperty.call(message, "tablet_type"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.tablet_type);
            if (message.key_range != null && Object.hasOwnProperty.call(message, "key_range"))
                $root.topodata.KeyRange.encode(message.key_range, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.tables != null && message.tables.length)
                for (var i = 0; i < message.tables.length; ++i)
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.tables[i]);
            if (message.filter != null && Object.hasOwnProperty.call(message, "filter"))
                $root.binlogdata.Filter.encode(message.filter, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.on_ddl != null && Object.hasOwnProperty.call(message, "on_ddl"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.on_ddl);
            if (message.external_mysql != null && Object.hasOwnProperty.call(message, "external_mysql"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.external_mysql);
            if (message.stop_after_copy != null && Object.hasOwnProperty.call(message, "stop_after_copy"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.stop_after_copy);
            if (message.external_cluster != null && Object.hasOwnProperty.call(message, "external_cluster"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.external_cluster);
            return writer;
        };

        /**
         * Encodes the specified BinlogSource message, length delimited. Does not implicitly {@link binlogdata.BinlogSource.verify|verify} messages.
         * @function encodeDelimited
         * @memberof binlogdata.BinlogSource
         * @static
         * @param {binlogdata.IBinlogSource} message BinlogSource message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BinlogSource.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BinlogSource message from the specified reader or buffer.
         * @function decode
         * @memberof binlogdata.BinlogSource
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {binlogdata.BinlogSource} BinlogSource
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BinlogSource.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.binlogdata.BinlogSource();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.keyspace = reader.string();
                    break;
                case 2:
                    message.shard = reader.string();
                    break;
                case 3:
                    message.tablet_type = reader.int32();
                    break;
                case 4:
                    message.key_range = $root.topodata.KeyRange.decode(reader, reader.uint32());
                    break;
                case 5:
                    if (!(message.tables && message.tables.length))
                        message.tables = [];
                    message.tables.push(reader.string());
                    break;
                case 6:
                    message.filter = $root.binlogdata.Filter.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.on_ddl = reader.int32();
                    break;
                case 8:
                    message.external_mysql = reader.string();
                    break;
                case 9:
                    message.stop_after_copy = reader.bool();
                    break;
                case 10:
                    message.external_cluster = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BinlogSource message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof binlogdata.BinlogSource
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {binlogdata.BinlogSource} BinlogSource
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BinlogSource.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BinlogSource message.
         * @function verify
         * @memberof binlogdata.BinlogSource
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BinlogSource.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                if (!$util.isString(message.keyspace))
                    return "keyspace: string expected";
            if (message.shard != null && message.hasOwnProperty("shard"))
                if (!$util.isString(message.shard))
                    return "shard: string expected";
            if (message.tablet_type != null && message.hasOwnProperty("tablet_type"))
                switch (message.tablet_type) {
                default:
                    return "tablet_type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                    break;
                }
            if (message.key_range != null && message.hasOwnProperty("key_range")) {
                var error = $root.topodata.KeyRange.verify(message.key_range);
                if (error)
                    return "key_range." + error;
            }
            if (message.tables != null && message.hasOwnProperty("tables")) {
                if (!Array.isArray(message.tables))
                    return "tables: array expected";
                for (var i = 0; i < message.tables.length; ++i)
                    if (!$util.isString(message.tables[i]))
                        return "tables: string[] expected";
            }
            if (message.filter != null && message.hasOwnProperty("filter")) {
                var error = $root.binlogdata.Filter.verify(message.filter);
                if (error)
                    return "filter." + error;
            }
            if (message.on_ddl != null && message.hasOwnProperty("on_ddl"))
                switch (message.on_ddl) {
                default:
                    return "on_ddl: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.external_mysql != null && message.hasOwnProperty("external_mysql"))
                if (!$util.isString(message.external_mysql))
                    return "external_mysql: string expected";
            if (message.stop_after_copy != null && message.hasOwnProperty("stop_after_copy"))
                if (typeof message.stop_after_copy !== "boolean")
                    return "stop_after_copy: boolean expected";
            if (message.external_cluster != null && message.hasOwnProperty("external_cluster"))
                if (!$util.isString(message.external_cluster))
                    return "external_cluster: string expected";
            return null;
        };

        /**
         * Creates a BinlogSource message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof binlogdata.BinlogSource
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {binlogdata.BinlogSource} BinlogSource
         */
        BinlogSource.fromObject = function fromObject(object) {
            if (object instanceof $root.binlogdata.BinlogSource)
                return object;
            var message = new $root.binlogdata.BinlogSource();
            if (object.keyspace != null)
                message.keyspace = String(object.keyspace);
            if (object.shard != null)
                message.shard = String(object.shard);
            switch (object.tablet_type) {
            case "UNKNOWN":
            case 0:
                message.tablet_type = 0;
                break;
            case "MASTER":
            case 1:
                message.tablet_type = 1;
                break;
            case "REPLICA":
            case 2:
                message.tablet_type = 2;
                break;
            case "RDONLY":
            case 3:
                message.tablet_type = 3;
                break;
            case "BATCH":
            case 3:
                message.tablet_type = 3;
                break;
            case "SPARE":
            case 4:
                message.tablet_type = 4;
                break;
            case "EXPERIMENTAL":
            case 5:
                message.tablet_type = 5;
                break;
            case "BACKUP":
            case 6:
                message.tablet_type = 6;
                break;
            case "RESTORE":
            case 7:
                message.tablet_type = 7;
                break;
            case "DRAINED":
            case 8:
                message.tablet_type = 8;
                break;
            }
            if (object.key_range != null) {
                if (typeof object.key_range !== "object")
                    throw TypeError(".binlogdata.BinlogSource.key_range: object expected");
                message.key_range = $root.topodata.KeyRange.fromObject(object.key_range);
            }
            if (object.tables) {
                if (!Array.isArray(object.tables))
                    throw TypeError(".binlogdata.BinlogSource.tables: array expected");
                message.tables = [];
                for (var i = 0; i < object.tables.length; ++i)
                    message.tables[i] = String(object.tables[i]);
            }
            if (object.filter != null) {
                if (typeof object.filter !== "object")
                    throw TypeError(".binlogdata.BinlogSource.filter: object expected");
                message.filter = $root.binlogdata.Filter.fromObject(object.filter);
            }
            switch (object.on_ddl) {
            case "IGNORE":
            case 0:
                message.on_ddl = 0;
                break;
            case "STOP":
            case 1:
                message.on_ddl = 1;
                break;
            case "EXEC":
            case 2:
                message.on_ddl = 2;
                break;
            case "EXEC_IGNORE":
            case 3:
                message.on_ddl = 3;
                break;
            }
            if (object.external_mysql != null)
                message.external_mysql = String(object.external_mysql);
            if (object.stop_after_copy != null)
                message.stop_after_copy = Boolean(object.stop_after_copy);
            if (object.external_cluster != null)
                message.external_cluster = String(object.external_cluster);
            return message;
        };

        /**
         * Creates a plain object from a BinlogSource message. Also converts values to other types if specified.
         * @function toObject
         * @memberof binlogdata.BinlogSource
         * @static
         * @param {binlogdata.BinlogSource} message BinlogSource
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BinlogSource.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.tables = [];
            if (options.defaults) {
                object.keyspace = "";
                object.shard = "";
                object.tablet_type = options.enums === String ? "UNKNOWN" : 0;
                object.key_range = null;
                object.filter = null;
                object.on_ddl = options.enums === String ? "IGNORE" : 0;
                object.external_mysql = "";
                object.stop_after_copy = false;
                object.external_cluster = "";
            }
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                object.keyspace = message.keyspace;
            if (message.shard != null && message.hasOwnProperty("shard"))
                object.shard = message.shard;
            if (message.tablet_type != null && message.hasOwnProperty("tablet_type"))
                object.tablet_type = options.enums === String ? $root.topodata.TabletType[message.tablet_type] : message.tablet_type;
            if (message.key_range != null && message.hasOwnProperty("key_range"))
                object.key_range = $root.topodata.KeyRange.toObject(message.key_range, options);
            if (message.tables && message.tables.length) {
                object.tables = [];
                for (var j = 0; j < message.tables.length; ++j)
                    object.tables[j] = message.tables[j];
            }
            if (message.filter != null && message.hasOwnProperty("filter"))
                object.filter = $root.binlogdata.Filter.toObject(message.filter, options);
            if (message.on_ddl != null && message.hasOwnProperty("on_ddl"))
                object.on_ddl = options.enums === String ? $root.binlogdata.OnDDLAction[message.on_ddl] : message.on_ddl;
            if (message.external_mysql != null && message.hasOwnProperty("external_mysql"))
                object.external_mysql = message.external_mysql;
            if (message.stop_after_copy != null && message.hasOwnProperty("stop_after_copy"))
                object.stop_after_copy = message.stop_after_copy;
            if (message.external_cluster != null && message.hasOwnProperty("external_cluster"))
                object.external_cluster = message.external_cluster;
            return object;
        };

        /**
         * Converts this BinlogSource to JSON.
         * @function toJSON
         * @memberof binlogdata.BinlogSource
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BinlogSource.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BinlogSource;
    })();

    /**
     * VEventType enum.
     * @name binlogdata.VEventType
     * @enum {number}
     * @property {number} UNKNOWN=0 UNKNOWN value
     * @property {number} GTID=1 GTID value
     * @property {number} BEGIN=2 BEGIN value
     * @property {number} COMMIT=3 COMMIT value
     * @property {number} ROLLBACK=4 ROLLBACK value
     * @property {number} DDL=5 DDL value
     * @property {number} INSERT=6 INSERT value
     * @property {number} REPLACE=7 REPLACE value
     * @property {number} UPDATE=8 UPDATE value
     * @property {number} DELETE=9 DELETE value
     * @property {number} SET=10 SET value
     * @property {number} OTHER=11 OTHER value
     * @property {number} ROW=12 ROW value
     * @property {number} FIELD=13 FIELD value
     * @property {number} HEARTBEAT=14 HEARTBEAT value
     * @property {number} VGTID=15 VGTID value
     * @property {number} JOURNAL=16 JOURNAL value
     * @property {number} VERSION=17 VERSION value
     * @property {number} LASTPK=18 LASTPK value
     * @property {number} SAVEPOINT=19 SAVEPOINT value
     */
    binlogdata.VEventType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKNOWN"] = 0;
        values[valuesById[1] = "GTID"] = 1;
        values[valuesById[2] = "BEGIN"] = 2;
        values[valuesById[3] = "COMMIT"] = 3;
        values[valuesById[4] = "ROLLBACK"] = 4;
        values[valuesById[5] = "DDL"] = 5;
        values[valuesById[6] = "INSERT"] = 6;
        values[valuesById[7] = "REPLACE"] = 7;
        values[valuesById[8] = "UPDATE"] = 8;
        values[valuesById[9] = "DELETE"] = 9;
        values[valuesById[10] = "SET"] = 10;
        values[valuesById[11] = "OTHER"] = 11;
        values[valuesById[12] = "ROW"] = 12;
        values[valuesById[13] = "FIELD"] = 13;
        values[valuesById[14] = "HEARTBEAT"] = 14;
        values[valuesById[15] = "VGTID"] = 15;
        values[valuesById[16] = "JOURNAL"] = 16;
        values[valuesById[17] = "VERSION"] = 17;
        values[valuesById[18] = "LASTPK"] = 18;
        values[valuesById[19] = "SAVEPOINT"] = 19;
        return values;
    })();

    binlogdata.RowChange = (function() {

        /**
         * Properties of a RowChange.
         * @memberof binlogdata
         * @interface IRowChange
         * @property {query.IRow|null} [before] RowChange before
         * @property {query.IRow|null} [after] RowChange after
         */

        /**
         * Constructs a new RowChange.
         * @memberof binlogdata
         * @classdesc Represents a RowChange.
         * @implements IRowChange
         * @constructor
         * @param {binlogdata.IRowChange=} [properties] Properties to set
         */
        function RowChange(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RowChange before.
         * @member {query.IRow|null|undefined} before
         * @memberof binlogdata.RowChange
         * @instance
         */
        RowChange.prototype.before = null;

        /**
         * RowChange after.
         * @member {query.IRow|null|undefined} after
         * @memberof binlogdata.RowChange
         * @instance
         */
        RowChange.prototype.after = null;

        /**
         * Creates a new RowChange instance using the specified properties.
         * @function create
         * @memberof binlogdata.RowChange
         * @static
         * @param {binlogdata.IRowChange=} [properties] Properties to set
         * @returns {binlogdata.RowChange} RowChange instance
         */
        RowChange.create = function create(properties) {
            return new RowChange(properties);
        };

        /**
         * Encodes the specified RowChange message. Does not implicitly {@link binlogdata.RowChange.verify|verify} messages.
         * @function encode
         * @memberof binlogdata.RowChange
         * @static
         * @param {binlogdata.IRowChange} message RowChange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RowChange.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.before != null && Object.hasOwnProperty.call(message, "before"))
                $root.query.Row.encode(message.before, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.after != null && Object.hasOwnProperty.call(message, "after"))
                $root.query.Row.encode(message.after, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RowChange message, length delimited. Does not implicitly {@link binlogdata.RowChange.verify|verify} messages.
         * @function encodeDelimited
         * @memberof binlogdata.RowChange
         * @static
         * @param {binlogdata.IRowChange} message RowChange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RowChange.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RowChange message from the specified reader or buffer.
         * @function decode
         * @memberof binlogdata.RowChange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {binlogdata.RowChange} RowChange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RowChange.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.binlogdata.RowChange();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.before = $root.query.Row.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.after = $root.query.Row.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RowChange message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof binlogdata.RowChange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {binlogdata.RowChange} RowChange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RowChange.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RowChange message.
         * @function verify
         * @memberof binlogdata.RowChange
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RowChange.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.before != null && message.hasOwnProperty("before")) {
                var error = $root.query.Row.verify(message.before);
                if (error)
                    return "before." + error;
            }
            if (message.after != null && message.hasOwnProperty("after")) {
                var error = $root.query.Row.verify(message.after);
                if (error)
                    return "after." + error;
            }
            return null;
        };

        /**
         * Creates a RowChange message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof binlogdata.RowChange
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {binlogdata.RowChange} RowChange
         */
        RowChange.fromObject = function fromObject(object) {
            if (object instanceof $root.binlogdata.RowChange)
                return object;
            var message = new $root.binlogdata.RowChange();
            if (object.before != null) {
                if (typeof object.before !== "object")
                    throw TypeError(".binlogdata.RowChange.before: object expected");
                message.before = $root.query.Row.fromObject(object.before);
            }
            if (object.after != null) {
                if (typeof object.after !== "object")
                    throw TypeError(".binlogdata.RowChange.after: object expected");
                message.after = $root.query.Row.fromObject(object.after);
            }
            return message;
        };

        /**
         * Creates a plain object from a RowChange message. Also converts values to other types if specified.
         * @function toObject
         * @memberof binlogdata.RowChange
         * @static
         * @param {binlogdata.RowChange} message RowChange
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RowChange.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.before = null;
                object.after = null;
            }
            if (message.before != null && message.hasOwnProperty("before"))
                object.before = $root.query.Row.toObject(message.before, options);
            if (message.after != null && message.hasOwnProperty("after"))
                object.after = $root.query.Row.toObject(message.after, options);
            return object;
        };

        /**
         * Converts this RowChange to JSON.
         * @function toJSON
         * @memberof binlogdata.RowChange
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RowChange.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RowChange;
    })();

    binlogdata.RowEvent = (function() {

        /**
         * Properties of a RowEvent.
         * @memberof binlogdata
         * @interface IRowEvent
         * @property {string|null} [table_name] RowEvent table_name
         * @property {Array.<binlogdata.IRowChange>|null} [row_changes] RowEvent row_changes
         */

        /**
         * Constructs a new RowEvent.
         * @memberof binlogdata
         * @classdesc Represents a RowEvent.
         * @implements IRowEvent
         * @constructor
         * @param {binlogdata.IRowEvent=} [properties] Properties to set
         */
        function RowEvent(properties) {
            this.row_changes = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RowEvent table_name.
         * @member {string} table_name
         * @memberof binlogdata.RowEvent
         * @instance
         */
        RowEvent.prototype.table_name = "";

        /**
         * RowEvent row_changes.
         * @member {Array.<binlogdata.IRowChange>} row_changes
         * @memberof binlogdata.RowEvent
         * @instance
         */
        RowEvent.prototype.row_changes = $util.emptyArray;

        /**
         * Creates a new RowEvent instance using the specified properties.
         * @function create
         * @memberof binlogdata.RowEvent
         * @static
         * @param {binlogdata.IRowEvent=} [properties] Properties to set
         * @returns {binlogdata.RowEvent} RowEvent instance
         */
        RowEvent.create = function create(properties) {
            return new RowEvent(properties);
        };

        /**
         * Encodes the specified RowEvent message. Does not implicitly {@link binlogdata.RowEvent.verify|verify} messages.
         * @function encode
         * @memberof binlogdata.RowEvent
         * @static
         * @param {binlogdata.IRowEvent} message RowEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RowEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.table_name != null && Object.hasOwnProperty.call(message, "table_name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.table_name);
            if (message.row_changes != null && message.row_changes.length)
                for (var i = 0; i < message.row_changes.length; ++i)
                    $root.binlogdata.RowChange.encode(message.row_changes[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RowEvent message, length delimited. Does not implicitly {@link binlogdata.RowEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof binlogdata.RowEvent
         * @static
         * @param {binlogdata.IRowEvent} message RowEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RowEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RowEvent message from the specified reader or buffer.
         * @function decode
         * @memberof binlogdata.RowEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {binlogdata.RowEvent} RowEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RowEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.binlogdata.RowEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.table_name = reader.string();
                    break;
                case 2:
                    if (!(message.row_changes && message.row_changes.length))
                        message.row_changes = [];
                    message.row_changes.push($root.binlogdata.RowChange.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RowEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof binlogdata.RowEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {binlogdata.RowEvent} RowEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RowEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RowEvent message.
         * @function verify
         * @memberof binlogdata.RowEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RowEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.table_name != null && message.hasOwnProperty("table_name"))
                if (!$util.isString(message.table_name))
                    return "table_name: string expected";
            if (message.row_changes != null && message.hasOwnProperty("row_changes")) {
                if (!Array.isArray(message.row_changes))
                    return "row_changes: array expected";
                for (var i = 0; i < message.row_changes.length; ++i) {
                    var error = $root.binlogdata.RowChange.verify(message.row_changes[i]);
                    if (error)
                        return "row_changes." + error;
                }
            }
            return null;
        };

        /**
         * Creates a RowEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof binlogdata.RowEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {binlogdata.RowEvent} RowEvent
         */
        RowEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.binlogdata.RowEvent)
                return object;
            var message = new $root.binlogdata.RowEvent();
            if (object.table_name != null)
                message.table_name = String(object.table_name);
            if (object.row_changes) {
                if (!Array.isArray(object.row_changes))
                    throw TypeError(".binlogdata.RowEvent.row_changes: array expected");
                message.row_changes = [];
                for (var i = 0; i < object.row_changes.length; ++i) {
                    if (typeof object.row_changes[i] !== "object")
                        throw TypeError(".binlogdata.RowEvent.row_changes: object expected");
                    message.row_changes[i] = $root.binlogdata.RowChange.fromObject(object.row_changes[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a RowEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof binlogdata.RowEvent
         * @static
         * @param {binlogdata.RowEvent} message RowEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RowEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.row_changes = [];
            if (options.defaults)
                object.table_name = "";
            if (message.table_name != null && message.hasOwnProperty("table_name"))
                object.table_name = message.table_name;
            if (message.row_changes && message.row_changes.length) {
                object.row_changes = [];
                for (var j = 0; j < message.row_changes.length; ++j)
                    object.row_changes[j] = $root.binlogdata.RowChange.toObject(message.row_changes[j], options);
            }
            return object;
        };

        /**
         * Converts this RowEvent to JSON.
         * @function toJSON
         * @memberof binlogdata.RowEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RowEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RowEvent;
    })();

    binlogdata.FieldEvent = (function() {

        /**
         * Properties of a FieldEvent.
         * @memberof binlogdata
         * @interface IFieldEvent
         * @property {string|null} [table_name] FieldEvent table_name
         * @property {Array.<query.IField>|null} [fields] FieldEvent fields
         */

        /**
         * Constructs a new FieldEvent.
         * @memberof binlogdata
         * @classdesc Represents a FieldEvent.
         * @implements IFieldEvent
         * @constructor
         * @param {binlogdata.IFieldEvent=} [properties] Properties to set
         */
        function FieldEvent(properties) {
            this.fields = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FieldEvent table_name.
         * @member {string} table_name
         * @memberof binlogdata.FieldEvent
         * @instance
         */
        FieldEvent.prototype.table_name = "";

        /**
         * FieldEvent fields.
         * @member {Array.<query.IField>} fields
         * @memberof binlogdata.FieldEvent
         * @instance
         */
        FieldEvent.prototype.fields = $util.emptyArray;

        /**
         * Creates a new FieldEvent instance using the specified properties.
         * @function create
         * @memberof binlogdata.FieldEvent
         * @static
         * @param {binlogdata.IFieldEvent=} [properties] Properties to set
         * @returns {binlogdata.FieldEvent} FieldEvent instance
         */
        FieldEvent.create = function create(properties) {
            return new FieldEvent(properties);
        };

        /**
         * Encodes the specified FieldEvent message. Does not implicitly {@link binlogdata.FieldEvent.verify|verify} messages.
         * @function encode
         * @memberof binlogdata.FieldEvent
         * @static
         * @param {binlogdata.IFieldEvent} message FieldEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FieldEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.table_name != null && Object.hasOwnProperty.call(message, "table_name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.table_name);
            if (message.fields != null && message.fields.length)
                for (var i = 0; i < message.fields.length; ++i)
                    $root.query.Field.encode(message.fields[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified FieldEvent message, length delimited. Does not implicitly {@link binlogdata.FieldEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof binlogdata.FieldEvent
         * @static
         * @param {binlogdata.IFieldEvent} message FieldEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FieldEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FieldEvent message from the specified reader or buffer.
         * @function decode
         * @memberof binlogdata.FieldEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {binlogdata.FieldEvent} FieldEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FieldEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.binlogdata.FieldEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.table_name = reader.string();
                    break;
                case 2:
                    if (!(message.fields && message.fields.length))
                        message.fields = [];
                    message.fields.push($root.query.Field.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FieldEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof binlogdata.FieldEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {binlogdata.FieldEvent} FieldEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FieldEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FieldEvent message.
         * @function verify
         * @memberof binlogdata.FieldEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FieldEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.table_name != null && message.hasOwnProperty("table_name"))
                if (!$util.isString(message.table_name))
                    return "table_name: string expected";
            if (message.fields != null && message.hasOwnProperty("fields")) {
                if (!Array.isArray(message.fields))
                    return "fields: array expected";
                for (var i = 0; i < message.fields.length; ++i) {
                    var error = $root.query.Field.verify(message.fields[i]);
                    if (error)
                        return "fields." + error;
                }
            }
            return null;
        };

        /**
         * Creates a FieldEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof binlogdata.FieldEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {binlogdata.FieldEvent} FieldEvent
         */
        FieldEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.binlogdata.FieldEvent)
                return object;
            var message = new $root.binlogdata.FieldEvent();
            if (object.table_name != null)
                message.table_name = String(object.table_name);
            if (object.fields) {
                if (!Array.isArray(object.fields))
                    throw TypeError(".binlogdata.FieldEvent.fields: array expected");
                message.fields = [];
                for (var i = 0; i < object.fields.length; ++i) {
                    if (typeof object.fields[i] !== "object")
                        throw TypeError(".binlogdata.FieldEvent.fields: object expected");
                    message.fields[i] = $root.query.Field.fromObject(object.fields[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a FieldEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof binlogdata.FieldEvent
         * @static
         * @param {binlogdata.FieldEvent} message FieldEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FieldEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.fields = [];
            if (options.defaults)
                object.table_name = "";
            if (message.table_name != null && message.hasOwnProperty("table_name"))
                object.table_name = message.table_name;
            if (message.fields && message.fields.length) {
                object.fields = [];
                for (var j = 0; j < message.fields.length; ++j)
                    object.fields[j] = $root.query.Field.toObject(message.fields[j], options);
            }
            return object;
        };

        /**
         * Converts this FieldEvent to JSON.
         * @function toJSON
         * @memberof binlogdata.FieldEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FieldEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FieldEvent;
    })();

    binlogdata.ShardGtid = (function() {

        /**
         * Properties of a ShardGtid.
         * @memberof binlogdata
         * @interface IShardGtid
         * @property {string|null} [keyspace] ShardGtid keyspace
         * @property {string|null} [shard] ShardGtid shard
         * @property {string|null} [gtid] ShardGtid gtid
         * @property {Array.<binlogdata.ITableLastPK>|null} [table_p_ks] ShardGtid table_p_ks
         */

        /**
         * Constructs a new ShardGtid.
         * @memberof binlogdata
         * @classdesc Represents a ShardGtid.
         * @implements IShardGtid
         * @constructor
         * @param {binlogdata.IShardGtid=} [properties] Properties to set
         */
        function ShardGtid(properties) {
            this.table_p_ks = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ShardGtid keyspace.
         * @member {string} keyspace
         * @memberof binlogdata.ShardGtid
         * @instance
         */
        ShardGtid.prototype.keyspace = "";

        /**
         * ShardGtid shard.
         * @member {string} shard
         * @memberof binlogdata.ShardGtid
         * @instance
         */
        ShardGtid.prototype.shard = "";

        /**
         * ShardGtid gtid.
         * @member {string} gtid
         * @memberof binlogdata.ShardGtid
         * @instance
         */
        ShardGtid.prototype.gtid = "";

        /**
         * ShardGtid table_p_ks.
         * @member {Array.<binlogdata.ITableLastPK>} table_p_ks
         * @memberof binlogdata.ShardGtid
         * @instance
         */
        ShardGtid.prototype.table_p_ks = $util.emptyArray;

        /**
         * Creates a new ShardGtid instance using the specified properties.
         * @function create
         * @memberof binlogdata.ShardGtid
         * @static
         * @param {binlogdata.IShardGtid=} [properties] Properties to set
         * @returns {binlogdata.ShardGtid} ShardGtid instance
         */
        ShardGtid.create = function create(properties) {
            return new ShardGtid(properties);
        };

        /**
         * Encodes the specified ShardGtid message. Does not implicitly {@link binlogdata.ShardGtid.verify|verify} messages.
         * @function encode
         * @memberof binlogdata.ShardGtid
         * @static
         * @param {binlogdata.IShardGtid} message ShardGtid message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShardGtid.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keyspace != null && Object.hasOwnProperty.call(message, "keyspace"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.keyspace);
            if (message.shard != null && Object.hasOwnProperty.call(message, "shard"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.shard);
            if (message.gtid != null && Object.hasOwnProperty.call(message, "gtid"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.gtid);
            if (message.table_p_ks != null && message.table_p_ks.length)
                for (var i = 0; i < message.table_p_ks.length; ++i)
                    $root.binlogdata.TableLastPK.encode(message.table_p_ks[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ShardGtid message, length delimited. Does not implicitly {@link binlogdata.ShardGtid.verify|verify} messages.
         * @function encodeDelimited
         * @memberof binlogdata.ShardGtid
         * @static
         * @param {binlogdata.IShardGtid} message ShardGtid message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShardGtid.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ShardGtid message from the specified reader or buffer.
         * @function decode
         * @memberof binlogdata.ShardGtid
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {binlogdata.ShardGtid} ShardGtid
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShardGtid.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.binlogdata.ShardGtid();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.keyspace = reader.string();
                    break;
                case 2:
                    message.shard = reader.string();
                    break;
                case 3:
                    message.gtid = reader.string();
                    break;
                case 4:
                    if (!(message.table_p_ks && message.table_p_ks.length))
                        message.table_p_ks = [];
                    message.table_p_ks.push($root.binlogdata.TableLastPK.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ShardGtid message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof binlogdata.ShardGtid
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {binlogdata.ShardGtid} ShardGtid
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShardGtid.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ShardGtid message.
         * @function verify
         * @memberof binlogdata.ShardGtid
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ShardGtid.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                if (!$util.isString(message.keyspace))
                    return "keyspace: string expected";
            if (message.shard != null && message.hasOwnProperty("shard"))
                if (!$util.isString(message.shard))
                    return "shard: string expected";
            if (message.gtid != null && message.hasOwnProperty("gtid"))
                if (!$util.isString(message.gtid))
                    return "gtid: string expected";
            if (message.table_p_ks != null && message.hasOwnProperty("table_p_ks")) {
                if (!Array.isArray(message.table_p_ks))
                    return "table_p_ks: array expected";
                for (var i = 0; i < message.table_p_ks.length; ++i) {
                    var error = $root.binlogdata.TableLastPK.verify(message.table_p_ks[i]);
                    if (error)
                        return "table_p_ks." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ShardGtid message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof binlogdata.ShardGtid
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {binlogdata.ShardGtid} ShardGtid
         */
        ShardGtid.fromObject = function fromObject(object) {
            if (object instanceof $root.binlogdata.ShardGtid)
                return object;
            var message = new $root.binlogdata.ShardGtid();
            if (object.keyspace != null)
                message.keyspace = String(object.keyspace);
            if (object.shard != null)
                message.shard = String(object.shard);
            if (object.gtid != null)
                message.gtid = String(object.gtid);
            if (object.table_p_ks) {
                if (!Array.isArray(object.table_p_ks))
                    throw TypeError(".binlogdata.ShardGtid.table_p_ks: array expected");
                message.table_p_ks = [];
                for (var i = 0; i < object.table_p_ks.length; ++i) {
                    if (typeof object.table_p_ks[i] !== "object")
                        throw TypeError(".binlogdata.ShardGtid.table_p_ks: object expected");
                    message.table_p_ks[i] = $root.binlogdata.TableLastPK.fromObject(object.table_p_ks[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ShardGtid message. Also converts values to other types if specified.
         * @function toObject
         * @memberof binlogdata.ShardGtid
         * @static
         * @param {binlogdata.ShardGtid} message ShardGtid
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ShardGtid.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.table_p_ks = [];
            if (options.defaults) {
                object.keyspace = "";
                object.shard = "";
                object.gtid = "";
            }
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                object.keyspace = message.keyspace;
            if (message.shard != null && message.hasOwnProperty("shard"))
                object.shard = message.shard;
            if (message.gtid != null && message.hasOwnProperty("gtid"))
                object.gtid = message.gtid;
            if (message.table_p_ks && message.table_p_ks.length) {
                object.table_p_ks = [];
                for (var j = 0; j < message.table_p_ks.length; ++j)
                    object.table_p_ks[j] = $root.binlogdata.TableLastPK.toObject(message.table_p_ks[j], options);
            }
            return object;
        };

        /**
         * Converts this ShardGtid to JSON.
         * @function toJSON
         * @memberof binlogdata.ShardGtid
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ShardGtid.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ShardGtid;
    })();

    binlogdata.VGtid = (function() {

        /**
         * Properties of a VGtid.
         * @memberof binlogdata
         * @interface IVGtid
         * @property {Array.<binlogdata.IShardGtid>|null} [shard_gtids] VGtid shard_gtids
         */

        /**
         * Constructs a new VGtid.
         * @memberof binlogdata
         * @classdesc Represents a VGtid.
         * @implements IVGtid
         * @constructor
         * @param {binlogdata.IVGtid=} [properties] Properties to set
         */
        function VGtid(properties) {
            this.shard_gtids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VGtid shard_gtids.
         * @member {Array.<binlogdata.IShardGtid>} shard_gtids
         * @memberof binlogdata.VGtid
         * @instance
         */
        VGtid.prototype.shard_gtids = $util.emptyArray;

        /**
         * Creates a new VGtid instance using the specified properties.
         * @function create
         * @memberof binlogdata.VGtid
         * @static
         * @param {binlogdata.IVGtid=} [properties] Properties to set
         * @returns {binlogdata.VGtid} VGtid instance
         */
        VGtid.create = function create(properties) {
            return new VGtid(properties);
        };

        /**
         * Encodes the specified VGtid message. Does not implicitly {@link binlogdata.VGtid.verify|verify} messages.
         * @function encode
         * @memberof binlogdata.VGtid
         * @static
         * @param {binlogdata.IVGtid} message VGtid message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VGtid.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.shard_gtids != null && message.shard_gtids.length)
                for (var i = 0; i < message.shard_gtids.length; ++i)
                    $root.binlogdata.ShardGtid.encode(message.shard_gtids[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified VGtid message, length delimited. Does not implicitly {@link binlogdata.VGtid.verify|verify} messages.
         * @function encodeDelimited
         * @memberof binlogdata.VGtid
         * @static
         * @param {binlogdata.IVGtid} message VGtid message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VGtid.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VGtid message from the specified reader or buffer.
         * @function decode
         * @memberof binlogdata.VGtid
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {binlogdata.VGtid} VGtid
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VGtid.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.binlogdata.VGtid();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.shard_gtids && message.shard_gtids.length))
                        message.shard_gtids = [];
                    message.shard_gtids.push($root.binlogdata.ShardGtid.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VGtid message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof binlogdata.VGtid
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {binlogdata.VGtid} VGtid
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VGtid.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VGtid message.
         * @function verify
         * @memberof binlogdata.VGtid
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VGtid.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.shard_gtids != null && message.hasOwnProperty("shard_gtids")) {
                if (!Array.isArray(message.shard_gtids))
                    return "shard_gtids: array expected";
                for (var i = 0; i < message.shard_gtids.length; ++i) {
                    var error = $root.binlogdata.ShardGtid.verify(message.shard_gtids[i]);
                    if (error)
                        return "shard_gtids." + error;
                }
            }
            return null;
        };

        /**
         * Creates a VGtid message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof binlogdata.VGtid
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {binlogdata.VGtid} VGtid
         */
        VGtid.fromObject = function fromObject(object) {
            if (object instanceof $root.binlogdata.VGtid)
                return object;
            var message = new $root.binlogdata.VGtid();
            if (object.shard_gtids) {
                if (!Array.isArray(object.shard_gtids))
                    throw TypeError(".binlogdata.VGtid.shard_gtids: array expected");
                message.shard_gtids = [];
                for (var i = 0; i < object.shard_gtids.length; ++i) {
                    if (typeof object.shard_gtids[i] !== "object")
                        throw TypeError(".binlogdata.VGtid.shard_gtids: object expected");
                    message.shard_gtids[i] = $root.binlogdata.ShardGtid.fromObject(object.shard_gtids[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a VGtid message. Also converts values to other types if specified.
         * @function toObject
         * @memberof binlogdata.VGtid
         * @static
         * @param {binlogdata.VGtid} message VGtid
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VGtid.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.shard_gtids = [];
            if (message.shard_gtids && message.shard_gtids.length) {
                object.shard_gtids = [];
                for (var j = 0; j < message.shard_gtids.length; ++j)
                    object.shard_gtids[j] = $root.binlogdata.ShardGtid.toObject(message.shard_gtids[j], options);
            }
            return object;
        };

        /**
         * Converts this VGtid to JSON.
         * @function toJSON
         * @memberof binlogdata.VGtid
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VGtid.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VGtid;
    })();

    binlogdata.KeyspaceShard = (function() {

        /**
         * Properties of a KeyspaceShard.
         * @memberof binlogdata
         * @interface IKeyspaceShard
         * @property {string|null} [keyspace] KeyspaceShard keyspace
         * @property {string|null} [shard] KeyspaceShard shard
         */

        /**
         * Constructs a new KeyspaceShard.
         * @memberof binlogdata
         * @classdesc Represents a KeyspaceShard.
         * @implements IKeyspaceShard
         * @constructor
         * @param {binlogdata.IKeyspaceShard=} [properties] Properties to set
         */
        function KeyspaceShard(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * KeyspaceShard keyspace.
         * @member {string} keyspace
         * @memberof binlogdata.KeyspaceShard
         * @instance
         */
        KeyspaceShard.prototype.keyspace = "";

        /**
         * KeyspaceShard shard.
         * @member {string} shard
         * @memberof binlogdata.KeyspaceShard
         * @instance
         */
        KeyspaceShard.prototype.shard = "";

        /**
         * Creates a new KeyspaceShard instance using the specified properties.
         * @function create
         * @memberof binlogdata.KeyspaceShard
         * @static
         * @param {binlogdata.IKeyspaceShard=} [properties] Properties to set
         * @returns {binlogdata.KeyspaceShard} KeyspaceShard instance
         */
        KeyspaceShard.create = function create(properties) {
            return new KeyspaceShard(properties);
        };

        /**
         * Encodes the specified KeyspaceShard message. Does not implicitly {@link binlogdata.KeyspaceShard.verify|verify} messages.
         * @function encode
         * @memberof binlogdata.KeyspaceShard
         * @static
         * @param {binlogdata.IKeyspaceShard} message KeyspaceShard message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeyspaceShard.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keyspace != null && Object.hasOwnProperty.call(message, "keyspace"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.keyspace);
            if (message.shard != null && Object.hasOwnProperty.call(message, "shard"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.shard);
            return writer;
        };

        /**
         * Encodes the specified KeyspaceShard message, length delimited. Does not implicitly {@link binlogdata.KeyspaceShard.verify|verify} messages.
         * @function encodeDelimited
         * @memberof binlogdata.KeyspaceShard
         * @static
         * @param {binlogdata.IKeyspaceShard} message KeyspaceShard message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeyspaceShard.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a KeyspaceShard message from the specified reader or buffer.
         * @function decode
         * @memberof binlogdata.KeyspaceShard
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {binlogdata.KeyspaceShard} KeyspaceShard
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyspaceShard.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.binlogdata.KeyspaceShard();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.keyspace = reader.string();
                    break;
                case 2:
                    message.shard = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a KeyspaceShard message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof binlogdata.KeyspaceShard
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {binlogdata.KeyspaceShard} KeyspaceShard
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyspaceShard.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a KeyspaceShard message.
         * @function verify
         * @memberof binlogdata.KeyspaceShard
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        KeyspaceShard.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                if (!$util.isString(message.keyspace))
                    return "keyspace: string expected";
            if (message.shard != null && message.hasOwnProperty("shard"))
                if (!$util.isString(message.shard))
                    return "shard: string expected";
            return null;
        };

        /**
         * Creates a KeyspaceShard message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof binlogdata.KeyspaceShard
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {binlogdata.KeyspaceShard} KeyspaceShard
         */
        KeyspaceShard.fromObject = function fromObject(object) {
            if (object instanceof $root.binlogdata.KeyspaceShard)
                return object;
            var message = new $root.binlogdata.KeyspaceShard();
            if (object.keyspace != null)
                message.keyspace = String(object.keyspace);
            if (object.shard != null)
                message.shard = String(object.shard);
            return message;
        };

        /**
         * Creates a plain object from a KeyspaceShard message. Also converts values to other types if specified.
         * @function toObject
         * @memberof binlogdata.KeyspaceShard
         * @static
         * @param {binlogdata.KeyspaceShard} message KeyspaceShard
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        KeyspaceShard.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.keyspace = "";
                object.shard = "";
            }
            if (message.keyspace != null && message.hasOwnProperty("keyspace"))
                object.keyspace = message.keyspace;
            if (message.shard != null && message.hasOwnProperty("shard"))
                object.shard = message.shard;
            return object;
        };

        /**
         * Converts this KeyspaceShard to JSON.
         * @function toJSON
         * @memberof binlogdata.KeyspaceShard
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        KeyspaceShard.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return KeyspaceShard;
    })();

    /**
     * MigrationType enum.
     * @name binlogdata.MigrationType
     * @enum {number}
     * @property {number} TABLES=0 TABLES value
     * @property {number} SHARDS=1 SHARDS value
     */
    binlogdata.MigrationType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TABLES"] = 0;
        values[valuesById[1] = "SHARDS"] = 1;
        return values;
    })();

    binlogdata.Journal = (function() {

        /**
         * Properties of a Journal.
         * @memberof binlogdata
         * @interface IJournal
         * @property {number|Long|null} [id] Journal id
         * @property {binlogdata.MigrationType|null} [migration_type] Journal migration_type
         * @property {Array.<string>|null} [tables] Journal tables
         * @property {string|null} [local_position] Journal local_position
         * @property {Array.<binlogdata.IShardGtid>|null} [shard_gtids] Journal shard_gtids
         * @property {Array.<binlogdata.IKeyspaceShard>|null} [participants] Journal participants
         * @property {Array.<string>|null} [source_workflows] Journal source_workflows
         */

        /**
         * Constructs a new Journal.
         * @memberof binlogdata
         * @classdesc Represents a Journal.
         * @implements IJournal
         * @constructor
         * @param {binlogdata.IJournal=} [properties] Properties to set
         */
        function Journal(properties) {
            this.tables = [];
            this.shard_gtids = [];
            this.participants = [];
            this.source_workflows = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Journal id.
         * @member {number|Long} id
         * @memberof binlogdata.Journal
         * @instance
         */
        Journal.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Journal migration_type.
         * @member {binlogdata.MigrationType} migration_type
         * @memberof binlogdata.Journal
         * @instance
         */
        Journal.prototype.migration_type = 0;

        /**
         * Journal tables.
         * @member {Array.<string>} tables
         * @memberof binlogdata.Journal
         * @instance
         */
        Journal.prototype.tables = $util.emptyArray;

        /**
         * Journal local_position.
         * @member {string} local_position
         * @memberof binlogdata.Journal
         * @instance
         */
        Journal.prototype.local_position = "";

        /**
         * Journal shard_gtids.
         * @member {Array.<binlogdata.IShardGtid>} shard_gtids
         * @memberof binlogdata.Journal
         * @instance
         */
        Journal.prototype.shard_gtids = $util.emptyArray;

        /**
         * Journal participants.
         * @member {Array.<binlogdata.IKeyspaceShard>} participants
         * @memberof binlogdata.Journal
         * @instance
         */
        Journal.prototype.participants = $util.emptyArray;

        /**
         * Journal source_workflows.
         * @member {Array.<string>} source_workflows
         * @memberof binlogdata.Journal
         * @instance
         */
        Journal.prototype.source_workflows = $util.emptyArray;

        /**
         * Creates a new Journal instance using the specified properties.
         * @function create
         * @memberof binlogdata.Journal
         * @static
         * @param {binlogdata.IJournal=} [properties] Properties to set
         * @returns {binlogdata.Journal} Journal instance
         */
        Journal.create = function create(properties) {
            return new Journal(properties);
        };

        /**
         * Encodes the specified Journal message. Does not implicitly {@link binlogdata.Journal.verify|verify} messages.
         * @function encode
         * @memberof binlogdata.Journal
         * @static
         * @param {binlogdata.IJournal} message Journal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Journal.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.id);
            if (message.migration_type != null && Object.hasOwnProperty.call(message, "migration_type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.migration_type);
            if (message.tables != null && message.tables.length)
                for (var i = 0; i < message.tables.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.tables[i]);
            if (message.local_position != null && Object.hasOwnProperty.call(message, "local_position"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.local_position);
            if (message.shard_gtids != null && message.shard_gtids.length)
                for (var i = 0; i < message.shard_gtids.length; ++i)
                    $root.binlogdata.ShardGtid.encode(message.shard_gtids[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.participants != null && message.participants.length)
                for (var i = 0; i < message.participants.length; ++i)
                    $root.binlogdata.KeyspaceShard.encode(message.participants[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.source_workflows != null && message.source_workflows.length)
                for (var i = 0; i < message.source_workflows.length; ++i)
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.source_workflows[i]);
            return writer;
        };

        /**
         * Encodes the specified Journal message, length delimited. Does not implicitly {@link binlogdata.Journal.verify|verify} messages.
         * @function encodeDelimited
         * @memberof binlogdata.Journal
         * @static
         * @param {binlogdata.IJournal} message Journal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Journal.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Journal message from the specified reader or buffer.
         * @function decode
         * @memberof binlogdata.Journal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {binlogdata.Journal} Journal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Journal.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.binlogdata.Journal();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int64();
                    break;
                case 2:
                    message.migration_type = reader.int32();
                    break;
                case 3:
                    if (!(message.tables && message.tables.length))
                        message.tables = [];
                    message.tables.push(reader.string());
                    break;
                case 4:
                    message.local_position = reader.string();
                    break;
                case 5:
                    if (!(message.shard_gtids && message.shard_gtids.length))
                        message.shard_gtids = [];
                    message.shard_gtids.push($root.binlogdata.ShardGtid.decode(reader, reader.uint32()));
                    break;
                case 6:
                    if (!(message.participants && message.participants.length))
                        message.participants = [];
                    message.participants.push($root.binlogdata.KeyspaceShard.decode(reader, reader.uint32()));
                    break;
                case 7:
                    if (!(message.source_workflows && message.source_workflows.length))
                        message.source_workflows = [];
                    message.source_workflows.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Journal message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof binlogdata.Journal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {binlogdata.Journal} Journal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Journal.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Journal message.
         * @function verify
         * @memberof binlogdata.Journal
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Journal.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            if (message.migration_type != null && message.hasOwnProperty("migration_type"))
                switch (message.migration_type) {
                default:
                    return "migration_type: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.tables != null && message.hasOwnProperty("tables")) {
                if (!Array.isArray(message.tables))
                    return "tables: array expected";
                for (var i = 0; i < message.tables.length; ++i)
                    if (!$util.isString(message.tables[i]))
                        return "tables: string[] expected";
            }
            if (message.local_position != null && message.hasOwnProperty("local_position"))
                if (!$util.isString(message.local_position))
                    return "local_position: string expected";
            if (message.shard_gtids != null && message.hasOwnProperty("shard_gtids")) {
                if (!Array.isArray(message.shard_gtids))
                    return "shard_gtids: array expected";
                for (var i = 0; i < message.shard_gtids.length; ++i) {
                    var error = $root.binlogdata.ShardGtid.verify(message.shard_gtids[i]);
                    if (error)
                        return "shard_gtids." + error;
                }
            }
            if (message.participants != null && message.hasOwnProperty("participants")) {
                if (!Array.isArray(message.participants))
                    return "participants: array expected";
                for (var i = 0; i < message.participants.length; ++i) {
                    var error = $root.binlogdata.KeyspaceShard.verify(message.participants[i]);
                    if (error)
                        return "participants." + error;
                }
            }
            if (message.source_workflows != null && message.hasOwnProperty("source_workflows")) {
                if (!Array.isArray(message.source_workflows))
                    return "source_workflows: array expected";
                for (var i = 0; i < message.source_workflows.length; ++i)
                    if (!$util.isString(message.source_workflows[i]))
                        return "source_workflows: string[] expected";
            }
            return null;
        };

        /**
         * Creates a Journal message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof binlogdata.Journal
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {binlogdata.Journal} Journal
         */
        Journal.fromObject = function fromObject(object) {
            if (object instanceof $root.binlogdata.Journal)
                return object;
            var message = new $root.binlogdata.Journal();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = false;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
            switch (object.migration_type) {
            case "TABLES":
            case 0:
                message.migration_type = 0;
                break;
            case "SHARDS":
            case 1:
                message.migration_type = 1;
                break;
            }
            if (object.tables) {
                if (!Array.isArray(object.tables))
                    throw TypeError(".binlogdata.Journal.tables: array expected");
                message.tables = [];
                for (var i = 0; i < object.tables.length; ++i)
                    message.tables[i] = String(object.tables[i]);
            }
            if (object.local_position != null)
                message.local_position = String(object.local_position);
            if (object.shard_gtids) {
                if (!Array.isArray(object.shard_gtids))
                    throw TypeError(".binlogdata.Journal.shard_gtids: array expected");
                message.shard_gtids = [];
                for (var i = 0; i < object.shard_gtids.length; ++i) {
                    if (typeof object.shard_gtids[i] !== "object")
                        throw TypeError(".binlogdata.Journal.shard_gtids: object expected");
                    message.shard_gtids[i] = $root.binlogdata.ShardGtid.fromObject(object.shard_gtids[i]);
                }
            }
            if (object.participants) {
                if (!Array.isArray(object.participants))
                    throw TypeError(".binlogdata.Journal.participants: array expected");
                message.participants = [];
                for (var i = 0; i < object.participants.length; ++i) {
                    if (typeof object.participants[i] !== "object")
                        throw TypeError(".binlogdata.Journal.participants: object expected");
                    message.participants[i] = $root.binlogdata.KeyspaceShard.fromObject(object.participants[i]);
                }
            }
            if (object.source_workflows) {
                if (!Array.isArray(object.source_workflows))
                    throw TypeError(".binlogdata.Journal.source_workflows: array expected");
                message.source_workflows = [];
                for (var i = 0; i < object.source_workflows.length; ++i)
                    message.source_workflows[i] = String(object.source_workflows[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a Journal message. Also converts values to other types if specified.
         * @function toObject
         * @memberof binlogdata.Journal
         * @static
         * @param {binlogdata.Journal} message Journal
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Journal.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.tables = [];
                object.shard_gtids = [];
                object.participants = [];
                object.source_workflows = [];
            }
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
                object.migration_type = options.enums === String ? "TABLES" : 0;
                object.local_position = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
            if (message.migration_type != null && message.hasOwnProperty("migration_type"))
                object.migration_type = options.enums === String ? $root.binlogdata.MigrationType[message.migration_type] : message.migration_type;
            if (message.tables && message.tables.length) {
                object.tables = [];
                for (var j = 0; j < message.tables.length; ++j)
                    object.tables[j] = message.tables[j];
            }
            if (message.local_position != null && message.hasOwnProperty("local_position"))
                object.local_position = message.local_position;
            if (message.shard_gtids && message.shard_gtids.length) {
                object.shard_gtids = [];
                for (var j = 0; j < message.shard_gtids.length; ++j)
                    object.shard_gtids[j] = $root.binlogdata.ShardGtid.toObject(message.shard_gtids[j], options);
            }
            if (message.participants && message.participants.length) {
                object.participants = [];
                for (var j = 0; j < message.participants.length; ++j)
                    object.participants[j] = $root.binlogdata.KeyspaceShard.toObject(message.participants[j], options);
            }
            if (message.source_workflows && message.source_workflows.length) {
                object.source_workflows = [];
                for (var j = 0; j < message.source_workflows.length; ++j)
                    object.source_workflows[j] = message.source_workflows[j];
            }
            return object;
        };

        /**
         * Converts this Journal to JSON.
         * @function toJSON
         * @memberof binlogdata.Journal
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Journal.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Journal;
    })();

    binlogdata.VEvent = (function() {

        /**
         * Properties of a VEvent.
         * @memberof binlogdata
         * @interface IVEvent
         * @property {binlogdata.VEventType|null} [type] VEvent type
         * @property {number|Long|null} [timestamp] VEvent timestamp
         * @property {string|null} [gtid] VEvent gtid
         * @property {string|null} [statement] VEvent statement
         * @property {binlogdata.IRowEvent|null} [row_event] VEvent row_event
         * @property {binlogdata.IFieldEvent|null} [field_event] VEvent field_event
         * @property {binlogdata.IVGtid|null} [vgtid] VEvent vgtid
         * @property {binlogdata.IJournal|null} [journal] VEvent journal
         * @property {string|null} [dml] VEvent dml
         * @property {number|Long|null} [current_time] VEvent current_time
         * @property {binlogdata.ILastPKEvent|null} [last_p_k_event] VEvent last_p_k_event
         */

        /**
         * Constructs a new VEvent.
         * @memberof binlogdata
         * @classdesc Represents a VEvent.
         * @implements IVEvent
         * @constructor
         * @param {binlogdata.IVEvent=} [properties] Properties to set
         */
        function VEvent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VEvent type.
         * @member {binlogdata.VEventType} type
         * @memberof binlogdata.VEvent
         * @instance
         */
        VEvent.prototype.type = 0;

        /**
         * VEvent timestamp.
         * @member {number|Long} timestamp
         * @memberof binlogdata.VEvent
         * @instance
         */
        VEvent.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * VEvent gtid.
         * @member {string} gtid
         * @memberof binlogdata.VEvent
         * @instance
         */
        VEvent.prototype.gtid = "";

        /**
         * VEvent statement.
         * @member {string} statement
         * @memberof binlogdata.VEvent
         * @instance
         */
        VEvent.prototype.statement = "";

        /**
         * VEvent row_event.
         * @member {binlogdata.IRowEvent|null|undefined} row_event
         * @memberof binlogdata.VEvent
         * @instance
         */
        VEvent.prototype.row_event = null;

        /**
         * VEvent field_event.
         * @member {binlogdata.IFieldEvent|null|undefined} field_event
         * @memberof binlogdata.VEvent
         * @instance
         */
        VEvent.prototype.field_event = null;

        /**
         * VEvent vgtid.
         * @member {binlogdata.IVGtid|null|undefined} vgtid
         * @memberof binlogdata.VEvent
         * @instance
         */
        VEvent.prototype.vgtid = null;

        /**
         * VEvent journal.
         * @member {binlogdata.IJournal|null|undefined} journal
         * @memberof binlogdata.VEvent
         * @instance
         */
        VEvent.prototype.journal = null;

        /**
         * VEvent dml.
         * @member {string} dml
         * @memberof binlogdata.VEvent
         * @instance
         */
        VEvent.prototype.dml = "";

        /**
         * VEvent current_time.
         * @member {number|Long} current_time
         * @memberof binlogdata.VEvent
         * @instance
         */
        VEvent.prototype.current_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * VEvent last_p_k_event.
         * @member {binlogdata.ILastPKEvent|null|undefined} last_p_k_event
         * @memberof binlogdata.VEvent
         * @instance
         */
        VEvent.prototype.last_p_k_event = null;

        /**
         * Creates a new VEvent instance using the specified properties.
         * @function create
         * @memberof binlogdata.VEvent
         * @static
         * @param {binlogdata.IVEvent=} [properties] Properties to set
         * @returns {binlogdata.VEvent} VEvent instance
         */
        VEvent.create = function create(properties) {
            return new VEvent(properties);
        };

        /**
         * Encodes the specified VEvent message. Does not implicitly {@link binlogdata.VEvent.verify|verify} messages.
         * @function encode
         * @memberof binlogdata.VEvent
         * @static
         * @param {binlogdata.IVEvent} message VEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.timestamp);
            if (message.gtid != null && Object.hasOwnProperty.call(message, "gtid"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.gtid);
            if (message.statement != null && Object.hasOwnProperty.call(message, "statement"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.statement);
            if (message.row_event != null && Object.hasOwnProperty.call(message, "row_event"))
                $root.binlogdata.RowEvent.encode(message.row_event, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.field_event != null && Object.hasOwnProperty.call(message, "field_event"))
                $root.binlogdata.FieldEvent.encode(message.field_event, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.vgtid != null && Object.hasOwnProperty.call(message, "vgtid"))
                $root.binlogdata.VGtid.encode(message.vgtid, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.journal != null && Object.hasOwnProperty.call(message, "journal"))
                $root.binlogdata.Journal.encode(message.journal, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.dml != null && Object.hasOwnProperty.call(message, "dml"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.dml);
            if (message.current_time != null && Object.hasOwnProperty.call(message, "current_time"))
                writer.uint32(/* id 20, wireType 0 =*/160).int64(message.current_time);
            if (message.last_p_k_event != null && Object.hasOwnProperty.call(message, "last_p_k_event"))
                $root.binlogdata.LastPKEvent.encode(message.last_p_k_event, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified VEvent message, length delimited. Does not implicitly {@link binlogdata.VEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof binlogdata.VEvent
         * @static
         * @param {binlogdata.IVEvent} message VEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VEvent message from the specified reader or buffer.
         * @function decode
         * @memberof binlogdata.VEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {binlogdata.VEvent} VEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.binlogdata.VEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.timestamp = reader.int64();
                    break;
                case 3:
                    message.gtid = reader.string();
                    break;
                case 4:
                    message.statement = reader.string();
                    break;
                case 5:
                    message.row_event = $root.binlogdata.RowEvent.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.field_event = $root.binlogdata.FieldEvent.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.vgtid = $root.binlogdata.VGtid.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.journal = $root.binlogdata.Journal.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.dml = reader.string();
                    break;
                case 20:
                    message.current_time = reader.int64();
                    break;
                case 21:
                    message.last_p_k_event = $root.binlogdata.LastPKEvent.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof binlogdata.VEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {binlogdata.VEvent} VEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VEvent message.
         * @function verify
         * @memberof binlogdata.VEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                    break;
                }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.gtid != null && message.hasOwnProperty("gtid"))
                if (!$util.isString(message.gtid))
                    return "gtid: string expected";
            if (message.statement != null && message.hasOwnProperty("statement"))
                if (!$util.isString(message.statement))
                    return "statement: string expected";
            if (message.row_event != null && message.hasOwnProperty("row_event")) {
                var error = $root.binlogdata.RowEvent.verify(message.row_event);
                if (error)
                    return "row_event." + error;
            }
            if (message.field_event != null && message.hasOwnProperty("field_event")) {
                var error = $root.binlogdata.FieldEvent.verify(message.field_event);
                if (error)
                    return "field_event." + error;
            }
            if (message.vgtid != null && message.hasOwnProperty("vgtid")) {
                var error = $root.binlogdata.VGtid.verify(message.vgtid);
                if (error)
                    return "vgtid." + error;
            }
            if (message.journal != null && message.hasOwnProperty("journal")) {
                var error = $root.binlogdata.Journal.verify(message.journal);
                if (error)
                    return "journal." + error;
            }
            if (message.dml != null && message.hasOwnProperty("dml"))
                if (!$util.isString(message.dml))
                    return "dml: string expected";
            if (message.current_time != null && message.hasOwnProperty("current_time"))
                if (!$util.isInteger(message.current_time) && !(message.current_time && $util.isInteger(message.current_time.low) && $util.isInteger(message.current_time.high)))
                    return "current_time: integer|Long expected";
            if (message.last_p_k_event != null && message.hasOwnProperty("last_p_k_event")) {
                var error = $root.binlogdata.LastPKEvent.verify(message.last_p_k_event);
                if (error)
                    return "last_p_k_event." + error;
            }
            return null;
        };

        /**
         * Creates a VEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof binlogdata.VEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {binlogdata.VEvent} VEvent
         */
        VEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.binlogdata.VEvent)
                return object;
            var message = new $root.binlogdata.VEvent();
            switch (object.type) {
            case "UNKNOWN":
            case 0:
                message.type = 0;
                break;
            case "GTID":
            case 1:
                message.type = 1;
                break;
            case "BEGIN":
            case 2:
                message.type = 2;
                break;
            case "COMMIT":
            case 3:
                message.type = 3;
                break;
            case "ROLLBACK":
            case 4:
                message.type = 4;
                break;
            case "DDL":
            case 5:
                message.type = 5;
                break;
            case "INSERT":
            case 6:
                message.type = 6;
                break;
            case "REPLACE":
            case 7:
                message.type = 7;
                break;
            case "UPDATE":
            case 8:
                message.type = 8;
                break;
            case "DELETE":
            case 9:
                message.type = 9;
                break;
            case "SET":
            case 10:
                message.type = 10;
                break;
            case "OTHER":
            case 11:
                message.type = 11;
                break;
            case "ROW":
            case 12:
                message.type = 12;
                break;
            case "FIELD":
            case 13:
                message.type = 13;
                break;
            case "HEARTBEAT":
            case 14:
                message.type = 14;
                break;
            case "VGTID":
            case 15:
                message.type = 15;
                break;
            case "JOURNAL":
            case 16:
                message.type = 16;
                break;
            case "VERSION":
            case 17:
                message.type = 17;
                break;
            case "LASTPK":
            case 18:
                message.type = 18;
                break;
            case "SAVEPOINT":
            case 19:
                message.type = 19;
                break;
            }
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.gtid != null)
                message.gtid = String(object.gtid);
            if (object.statement != null)
                message.statement = String(object.statement);
            if (object.row_event != null) {
                if (typeof object.row_event !== "object")
                    throw TypeError(".binlogdata.VEvent.row_event: object expected");
                message.row_event = $root.binlogdata.RowEvent.fromObject(object.row_event);
            }
            if (object.field_event != null) {
                if (typeof object.field_event !== "object")
                    throw TypeError(".binlogdata.VEvent.field_event: object expected");
                message.field_event = $root.binlogdata.FieldEvent.fromObject(object.field_event);
            }
            if (object.vgtid != null) {
                if (typeof object.vgtid !== "object")
                    throw TypeError(".binlogdata.VEvent.vgtid: object expected");
                message.vgtid = $root.binlogdata.VGtid.fromObject(object.vgtid);
            }
            if (object.journal != null) {
                if (typeof object.journal !== "object")
                    throw TypeError(".binlogdata.VEvent.journal: object expected");
                message.journal = $root.binlogdata.Journal.fromObject(object.journal);
            }
            if (object.dml != null)
                message.dml = String(object.dml);
            if (object.current_time != null)
                if ($util.Long)
                    (message.current_time = $util.Long.fromValue(object.current_time)).unsigned = false;
                else if (typeof object.current_time === "string")
                    message.current_time = parseInt(object.current_time, 10);
                else if (typeof object.current_time === "number")
                    message.current_time = object.current_time;
                else if (typeof object.current_time === "object")
                    message.current_time = new $util.LongBits(object.current_time.low >>> 0, object.current_time.high >>> 0).toNumber();
            if (object.last_p_k_event != null) {
                if (typeof object.last_p_k_event !== "object")
                    throw TypeError(".binlogdata.VEvent.last_p_k_event: object expected");
                message.last_p_k_event = $root.binlogdata.LastPKEvent.fromObject(object.last_p_k_event);
            }
            return message;
        };

        /**
         * Creates a plain object from a VEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof binlogdata.VEvent
         * @static
         * @param {binlogdata.VEvent} message VEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "UNKNOWN" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                object.gtid = "";
                object.statement = "";
                object.row_event = null;
                object.field_event = null;
                object.vgtid = null;
                object.journal = null;
                object.dml = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.current_time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.current_time = options.longs === String ? "0" : 0;
                object.last_p_k_event = null;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.binlogdata.VEventType[message.type] : message.type;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.gtid != null && message.hasOwnProperty("gtid"))
                object.gtid = message.gtid;
            if (message.statement != null && message.hasOwnProperty("statement"))
                object.statement = message.statement;
            if (message.row_event != null && message.hasOwnProperty("row_event"))
                object.row_event = $root.binlogdata.RowEvent.toObject(message.row_event, options);
            if (message.field_event != null && message.hasOwnProperty("field_event"))
                object.field_event = $root.binlogdata.FieldEvent.toObject(message.field_event, options);
            if (message.vgtid != null && message.hasOwnProperty("vgtid"))
                object.vgtid = $root.binlogdata.VGtid.toObject(message.vgtid, options);
            if (message.journal != null && message.hasOwnProperty("journal"))
                object.journal = $root.binlogdata.Journal.toObject(message.journal, options);
            if (message.dml != null && message.hasOwnProperty("dml"))
                object.dml = message.dml;
            if (message.current_time != null && message.hasOwnProperty("current_time"))
                if (typeof message.current_time === "number")
                    object.current_time = options.longs === String ? String(message.current_time) : message.current_time;
                else
                    object.current_time = options.longs === String ? $util.Long.prototype.toString.call(message.current_time) : options.longs === Number ? new $util.LongBits(message.current_time.low >>> 0, message.current_time.high >>> 0).toNumber() : message.current_time;
            if (message.last_p_k_event != null && message.hasOwnProperty("last_p_k_event"))
                object.last_p_k_event = $root.binlogdata.LastPKEvent.toObject(message.last_p_k_event, options);
            return object;
        };

        /**
         * Converts this VEvent to JSON.
         * @function toJSON
         * @memberof binlogdata.VEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VEvent;
    })();

    binlogdata.MinimalTable = (function() {

        /**
         * Properties of a MinimalTable.
         * @memberof binlogdata
         * @interface IMinimalTable
         * @property {string|null} [name] MinimalTable name
         * @property {Array.<query.IField>|null} [fields] MinimalTable fields
         * @property {Array.<number|Long>|null} [p_k_columns] MinimalTable p_k_columns
         */

        /**
         * Constructs a new MinimalTable.
         * @memberof binlogdata
         * @classdesc Represents a MinimalTable.
         * @implements IMinimalTable
         * @constructor
         * @param {binlogdata.IMinimalTable=} [properties] Properties to set
         */
        function MinimalTable(properties) {
            this.fields = [];
            this.p_k_columns = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MinimalTable name.
         * @member {string} name
         * @memberof binlogdata.MinimalTable
         * @instance
         */
        MinimalTable.prototype.name = "";

        /**
         * MinimalTable fields.
         * @member {Array.<query.IField>} fields
         * @memberof binlogdata.MinimalTable
         * @instance
         */
        MinimalTable.prototype.fields = $util.emptyArray;

        /**
         * MinimalTable p_k_columns.
         * @member {Array.<number|Long>} p_k_columns
         * @memberof binlogdata.MinimalTable
         * @instance
         */
        MinimalTable.prototype.p_k_columns = $util.emptyArray;

        /**
         * Creates a new MinimalTable instance using the specified properties.
         * @function create
         * @memberof binlogdata.MinimalTable
         * @static
         * @param {binlogdata.IMinimalTable=} [properties] Properties to set
         * @returns {binlogdata.MinimalTable} MinimalTable instance
         */
        MinimalTable.create = function create(properties) {
            return new MinimalTable(properties);
        };

        /**
         * Encodes the specified MinimalTable message. Does not implicitly {@link binlogdata.MinimalTable.verify|verify} messages.
         * @function encode
         * @memberof binlogdata.MinimalTable
         * @static
         * @param {binlogdata.IMinimalTable} message MinimalTable message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MinimalTable.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.fields != null && message.fields.length)
                for (var i = 0; i < message.fields.length; ++i)
                    $root.query.Field.encode(message.fields[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.p_k_columns != null && message.p_k_columns.length) {
                writer.uint32(/* id 3, wireType 2 =*/26).fork();
                for (var i = 0; i < message.p_k_columns.length; ++i)
                    writer.int64(message.p_k_columns[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified MinimalTable message, length delimited. Does not implicitly {@link binlogdata.MinimalTable.verify|verify} messages.
         * @function encodeDelimited
         * @memberof binlogdata.MinimalTable
         * @static
         * @param {binlogdata.IMinimalTable} message MinimalTable message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MinimalTable.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MinimalTable message from the specified reader or buffer.
         * @function decode
         * @memberof binlogdata.MinimalTable
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {binlogdata.MinimalTable} MinimalTable
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MinimalTable.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.binlogdata.MinimalTable();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    if (!(message.fields && message.fields.length))
                        message.fields = [];
                    message.fields.push($root.query.Field.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.p_k_columns && message.p_k_columns.length))
                        message.p_k_columns = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.p_k_columns.push(reader.int64());
                    } else
                        message.p_k_columns.push(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MinimalTable message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof binlogdata.MinimalTable
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {binlogdata.MinimalTable} MinimalTable
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MinimalTable.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MinimalTable message.
         * @function verify
         * @memberof binlogdata.MinimalTable
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MinimalTable.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.fields != null && message.hasOwnProperty("fields")) {
                if (!Array.isArray(message.fields))
                    return "fields: array expected";
                for (var i = 0; i < message.fields.length; ++i) {
                    var error = $root.query.Field.verify(message.fields[i]);
                    if (error)
                        return "fields." + error;
                }
            }
            if (message.p_k_columns != null && message.hasOwnProperty("p_k_columns")) {
                if (!Array.isArray(message.p_k_columns))
                    return "p_k_columns: array expected";
                for (var i = 0; i < message.p_k_columns.length; ++i)
                    if (!$util.isInteger(message.p_k_columns[i]) && !(message.p_k_columns[i] && $util.isInteger(message.p_k_columns[i].low) && $util.isInteger(message.p_k_columns[i].high)))
                        return "p_k_columns: integer|Long[] expected";
            }
            return null;
        };

        /**
         * Creates a MinimalTable message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof binlogdata.MinimalTable
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {binlogdata.MinimalTable} MinimalTable
         */
        MinimalTable.fromObject = function fromObject(object) {
            if (object instanceof $root.binlogdata.MinimalTable)
                return object;
            var message = new $root.binlogdata.MinimalTable();
            if (object.name != null)
                message.name = String(object.name);
            if (object.fields) {
                if (!Array.isArray(object.fields))
                    throw TypeError(".binlogdata.MinimalTable.fields: array expected");
                message.fields = [];
                for (var i = 0; i < object.fields.length; ++i) {
                    if (typeof object.fields[i] !== "object")
                        throw TypeError(".binlogdata.MinimalTable.fields: object expected");
                    message.fields[i] = $root.query.Field.fromObject(object.fields[i]);
                }
            }
            if (object.p_k_columns) {
                if (!Array.isArray(object.p_k_columns))
                    throw TypeError(".binlogdata.MinimalTable.p_k_columns: array expected");
                message.p_k_columns = [];
                for (var i = 0; i < object.p_k_columns.length; ++i)
                    if ($util.Long)
                        (message.p_k_columns[i] = $util.Long.fromValue(object.p_k_columns[i])).unsigned = false;
                    else if (typeof object.p_k_columns[i] === "string")
                        message.p_k_columns[i] = parseInt(object.p_k_columns[i], 10);
                    else if (typeof object.p_k_columns[i] === "number")
                        message.p_k_columns[i] = object.p_k_columns[i];
                    else if (typeof object.p_k_columns[i] === "object")
                        message.p_k_columns[i] = new $util.LongBits(object.p_k_columns[i].low >>> 0, object.p_k_columns[i].high >>> 0).toNumber();
            }
            return message;
        };

        /**
         * Creates a plain object from a MinimalTable message. Also converts values to other types if specified.
         * @function toObject
         * @memberof binlogdata.MinimalTable
         * @static
         * @param {binlogdata.MinimalTable} message MinimalTable
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MinimalTable.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.fields = [];
                object.p_k_columns = [];
            }
            if (options.defaults)
                object.name = "";
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.fields && message.fields.length) {
                object.fields = [];
                for (var j = 0; j < message.fields.length; ++j)
                    object.fields[j] = $root.query.Field.toObject(message.fields[j], options);
            }
            if (message.p_k_columns && message.p_k_columns.length) {
                object.p_k_columns = [];
                for (var j = 0; j < message.p_k_columns.length; ++j)
                    if (typeof message.p_k_columns[j] === "number")
                        object.p_k_columns[j] = options.longs === String ? String(message.p_k_columns[j]) : message.p_k_columns[j];
                    else
                        object.p_k_columns[j] = options.longs === String ? $util.Long.prototype.toString.call(message.p_k_columns[j]) : options.longs === Number ? new $util.LongBits(message.p_k_columns[j].low >>> 0, message.p_k_columns[j].high >>> 0).toNumber() : message.p_k_columns[j];
            }
            return object;
        };

        /**
         * Converts this MinimalTable to JSON.
         * @function toJSON
         * @memberof binlogdata.MinimalTable
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MinimalTable.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MinimalTable;
    })();

    binlogdata.MinimalSchema = (function() {

        /**
         * Properties of a MinimalSchema.
         * @memberof binlogdata
         * @interface IMinimalSchema
         * @property {Array.<binlogdata.IMinimalTable>|null} [tables] MinimalSchema tables
         */

        /**
         * Constructs a new MinimalSchema.
         * @memberof binlogdata
         * @classdesc Represents a MinimalSchema.
         * @implements IMinimalSchema
         * @constructor
         * @param {binlogdata.IMinimalSchema=} [properties] Properties to set
         */
        function MinimalSchema(properties) {
            this.tables = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MinimalSchema tables.
         * @member {Array.<binlogdata.IMinimalTable>} tables
         * @memberof binlogdata.MinimalSchema
         * @instance
         */
        MinimalSchema.prototype.tables = $util.emptyArray;

        /**
         * Creates a new MinimalSchema instance using the specified properties.
         * @function create
         * @memberof binlogdata.MinimalSchema
         * @static
         * @param {binlogdata.IMinimalSchema=} [properties] Properties to set
         * @returns {binlogdata.MinimalSchema} MinimalSchema instance
         */
        MinimalSchema.create = function create(properties) {
            return new MinimalSchema(properties);
        };

        /**
         * Encodes the specified MinimalSchema message. Does not implicitly {@link binlogdata.MinimalSchema.verify|verify} messages.
         * @function encode
         * @memberof binlogdata.MinimalSchema
         * @static
         * @param {binlogdata.IMinimalSchema} message MinimalSchema message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MinimalSchema.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tables != null && message.tables.length)
                for (var i = 0; i < message.tables.length; ++i)
                    $root.binlogdata.MinimalTable.encode(message.tables[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MinimalSchema message, length delimited. Does not implicitly {@link binlogdata.MinimalSchema.verify|verify} messages.
         * @function encodeDelimited
         * @memberof binlogdata.MinimalSchema
         * @static
         * @param {binlogdata.IMinimalSchema} message MinimalSchema message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MinimalSchema.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MinimalSchema message from the specified reader or buffer.
         * @function decode
         * @memberof binlogdata.MinimalSchema
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {binlogdata.MinimalSchema} MinimalSchema
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MinimalSchema.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.binlogdata.MinimalSchema();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.tables && message.tables.length))
                        message.tables = [];
                    message.tables.push($root.binlogdata.MinimalTable.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MinimalSchema message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof binlogdata.MinimalSchema
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {binlogdata.MinimalSchema} MinimalSchema
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MinimalSchema.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MinimalSchema message.
         * @function verify
         * @memberof binlogdata.MinimalSchema
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MinimalSchema.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tables != null && message.hasOwnProperty("tables")) {
                if (!Array.isArray(message.tables))
                    return "tables: array expected";
                for (var i = 0; i < message.tables.length; ++i) {
                    var error = $root.binlogdata.MinimalTable.verify(message.tables[i]);
                    if (error)
                        return "tables." + error;
                }
            }
            return null;
        };

        /**
         * Creates a MinimalSchema message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof binlogdata.MinimalSchema
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {binlogdata.MinimalSchema} MinimalSchema
         */
        MinimalSchema.fromObject = function fromObject(object) {
            if (object instanceof $root.binlogdata.MinimalSchema)
                return object;
            var message = new $root.binlogdata.MinimalSchema();
            if (object.tables) {
                if (!Array.isArray(object.tables))
                    throw TypeError(".binlogdata.MinimalSchema.tables: array expected");
                message.tables = [];
                for (var i = 0; i < object.tables.length; ++i) {
                    if (typeof object.tables[i] !== "object")
                        throw TypeError(".binlogdata.MinimalSchema.tables: object expected");
                    message.tables[i] = $root.binlogdata.MinimalTable.fromObject(object.tables[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a MinimalSchema message. Also converts values to other types if specified.
         * @function toObject
         * @memberof binlogdata.MinimalSchema
         * @static
         * @param {binlogdata.MinimalSchema} message MinimalSchema
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MinimalSchema.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.tables = [];
            if (message.tables && message.tables.length) {
                object.tables = [];
                for (var j = 0; j < message.tables.length; ++j)
                    object.tables[j] = $root.binlogdata.MinimalTable.toObject(message.tables[j], options);
            }
            return object;
        };

        /**
         * Converts this MinimalSchema to JSON.
         * @function toJSON
         * @memberof binlogdata.MinimalSchema
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MinimalSchema.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MinimalSchema;
    })();

    binlogdata.VStreamRequest = (function() {

        /**
         * Properties of a VStreamRequest.
         * @memberof binlogdata
         * @interface IVStreamRequest
         * @property {vtrpc.ICallerID|null} [effective_caller_id] VStreamRequest effective_caller_id
         * @property {query.IVTGateCallerID|null} [immediate_caller_id] VStreamRequest immediate_caller_id
         * @property {query.ITarget|null} [target] VStreamRequest target
         * @property {string|null} [position] VStreamRequest position
         * @property {binlogdata.IFilter|null} [filter] VStreamRequest filter
         * @property {Array.<binlogdata.ITableLastPK>|null} [table_last_p_ks] VStreamRequest table_last_p_ks
         */

        /**
         * Constructs a new VStreamRequest.
         * @memberof binlogdata
         * @classdesc Represents a VStreamRequest.
         * @implements IVStreamRequest
         * @constructor
         * @param {binlogdata.IVStreamRequest=} [properties] Properties to set
         */
        function VStreamRequest(properties) {
            this.table_last_p_ks = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VStreamRequest effective_caller_id.
         * @member {vtrpc.ICallerID|null|undefined} effective_caller_id
         * @memberof binlogdata.VStreamRequest
         * @instance
         */
        VStreamRequest.prototype.effective_caller_id = null;

        /**
         * VStreamRequest immediate_caller_id.
         * @member {query.IVTGateCallerID|null|undefined} immediate_caller_id
         * @memberof binlogdata.VStreamRequest
         * @instance
         */
        VStreamRequest.prototype.immediate_caller_id = null;

        /**
         * VStreamRequest target.
         * @member {query.ITarget|null|undefined} target
         * @memberof binlogdata.VStreamRequest
         * @instance
         */
        VStreamRequest.prototype.target = null;

        /**
         * VStreamRequest position.
         * @member {string} position
         * @memberof binlogdata.VStreamRequest
         * @instance
         */
        VStreamRequest.prototype.position = "";

        /**
         * VStreamRequest filter.
         * @member {binlogdata.IFilter|null|undefined} filter
         * @memberof binlogdata.VStreamRequest
         * @instance
         */
        VStreamRequest.prototype.filter = null;

        /**
         * VStreamRequest table_last_p_ks.
         * @member {Array.<binlogdata.ITableLastPK>} table_last_p_ks
         * @memberof binlogdata.VStreamRequest
         * @instance
         */
        VStreamRequest.prototype.table_last_p_ks = $util.emptyArray;

        /**
         * Creates a new VStreamRequest instance using the specified properties.
         * @function create
         * @memberof binlogdata.VStreamRequest
         * @static
         * @param {binlogdata.IVStreamRequest=} [properties] Properties to set
         * @returns {binlogdata.VStreamRequest} VStreamRequest instance
         */
        VStreamRequest.create = function create(properties) {
            return new VStreamRequest(properties);
        };

        /**
         * Encodes the specified VStreamRequest message. Does not implicitly {@link binlogdata.VStreamRequest.verify|verify} messages.
         * @function encode
         * @memberof binlogdata.VStreamRequest
         * @static
         * @param {binlogdata.IVStreamRequest} message VStreamRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VStreamRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.effective_caller_id != null && Object.hasOwnProperty.call(message, "effective_caller_id"))
                $root.vtrpc.CallerID.encode(message.effective_caller_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.immediate_caller_id != null && Object.hasOwnProperty.call(message, "immediate_caller_id"))
                $root.query.VTGateCallerID.encode(message.immediate_caller_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                $root.query.Target.encode(message.target, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.position);
            if (message.filter != null && Object.hasOwnProperty.call(message, "filter"))
                $root.binlogdata.Filter.encode(message.filter, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.table_last_p_ks != null && message.table_last_p_ks.length)
                for (var i = 0; i < message.table_last_p_ks.length; ++i)
                    $root.binlogdata.TableLastPK.encode(message.table_last_p_ks[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified VStreamRequest message, length delimited. Does not implicitly {@link binlogdata.VStreamRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof binlogdata.VStreamRequest
         * @static
         * @param {binlogdata.IVStreamRequest} message VStreamRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VStreamRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VStreamRequest message from the specified reader or buffer.
         * @function decode
         * @memberof binlogdata.VStreamRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {binlogdata.VStreamRequest} VStreamRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VStreamRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.binlogdata.VStreamRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.effective_caller_id = $root.vtrpc.CallerID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.immediate_caller_id = $root.query.VTGateCallerID.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.target = $root.query.Target.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.position = reader.string();
                    break;
                case 5:
                    message.filter = $root.binlogdata.Filter.decode(reader, reader.uint32());
                    break;
                case 6:
                    if (!(message.table_last_p_ks && message.table_last_p_ks.length))
                        message.table_last_p_ks = [];
                    message.table_last_p_ks.push($root.binlogdata.TableLastPK.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VStreamRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof binlogdata.VStreamRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {binlogdata.VStreamRequest} VStreamRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VStreamRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VStreamRequest message.
         * @function verify
         * @memberof binlogdata.VStreamRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VStreamRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id")) {
                var error = $root.vtrpc.CallerID.verify(message.effective_caller_id);
                if (error)
                    return "effective_caller_id." + error;
            }
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id")) {
                var error = $root.query.VTGateCallerID.verify(message.immediate_caller_id);
                if (error)
                    return "immediate_caller_id." + error;
            }
            if (message.target != null && message.hasOwnProperty("target")) {
                var error = $root.query.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.position != null && message.hasOwnProperty("position"))
                if (!$util.isString(message.position))
                    return "position: string expected";
            if (message.filter != null && message.hasOwnProperty("filter")) {
                var error = $root.binlogdata.Filter.verify(message.filter);
                if (error)
                    return "filter." + error;
            }
            if (message.table_last_p_ks != null && message.hasOwnProperty("table_last_p_ks")) {
                if (!Array.isArray(message.table_last_p_ks))
                    return "table_last_p_ks: array expected";
                for (var i = 0; i < message.table_last_p_ks.length; ++i) {
                    var error = $root.binlogdata.TableLastPK.verify(message.table_last_p_ks[i]);
                    if (error)
                        return "table_last_p_ks." + error;
                }
            }
            return null;
        };

        /**
         * Creates a VStreamRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof binlogdata.VStreamRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {binlogdata.VStreamRequest} VStreamRequest
         */
        VStreamRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.binlogdata.VStreamRequest)
                return object;
            var message = new $root.binlogdata.VStreamRequest();
            if (object.effective_caller_id != null) {
                if (typeof object.effective_caller_id !== "object")
                    throw TypeError(".binlogdata.VStreamRequest.effective_caller_id: object expected");
                message.effective_caller_id = $root.vtrpc.CallerID.fromObject(object.effective_caller_id);
            }
            if (object.immediate_caller_id != null) {
                if (typeof object.immediate_caller_id !== "object")
                    throw TypeError(".binlogdata.VStreamRequest.immediate_caller_id: object expected");
                message.immediate_caller_id = $root.query.VTGateCallerID.fromObject(object.immediate_caller_id);
            }
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".binlogdata.VStreamRequest.target: object expected");
                message.target = $root.query.Target.fromObject(object.target);
            }
            if (object.position != null)
                message.position = String(object.position);
            if (object.filter != null) {
                if (typeof object.filter !== "object")
                    throw TypeError(".binlogdata.VStreamRequest.filter: object expected");
                message.filter = $root.binlogdata.Filter.fromObject(object.filter);
            }
            if (object.table_last_p_ks) {
                if (!Array.isArray(object.table_last_p_ks))
                    throw TypeError(".binlogdata.VStreamRequest.table_last_p_ks: array expected");
                message.table_last_p_ks = [];
                for (var i = 0; i < object.table_last_p_ks.length; ++i) {
                    if (typeof object.table_last_p_ks[i] !== "object")
                        throw TypeError(".binlogdata.VStreamRequest.table_last_p_ks: object expected");
                    message.table_last_p_ks[i] = $root.binlogdata.TableLastPK.fromObject(object.table_last_p_ks[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a VStreamRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof binlogdata.VStreamRequest
         * @static
         * @param {binlogdata.VStreamRequest} message VStreamRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VStreamRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.table_last_p_ks = [];
            if (options.defaults) {
                object.effective_caller_id = null;
                object.immediate_caller_id = null;
                object.target = null;
                object.position = "";
                object.filter = null;
            }
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id"))
                object.effective_caller_id = $root.vtrpc.CallerID.toObject(message.effective_caller_id, options);
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id"))
                object.immediate_caller_id = $root.query.VTGateCallerID.toObject(message.immediate_caller_id, options);
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.query.Target.toObject(message.target, options);
            if (message.position != null && message.hasOwnProperty("position"))
                object.position = message.position;
            if (message.filter != null && message.hasOwnProperty("filter"))
                object.filter = $root.binlogdata.Filter.toObject(message.filter, options);
            if (message.table_last_p_ks && message.table_last_p_ks.length) {
                object.table_last_p_ks = [];
                for (var j = 0; j < message.table_last_p_ks.length; ++j)
                    object.table_last_p_ks[j] = $root.binlogdata.TableLastPK.toObject(message.table_last_p_ks[j], options);
            }
            return object;
        };

        /**
         * Converts this VStreamRequest to JSON.
         * @function toJSON
         * @memberof binlogdata.VStreamRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VStreamRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VStreamRequest;
    })();

    binlogdata.VStreamResponse = (function() {

        /**
         * Properties of a VStreamResponse.
         * @memberof binlogdata
         * @interface IVStreamResponse
         * @property {Array.<binlogdata.IVEvent>|null} [events] VStreamResponse events
         */

        /**
         * Constructs a new VStreamResponse.
         * @memberof binlogdata
         * @classdesc Represents a VStreamResponse.
         * @implements IVStreamResponse
         * @constructor
         * @param {binlogdata.IVStreamResponse=} [properties] Properties to set
         */
        function VStreamResponse(properties) {
            this.events = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VStreamResponse events.
         * @member {Array.<binlogdata.IVEvent>} events
         * @memberof binlogdata.VStreamResponse
         * @instance
         */
        VStreamResponse.prototype.events = $util.emptyArray;

        /**
         * Creates a new VStreamResponse instance using the specified properties.
         * @function create
         * @memberof binlogdata.VStreamResponse
         * @static
         * @param {binlogdata.IVStreamResponse=} [properties] Properties to set
         * @returns {binlogdata.VStreamResponse} VStreamResponse instance
         */
        VStreamResponse.create = function create(properties) {
            return new VStreamResponse(properties);
        };

        /**
         * Encodes the specified VStreamResponse message. Does not implicitly {@link binlogdata.VStreamResponse.verify|verify} messages.
         * @function encode
         * @memberof binlogdata.VStreamResponse
         * @static
         * @param {binlogdata.IVStreamResponse} message VStreamResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VStreamResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.events != null && message.events.length)
                for (var i = 0; i < message.events.length; ++i)
                    $root.binlogdata.VEvent.encode(message.events[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified VStreamResponse message, length delimited. Does not implicitly {@link binlogdata.VStreamResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof binlogdata.VStreamResponse
         * @static
         * @param {binlogdata.IVStreamResponse} message VStreamResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VStreamResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VStreamResponse message from the specified reader or buffer.
         * @function decode
         * @memberof binlogdata.VStreamResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {binlogdata.VStreamResponse} VStreamResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VStreamResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.binlogdata.VStreamResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.events && message.events.length))
                        message.events = [];
                    message.events.push($root.binlogdata.VEvent.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VStreamResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof binlogdata.VStreamResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {binlogdata.VStreamResponse} VStreamResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VStreamResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VStreamResponse message.
         * @function verify
         * @memberof binlogdata.VStreamResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VStreamResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.events != null && message.hasOwnProperty("events")) {
                if (!Array.isArray(message.events))
                    return "events: array expected";
                for (var i = 0; i < message.events.length; ++i) {
                    var error = $root.binlogdata.VEvent.verify(message.events[i]);
                    if (error)
                        return "events." + error;
                }
            }
            return null;
        };

        /**
         * Creates a VStreamResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof binlogdata.VStreamResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {binlogdata.VStreamResponse} VStreamResponse
         */
        VStreamResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.binlogdata.VStreamResponse)
                return object;
            var message = new $root.binlogdata.VStreamResponse();
            if (object.events) {
                if (!Array.isArray(object.events))
                    throw TypeError(".binlogdata.VStreamResponse.events: array expected");
                message.events = [];
                for (var i = 0; i < object.events.length; ++i) {
                    if (typeof object.events[i] !== "object")
                        throw TypeError(".binlogdata.VStreamResponse.events: object expected");
                    message.events[i] = $root.binlogdata.VEvent.fromObject(object.events[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a VStreamResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof binlogdata.VStreamResponse
         * @static
         * @param {binlogdata.VStreamResponse} message VStreamResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VStreamResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.events = [];
            if (message.events && message.events.length) {
                object.events = [];
                for (var j = 0; j < message.events.length; ++j)
                    object.events[j] = $root.binlogdata.VEvent.toObject(message.events[j], options);
            }
            return object;
        };

        /**
         * Converts this VStreamResponse to JSON.
         * @function toJSON
         * @memberof binlogdata.VStreamResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VStreamResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VStreamResponse;
    })();

    binlogdata.VStreamRowsRequest = (function() {

        /**
         * Properties of a VStreamRowsRequest.
         * @memberof binlogdata
         * @interface IVStreamRowsRequest
         * @property {vtrpc.ICallerID|null} [effective_caller_id] VStreamRowsRequest effective_caller_id
         * @property {query.IVTGateCallerID|null} [immediate_caller_id] VStreamRowsRequest immediate_caller_id
         * @property {query.ITarget|null} [target] VStreamRowsRequest target
         * @property {string|null} [query] VStreamRowsRequest query
         * @property {query.IQueryResult|null} [lastpk] VStreamRowsRequest lastpk
         */

        /**
         * Constructs a new VStreamRowsRequest.
         * @memberof binlogdata
         * @classdesc Represents a VStreamRowsRequest.
         * @implements IVStreamRowsRequest
         * @constructor
         * @param {binlogdata.IVStreamRowsRequest=} [properties] Properties to set
         */
        function VStreamRowsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VStreamRowsRequest effective_caller_id.
         * @member {vtrpc.ICallerID|null|undefined} effective_caller_id
         * @memberof binlogdata.VStreamRowsRequest
         * @instance
         */
        VStreamRowsRequest.prototype.effective_caller_id = null;

        /**
         * VStreamRowsRequest immediate_caller_id.
         * @member {query.IVTGateCallerID|null|undefined} immediate_caller_id
         * @memberof binlogdata.VStreamRowsRequest
         * @instance
         */
        VStreamRowsRequest.prototype.immediate_caller_id = null;

        /**
         * VStreamRowsRequest target.
         * @member {query.ITarget|null|undefined} target
         * @memberof binlogdata.VStreamRowsRequest
         * @instance
         */
        VStreamRowsRequest.prototype.target = null;

        /**
         * VStreamRowsRequest query.
         * @member {string} query
         * @memberof binlogdata.VStreamRowsRequest
         * @instance
         */
        VStreamRowsRequest.prototype.query = "";

        /**
         * VStreamRowsRequest lastpk.
         * @member {query.IQueryResult|null|undefined} lastpk
         * @memberof binlogdata.VStreamRowsRequest
         * @instance
         */
        VStreamRowsRequest.prototype.lastpk = null;

        /**
         * Creates a new VStreamRowsRequest instance using the specified properties.
         * @function create
         * @memberof binlogdata.VStreamRowsRequest
         * @static
         * @param {binlogdata.IVStreamRowsRequest=} [properties] Properties to set
         * @returns {binlogdata.VStreamRowsRequest} VStreamRowsRequest instance
         */
        VStreamRowsRequest.create = function create(properties) {
            return new VStreamRowsRequest(properties);
        };

        /**
         * Encodes the specified VStreamRowsRequest message. Does not implicitly {@link binlogdata.VStreamRowsRequest.verify|verify} messages.
         * @function encode
         * @memberof binlogdata.VStreamRowsRequest
         * @static
         * @param {binlogdata.IVStreamRowsRequest} message VStreamRowsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VStreamRowsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.effective_caller_id != null && Object.hasOwnProperty.call(message, "effective_caller_id"))
                $root.vtrpc.CallerID.encode(message.effective_caller_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.immediate_caller_id != null && Object.hasOwnProperty.call(message, "immediate_caller_id"))
                $root.query.VTGateCallerID.encode(message.immediate_caller_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                $root.query.Target.encode(message.target, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.query);
            if (message.lastpk != null && Object.hasOwnProperty.call(message, "lastpk"))
                $root.query.QueryResult.encode(message.lastpk, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified VStreamRowsRequest message, length delimited. Does not implicitly {@link binlogdata.VStreamRowsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof binlogdata.VStreamRowsRequest
         * @static
         * @param {binlogdata.IVStreamRowsRequest} message VStreamRowsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VStreamRowsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VStreamRowsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof binlogdata.VStreamRowsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {binlogdata.VStreamRowsRequest} VStreamRowsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VStreamRowsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.binlogdata.VStreamRowsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.effective_caller_id = $root.vtrpc.CallerID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.immediate_caller_id = $root.query.VTGateCallerID.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.target = $root.query.Target.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.query = reader.string();
                    break;
                case 5:
                    message.lastpk = $root.query.QueryResult.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VStreamRowsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof binlogdata.VStreamRowsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {binlogdata.VStreamRowsRequest} VStreamRowsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VStreamRowsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VStreamRowsRequest message.
         * @function verify
         * @memberof binlogdata.VStreamRowsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VStreamRowsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id")) {
                var error = $root.vtrpc.CallerID.verify(message.effective_caller_id);
                if (error)
                    return "effective_caller_id." + error;
            }
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id")) {
                var error = $root.query.VTGateCallerID.verify(message.immediate_caller_id);
                if (error)
                    return "immediate_caller_id." + error;
            }
            if (message.target != null && message.hasOwnProperty("target")) {
                var error = $root.query.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.query != null && message.hasOwnProperty("query"))
                if (!$util.isString(message.query))
                    return "query: string expected";
            if (message.lastpk != null && message.hasOwnProperty("lastpk")) {
                var error = $root.query.QueryResult.verify(message.lastpk);
                if (error)
                    return "lastpk." + error;
            }
            return null;
        };

        /**
         * Creates a VStreamRowsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof binlogdata.VStreamRowsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {binlogdata.VStreamRowsRequest} VStreamRowsRequest
         */
        VStreamRowsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.binlogdata.VStreamRowsRequest)
                return object;
            var message = new $root.binlogdata.VStreamRowsRequest();
            if (object.effective_caller_id != null) {
                if (typeof object.effective_caller_id !== "object")
                    throw TypeError(".binlogdata.VStreamRowsRequest.effective_caller_id: object expected");
                message.effective_caller_id = $root.vtrpc.CallerID.fromObject(object.effective_caller_id);
            }
            if (object.immediate_caller_id != null) {
                if (typeof object.immediate_caller_id !== "object")
                    throw TypeError(".binlogdata.VStreamRowsRequest.immediate_caller_id: object expected");
                message.immediate_caller_id = $root.query.VTGateCallerID.fromObject(object.immediate_caller_id);
            }
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".binlogdata.VStreamRowsRequest.target: object expected");
                message.target = $root.query.Target.fromObject(object.target);
            }
            if (object.query != null)
                message.query = String(object.query);
            if (object.lastpk != null) {
                if (typeof object.lastpk !== "object")
                    throw TypeError(".binlogdata.VStreamRowsRequest.lastpk: object expected");
                message.lastpk = $root.query.QueryResult.fromObject(object.lastpk);
            }
            return message;
        };

        /**
         * Creates a plain object from a VStreamRowsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof binlogdata.VStreamRowsRequest
         * @static
         * @param {binlogdata.VStreamRowsRequest} message VStreamRowsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VStreamRowsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.effective_caller_id = null;
                object.immediate_caller_id = null;
                object.target = null;
                object.query = "";
                object.lastpk = null;
            }
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id"))
                object.effective_caller_id = $root.vtrpc.CallerID.toObject(message.effective_caller_id, options);
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id"))
                object.immediate_caller_id = $root.query.VTGateCallerID.toObject(message.immediate_caller_id, options);
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.query.Target.toObject(message.target, options);
            if (message.query != null && message.hasOwnProperty("query"))
                object.query = message.query;
            if (message.lastpk != null && message.hasOwnProperty("lastpk"))
                object.lastpk = $root.query.QueryResult.toObject(message.lastpk, options);
            return object;
        };

        /**
         * Converts this VStreamRowsRequest to JSON.
         * @function toJSON
         * @memberof binlogdata.VStreamRowsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VStreamRowsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VStreamRowsRequest;
    })();

    binlogdata.VStreamRowsResponse = (function() {

        /**
         * Properties of a VStreamRowsResponse.
         * @memberof binlogdata
         * @interface IVStreamRowsResponse
         * @property {Array.<query.IField>|null} [fields] VStreamRowsResponse fields
         * @property {Array.<query.IField>|null} [pkfields] VStreamRowsResponse pkfields
         * @property {string|null} [gtid] VStreamRowsResponse gtid
         * @property {Array.<query.IRow>|null} [rows] VStreamRowsResponse rows
         * @property {query.IRow|null} [lastpk] VStreamRowsResponse lastpk
         */

        /**
         * Constructs a new VStreamRowsResponse.
         * @memberof binlogdata
         * @classdesc Represents a VStreamRowsResponse.
         * @implements IVStreamRowsResponse
         * @constructor
         * @param {binlogdata.IVStreamRowsResponse=} [properties] Properties to set
         */
        function VStreamRowsResponse(properties) {
            this.fields = [];
            this.pkfields = [];
            this.rows = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VStreamRowsResponse fields.
         * @member {Array.<query.IField>} fields
         * @memberof binlogdata.VStreamRowsResponse
         * @instance
         */
        VStreamRowsResponse.prototype.fields = $util.emptyArray;

        /**
         * VStreamRowsResponse pkfields.
         * @member {Array.<query.IField>} pkfields
         * @memberof binlogdata.VStreamRowsResponse
         * @instance
         */
        VStreamRowsResponse.prototype.pkfields = $util.emptyArray;

        /**
         * VStreamRowsResponse gtid.
         * @member {string} gtid
         * @memberof binlogdata.VStreamRowsResponse
         * @instance
         */
        VStreamRowsResponse.prototype.gtid = "";

        /**
         * VStreamRowsResponse rows.
         * @member {Array.<query.IRow>} rows
         * @memberof binlogdata.VStreamRowsResponse
         * @instance
         */
        VStreamRowsResponse.prototype.rows = $util.emptyArray;

        /**
         * VStreamRowsResponse lastpk.
         * @member {query.IRow|null|undefined} lastpk
         * @memberof binlogdata.VStreamRowsResponse
         * @instance
         */
        VStreamRowsResponse.prototype.lastpk = null;

        /**
         * Creates a new VStreamRowsResponse instance using the specified properties.
         * @function create
         * @memberof binlogdata.VStreamRowsResponse
         * @static
         * @param {binlogdata.IVStreamRowsResponse=} [properties] Properties to set
         * @returns {binlogdata.VStreamRowsResponse} VStreamRowsResponse instance
         */
        VStreamRowsResponse.create = function create(properties) {
            return new VStreamRowsResponse(properties);
        };

        /**
         * Encodes the specified VStreamRowsResponse message. Does not implicitly {@link binlogdata.VStreamRowsResponse.verify|verify} messages.
         * @function encode
         * @memberof binlogdata.VStreamRowsResponse
         * @static
         * @param {binlogdata.IVStreamRowsResponse} message VStreamRowsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VStreamRowsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fields != null && message.fields.length)
                for (var i = 0; i < message.fields.length; ++i)
                    $root.query.Field.encode(message.fields[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.pkfields != null && message.pkfields.length)
                for (var i = 0; i < message.pkfields.length; ++i)
                    $root.query.Field.encode(message.pkfields[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.gtid != null && Object.hasOwnProperty.call(message, "gtid"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.gtid);
            if (message.rows != null && message.rows.length)
                for (var i = 0; i < message.rows.length; ++i)
                    $root.query.Row.encode(message.rows[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.lastpk != null && Object.hasOwnProperty.call(message, "lastpk"))
                $root.query.Row.encode(message.lastpk, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified VStreamRowsResponse message, length delimited. Does not implicitly {@link binlogdata.VStreamRowsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof binlogdata.VStreamRowsResponse
         * @static
         * @param {binlogdata.IVStreamRowsResponse} message VStreamRowsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VStreamRowsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VStreamRowsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof binlogdata.VStreamRowsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {binlogdata.VStreamRowsResponse} VStreamRowsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VStreamRowsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.binlogdata.VStreamRowsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.fields && message.fields.length))
                        message.fields = [];
                    message.fields.push($root.query.Field.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.pkfields && message.pkfields.length))
                        message.pkfields = [];
                    message.pkfields.push($root.query.Field.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.gtid = reader.string();
                    break;
                case 4:
                    if (!(message.rows && message.rows.length))
                        message.rows = [];
                    message.rows.push($root.query.Row.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.lastpk = $root.query.Row.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VStreamRowsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof binlogdata.VStreamRowsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {binlogdata.VStreamRowsResponse} VStreamRowsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VStreamRowsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VStreamRowsResponse message.
         * @function verify
         * @memberof binlogdata.VStreamRowsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VStreamRowsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fields != null && message.hasOwnProperty("fields")) {
                if (!Array.isArray(message.fields))
                    return "fields: array expected";
                for (var i = 0; i < message.fields.length; ++i) {
                    var error = $root.query.Field.verify(message.fields[i]);
                    if (error)
                        return "fields." + error;
                }
            }
            if (message.pkfields != null && message.hasOwnProperty("pkfields")) {
                if (!Array.isArray(message.pkfields))
                    return "pkfields: array expected";
                for (var i = 0; i < message.pkfields.length; ++i) {
                    var error = $root.query.Field.verify(message.pkfields[i]);
                    if (error)
                        return "pkfields." + error;
                }
            }
            if (message.gtid != null && message.hasOwnProperty("gtid"))
                if (!$util.isString(message.gtid))
                    return "gtid: string expected";
            if (message.rows != null && message.hasOwnProperty("rows")) {
                if (!Array.isArray(message.rows))
                    return "rows: array expected";
                for (var i = 0; i < message.rows.length; ++i) {
                    var error = $root.query.Row.verify(message.rows[i]);
                    if (error)
                        return "rows." + error;
                }
            }
            if (message.lastpk != null && message.hasOwnProperty("lastpk")) {
                var error = $root.query.Row.verify(message.lastpk);
                if (error)
                    return "lastpk." + error;
            }
            return null;
        };

        /**
         * Creates a VStreamRowsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof binlogdata.VStreamRowsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {binlogdata.VStreamRowsResponse} VStreamRowsResponse
         */
        VStreamRowsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.binlogdata.VStreamRowsResponse)
                return object;
            var message = new $root.binlogdata.VStreamRowsResponse();
            if (object.fields) {
                if (!Array.isArray(object.fields))
                    throw TypeError(".binlogdata.VStreamRowsResponse.fields: array expected");
                message.fields = [];
                for (var i = 0; i < object.fields.length; ++i) {
                    if (typeof object.fields[i] !== "object")
                        throw TypeError(".binlogdata.VStreamRowsResponse.fields: object expected");
                    message.fields[i] = $root.query.Field.fromObject(object.fields[i]);
                }
            }
            if (object.pkfields) {
                if (!Array.isArray(object.pkfields))
                    throw TypeError(".binlogdata.VStreamRowsResponse.pkfields: array expected");
                message.pkfields = [];
                for (var i = 0; i < object.pkfields.length; ++i) {
                    if (typeof object.pkfields[i] !== "object")
                        throw TypeError(".binlogdata.VStreamRowsResponse.pkfields: object expected");
                    message.pkfields[i] = $root.query.Field.fromObject(object.pkfields[i]);
                }
            }
            if (object.gtid != null)
                message.gtid = String(object.gtid);
            if (object.rows) {
                if (!Array.isArray(object.rows))
                    throw TypeError(".binlogdata.VStreamRowsResponse.rows: array expected");
                message.rows = [];
                for (var i = 0; i < object.rows.length; ++i) {
                    if (typeof object.rows[i] !== "object")
                        throw TypeError(".binlogdata.VStreamRowsResponse.rows: object expected");
                    message.rows[i] = $root.query.Row.fromObject(object.rows[i]);
                }
            }
            if (object.lastpk != null) {
                if (typeof object.lastpk !== "object")
                    throw TypeError(".binlogdata.VStreamRowsResponse.lastpk: object expected");
                message.lastpk = $root.query.Row.fromObject(object.lastpk);
            }
            return message;
        };

        /**
         * Creates a plain object from a VStreamRowsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof binlogdata.VStreamRowsResponse
         * @static
         * @param {binlogdata.VStreamRowsResponse} message VStreamRowsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VStreamRowsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.fields = [];
                object.pkfields = [];
                object.rows = [];
            }
            if (options.defaults) {
                object.gtid = "";
                object.lastpk = null;
            }
            if (message.fields && message.fields.length) {
                object.fields = [];
                for (var j = 0; j < message.fields.length; ++j)
                    object.fields[j] = $root.query.Field.toObject(message.fields[j], options);
            }
            if (message.pkfields && message.pkfields.length) {
                object.pkfields = [];
                for (var j = 0; j < message.pkfields.length; ++j)
                    object.pkfields[j] = $root.query.Field.toObject(message.pkfields[j], options);
            }
            if (message.gtid != null && message.hasOwnProperty("gtid"))
                object.gtid = message.gtid;
            if (message.rows && message.rows.length) {
                object.rows = [];
                for (var j = 0; j < message.rows.length; ++j)
                    object.rows[j] = $root.query.Row.toObject(message.rows[j], options);
            }
            if (message.lastpk != null && message.hasOwnProperty("lastpk"))
                object.lastpk = $root.query.Row.toObject(message.lastpk, options);
            return object;
        };

        /**
         * Converts this VStreamRowsResponse to JSON.
         * @function toJSON
         * @memberof binlogdata.VStreamRowsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VStreamRowsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VStreamRowsResponse;
    })();

    binlogdata.LastPKEvent = (function() {

        /**
         * Properties of a LastPKEvent.
         * @memberof binlogdata
         * @interface ILastPKEvent
         * @property {binlogdata.ITableLastPK|null} [table_last_p_k] LastPKEvent table_last_p_k
         * @property {boolean|null} [completed] LastPKEvent completed
         */

        /**
         * Constructs a new LastPKEvent.
         * @memberof binlogdata
         * @classdesc Represents a LastPKEvent.
         * @implements ILastPKEvent
         * @constructor
         * @param {binlogdata.ILastPKEvent=} [properties] Properties to set
         */
        function LastPKEvent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LastPKEvent table_last_p_k.
         * @member {binlogdata.ITableLastPK|null|undefined} table_last_p_k
         * @memberof binlogdata.LastPKEvent
         * @instance
         */
        LastPKEvent.prototype.table_last_p_k = null;

        /**
         * LastPKEvent completed.
         * @member {boolean} completed
         * @memberof binlogdata.LastPKEvent
         * @instance
         */
        LastPKEvent.prototype.completed = false;

        /**
         * Creates a new LastPKEvent instance using the specified properties.
         * @function create
         * @memberof binlogdata.LastPKEvent
         * @static
         * @param {binlogdata.ILastPKEvent=} [properties] Properties to set
         * @returns {binlogdata.LastPKEvent} LastPKEvent instance
         */
        LastPKEvent.create = function create(properties) {
            return new LastPKEvent(properties);
        };

        /**
         * Encodes the specified LastPKEvent message. Does not implicitly {@link binlogdata.LastPKEvent.verify|verify} messages.
         * @function encode
         * @memberof binlogdata.LastPKEvent
         * @static
         * @param {binlogdata.ILastPKEvent} message LastPKEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LastPKEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.table_last_p_k != null && Object.hasOwnProperty.call(message, "table_last_p_k"))
                $root.binlogdata.TableLastPK.encode(message.table_last_p_k, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.completed != null && Object.hasOwnProperty.call(message, "completed"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.completed);
            return writer;
        };

        /**
         * Encodes the specified LastPKEvent message, length delimited. Does not implicitly {@link binlogdata.LastPKEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof binlogdata.LastPKEvent
         * @static
         * @param {binlogdata.ILastPKEvent} message LastPKEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LastPKEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LastPKEvent message from the specified reader or buffer.
         * @function decode
         * @memberof binlogdata.LastPKEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {binlogdata.LastPKEvent} LastPKEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LastPKEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.binlogdata.LastPKEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.table_last_p_k = $root.binlogdata.TableLastPK.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.completed = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LastPKEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof binlogdata.LastPKEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {binlogdata.LastPKEvent} LastPKEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LastPKEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LastPKEvent message.
         * @function verify
         * @memberof binlogdata.LastPKEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LastPKEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.table_last_p_k != null && message.hasOwnProperty("table_last_p_k")) {
                var error = $root.binlogdata.TableLastPK.verify(message.table_last_p_k);
                if (error)
                    return "table_last_p_k." + error;
            }
            if (message.completed != null && message.hasOwnProperty("completed"))
                if (typeof message.completed !== "boolean")
                    return "completed: boolean expected";
            return null;
        };

        /**
         * Creates a LastPKEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof binlogdata.LastPKEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {binlogdata.LastPKEvent} LastPKEvent
         */
        LastPKEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.binlogdata.LastPKEvent)
                return object;
            var message = new $root.binlogdata.LastPKEvent();
            if (object.table_last_p_k != null) {
                if (typeof object.table_last_p_k !== "object")
                    throw TypeError(".binlogdata.LastPKEvent.table_last_p_k: object expected");
                message.table_last_p_k = $root.binlogdata.TableLastPK.fromObject(object.table_last_p_k);
            }
            if (object.completed != null)
                message.completed = Boolean(object.completed);
            return message;
        };

        /**
         * Creates a plain object from a LastPKEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof binlogdata.LastPKEvent
         * @static
         * @param {binlogdata.LastPKEvent} message LastPKEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LastPKEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.table_last_p_k = null;
                object.completed = false;
            }
            if (message.table_last_p_k != null && message.hasOwnProperty("table_last_p_k"))
                object.table_last_p_k = $root.binlogdata.TableLastPK.toObject(message.table_last_p_k, options);
            if (message.completed != null && message.hasOwnProperty("completed"))
                object.completed = message.completed;
            return object;
        };

        /**
         * Converts this LastPKEvent to JSON.
         * @function toJSON
         * @memberof binlogdata.LastPKEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LastPKEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LastPKEvent;
    })();

    binlogdata.TableLastPK = (function() {

        /**
         * Properties of a TableLastPK.
         * @memberof binlogdata
         * @interface ITableLastPK
         * @property {string|null} [table_name] TableLastPK table_name
         * @property {query.IQueryResult|null} [lastpk] TableLastPK lastpk
         */

        /**
         * Constructs a new TableLastPK.
         * @memberof binlogdata
         * @classdesc Represents a TableLastPK.
         * @implements ITableLastPK
         * @constructor
         * @param {binlogdata.ITableLastPK=} [properties] Properties to set
         */
        function TableLastPK(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TableLastPK table_name.
         * @member {string} table_name
         * @memberof binlogdata.TableLastPK
         * @instance
         */
        TableLastPK.prototype.table_name = "";

        /**
         * TableLastPK lastpk.
         * @member {query.IQueryResult|null|undefined} lastpk
         * @memberof binlogdata.TableLastPK
         * @instance
         */
        TableLastPK.prototype.lastpk = null;

        /**
         * Creates a new TableLastPK instance using the specified properties.
         * @function create
         * @memberof binlogdata.TableLastPK
         * @static
         * @param {binlogdata.ITableLastPK=} [properties] Properties to set
         * @returns {binlogdata.TableLastPK} TableLastPK instance
         */
        TableLastPK.create = function create(properties) {
            return new TableLastPK(properties);
        };

        /**
         * Encodes the specified TableLastPK message. Does not implicitly {@link binlogdata.TableLastPK.verify|verify} messages.
         * @function encode
         * @memberof binlogdata.TableLastPK
         * @static
         * @param {binlogdata.ITableLastPK} message TableLastPK message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TableLastPK.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.table_name != null && Object.hasOwnProperty.call(message, "table_name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.table_name);
            if (message.lastpk != null && Object.hasOwnProperty.call(message, "lastpk"))
                $root.query.QueryResult.encode(message.lastpk, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TableLastPK message, length delimited. Does not implicitly {@link binlogdata.TableLastPK.verify|verify} messages.
         * @function encodeDelimited
         * @memberof binlogdata.TableLastPK
         * @static
         * @param {binlogdata.ITableLastPK} message TableLastPK message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TableLastPK.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TableLastPK message from the specified reader or buffer.
         * @function decode
         * @memberof binlogdata.TableLastPK
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {binlogdata.TableLastPK} TableLastPK
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TableLastPK.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.binlogdata.TableLastPK();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.table_name = reader.string();
                    break;
                case 3:
                    message.lastpk = $root.query.QueryResult.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TableLastPK message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof binlogdata.TableLastPK
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {binlogdata.TableLastPK} TableLastPK
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TableLastPK.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TableLastPK message.
         * @function verify
         * @memberof binlogdata.TableLastPK
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TableLastPK.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.table_name != null && message.hasOwnProperty("table_name"))
                if (!$util.isString(message.table_name))
                    return "table_name: string expected";
            if (message.lastpk != null && message.hasOwnProperty("lastpk")) {
                var error = $root.query.QueryResult.verify(message.lastpk);
                if (error)
                    return "lastpk." + error;
            }
            return null;
        };

        /**
         * Creates a TableLastPK message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof binlogdata.TableLastPK
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {binlogdata.TableLastPK} TableLastPK
         */
        TableLastPK.fromObject = function fromObject(object) {
            if (object instanceof $root.binlogdata.TableLastPK)
                return object;
            var message = new $root.binlogdata.TableLastPK();
            if (object.table_name != null)
                message.table_name = String(object.table_name);
            if (object.lastpk != null) {
                if (typeof object.lastpk !== "object")
                    throw TypeError(".binlogdata.TableLastPK.lastpk: object expected");
                message.lastpk = $root.query.QueryResult.fromObject(object.lastpk);
            }
            return message;
        };

        /**
         * Creates a plain object from a TableLastPK message. Also converts values to other types if specified.
         * @function toObject
         * @memberof binlogdata.TableLastPK
         * @static
         * @param {binlogdata.TableLastPK} message TableLastPK
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TableLastPK.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.table_name = "";
                object.lastpk = null;
            }
            if (message.table_name != null && message.hasOwnProperty("table_name"))
                object.table_name = message.table_name;
            if (message.lastpk != null && message.hasOwnProperty("lastpk"))
                object.lastpk = $root.query.QueryResult.toObject(message.lastpk, options);
            return object;
        };

        /**
         * Converts this TableLastPK to JSON.
         * @function toJSON
         * @memberof binlogdata.TableLastPK
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TableLastPK.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TableLastPK;
    })();

    binlogdata.VStreamResultsRequest = (function() {

        /**
         * Properties of a VStreamResultsRequest.
         * @memberof binlogdata
         * @interface IVStreamResultsRequest
         * @property {vtrpc.ICallerID|null} [effective_caller_id] VStreamResultsRequest effective_caller_id
         * @property {query.IVTGateCallerID|null} [immediate_caller_id] VStreamResultsRequest immediate_caller_id
         * @property {query.ITarget|null} [target] VStreamResultsRequest target
         * @property {string|null} [query] VStreamResultsRequest query
         */

        /**
         * Constructs a new VStreamResultsRequest.
         * @memberof binlogdata
         * @classdesc Represents a VStreamResultsRequest.
         * @implements IVStreamResultsRequest
         * @constructor
         * @param {binlogdata.IVStreamResultsRequest=} [properties] Properties to set
         */
        function VStreamResultsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VStreamResultsRequest effective_caller_id.
         * @member {vtrpc.ICallerID|null|undefined} effective_caller_id
         * @memberof binlogdata.VStreamResultsRequest
         * @instance
         */
        VStreamResultsRequest.prototype.effective_caller_id = null;

        /**
         * VStreamResultsRequest immediate_caller_id.
         * @member {query.IVTGateCallerID|null|undefined} immediate_caller_id
         * @memberof binlogdata.VStreamResultsRequest
         * @instance
         */
        VStreamResultsRequest.prototype.immediate_caller_id = null;

        /**
         * VStreamResultsRequest target.
         * @member {query.ITarget|null|undefined} target
         * @memberof binlogdata.VStreamResultsRequest
         * @instance
         */
        VStreamResultsRequest.prototype.target = null;

        /**
         * VStreamResultsRequest query.
         * @member {string} query
         * @memberof binlogdata.VStreamResultsRequest
         * @instance
         */
        VStreamResultsRequest.prototype.query = "";

        /**
         * Creates a new VStreamResultsRequest instance using the specified properties.
         * @function create
         * @memberof binlogdata.VStreamResultsRequest
         * @static
         * @param {binlogdata.IVStreamResultsRequest=} [properties] Properties to set
         * @returns {binlogdata.VStreamResultsRequest} VStreamResultsRequest instance
         */
        VStreamResultsRequest.create = function create(properties) {
            return new VStreamResultsRequest(properties);
        };

        /**
         * Encodes the specified VStreamResultsRequest message. Does not implicitly {@link binlogdata.VStreamResultsRequest.verify|verify} messages.
         * @function encode
         * @memberof binlogdata.VStreamResultsRequest
         * @static
         * @param {binlogdata.IVStreamResultsRequest} message VStreamResultsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VStreamResultsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.effective_caller_id != null && Object.hasOwnProperty.call(message, "effective_caller_id"))
                $root.vtrpc.CallerID.encode(message.effective_caller_id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.immediate_caller_id != null && Object.hasOwnProperty.call(message, "immediate_caller_id"))
                $root.query.VTGateCallerID.encode(message.immediate_caller_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                $root.query.Target.encode(message.target, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.query);
            return writer;
        };

        /**
         * Encodes the specified VStreamResultsRequest message, length delimited. Does not implicitly {@link binlogdata.VStreamResultsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof binlogdata.VStreamResultsRequest
         * @static
         * @param {binlogdata.IVStreamResultsRequest} message VStreamResultsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VStreamResultsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VStreamResultsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof binlogdata.VStreamResultsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {binlogdata.VStreamResultsRequest} VStreamResultsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VStreamResultsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.binlogdata.VStreamResultsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.effective_caller_id = $root.vtrpc.CallerID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.immediate_caller_id = $root.query.VTGateCallerID.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.target = $root.query.Target.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.query = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VStreamResultsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof binlogdata.VStreamResultsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {binlogdata.VStreamResultsRequest} VStreamResultsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VStreamResultsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VStreamResultsRequest message.
         * @function verify
         * @memberof binlogdata.VStreamResultsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VStreamResultsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id")) {
                var error = $root.vtrpc.CallerID.verify(message.effective_caller_id);
                if (error)
                    return "effective_caller_id." + error;
            }
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id")) {
                var error = $root.query.VTGateCallerID.verify(message.immediate_caller_id);
                if (error)
                    return "immediate_caller_id." + error;
            }
            if (message.target != null && message.hasOwnProperty("target")) {
                var error = $root.query.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.query != null && message.hasOwnProperty("query"))
                if (!$util.isString(message.query))
                    return "query: string expected";
            return null;
        };

        /**
         * Creates a VStreamResultsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof binlogdata.VStreamResultsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {binlogdata.VStreamResultsRequest} VStreamResultsRequest
         */
        VStreamResultsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.binlogdata.VStreamResultsRequest)
                return object;
            var message = new $root.binlogdata.VStreamResultsRequest();
            if (object.effective_caller_id != null) {
                if (typeof object.effective_caller_id !== "object")
                    throw TypeError(".binlogdata.VStreamResultsRequest.effective_caller_id: object expected");
                message.effective_caller_id = $root.vtrpc.CallerID.fromObject(object.effective_caller_id);
            }
            if (object.immediate_caller_id != null) {
                if (typeof object.immediate_caller_id !== "object")
                    throw TypeError(".binlogdata.VStreamResultsRequest.immediate_caller_id: object expected");
                message.immediate_caller_id = $root.query.VTGateCallerID.fromObject(object.immediate_caller_id);
            }
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".binlogdata.VStreamResultsRequest.target: object expected");
                message.target = $root.query.Target.fromObject(object.target);
            }
            if (object.query != null)
                message.query = String(object.query);
            return message;
        };

        /**
         * Creates a plain object from a VStreamResultsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof binlogdata.VStreamResultsRequest
         * @static
         * @param {binlogdata.VStreamResultsRequest} message VStreamResultsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VStreamResultsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.effective_caller_id = null;
                object.immediate_caller_id = null;
                object.target = null;
                object.query = "";
            }
            if (message.effective_caller_id != null && message.hasOwnProperty("effective_caller_id"))
                object.effective_caller_id = $root.vtrpc.CallerID.toObject(message.effective_caller_id, options);
            if (message.immediate_caller_id != null && message.hasOwnProperty("immediate_caller_id"))
                object.immediate_caller_id = $root.query.VTGateCallerID.toObject(message.immediate_caller_id, options);
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.query.Target.toObject(message.target, options);
            if (message.query != null && message.hasOwnProperty("query"))
                object.query = message.query;
            return object;
        };

        /**
         * Converts this VStreamResultsRequest to JSON.
         * @function toJSON
         * @memberof binlogdata.VStreamResultsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VStreamResultsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VStreamResultsRequest;
    })();

    binlogdata.VStreamResultsResponse = (function() {

        /**
         * Properties of a VStreamResultsResponse.
         * @memberof binlogdata
         * @interface IVStreamResultsResponse
         * @property {Array.<query.IField>|null} [fields] VStreamResultsResponse fields
         * @property {string|null} [gtid] VStreamResultsResponse gtid
         * @property {Array.<query.IRow>|null} [rows] VStreamResultsResponse rows
         */

        /**
         * Constructs a new VStreamResultsResponse.
         * @memberof binlogdata
         * @classdesc Represents a VStreamResultsResponse.
         * @implements IVStreamResultsResponse
         * @constructor
         * @param {binlogdata.IVStreamResultsResponse=} [properties] Properties to set
         */
        function VStreamResultsResponse(properties) {
            this.fields = [];
            this.rows = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VStreamResultsResponse fields.
         * @member {Array.<query.IField>} fields
         * @memberof binlogdata.VStreamResultsResponse
         * @instance
         */
        VStreamResultsResponse.prototype.fields = $util.emptyArray;

        /**
         * VStreamResultsResponse gtid.
         * @member {string} gtid
         * @memberof binlogdata.VStreamResultsResponse
         * @instance
         */
        VStreamResultsResponse.prototype.gtid = "";

        /**
         * VStreamResultsResponse rows.
         * @member {Array.<query.IRow>} rows
         * @memberof binlogdata.VStreamResultsResponse
         * @instance
         */
        VStreamResultsResponse.prototype.rows = $util.emptyArray;

        /**
         * Creates a new VStreamResultsResponse instance using the specified properties.
         * @function create
         * @memberof binlogdata.VStreamResultsResponse
         * @static
         * @param {binlogdata.IVStreamResultsResponse=} [properties] Properties to set
         * @returns {binlogdata.VStreamResultsResponse} VStreamResultsResponse instance
         */
        VStreamResultsResponse.create = function create(properties) {
            return new VStreamResultsResponse(properties);
        };

        /**
         * Encodes the specified VStreamResultsResponse message. Does not implicitly {@link binlogdata.VStreamResultsResponse.verify|verify} messages.
         * @function encode
         * @memberof binlogdata.VStreamResultsResponse
         * @static
         * @param {binlogdata.IVStreamResultsResponse} message VStreamResultsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VStreamResultsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fields != null && message.fields.length)
                for (var i = 0; i < message.fields.length; ++i)
                    $root.query.Field.encode(message.fields[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.gtid != null && Object.hasOwnProperty.call(message, "gtid"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.gtid);
            if (message.rows != null && message.rows.length)
                for (var i = 0; i < message.rows.length; ++i)
                    $root.query.Row.encode(message.rows[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified VStreamResultsResponse message, length delimited. Does not implicitly {@link binlogdata.VStreamResultsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof binlogdata.VStreamResultsResponse
         * @static
         * @param {binlogdata.IVStreamResultsResponse} message VStreamResultsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VStreamResultsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VStreamResultsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof binlogdata.VStreamResultsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {binlogdata.VStreamResultsResponse} VStreamResultsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VStreamResultsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.binlogdata.VStreamResultsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.fields && message.fields.length))
                        message.fields = [];
                    message.fields.push($root.query.Field.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.gtid = reader.string();
                    break;
                case 4:
                    if (!(message.rows && message.rows.length))
                        message.rows = [];
                    message.rows.push($root.query.Row.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VStreamResultsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof binlogdata.VStreamResultsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {binlogdata.VStreamResultsResponse} VStreamResultsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VStreamResultsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VStreamResultsResponse message.
         * @function verify
         * @memberof binlogdata.VStreamResultsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VStreamResultsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fields != null && message.hasOwnProperty("fields")) {
                if (!Array.isArray(message.fields))
                    return "fields: array expected";
                for (var i = 0; i < message.fields.length; ++i) {
                    var error = $root.query.Field.verify(message.fields[i]);
                    if (error)
                        return "fields." + error;
                }
            }
            if (message.gtid != null && message.hasOwnProperty("gtid"))
                if (!$util.isString(message.gtid))
                    return "gtid: string expected";
            if (message.rows != null && message.hasOwnProperty("rows")) {
                if (!Array.isArray(message.rows))
                    return "rows: array expected";
                for (var i = 0; i < message.rows.length; ++i) {
                    var error = $root.query.Row.verify(message.rows[i]);
                    if (error)
                        return "rows." + error;
                }
            }
            return null;
        };

        /**
         * Creates a VStreamResultsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof binlogdata.VStreamResultsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {binlogdata.VStreamResultsResponse} VStreamResultsResponse
         */
        VStreamResultsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.binlogdata.VStreamResultsResponse)
                return object;
            var message = new $root.binlogdata.VStreamResultsResponse();
            if (object.fields) {
                if (!Array.isArray(object.fields))
                    throw TypeError(".binlogdata.VStreamResultsResponse.fields: array expected");
                message.fields = [];
                for (var i = 0; i < object.fields.length; ++i) {
                    if (typeof object.fields[i] !== "object")
                        throw TypeError(".binlogdata.VStreamResultsResponse.fields: object expected");
                    message.fields[i] = $root.query.Field.fromObject(object.fields[i]);
                }
            }
            if (object.gtid != null)
                message.gtid = String(object.gtid);
            if (object.rows) {
                if (!Array.isArray(object.rows))
                    throw TypeError(".binlogdata.VStreamResultsResponse.rows: array expected");
                message.rows = [];
                for (var i = 0; i < object.rows.length; ++i) {
                    if (typeof object.rows[i] !== "object")
                        throw TypeError(".binlogdata.VStreamResultsResponse.rows: object expected");
                    message.rows[i] = $root.query.Row.fromObject(object.rows[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a VStreamResultsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof binlogdata.VStreamResultsResponse
         * @static
         * @param {binlogdata.VStreamResultsResponse} message VStreamResultsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VStreamResultsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.fields = [];
                object.rows = [];
            }
            if (options.defaults)
                object.gtid = "";
            if (message.fields && message.fields.length) {
                object.fields = [];
                for (var j = 0; j < message.fields.length; ++j)
                    object.fields[j] = $root.query.Field.toObject(message.fields[j], options);
            }
            if (message.gtid != null && message.hasOwnProperty("gtid"))
                object.gtid = message.gtid;
            if (message.rows && message.rows.length) {
                object.rows = [];
                for (var j = 0; j < message.rows.length; ++j)
                    object.rows[j] = $root.query.Row.toObject(message.rows[j], options);
            }
            return object;
        };

        /**
         * Converts this VStreamResultsResponse to JSON.
         * @function toJSON
         * @memberof binlogdata.VStreamResultsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VStreamResultsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VStreamResultsResponse;
    })();

    return binlogdata;
})();

$root.mysqlctl = (function() {

    /**
     * Namespace mysqlctl.
     * @exports mysqlctl
     * @namespace
     */
    var mysqlctl = {};

    mysqlctl.StartRequest = (function() {

        /**
         * Properties of a StartRequest.
         * @memberof mysqlctl
         * @interface IStartRequest
         * @property {Array.<string>|null} [mysqld_args] StartRequest mysqld_args
         */

        /**
         * Constructs a new StartRequest.
         * @memberof mysqlctl
         * @classdesc Represents a StartRequest.
         * @implements IStartRequest
         * @constructor
         * @param {mysqlctl.IStartRequest=} [properties] Properties to set
         */
        function StartRequest(properties) {
            this.mysqld_args = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StartRequest mysqld_args.
         * @member {Array.<string>} mysqld_args
         * @memberof mysqlctl.StartRequest
         * @instance
         */
        StartRequest.prototype.mysqld_args = $util.emptyArray;

        /**
         * Creates a new StartRequest instance using the specified properties.
         * @function create
         * @memberof mysqlctl.StartRequest
         * @static
         * @param {mysqlctl.IStartRequest=} [properties] Properties to set
         * @returns {mysqlctl.StartRequest} StartRequest instance
         */
        StartRequest.create = function create(properties) {
            return new StartRequest(properties);
        };

        /**
         * Encodes the specified StartRequest message. Does not implicitly {@link mysqlctl.StartRequest.verify|verify} messages.
         * @function encode
         * @memberof mysqlctl.StartRequest
         * @static
         * @param {mysqlctl.IStartRequest} message StartRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mysqld_args != null && message.mysqld_args.length)
                for (var i = 0; i < message.mysqld_args.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.mysqld_args[i]);
            return writer;
        };

        /**
         * Encodes the specified StartRequest message, length delimited. Does not implicitly {@link mysqlctl.StartRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mysqlctl.StartRequest
         * @static
         * @param {mysqlctl.IStartRequest} message StartRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StartRequest message from the specified reader or buffer.
         * @function decode
         * @memberof mysqlctl.StartRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mysqlctl.StartRequest} StartRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.mysqlctl.StartRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.mysqld_args && message.mysqld_args.length))
                        message.mysqld_args = [];
                    message.mysqld_args.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StartRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mysqlctl.StartRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mysqlctl.StartRequest} StartRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StartRequest message.
         * @function verify
         * @memberof mysqlctl.StartRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StartRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mysqld_args != null && message.hasOwnProperty("mysqld_args")) {
                if (!Array.isArray(message.mysqld_args))
                    return "mysqld_args: array expected";
                for (var i = 0; i < message.mysqld_args.length; ++i)
                    if (!$util.isString(message.mysqld_args[i]))
                        return "mysqld_args: string[] expected";
            }
            return null;
        };

        /**
         * Creates a StartRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mysqlctl.StartRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mysqlctl.StartRequest} StartRequest
         */
        StartRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.mysqlctl.StartRequest)
                return object;
            var message = new $root.mysqlctl.StartRequest();
            if (object.mysqld_args) {
                if (!Array.isArray(object.mysqld_args))
                    throw TypeError(".mysqlctl.StartRequest.mysqld_args: array expected");
                message.mysqld_args = [];
                for (var i = 0; i < object.mysqld_args.length; ++i)
                    message.mysqld_args[i] = String(object.mysqld_args[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a StartRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mysqlctl.StartRequest
         * @static
         * @param {mysqlctl.StartRequest} message StartRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StartRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.mysqld_args = [];
            if (message.mysqld_args && message.mysqld_args.length) {
                object.mysqld_args = [];
                for (var j = 0; j < message.mysqld_args.length; ++j)
                    object.mysqld_args[j] = message.mysqld_args[j];
            }
            return object;
        };

        /**
         * Converts this StartRequest to JSON.
         * @function toJSON
         * @memberof mysqlctl.StartRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StartRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StartRequest;
    })();

    mysqlctl.StartResponse = (function() {

        /**
         * Properties of a StartResponse.
         * @memberof mysqlctl
         * @interface IStartResponse
         */

        /**
         * Constructs a new StartResponse.
         * @memberof mysqlctl
         * @classdesc Represents a StartResponse.
         * @implements IStartResponse
         * @constructor
         * @param {mysqlctl.IStartResponse=} [properties] Properties to set
         */
        function StartResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new StartResponse instance using the specified properties.
         * @function create
         * @memberof mysqlctl.StartResponse
         * @static
         * @param {mysqlctl.IStartResponse=} [properties] Properties to set
         * @returns {mysqlctl.StartResponse} StartResponse instance
         */
        StartResponse.create = function create(properties) {
            return new StartResponse(properties);
        };

        /**
         * Encodes the specified StartResponse message. Does not implicitly {@link mysqlctl.StartResponse.verify|verify} messages.
         * @function encode
         * @memberof mysqlctl.StartResponse
         * @static
         * @param {mysqlctl.IStartResponse} message StartResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified StartResponse message, length delimited. Does not implicitly {@link mysqlctl.StartResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mysqlctl.StartResponse
         * @static
         * @param {mysqlctl.IStartResponse} message StartResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StartResponse message from the specified reader or buffer.
         * @function decode
         * @memberof mysqlctl.StartResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mysqlctl.StartResponse} StartResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.mysqlctl.StartResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StartResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mysqlctl.StartResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mysqlctl.StartResponse} StartResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StartResponse message.
         * @function verify
         * @memberof mysqlctl.StartResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StartResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a StartResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mysqlctl.StartResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mysqlctl.StartResponse} StartResponse
         */
        StartResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.mysqlctl.StartResponse)
                return object;
            return new $root.mysqlctl.StartResponse();
        };

        /**
         * Creates a plain object from a StartResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mysqlctl.StartResponse
         * @static
         * @param {mysqlctl.StartResponse} message StartResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StartResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this StartResponse to JSON.
         * @function toJSON
         * @memberof mysqlctl.StartResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StartResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StartResponse;
    })();

    mysqlctl.ShutdownRequest = (function() {

        /**
         * Properties of a ShutdownRequest.
         * @memberof mysqlctl
         * @interface IShutdownRequest
         * @property {boolean|null} [wait_for_mysqld] ShutdownRequest wait_for_mysqld
         */

        /**
         * Constructs a new ShutdownRequest.
         * @memberof mysqlctl
         * @classdesc Represents a ShutdownRequest.
         * @implements IShutdownRequest
         * @constructor
         * @param {mysqlctl.IShutdownRequest=} [properties] Properties to set
         */
        function ShutdownRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ShutdownRequest wait_for_mysqld.
         * @member {boolean} wait_for_mysqld
         * @memberof mysqlctl.ShutdownRequest
         * @instance
         */
        ShutdownRequest.prototype.wait_for_mysqld = false;

        /**
         * Creates a new ShutdownRequest instance using the specified properties.
         * @function create
         * @memberof mysqlctl.ShutdownRequest
         * @static
         * @param {mysqlctl.IShutdownRequest=} [properties] Properties to set
         * @returns {mysqlctl.ShutdownRequest} ShutdownRequest instance
         */
        ShutdownRequest.create = function create(properties) {
            return new ShutdownRequest(properties);
        };

        /**
         * Encodes the specified ShutdownRequest message. Does not implicitly {@link mysqlctl.ShutdownRequest.verify|verify} messages.
         * @function encode
         * @memberof mysqlctl.ShutdownRequest
         * @static
         * @param {mysqlctl.IShutdownRequest} message ShutdownRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShutdownRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.wait_for_mysqld != null && Object.hasOwnProperty.call(message, "wait_for_mysqld"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.wait_for_mysqld);
            return writer;
        };

        /**
         * Encodes the specified ShutdownRequest message, length delimited. Does not implicitly {@link mysqlctl.ShutdownRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mysqlctl.ShutdownRequest
         * @static
         * @param {mysqlctl.IShutdownRequest} message ShutdownRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShutdownRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ShutdownRequest message from the specified reader or buffer.
         * @function decode
         * @memberof mysqlctl.ShutdownRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mysqlctl.ShutdownRequest} ShutdownRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShutdownRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.mysqlctl.ShutdownRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.wait_for_mysqld = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ShutdownRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mysqlctl.ShutdownRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mysqlctl.ShutdownRequest} ShutdownRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShutdownRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ShutdownRequest message.
         * @function verify
         * @memberof mysqlctl.ShutdownRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ShutdownRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.wait_for_mysqld != null && message.hasOwnProperty("wait_for_mysqld"))
                if (typeof message.wait_for_mysqld !== "boolean")
                    return "wait_for_mysqld: boolean expected";
            return null;
        };

        /**
         * Creates a ShutdownRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mysqlctl.ShutdownRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mysqlctl.ShutdownRequest} ShutdownRequest
         */
        ShutdownRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.mysqlctl.ShutdownRequest)
                return object;
            var message = new $root.mysqlctl.ShutdownRequest();
            if (object.wait_for_mysqld != null)
                message.wait_for_mysqld = Boolean(object.wait_for_mysqld);
            return message;
        };

        /**
         * Creates a plain object from a ShutdownRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mysqlctl.ShutdownRequest
         * @static
         * @param {mysqlctl.ShutdownRequest} message ShutdownRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ShutdownRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.wait_for_mysqld = false;
            if (message.wait_for_mysqld != null && message.hasOwnProperty("wait_for_mysqld"))
                object.wait_for_mysqld = message.wait_for_mysqld;
            return object;
        };

        /**
         * Converts this ShutdownRequest to JSON.
         * @function toJSON
         * @memberof mysqlctl.ShutdownRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ShutdownRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ShutdownRequest;
    })();

    mysqlctl.ShutdownResponse = (function() {

        /**
         * Properties of a ShutdownResponse.
         * @memberof mysqlctl
         * @interface IShutdownResponse
         */

        /**
         * Constructs a new ShutdownResponse.
         * @memberof mysqlctl
         * @classdesc Represents a ShutdownResponse.
         * @implements IShutdownResponse
         * @constructor
         * @param {mysqlctl.IShutdownResponse=} [properties] Properties to set
         */
        function ShutdownResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ShutdownResponse instance using the specified properties.
         * @function create
         * @memberof mysqlctl.ShutdownResponse
         * @static
         * @param {mysqlctl.IShutdownResponse=} [properties] Properties to set
         * @returns {mysqlctl.ShutdownResponse} ShutdownResponse instance
         */
        ShutdownResponse.create = function create(properties) {
            return new ShutdownResponse(properties);
        };

        /**
         * Encodes the specified ShutdownResponse message. Does not implicitly {@link mysqlctl.ShutdownResponse.verify|verify} messages.
         * @function encode
         * @memberof mysqlctl.ShutdownResponse
         * @static
         * @param {mysqlctl.IShutdownResponse} message ShutdownResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShutdownResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ShutdownResponse message, length delimited. Does not implicitly {@link mysqlctl.ShutdownResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mysqlctl.ShutdownResponse
         * @static
         * @param {mysqlctl.IShutdownResponse} message ShutdownResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShutdownResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ShutdownResponse message from the specified reader or buffer.
         * @function decode
         * @memberof mysqlctl.ShutdownResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mysqlctl.ShutdownResponse} ShutdownResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShutdownResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.mysqlctl.ShutdownResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ShutdownResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mysqlctl.ShutdownResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mysqlctl.ShutdownResponse} ShutdownResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShutdownResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ShutdownResponse message.
         * @function verify
         * @memberof mysqlctl.ShutdownResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ShutdownResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ShutdownResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mysqlctl.ShutdownResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mysqlctl.ShutdownResponse} ShutdownResponse
         */
        ShutdownResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.mysqlctl.ShutdownResponse)
                return object;
            return new $root.mysqlctl.ShutdownResponse();
        };

        /**
         * Creates a plain object from a ShutdownResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mysqlctl.ShutdownResponse
         * @static
         * @param {mysqlctl.ShutdownResponse} message ShutdownResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ShutdownResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ShutdownResponse to JSON.
         * @function toJSON
         * @memberof mysqlctl.ShutdownResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ShutdownResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ShutdownResponse;
    })();

    mysqlctl.RunMysqlUpgradeRequest = (function() {

        /**
         * Properties of a RunMysqlUpgradeRequest.
         * @memberof mysqlctl
         * @interface IRunMysqlUpgradeRequest
         */

        /**
         * Constructs a new RunMysqlUpgradeRequest.
         * @memberof mysqlctl
         * @classdesc Represents a RunMysqlUpgradeRequest.
         * @implements IRunMysqlUpgradeRequest
         * @constructor
         * @param {mysqlctl.IRunMysqlUpgradeRequest=} [properties] Properties to set
         */
        function RunMysqlUpgradeRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new RunMysqlUpgradeRequest instance using the specified properties.
         * @function create
         * @memberof mysqlctl.RunMysqlUpgradeRequest
         * @static
         * @param {mysqlctl.IRunMysqlUpgradeRequest=} [properties] Properties to set
         * @returns {mysqlctl.RunMysqlUpgradeRequest} RunMysqlUpgradeRequest instance
         */
        RunMysqlUpgradeRequest.create = function create(properties) {
            return new RunMysqlUpgradeRequest(properties);
        };

        /**
         * Encodes the specified RunMysqlUpgradeRequest message. Does not implicitly {@link mysqlctl.RunMysqlUpgradeRequest.verify|verify} messages.
         * @function encode
         * @memberof mysqlctl.RunMysqlUpgradeRequest
         * @static
         * @param {mysqlctl.IRunMysqlUpgradeRequest} message RunMysqlUpgradeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RunMysqlUpgradeRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified RunMysqlUpgradeRequest message, length delimited. Does not implicitly {@link mysqlctl.RunMysqlUpgradeRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mysqlctl.RunMysqlUpgradeRequest
         * @static
         * @param {mysqlctl.IRunMysqlUpgradeRequest} message RunMysqlUpgradeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RunMysqlUpgradeRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RunMysqlUpgradeRequest message from the specified reader or buffer.
         * @function decode
         * @memberof mysqlctl.RunMysqlUpgradeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mysqlctl.RunMysqlUpgradeRequest} RunMysqlUpgradeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RunMysqlUpgradeRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.mysqlctl.RunMysqlUpgradeRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RunMysqlUpgradeRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mysqlctl.RunMysqlUpgradeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mysqlctl.RunMysqlUpgradeRequest} RunMysqlUpgradeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RunMysqlUpgradeRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RunMysqlUpgradeRequest message.
         * @function verify
         * @memberof mysqlctl.RunMysqlUpgradeRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RunMysqlUpgradeRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a RunMysqlUpgradeRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mysqlctl.RunMysqlUpgradeRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mysqlctl.RunMysqlUpgradeRequest} RunMysqlUpgradeRequest
         */
        RunMysqlUpgradeRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.mysqlctl.RunMysqlUpgradeRequest)
                return object;
            return new $root.mysqlctl.RunMysqlUpgradeRequest();
        };

        /**
         * Creates a plain object from a RunMysqlUpgradeRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mysqlctl.RunMysqlUpgradeRequest
         * @static
         * @param {mysqlctl.RunMysqlUpgradeRequest} message RunMysqlUpgradeRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RunMysqlUpgradeRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this RunMysqlUpgradeRequest to JSON.
         * @function toJSON
         * @memberof mysqlctl.RunMysqlUpgradeRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RunMysqlUpgradeRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RunMysqlUpgradeRequest;
    })();

    mysqlctl.RunMysqlUpgradeResponse = (function() {

        /**
         * Properties of a RunMysqlUpgradeResponse.
         * @memberof mysqlctl
         * @interface IRunMysqlUpgradeResponse
         */

        /**
         * Constructs a new RunMysqlUpgradeResponse.
         * @memberof mysqlctl
         * @classdesc Represents a RunMysqlUpgradeResponse.
         * @implements IRunMysqlUpgradeResponse
         * @constructor
         * @param {mysqlctl.IRunMysqlUpgradeResponse=} [properties] Properties to set
         */
        function RunMysqlUpgradeResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new RunMysqlUpgradeResponse instance using the specified properties.
         * @function create
         * @memberof mysqlctl.RunMysqlUpgradeResponse
         * @static
         * @param {mysqlctl.IRunMysqlUpgradeResponse=} [properties] Properties to set
         * @returns {mysqlctl.RunMysqlUpgradeResponse} RunMysqlUpgradeResponse instance
         */
        RunMysqlUpgradeResponse.create = function create(properties) {
            return new RunMysqlUpgradeResponse(properties);
        };

        /**
         * Encodes the specified RunMysqlUpgradeResponse message. Does not implicitly {@link mysqlctl.RunMysqlUpgradeResponse.verify|verify} messages.
         * @function encode
         * @memberof mysqlctl.RunMysqlUpgradeResponse
         * @static
         * @param {mysqlctl.IRunMysqlUpgradeResponse} message RunMysqlUpgradeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RunMysqlUpgradeResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified RunMysqlUpgradeResponse message, length delimited. Does not implicitly {@link mysqlctl.RunMysqlUpgradeResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mysqlctl.RunMysqlUpgradeResponse
         * @static
         * @param {mysqlctl.IRunMysqlUpgradeResponse} message RunMysqlUpgradeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RunMysqlUpgradeResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RunMysqlUpgradeResponse message from the specified reader or buffer.
         * @function decode
         * @memberof mysqlctl.RunMysqlUpgradeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mysqlctl.RunMysqlUpgradeResponse} RunMysqlUpgradeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RunMysqlUpgradeResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.mysqlctl.RunMysqlUpgradeResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RunMysqlUpgradeResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mysqlctl.RunMysqlUpgradeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mysqlctl.RunMysqlUpgradeResponse} RunMysqlUpgradeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RunMysqlUpgradeResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RunMysqlUpgradeResponse message.
         * @function verify
         * @memberof mysqlctl.RunMysqlUpgradeResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RunMysqlUpgradeResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a RunMysqlUpgradeResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mysqlctl.RunMysqlUpgradeResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mysqlctl.RunMysqlUpgradeResponse} RunMysqlUpgradeResponse
         */
        RunMysqlUpgradeResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.mysqlctl.RunMysqlUpgradeResponse)
                return object;
            return new $root.mysqlctl.RunMysqlUpgradeResponse();
        };

        /**
         * Creates a plain object from a RunMysqlUpgradeResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mysqlctl.RunMysqlUpgradeResponse
         * @static
         * @param {mysqlctl.RunMysqlUpgradeResponse} message RunMysqlUpgradeResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RunMysqlUpgradeResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this RunMysqlUpgradeResponse to JSON.
         * @function toJSON
         * @memberof mysqlctl.RunMysqlUpgradeResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RunMysqlUpgradeResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RunMysqlUpgradeResponse;
    })();

    mysqlctl.ReinitConfigRequest = (function() {

        /**
         * Properties of a ReinitConfigRequest.
         * @memberof mysqlctl
         * @interface IReinitConfigRequest
         */

        /**
         * Constructs a new ReinitConfigRequest.
         * @memberof mysqlctl
         * @classdesc Represents a ReinitConfigRequest.
         * @implements IReinitConfigRequest
         * @constructor
         * @param {mysqlctl.IReinitConfigRequest=} [properties] Properties to set
         */
        function ReinitConfigRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ReinitConfigRequest instance using the specified properties.
         * @function create
         * @memberof mysqlctl.ReinitConfigRequest
         * @static
         * @param {mysqlctl.IReinitConfigRequest=} [properties] Properties to set
         * @returns {mysqlctl.ReinitConfigRequest} ReinitConfigRequest instance
         */
        ReinitConfigRequest.create = function create(properties) {
            return new ReinitConfigRequest(properties);
        };

        /**
         * Encodes the specified ReinitConfigRequest message. Does not implicitly {@link mysqlctl.ReinitConfigRequest.verify|verify} messages.
         * @function encode
         * @memberof mysqlctl.ReinitConfigRequest
         * @static
         * @param {mysqlctl.IReinitConfigRequest} message ReinitConfigRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReinitConfigRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ReinitConfigRequest message, length delimited. Does not implicitly {@link mysqlctl.ReinitConfigRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mysqlctl.ReinitConfigRequest
         * @static
         * @param {mysqlctl.IReinitConfigRequest} message ReinitConfigRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReinitConfigRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReinitConfigRequest message from the specified reader or buffer.
         * @function decode
         * @memberof mysqlctl.ReinitConfigRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mysqlctl.ReinitConfigRequest} ReinitConfigRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReinitConfigRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.mysqlctl.ReinitConfigRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReinitConfigRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mysqlctl.ReinitConfigRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mysqlctl.ReinitConfigRequest} ReinitConfigRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReinitConfigRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReinitConfigRequest message.
         * @function verify
         * @memberof mysqlctl.ReinitConfigRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReinitConfigRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ReinitConfigRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mysqlctl.ReinitConfigRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mysqlctl.ReinitConfigRequest} ReinitConfigRequest
         */
        ReinitConfigRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.mysqlctl.ReinitConfigRequest)
                return object;
            return new $root.mysqlctl.ReinitConfigRequest();
        };

        /**
         * Creates a plain object from a ReinitConfigRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mysqlctl.ReinitConfigRequest
         * @static
         * @param {mysqlctl.ReinitConfigRequest} message ReinitConfigRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReinitConfigRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ReinitConfigRequest to JSON.
         * @function toJSON
         * @memberof mysqlctl.ReinitConfigRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReinitConfigRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ReinitConfigRequest;
    })();

    mysqlctl.ReinitConfigResponse = (function() {

        /**
         * Properties of a ReinitConfigResponse.
         * @memberof mysqlctl
         * @interface IReinitConfigResponse
         */

        /**
         * Constructs a new ReinitConfigResponse.
         * @memberof mysqlctl
         * @classdesc Represents a ReinitConfigResponse.
         * @implements IReinitConfigResponse
         * @constructor
         * @param {mysqlctl.IReinitConfigResponse=} [properties] Properties to set
         */
        function ReinitConfigResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ReinitConfigResponse instance using the specified properties.
         * @function create
         * @memberof mysqlctl.ReinitConfigResponse
         * @static
         * @param {mysqlctl.IReinitConfigResponse=} [properties] Properties to set
         * @returns {mysqlctl.ReinitConfigResponse} ReinitConfigResponse instance
         */
        ReinitConfigResponse.create = function create(properties) {
            return new ReinitConfigResponse(properties);
        };

        /**
         * Encodes the specified ReinitConfigResponse message. Does not implicitly {@link mysqlctl.ReinitConfigResponse.verify|verify} messages.
         * @function encode
         * @memberof mysqlctl.ReinitConfigResponse
         * @static
         * @param {mysqlctl.IReinitConfigResponse} message ReinitConfigResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReinitConfigResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ReinitConfigResponse message, length delimited. Does not implicitly {@link mysqlctl.ReinitConfigResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mysqlctl.ReinitConfigResponse
         * @static
         * @param {mysqlctl.IReinitConfigResponse} message ReinitConfigResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReinitConfigResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReinitConfigResponse message from the specified reader or buffer.
         * @function decode
         * @memberof mysqlctl.ReinitConfigResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mysqlctl.ReinitConfigResponse} ReinitConfigResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReinitConfigResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.mysqlctl.ReinitConfigResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReinitConfigResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mysqlctl.ReinitConfigResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mysqlctl.ReinitConfigResponse} ReinitConfigResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReinitConfigResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReinitConfigResponse message.
         * @function verify
         * @memberof mysqlctl.ReinitConfigResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReinitConfigResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ReinitConfigResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mysqlctl.ReinitConfigResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mysqlctl.ReinitConfigResponse} ReinitConfigResponse
         */
        ReinitConfigResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.mysqlctl.ReinitConfigResponse)
                return object;
            return new $root.mysqlctl.ReinitConfigResponse();
        };

        /**
         * Creates a plain object from a ReinitConfigResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mysqlctl.ReinitConfigResponse
         * @static
         * @param {mysqlctl.ReinitConfigResponse} message ReinitConfigResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReinitConfigResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ReinitConfigResponse to JSON.
         * @function toJSON
         * @memberof mysqlctl.ReinitConfigResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReinitConfigResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ReinitConfigResponse;
    })();

    mysqlctl.RefreshConfigRequest = (function() {

        /**
         * Properties of a RefreshConfigRequest.
         * @memberof mysqlctl
         * @interface IRefreshConfigRequest
         */

        /**
         * Constructs a new RefreshConfigRequest.
         * @memberof mysqlctl
         * @classdesc Represents a RefreshConfigRequest.
         * @implements IRefreshConfigRequest
         * @constructor
         * @param {mysqlctl.IRefreshConfigRequest=} [properties] Properties to set
         */
        function RefreshConfigRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new RefreshConfigRequest instance using the specified properties.
         * @function create
         * @memberof mysqlctl.RefreshConfigRequest
         * @static
         * @param {mysqlctl.IRefreshConfigRequest=} [properties] Properties to set
         * @returns {mysqlctl.RefreshConfigRequest} RefreshConfigRequest instance
         */
        RefreshConfigRequest.create = function create(properties) {
            return new RefreshConfigRequest(properties);
        };

        /**
         * Encodes the specified RefreshConfigRequest message. Does not implicitly {@link mysqlctl.RefreshConfigRequest.verify|verify} messages.
         * @function encode
         * @memberof mysqlctl.RefreshConfigRequest
         * @static
         * @param {mysqlctl.IRefreshConfigRequest} message RefreshConfigRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RefreshConfigRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified RefreshConfigRequest message, length delimited. Does not implicitly {@link mysqlctl.RefreshConfigRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mysqlctl.RefreshConfigRequest
         * @static
         * @param {mysqlctl.IRefreshConfigRequest} message RefreshConfigRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RefreshConfigRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RefreshConfigRequest message from the specified reader or buffer.
         * @function decode
         * @memberof mysqlctl.RefreshConfigRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mysqlctl.RefreshConfigRequest} RefreshConfigRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RefreshConfigRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.mysqlctl.RefreshConfigRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RefreshConfigRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mysqlctl.RefreshConfigRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mysqlctl.RefreshConfigRequest} RefreshConfigRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RefreshConfigRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RefreshConfigRequest message.
         * @function verify
         * @memberof mysqlctl.RefreshConfigRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RefreshConfigRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a RefreshConfigRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mysqlctl.RefreshConfigRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mysqlctl.RefreshConfigRequest} RefreshConfigRequest
         */
        RefreshConfigRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.mysqlctl.RefreshConfigRequest)
                return object;
            return new $root.mysqlctl.RefreshConfigRequest();
        };

        /**
         * Creates a plain object from a RefreshConfigRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mysqlctl.RefreshConfigRequest
         * @static
         * @param {mysqlctl.RefreshConfigRequest} message RefreshConfigRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RefreshConfigRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this RefreshConfigRequest to JSON.
         * @function toJSON
         * @memberof mysqlctl.RefreshConfigRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RefreshConfigRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RefreshConfigRequest;
    })();

    mysqlctl.RefreshConfigResponse = (function() {

        /**
         * Properties of a RefreshConfigResponse.
         * @memberof mysqlctl
         * @interface IRefreshConfigResponse
         */

        /**
         * Constructs a new RefreshConfigResponse.
         * @memberof mysqlctl
         * @classdesc Represents a RefreshConfigResponse.
         * @implements IRefreshConfigResponse
         * @constructor
         * @param {mysqlctl.IRefreshConfigResponse=} [properties] Properties to set
         */
        function RefreshConfigResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new RefreshConfigResponse instance using the specified properties.
         * @function create
         * @memberof mysqlctl.RefreshConfigResponse
         * @static
         * @param {mysqlctl.IRefreshConfigResponse=} [properties] Properties to set
         * @returns {mysqlctl.RefreshConfigResponse} RefreshConfigResponse instance
         */
        RefreshConfigResponse.create = function create(properties) {
            return new RefreshConfigResponse(properties);
        };

        /**
         * Encodes the specified RefreshConfigResponse message. Does not implicitly {@link mysqlctl.RefreshConfigResponse.verify|verify} messages.
         * @function encode
         * @memberof mysqlctl.RefreshConfigResponse
         * @static
         * @param {mysqlctl.IRefreshConfigResponse} message RefreshConfigResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RefreshConfigResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified RefreshConfigResponse message, length delimited. Does not implicitly {@link mysqlctl.RefreshConfigResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mysqlctl.RefreshConfigResponse
         * @static
         * @param {mysqlctl.IRefreshConfigResponse} message RefreshConfigResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RefreshConfigResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RefreshConfigResponse message from the specified reader or buffer.
         * @function decode
         * @memberof mysqlctl.RefreshConfigResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mysqlctl.RefreshConfigResponse} RefreshConfigResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RefreshConfigResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.mysqlctl.RefreshConfigResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RefreshConfigResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mysqlctl.RefreshConfigResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mysqlctl.RefreshConfigResponse} RefreshConfigResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RefreshConfigResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RefreshConfigResponse message.
         * @function verify
         * @memberof mysqlctl.RefreshConfigResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RefreshConfigResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a RefreshConfigResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mysqlctl.RefreshConfigResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mysqlctl.RefreshConfigResponse} RefreshConfigResponse
         */
        RefreshConfigResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.mysqlctl.RefreshConfigResponse)
                return object;
            return new $root.mysqlctl.RefreshConfigResponse();
        };

        /**
         * Creates a plain object from a RefreshConfigResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mysqlctl.RefreshConfigResponse
         * @static
         * @param {mysqlctl.RefreshConfigResponse} message RefreshConfigResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RefreshConfigResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this RefreshConfigResponse to JSON.
         * @function toJSON
         * @memberof mysqlctl.RefreshConfigResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RefreshConfigResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RefreshConfigResponse;
    })();

    mysqlctl.MysqlCtl = (function() {

        /**
         * Constructs a new MysqlCtl service.
         * @memberof mysqlctl
         * @classdesc Represents a MysqlCtl
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function MysqlCtl(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (MysqlCtl.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = MysqlCtl;

        /**
         * Creates new MysqlCtl service using the specified rpc implementation.
         * @function create
         * @memberof mysqlctl.MysqlCtl
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {MysqlCtl} RPC service. Useful where requests and/or responses are streamed.
         */
        MysqlCtl.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link mysqlctl.MysqlCtl#start}.
         * @memberof mysqlctl.MysqlCtl
         * @typedef StartCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {mysqlctl.StartResponse} [response] StartResponse
         */

        /**
         * Calls Start.
         * @function start
         * @memberof mysqlctl.MysqlCtl
         * @instance
         * @param {mysqlctl.IStartRequest} request StartRequest message or plain object
         * @param {mysqlctl.MysqlCtl.StartCallback} callback Node-style callback called with the error, if any, and StartResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MysqlCtl.prototype.start = function start(request, callback) {
            return this.rpcCall(start, $root.mysqlctl.StartRequest, $root.mysqlctl.StartResponse, request, callback);
        }, "name", { value: "Start" });

        /**
         * Calls Start.
         * @function start
         * @memberof mysqlctl.MysqlCtl
         * @instance
         * @param {mysqlctl.IStartRequest} request StartRequest message or plain object
         * @returns {Promise<mysqlctl.StartResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link mysqlctl.MysqlCtl#shutdown}.
         * @memberof mysqlctl.MysqlCtl
         * @typedef ShutdownCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {mysqlctl.ShutdownResponse} [response] ShutdownResponse
         */

        /**
         * Calls Shutdown.
         * @function shutdown
         * @memberof mysqlctl.MysqlCtl
         * @instance
         * @param {mysqlctl.IShutdownRequest} request ShutdownRequest message or plain object
         * @param {mysqlctl.MysqlCtl.ShutdownCallback} callback Node-style callback called with the error, if any, and ShutdownResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MysqlCtl.prototype.shutdown = function shutdown(request, callback) {
            return this.rpcCall(shutdown, $root.mysqlctl.ShutdownRequest, $root.mysqlctl.ShutdownResponse, request, callback);
        }, "name", { value: "Shutdown" });

        /**
         * Calls Shutdown.
         * @function shutdown
         * @memberof mysqlctl.MysqlCtl
         * @instance
         * @param {mysqlctl.IShutdownRequest} request ShutdownRequest message or plain object
         * @returns {Promise<mysqlctl.ShutdownResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link mysqlctl.MysqlCtl#runMysqlUpgrade}.
         * @memberof mysqlctl.MysqlCtl
         * @typedef RunMysqlUpgradeCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {mysqlctl.RunMysqlUpgradeResponse} [response] RunMysqlUpgradeResponse
         */

        /**
         * Calls RunMysqlUpgrade.
         * @function runMysqlUpgrade
         * @memberof mysqlctl.MysqlCtl
         * @instance
         * @param {mysqlctl.IRunMysqlUpgradeRequest} request RunMysqlUpgradeRequest message or plain object
         * @param {mysqlctl.MysqlCtl.RunMysqlUpgradeCallback} callback Node-style callback called with the error, if any, and RunMysqlUpgradeResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MysqlCtl.prototype.runMysqlUpgrade = function runMysqlUpgrade(request, callback) {
            return this.rpcCall(runMysqlUpgrade, $root.mysqlctl.RunMysqlUpgradeRequest, $root.mysqlctl.RunMysqlUpgradeResponse, request, callback);
        }, "name", { value: "RunMysqlUpgrade" });

        /**
         * Calls RunMysqlUpgrade.
         * @function runMysqlUpgrade
         * @memberof mysqlctl.MysqlCtl
         * @instance
         * @param {mysqlctl.IRunMysqlUpgradeRequest} request RunMysqlUpgradeRequest message or plain object
         * @returns {Promise<mysqlctl.RunMysqlUpgradeResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link mysqlctl.MysqlCtl#reinitConfig}.
         * @memberof mysqlctl.MysqlCtl
         * @typedef ReinitConfigCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {mysqlctl.ReinitConfigResponse} [response] ReinitConfigResponse
         */

        /**
         * Calls ReinitConfig.
         * @function reinitConfig
         * @memberof mysqlctl.MysqlCtl
         * @instance
         * @param {mysqlctl.IReinitConfigRequest} request ReinitConfigRequest message or plain object
         * @param {mysqlctl.MysqlCtl.ReinitConfigCallback} callback Node-style callback called with the error, if any, and ReinitConfigResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MysqlCtl.prototype.reinitConfig = function reinitConfig(request, callback) {
            return this.rpcCall(reinitConfig, $root.mysqlctl.ReinitConfigRequest, $root.mysqlctl.ReinitConfigResponse, request, callback);
        }, "name", { value: "ReinitConfig" });

        /**
         * Calls ReinitConfig.
         * @function reinitConfig
         * @memberof mysqlctl.MysqlCtl
         * @instance
         * @param {mysqlctl.IReinitConfigRequest} request ReinitConfigRequest message or plain object
         * @returns {Promise<mysqlctl.ReinitConfigResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link mysqlctl.MysqlCtl#refreshConfig}.
         * @memberof mysqlctl.MysqlCtl
         * @typedef RefreshConfigCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {mysqlctl.RefreshConfigResponse} [response] RefreshConfigResponse
         */

        /**
         * Calls RefreshConfig.
         * @function refreshConfig
         * @memberof mysqlctl.MysqlCtl
         * @instance
         * @param {mysqlctl.IRefreshConfigRequest} request RefreshConfigRequest message or plain object
         * @param {mysqlctl.MysqlCtl.RefreshConfigCallback} callback Node-style callback called with the error, if any, and RefreshConfigResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MysqlCtl.prototype.refreshConfig = function refreshConfig(request, callback) {
            return this.rpcCall(refreshConfig, $root.mysqlctl.RefreshConfigRequest, $root.mysqlctl.RefreshConfigResponse, request, callback);
        }, "name", { value: "RefreshConfig" });

        /**
         * Calls RefreshConfig.
         * @function refreshConfig
         * @memberof mysqlctl.MysqlCtl
         * @instance
         * @param {mysqlctl.IRefreshConfigRequest} request RefreshConfigRequest message or plain object
         * @returns {Promise<mysqlctl.RefreshConfigResponse>} Promise
         * @variation 2
         */

        return MysqlCtl;
    })();

    mysqlctl.BackupInfo = (function() {

        /**
         * Properties of a BackupInfo.
         * @memberof mysqlctl
         * @interface IBackupInfo
         * @property {string|null} [name] BackupInfo name
         * @property {string|null} [directory] BackupInfo directory
         */

        /**
         * Constructs a new BackupInfo.
         * @memberof mysqlctl
         * @classdesc Represents a BackupInfo.
         * @implements IBackupInfo
         * @constructor
         * @param {mysqlctl.IBackupInfo=} [properties] Properties to set
         */
        function BackupInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BackupInfo name.
         * @member {string} name
         * @memberof mysqlctl.BackupInfo
         * @instance
         */
        BackupInfo.prototype.name = "";

        /**
         * BackupInfo directory.
         * @member {string} directory
         * @memberof mysqlctl.BackupInfo
         * @instance
         */
        BackupInfo.prototype.directory = "";

        /**
         * Creates a new BackupInfo instance using the specified properties.
         * @function create
         * @memberof mysqlctl.BackupInfo
         * @static
         * @param {mysqlctl.IBackupInfo=} [properties] Properties to set
         * @returns {mysqlctl.BackupInfo} BackupInfo instance
         */
        BackupInfo.create = function create(properties) {
            return new BackupInfo(properties);
        };

        /**
         * Encodes the specified BackupInfo message. Does not implicitly {@link mysqlctl.BackupInfo.verify|verify} messages.
         * @function encode
         * @memberof mysqlctl.BackupInfo
         * @static
         * @param {mysqlctl.IBackupInfo} message BackupInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BackupInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.directory != null && Object.hasOwnProperty.call(message, "directory"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.directory);
            return writer;
        };

        /**
         * Encodes the specified BackupInfo message, length delimited. Does not implicitly {@link mysqlctl.BackupInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mysqlctl.BackupInfo
         * @static
         * @param {mysqlctl.IBackupInfo} message BackupInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BackupInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BackupInfo message from the specified reader or buffer.
         * @function decode
         * @memberof mysqlctl.BackupInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mysqlctl.BackupInfo} BackupInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BackupInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.mysqlctl.BackupInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.directory = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BackupInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mysqlctl.BackupInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mysqlctl.BackupInfo} BackupInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BackupInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BackupInfo message.
         * @function verify
         * @memberof mysqlctl.BackupInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BackupInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.directory != null && message.hasOwnProperty("directory"))
                if (!$util.isString(message.directory))
                    return "directory: string expected";
            return null;
        };

        /**
         * Creates a BackupInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mysqlctl.BackupInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mysqlctl.BackupInfo} BackupInfo
         */
        BackupInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.mysqlctl.BackupInfo)
                return object;
            var message = new $root.mysqlctl.BackupInfo();
            if (object.name != null)
                message.name = String(object.name);
            if (object.directory != null)
                message.directory = String(object.directory);
            return message;
        };

        /**
         * Creates a plain object from a BackupInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mysqlctl.BackupInfo
         * @static
         * @param {mysqlctl.BackupInfo} message BackupInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BackupInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.directory = "";
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.directory != null && message.hasOwnProperty("directory"))
                object.directory = message.directory;
            return object;
        };

        /**
         * Converts this BackupInfo to JSON.
         * @function toJSON
         * @memberof mysqlctl.BackupInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BackupInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BackupInfo;
    })();

    return mysqlctl;
})();

module.exports = $root;
