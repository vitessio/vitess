\section{Resharding}\hypertarget{resharding}{}\label{resharding}

In Vitess, resharding describes the process of re-organizing data dynamically, with very minimal downtime (we manage to
completely perform most data transitions with less than 5 seconds of read-only downtime - new data cannot be written,
existing data can still be read).

\subsection{Process}\hypertarget{process}{}\label{process}

The process to achieve this goal is composed of the following steps:

\begin{itemize}
\item pick the original shard(s)
\item pick the destination shard(s) coverage
\item create the destination shard(s) tablets (in a mode where they are not used to serve traffic yet)
\item bring up the destination shard(s) tablets, with read-only masters.
\item backup and split the data from the original shard(s)
\item merge and import the data on the destination shard(s)
\item start and run filtered replication from original to destination shard(s), catch up
\item move the read-only traffic to the destination shard(s), stop serving read-only traffic from original shard(s). This transition can take a few hours. We might want to move rdonly separately from replica traffic.
\item in quick succession:
   \begin{itemize}
   \item make original master(s) read-only
   \item flush filtered replication on all filtered replication source servers (after making sure they were caught up with their masters)
   \item wait until replication is caught up on all destination shard(s) masters
   \item move the write traffic to the destination shard(s)
   \item make destination master(s) read-write
   \end{itemize}
\item scrap the original shard(s)
\end{itemize}


\subsection{Applications}\hypertarget{applications}{}\label{applications}

The main application we currently support:


\begin{itemize}
\item in a sharded keyspace, split or merge shards (horizontal sharding)
\item in a non-sharded keyspace, break out some tables into a different keyspace (vertical sharding)
\end{itemize}

With these supported features, it is very easy to start with a single keyspace containing all the data (multiple tables),
and then as the data grows, move tables to different keyspaces, start sharding some keyspaces, ... without any real
downtime for the application.

\subsection{Scaling Up and Down}\hypertarget{scaling-up-and-down}{}\label{scaling-up-and-down}

Here is a quick table of what to do with Vitess when a change is required:

\begin{itemize}
\item uniformly increase read capacity: add replicas, or split shards
\item uniformly increase write capacity: split shards
\item reclaim free space: merge shards / keyspaces
\item increase geo-diversity: add new cells and new replicas
\item cool a hot tablet: if read access, add replicas or split shards, if write access, split shards.
\end{itemize}

\subsection{Filtered Replication}\hypertarget{filtered-replication}{}\label{filtered-replication}

The cornerstone of Resharding is being able to replicate the right data. Mysql doesn't support any filtering, so the
Vitess project implements it entirely:
\begin{itemize}
\item the tablet server tags transactions with comments that describe what the scope of the statements are (which keyspace\_id,
\item which table, ...). That way the MySQL binlogs contain all filtering data.
\item a server process can filter and stream the MySQL binlogs (using the comments).
\item a client process can apply the filtered logs locally (they are just regular SQL statements at this point).
\end{itemize}
