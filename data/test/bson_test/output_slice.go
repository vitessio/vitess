// Copyright 2012, Google Inc. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package mytype

import (
	"github.com/youtube/vitess/go/bytes2"

	"bytes"

	"github.com/youtube/vitess/go/bson"
)

// DO NOT EDIT.
// FILE GENERATED BY BSONGEN.

// MarshalBson bson-encodes MyType.
func (myType *MyType) MarshalBson(buf *bytes2.ChunkedWriter, key string) {
	bson.EncodeOptionalPrefix(buf, bson.Object, key)
	lenWriter := bson.NewLenWriter(buf)

	// []string
	{
		bson.EncodePrefix(buf, bson.Array, "Slice")
		lenWriter := bson.NewLenWriter(buf)
		for _i, _v1 := range myType.Slice {
			bson.EncodeString(buf, bson.Itoa(_i), _v1)
		}
		lenWriter.Close()
	}
	// [][]byte
	{
		bson.EncodePrefix(buf, bson.Array, "SliceBytes")
		lenWriter := bson.NewLenWriter(buf)
		for _i, _v2 := range myType.SliceBytes {
			bson.EncodeBinary(buf, bson.Itoa(_i), _v2)
		}
		lenWriter.Close()
	}
	// []*string
	{
		bson.EncodePrefix(buf, bson.Array, "SlicePtr")
		lenWriter := bson.NewLenWriter(buf)
		for _i, _v3 := range myType.SlicePtr {
			// *string
			if _v3 == nil {
				bson.EncodePrefix(buf, bson.Null, bson.Itoa(_i))
			} else {
				bson.EncodeString(buf, bson.Itoa(_i), (*_v3))
			}
		}
		lenWriter.Close()
	}
	// [][]string
	{
		bson.EncodePrefix(buf, bson.Array, "SliceSlice")
		lenWriter := bson.NewLenWriter(buf)
		for _i, _v4 := range myType.SliceSlice {
			// []string
			{
				bson.EncodePrefix(buf, bson.Array, bson.Itoa(_i))
				lenWriter := bson.NewLenWriter(buf)
				for _i, _v5 := range _v4 {
					bson.EncodeString(buf, bson.Itoa(_i), _v5)
				}
				lenWriter.Close()
			}
		}
		lenWriter.Close()
	}
	// []map[string]int64
	{
		bson.EncodePrefix(buf, bson.Array, "SliceMap")
		lenWriter := bson.NewLenWriter(buf)
		for _i, _v6 := range myType.SliceMap {
			// map[string]int64
			{
				bson.EncodePrefix(buf, bson.Object, bson.Itoa(_i))
				lenWriter := bson.NewLenWriter(buf)
				for _k, _v7 := range _v6 {
					bson.EncodeInt64(buf, _k, _v7)
				}
				lenWriter.Close()
			}
		}
		lenWriter.Close()
	}
	// []Custom
	{
		bson.EncodePrefix(buf, bson.Array, "SliceCustom")
		lenWriter := bson.NewLenWriter(buf)
		for _i, _v8 := range myType.SliceCustom {
			_v8.MarshalBson(buf, bson.Itoa(_i))
		}
		lenWriter.Close()
	}

	lenWriter.Close()
}

// UnmarshalBson bson-decodes into MyType.
func (myType *MyType) UnmarshalBson(buf *bytes.Buffer, kind byte) {
	switch kind {
	case bson.EOO, bson.Object:
		// valid
	case bson.Null:
		return
	default:
		panic(bson.NewBsonError("unexpected kind %v for MyType", kind))
	}
	bson.Next(buf, 4)

	for kind := bson.NextByte(buf); kind != bson.EOO; kind = bson.NextByte(buf) {
		switch bson.ReadCString(buf) {
		case "Slice":
			// []string
			if kind != bson.Null {
				if kind != bson.Array {
					panic(bson.NewBsonError("unexpected kind %v for myType.Slice", kind))
				}
				bson.Next(buf, 4)
				myType.Slice = make([]string, 0, 8)
				for kind := bson.NextByte(buf); kind != bson.EOO; kind = bson.NextByte(buf) {
					bson.SkipIndex(buf)
					var _v1 string
					_v1 = bson.DecodeString(buf, kind)
					myType.Slice = append(myType.Slice, _v1)
				}
			}
		case "SliceBytes":
			// [][]byte
			if kind != bson.Null {
				if kind != bson.Array {
					panic(bson.NewBsonError("unexpected kind %v for myType.SliceBytes", kind))
				}
				bson.Next(buf, 4)
				myType.SliceBytes = make([][]byte, 0, 8)
				for kind := bson.NextByte(buf); kind != bson.EOO; kind = bson.NextByte(buf) {
					bson.SkipIndex(buf)
					var _v2 []byte
					_v2 = bson.DecodeBinary(buf, kind)
					myType.SliceBytes = append(myType.SliceBytes, _v2)
				}
			}
		case "SlicePtr":
			// []*string
			if kind != bson.Null {
				if kind != bson.Array {
					panic(bson.NewBsonError("unexpected kind %v for myType.SlicePtr", kind))
				}
				bson.Next(buf, 4)
				myType.SlicePtr = make([]*string, 0, 8)
				for kind := bson.NextByte(buf); kind != bson.EOO; kind = bson.NextByte(buf) {
					bson.SkipIndex(buf)
					var _v3 *string
					// *string
					if kind != bson.Null {
						_v3 = new(string)
						(*_v3) = bson.DecodeString(buf, kind)
					}
					myType.SlicePtr = append(myType.SlicePtr, _v3)
				}
			}
		case "SliceSlice":
			// [][]string
			if kind != bson.Null {
				if kind != bson.Array {
					panic(bson.NewBsonError("unexpected kind %v for myType.SliceSlice", kind))
				}
				bson.Next(buf, 4)
				myType.SliceSlice = make([][]string, 0, 8)
				for kind := bson.NextByte(buf); kind != bson.EOO; kind = bson.NextByte(buf) {
					bson.SkipIndex(buf)
					var _v4 []string
					// []string
					if kind != bson.Null {
						if kind != bson.Array {
							panic(bson.NewBsonError("unexpected kind %v for _v4", kind))
						}
						bson.Next(buf, 4)
						_v4 = make([]string, 0, 8)
						for kind := bson.NextByte(buf); kind != bson.EOO; kind = bson.NextByte(buf) {
							bson.SkipIndex(buf)
							var _v5 string
							_v5 = bson.DecodeString(buf, kind)
							_v4 = append(_v4, _v5)
						}
					}
					myType.SliceSlice = append(myType.SliceSlice, _v4)
				}
			}
		case "SliceMap":
			// []map[string]int64
			if kind != bson.Null {
				if kind != bson.Array {
					panic(bson.NewBsonError("unexpected kind %v for myType.SliceMap", kind))
				}
				bson.Next(buf, 4)
				myType.SliceMap = make([]map[string]int64, 0, 8)
				for kind := bson.NextByte(buf); kind != bson.EOO; kind = bson.NextByte(buf) {
					bson.SkipIndex(buf)
					var _v6 map[string]int64
					// map[string]int64
					if kind != bson.Null {
						if kind != bson.Object {
							panic(bson.NewBsonError("unexpected kind %v for _v6", kind))
						}
						bson.Next(buf, 4)
						_v6 = make(map[string]int64)
						for kind := bson.NextByte(buf); kind != bson.EOO; kind = bson.NextByte(buf) {
							_k := bson.ReadCString(buf)
							var _v7 int64
							_v7 = bson.DecodeInt64(buf, kind)
							_v6[_k] = _v7
						}
					}
					myType.SliceMap = append(myType.SliceMap, _v6)
				}
			}
		case "SliceCustom":
			// []Custom
			if kind != bson.Null {
				if kind != bson.Array {
					panic(bson.NewBsonError("unexpected kind %v for myType.SliceCustom", kind))
				}
				bson.Next(buf, 4)
				myType.SliceCustom = make([]Custom, 0, 8)
				for kind := bson.NextByte(buf); kind != bson.EOO; kind = bson.NextByte(buf) {
					bson.SkipIndex(buf)
					var _v8 Custom
					_v8.UnmarshalBson(buf, kind)
					myType.SliceCustom = append(myType.SliceCustom, _v8)
				}
			}
		default:
			bson.Skip(buf, kind)
		}
	}
}
