<?php
// DO NOT EDIT! Generated by Protobuf-PHP protoc plugin 1.0
// Source: vtgate.proto
//   Date: 2015-10-27 20:47:13

namespace vtgate\Session {

  class ShardSession extends \DrSlump\Protobuf\Message {

    /**  @var \query\Target */
    public $target = null;
    
    /**  @var int */
    public $transaction_id = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, 'vtgate.Session.ShardSession');

      // OPTIONAL MESSAGE target = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "target";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\query\Target';
      $descriptor->addField($f);

      // OPTIONAL INT64 transaction_id = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "transaction_id";
      $f->type      = \DrSlump\Protobuf::TYPE_INT64;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <target> has a value
     *
     * @return boolean
     */
    public function hasTarget(){
      return $this->_has(1);
    }
    
    /**
     * Clear <target> value
     *
     * @return \vtgate\Session\ShardSession
     */
    public function clearTarget(){
      return $this->_clear(1);
    }
    
    /**
     * Get <target> value
     *
     * @return \query\Target
     */
    public function getTarget(){
      return $this->_get(1);
    }
    
    /**
     * Set <target> value
     *
     * @param \query\Target $value
     * @return \vtgate\Session\ShardSession
     */
    public function setTarget(\query\Target $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <transaction_id> has a value
     *
     * @return boolean
     */
    public function hasTransactionId(){
      return $this->_has(2);
    }
    
    /**
     * Clear <transaction_id> value
     *
     * @return \vtgate\Session\ShardSession
     */
    public function clearTransactionId(){
      return $this->_clear(2);
    }
    
    /**
     * Get <transaction_id> value
     *
     * @return int
     */
    public function getTransactionId(){
      return $this->_get(2);
    }
    
    /**
     * Set <transaction_id> value
     *
     * @param int $value
     * @return \vtgate\Session\ShardSession
     */
    public function setTransactionId( $value){
      return $this->_set(2, $value);
    }
  }
}

namespace vtgate {

  class Session extends \DrSlump\Protobuf\Message {

    /**  @var boolean */
    public $in_transaction = null;
    
    /**  @var \vtgate\Session\ShardSession[]  */
    public $shard_sessions = array();
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, 'vtgate.Session');

      // OPTIONAL BOOL in_transaction = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "in_transaction";
      $f->type      = \DrSlump\Protobuf::TYPE_BOOL;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // REPEATED MESSAGE shard_sessions = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "shard_sessions";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_REPEATED;
      $f->reference = '\vtgate\Session\ShardSession';
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <in_transaction> has a value
     *
     * @return boolean
     */
    public function hasInTransaction(){
      return $this->_has(1);
    }
    
    /**
     * Clear <in_transaction> value
     *
     * @return \vtgate\Session
     */
    public function clearInTransaction(){
      return $this->_clear(1);
    }
    
    /**
     * Get <in_transaction> value
     *
     * @return boolean
     */
    public function getInTransaction(){
      return $this->_get(1);
    }
    
    /**
     * Set <in_transaction> value
     *
     * @param boolean $value
     * @return \vtgate\Session
     */
    public function setInTransaction( $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <shard_sessions> has a value
     *
     * @return boolean
     */
    public function hasShardSessions(){
      return $this->_has(2);
    }
    
    /**
     * Clear <shard_sessions> value
     *
     * @return \vtgate\Session
     */
    public function clearShardSessions(){
      return $this->_clear(2);
    }
    
    /**
     * Get <shard_sessions> value
     *
     * @param int $idx
     * @return \vtgate\Session\ShardSession
     */
    public function getShardSessions($idx = NULL){
      return $this->_get(2, $idx);
    }
    
    /**
     * Set <shard_sessions> value
     *
     * @param \vtgate\Session\ShardSession $value
     * @return \vtgate\Session
     */
    public function setShardSessions(\vtgate\Session\ShardSession $value, $idx = NULL){
      return $this->_set(2, $value, $idx);
    }
    
    /**
     * Get all elements of <shard_sessions>
     *
     * @return \vtgate\Session\ShardSession[]
     */
    public function getShardSessionsList(){
     return $this->_get(2);
    }
    
    /**
     * Add a new element to <shard_sessions>
     *
     * @param \vtgate\Session\ShardSession $value
     * @return \vtgate\Session
     */
    public function addShardSessions(\vtgate\Session\ShardSession $value){
     return $this->_add(2, $value);
    }
  }
}

namespace vtgate {

  class ExecuteRequest extends \DrSlump\Protobuf\Message {

    /**  @var \vtrpc\CallerID */
    public $caller_id = null;
    
    /**  @var \vtgate\Session */
    public $session = null;
    
    /**  @var \query\BoundQuery */
    public $query = null;
    
    /**  @var int - \topodata\TabletType */
    public $tablet_type = null;
    
    /**  @var boolean */
    public $not_in_transaction = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, 'vtgate.ExecuteRequest');

      // OPTIONAL MESSAGE caller_id = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "caller_id";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\vtrpc\CallerID';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE session = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "session";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\vtgate\Session';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE query = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "query";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\query\BoundQuery';
      $descriptor->addField($f);

      // OPTIONAL ENUM tablet_type = 4
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 4;
      $f->name      = "tablet_type";
      $f->type      = \DrSlump\Protobuf::TYPE_ENUM;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\topodata\TabletType';
      $descriptor->addField($f);

      // OPTIONAL BOOL not_in_transaction = 5
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 5;
      $f->name      = "not_in_transaction";
      $f->type      = \DrSlump\Protobuf::TYPE_BOOL;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <caller_id> has a value
     *
     * @return boolean
     */
    public function hasCallerId(){
      return $this->_has(1);
    }
    
    /**
     * Clear <caller_id> value
     *
     * @return \vtgate\ExecuteRequest
     */
    public function clearCallerId(){
      return $this->_clear(1);
    }
    
    /**
     * Get <caller_id> value
     *
     * @return \vtrpc\CallerID
     */
    public function getCallerId(){
      return $this->_get(1);
    }
    
    /**
     * Set <caller_id> value
     *
     * @param \vtrpc\CallerID $value
     * @return \vtgate\ExecuteRequest
     */
    public function setCallerId(\vtrpc\CallerID $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <session> has a value
     *
     * @return boolean
     */
    public function hasSession(){
      return $this->_has(2);
    }
    
    /**
     * Clear <session> value
     *
     * @return \vtgate\ExecuteRequest
     */
    public function clearSession(){
      return $this->_clear(2);
    }
    
    /**
     * Get <session> value
     *
     * @return \vtgate\Session
     */
    public function getSession(){
      return $this->_get(2);
    }
    
    /**
     * Set <session> value
     *
     * @param \vtgate\Session $value
     * @return \vtgate\ExecuteRequest
     */
    public function setSession(\vtgate\Session $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <query> has a value
     *
     * @return boolean
     */
    public function hasQuery(){
      return $this->_has(3);
    }
    
    /**
     * Clear <query> value
     *
     * @return \vtgate\ExecuteRequest
     */
    public function clearQuery(){
      return $this->_clear(3);
    }
    
    /**
     * Get <query> value
     *
     * @return \query\BoundQuery
     */
    public function getQuery(){
      return $this->_get(3);
    }
    
    /**
     * Set <query> value
     *
     * @param \query\BoundQuery $value
     * @return \vtgate\ExecuteRequest
     */
    public function setQuery(\query\BoundQuery $value){
      return $this->_set(3, $value);
    }
    
    /**
     * Check if <tablet_type> has a value
     *
     * @return boolean
     */
    public function hasTabletType(){
      return $this->_has(4);
    }
    
    /**
     * Clear <tablet_type> value
     *
     * @return \vtgate\ExecuteRequest
     */
    public function clearTabletType(){
      return $this->_clear(4);
    }
    
    /**
     * Get <tablet_type> value
     *
     * @return int - \topodata\TabletType
     */
    public function getTabletType(){
      return $this->_get(4);
    }
    
    /**
     * Set <tablet_type> value
     *
     * @param int - \topodata\TabletType $value
     * @return \vtgate\ExecuteRequest
     */
    public function setTabletType( $value){
      return $this->_set(4, $value);
    }
    
    /**
     * Check if <not_in_transaction> has a value
     *
     * @return boolean
     */
    public function hasNotInTransaction(){
      return $this->_has(5);
    }
    
    /**
     * Clear <not_in_transaction> value
     *
     * @return \vtgate\ExecuteRequest
     */
    public function clearNotInTransaction(){
      return $this->_clear(5);
    }
    
    /**
     * Get <not_in_transaction> value
     *
     * @return boolean
     */
    public function getNotInTransaction(){
      return $this->_get(5);
    }
    
    /**
     * Set <not_in_transaction> value
     *
     * @param boolean $value
     * @return \vtgate\ExecuteRequest
     */
    public function setNotInTransaction( $value){
      return $this->_set(5, $value);
    }
  }
}

namespace vtgate {

  class ExecuteResponse extends \DrSlump\Protobuf\Message {

    /**  @var \vtrpc\RPCError */
    public $error = null;
    
    /**  @var \vtgate\Session */
    public $session = null;
    
    /**  @var \query\QueryResult */
    public $result = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, 'vtgate.ExecuteResponse');

      // OPTIONAL MESSAGE error = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "error";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\vtrpc\RPCError';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE session = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "session";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\vtgate\Session';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE result = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "result";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\query\QueryResult';
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <error> has a value
     *
     * @return boolean
     */
    public function hasError(){
      return $this->_has(1);
    }
    
    /**
     * Clear <error> value
     *
     * @return \vtgate\ExecuteResponse
     */
    public function clearError(){
      return $this->_clear(1);
    }
    
    /**
     * Get <error> value
     *
     * @return \vtrpc\RPCError
     */
    public function getError(){
      return $this->_get(1);
    }
    
    /**
     * Set <error> value
     *
     * @param \vtrpc\RPCError $value
     * @return \vtgate\ExecuteResponse
     */
    public function setError(\vtrpc\RPCError $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <session> has a value
     *
     * @return boolean
     */
    public function hasSession(){
      return $this->_has(2);
    }
    
    /**
     * Clear <session> value
     *
     * @return \vtgate\ExecuteResponse
     */
    public function clearSession(){
      return $this->_clear(2);
    }
    
    /**
     * Get <session> value
     *
     * @return \vtgate\Session
     */
    public function getSession(){
      return $this->_get(2);
    }
    
    /**
     * Set <session> value
     *
     * @param \vtgate\Session $value
     * @return \vtgate\ExecuteResponse
     */
    public function setSession(\vtgate\Session $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <result> has a value
     *
     * @return boolean
     */
    public function hasResult(){
      return $this->_has(3);
    }
    
    /**
     * Clear <result> value
     *
     * @return \vtgate\ExecuteResponse
     */
    public function clearResult(){
      return $this->_clear(3);
    }
    
    /**
     * Get <result> value
     *
     * @return \query\QueryResult
     */
    public function getResult(){
      return $this->_get(3);
    }
    
    /**
     * Set <result> value
     *
     * @param \query\QueryResult $value
     * @return \vtgate\ExecuteResponse
     */
    public function setResult(\query\QueryResult $value){
      return $this->_set(3, $value);
    }
  }
}

namespace vtgate {

  class ExecuteShardsRequest extends \DrSlump\Protobuf\Message {

    /**  @var \vtrpc\CallerID */
    public $caller_id = null;
    
    /**  @var \vtgate\Session */
    public $session = null;
    
    /**  @var \query\BoundQuery */
    public $query = null;
    
    /**  @var string */
    public $keyspace = null;
    
    /**  @var string[]  */
    public $shards = array();
    
    /**  @var int - \topodata\TabletType */
    public $tablet_type = null;
    
    /**  @var boolean */
    public $not_in_transaction = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, 'vtgate.ExecuteShardsRequest');

      // OPTIONAL MESSAGE caller_id = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "caller_id";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\vtrpc\CallerID';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE session = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "session";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\vtgate\Session';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE query = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "query";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\query\BoundQuery';
      $descriptor->addField($f);

      // OPTIONAL STRING keyspace = 4
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 4;
      $f->name      = "keyspace";
      $f->type      = \DrSlump\Protobuf::TYPE_STRING;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // REPEATED STRING shards = 5
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 5;
      $f->name      = "shards";
      $f->type      = \DrSlump\Protobuf::TYPE_STRING;
      $f->rule      = \DrSlump\Protobuf::RULE_REPEATED;
      $descriptor->addField($f);

      // OPTIONAL ENUM tablet_type = 6
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 6;
      $f->name      = "tablet_type";
      $f->type      = \DrSlump\Protobuf::TYPE_ENUM;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\topodata\TabletType';
      $descriptor->addField($f);

      // OPTIONAL BOOL not_in_transaction = 7
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 7;
      $f->name      = "not_in_transaction";
      $f->type      = \DrSlump\Protobuf::TYPE_BOOL;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <caller_id> has a value
     *
     * @return boolean
     */
    public function hasCallerId(){
      return $this->_has(1);
    }
    
    /**
     * Clear <caller_id> value
     *
     * @return \vtgate\ExecuteShardsRequest
     */
    public function clearCallerId(){
      return $this->_clear(1);
    }
    
    /**
     * Get <caller_id> value
     *
     * @return \vtrpc\CallerID
     */
    public function getCallerId(){
      return $this->_get(1);
    }
    
    /**
     * Set <caller_id> value
     *
     * @param \vtrpc\CallerID $value
     * @return \vtgate\ExecuteShardsRequest
     */
    public function setCallerId(\vtrpc\CallerID $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <session> has a value
     *
     * @return boolean
     */
    public function hasSession(){
      return $this->_has(2);
    }
    
    /**
     * Clear <session> value
     *
     * @return \vtgate\ExecuteShardsRequest
     */
    public function clearSession(){
      return $this->_clear(2);
    }
    
    /**
     * Get <session> value
     *
     * @return \vtgate\Session
     */
    public function getSession(){
      return $this->_get(2);
    }
    
    /**
     * Set <session> value
     *
     * @param \vtgate\Session $value
     * @return \vtgate\ExecuteShardsRequest
     */
    public function setSession(\vtgate\Session $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <query> has a value
     *
     * @return boolean
     */
    public function hasQuery(){
      return $this->_has(3);
    }
    
    /**
     * Clear <query> value
     *
     * @return \vtgate\ExecuteShardsRequest
     */
    public function clearQuery(){
      return $this->_clear(3);
    }
    
    /**
     * Get <query> value
     *
     * @return \query\BoundQuery
     */
    public function getQuery(){
      return $this->_get(3);
    }
    
    /**
     * Set <query> value
     *
     * @param \query\BoundQuery $value
     * @return \vtgate\ExecuteShardsRequest
     */
    public function setQuery(\query\BoundQuery $value){
      return $this->_set(3, $value);
    }
    
    /**
     * Check if <keyspace> has a value
     *
     * @return boolean
     */
    public function hasKeyspace(){
      return $this->_has(4);
    }
    
    /**
     * Clear <keyspace> value
     *
     * @return \vtgate\ExecuteShardsRequest
     */
    public function clearKeyspace(){
      return $this->_clear(4);
    }
    
    /**
     * Get <keyspace> value
     *
     * @return string
     */
    public function getKeyspace(){
      return $this->_get(4);
    }
    
    /**
     * Set <keyspace> value
     *
     * @param string $value
     * @return \vtgate\ExecuteShardsRequest
     */
    public function setKeyspace( $value){
      return $this->_set(4, $value);
    }
    
    /**
     * Check if <shards> has a value
     *
     * @return boolean
     */
    public function hasShards(){
      return $this->_has(5);
    }
    
    /**
     * Clear <shards> value
     *
     * @return \vtgate\ExecuteShardsRequest
     */
    public function clearShards(){
      return $this->_clear(5);
    }
    
    /**
     * Get <shards> value
     *
     * @param int $idx
     * @return string
     */
    public function getShards($idx = NULL){
      return $this->_get(5, $idx);
    }
    
    /**
     * Set <shards> value
     *
     * @param string $value
     * @return \vtgate\ExecuteShardsRequest
     */
    public function setShards( $value, $idx = NULL){
      return $this->_set(5, $value, $idx);
    }
    
    /**
     * Get all elements of <shards>
     *
     * @return string[]
     */
    public function getShardsList(){
     return $this->_get(5);
    }
    
    /**
     * Add a new element to <shards>
     *
     * @param string $value
     * @return \vtgate\ExecuteShardsRequest
     */
    public function addShards( $value){
     return $this->_add(5, $value);
    }
    
    /**
     * Check if <tablet_type> has a value
     *
     * @return boolean
     */
    public function hasTabletType(){
      return $this->_has(6);
    }
    
    /**
     * Clear <tablet_type> value
     *
     * @return \vtgate\ExecuteShardsRequest
     */
    public function clearTabletType(){
      return $this->_clear(6);
    }
    
    /**
     * Get <tablet_type> value
     *
     * @return int - \topodata\TabletType
     */
    public function getTabletType(){
      return $this->_get(6);
    }
    
    /**
     * Set <tablet_type> value
     *
     * @param int - \topodata\TabletType $value
     * @return \vtgate\ExecuteShardsRequest
     */
    public function setTabletType( $value){
      return $this->_set(6, $value);
    }
    
    /**
     * Check if <not_in_transaction> has a value
     *
     * @return boolean
     */
    public function hasNotInTransaction(){
      return $this->_has(7);
    }
    
    /**
     * Clear <not_in_transaction> value
     *
     * @return \vtgate\ExecuteShardsRequest
     */
    public function clearNotInTransaction(){
      return $this->_clear(7);
    }
    
    /**
     * Get <not_in_transaction> value
     *
     * @return boolean
     */
    public function getNotInTransaction(){
      return $this->_get(7);
    }
    
    /**
     * Set <not_in_transaction> value
     *
     * @param boolean $value
     * @return \vtgate\ExecuteShardsRequest
     */
    public function setNotInTransaction( $value){
      return $this->_set(7, $value);
    }
  }
}

namespace vtgate {

  class ExecuteShardsResponse extends \DrSlump\Protobuf\Message {

    /**  @var \vtrpc\RPCError */
    public $error = null;
    
    /**  @var \vtgate\Session */
    public $session = null;
    
    /**  @var \query\QueryResult */
    public $result = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, 'vtgate.ExecuteShardsResponse');

      // OPTIONAL MESSAGE error = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "error";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\vtrpc\RPCError';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE session = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "session";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\vtgate\Session';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE result = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "result";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\query\QueryResult';
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <error> has a value
     *
     * @return boolean
     */
    public function hasError(){
      return $this->_has(1);
    }
    
    /**
     * Clear <error> value
     *
     * @return \vtgate\ExecuteShardsResponse
     */
    public function clearError(){
      return $this->_clear(1);
    }
    
    /**
     * Get <error> value
     *
     * @return \vtrpc\RPCError
     */
    public function getError(){
      return $this->_get(1);
    }
    
    /**
     * Set <error> value
     *
     * @param \vtrpc\RPCError $value
     * @return \vtgate\ExecuteShardsResponse
     */
    public function setError(\vtrpc\RPCError $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <session> has a value
     *
     * @return boolean
     */
    public function hasSession(){
      return $this->_has(2);
    }
    
    /**
     * Clear <session> value
     *
     * @return \vtgate\ExecuteShardsResponse
     */
    public function clearSession(){
      return $this->_clear(2);
    }
    
    /**
     * Get <session> value
     *
     * @return \vtgate\Session
     */
    public function getSession(){
      return $this->_get(2);
    }
    
    /**
     * Set <session> value
     *
     * @param \vtgate\Session $value
     * @return \vtgate\ExecuteShardsResponse
     */
    public function setSession(\vtgate\Session $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <result> has a value
     *
     * @return boolean
     */
    public function hasResult(){
      return $this->_has(3);
    }
    
    /**
     * Clear <result> value
     *
     * @return \vtgate\ExecuteShardsResponse
     */
    public function clearResult(){
      return $this->_clear(3);
    }
    
    /**
     * Get <result> value
     *
     * @return \query\QueryResult
     */
    public function getResult(){
      return $this->_get(3);
    }
    
    /**
     * Set <result> value
     *
     * @param \query\QueryResult $value
     * @return \vtgate\ExecuteShardsResponse
     */
    public function setResult(\query\QueryResult $value){
      return $this->_set(3, $value);
    }
  }
}

namespace vtgate {

  class ExecuteKeyspaceIdsRequest extends \DrSlump\Protobuf\Message {

    /**  @var \vtrpc\CallerID */
    public $caller_id = null;
    
    /**  @var \vtgate\Session */
    public $session = null;
    
    /**  @var \query\BoundQuery */
    public $query = null;
    
    /**  @var string */
    public $keyspace = null;
    
    /**  @var string[]  */
    public $keyspace_ids = array();
    
    /**  @var int - \topodata\TabletType */
    public $tablet_type = null;
    
    /**  @var boolean */
    public $not_in_transaction = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, 'vtgate.ExecuteKeyspaceIdsRequest');

      // OPTIONAL MESSAGE caller_id = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "caller_id";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\vtrpc\CallerID';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE session = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "session";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\vtgate\Session';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE query = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "query";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\query\BoundQuery';
      $descriptor->addField($f);

      // OPTIONAL STRING keyspace = 4
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 4;
      $f->name      = "keyspace";
      $f->type      = \DrSlump\Protobuf::TYPE_STRING;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // REPEATED BYTES keyspace_ids = 5
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 5;
      $f->name      = "keyspace_ids";
      $f->type      = \DrSlump\Protobuf::TYPE_BYTES;
      $f->rule      = \DrSlump\Protobuf::RULE_REPEATED;
      $descriptor->addField($f);

      // OPTIONAL ENUM tablet_type = 6
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 6;
      $f->name      = "tablet_type";
      $f->type      = \DrSlump\Protobuf::TYPE_ENUM;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\topodata\TabletType';
      $descriptor->addField($f);

      // OPTIONAL BOOL not_in_transaction = 7
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 7;
      $f->name      = "not_in_transaction";
      $f->type      = \DrSlump\Protobuf::TYPE_BOOL;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <caller_id> has a value
     *
     * @return boolean
     */
    public function hasCallerId(){
      return $this->_has(1);
    }
    
    /**
     * Clear <caller_id> value
     *
     * @return \vtgate\ExecuteKeyspaceIdsRequest
     */
    public function clearCallerId(){
      return $this->_clear(1);
    }
    
    /**
     * Get <caller_id> value
     *
     * @return \vtrpc\CallerID
     */
    public function getCallerId(){
      return $this->_get(1);
    }
    
    /**
     * Set <caller_id> value
     *
     * @param \vtrpc\CallerID $value
     * @return \vtgate\ExecuteKeyspaceIdsRequest
     */
    public function setCallerId(\vtrpc\CallerID $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <session> has a value
     *
     * @return boolean
     */
    public function hasSession(){
      return $this->_has(2);
    }
    
    /**
     * Clear <session> value
     *
     * @return \vtgate\ExecuteKeyspaceIdsRequest
     */
    public function clearSession(){
      return $this->_clear(2);
    }
    
    /**
     * Get <session> value
     *
     * @return \vtgate\Session
     */
    public function getSession(){
      return $this->_get(2);
    }
    
    /**
     * Set <session> value
     *
     * @param \vtgate\Session $value
     * @return \vtgate\ExecuteKeyspaceIdsRequest
     */
    public function setSession(\vtgate\Session $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <query> has a value
     *
     * @return boolean
     */
    public function hasQuery(){
      return $this->_has(3);
    }
    
    /**
     * Clear <query> value
     *
     * @return \vtgate\ExecuteKeyspaceIdsRequest
     */
    public function clearQuery(){
      return $this->_clear(3);
    }
    
    /**
     * Get <query> value
     *
     * @return \query\BoundQuery
     */
    public function getQuery(){
      return $this->_get(3);
    }
    
    /**
     * Set <query> value
     *
     * @param \query\BoundQuery $value
     * @return \vtgate\ExecuteKeyspaceIdsRequest
     */
    public function setQuery(\query\BoundQuery $value){
      return $this->_set(3, $value);
    }
    
    /**
     * Check if <keyspace> has a value
     *
     * @return boolean
     */
    public function hasKeyspace(){
      return $this->_has(4);
    }
    
    /**
     * Clear <keyspace> value
     *
     * @return \vtgate\ExecuteKeyspaceIdsRequest
     */
    public function clearKeyspace(){
      return $this->_clear(4);
    }
    
    /**
     * Get <keyspace> value
     *
     * @return string
     */
    public function getKeyspace(){
      return $this->_get(4);
    }
    
    /**
     * Set <keyspace> value
     *
     * @param string $value
     * @return \vtgate\ExecuteKeyspaceIdsRequest
     */
    public function setKeyspace( $value){
      return $this->_set(4, $value);
    }
    
    /**
     * Check if <keyspace_ids> has a value
     *
     * @return boolean
     */
    public function hasKeyspaceIds(){
      return $this->_has(5);
    }
    
    /**
     * Clear <keyspace_ids> value
     *
     * @return \vtgate\ExecuteKeyspaceIdsRequest
     */
    public function clearKeyspaceIds(){
      return $this->_clear(5);
    }
    
    /**
     * Get <keyspace_ids> value
     *
     * @param int $idx
     * @return string
     */
    public function getKeyspaceIds($idx = NULL){
      return $this->_get(5, $idx);
    }
    
    /**
     * Set <keyspace_ids> value
     *
     * @param string $value
     * @return \vtgate\ExecuteKeyspaceIdsRequest
     */
    public function setKeyspaceIds( $value, $idx = NULL){
      return $this->_set(5, $value, $idx);
    }
    
    /**
     * Get all elements of <keyspace_ids>
     *
     * @return string[]
     */
    public function getKeyspaceIdsList(){
     return $this->_get(5);
    }
    
    /**
     * Add a new element to <keyspace_ids>
     *
     * @param string $value
     * @return \vtgate\ExecuteKeyspaceIdsRequest
     */
    public function addKeyspaceIds( $value){
     return $this->_add(5, $value);
    }
    
    /**
     * Check if <tablet_type> has a value
     *
     * @return boolean
     */
    public function hasTabletType(){
      return $this->_has(6);
    }
    
    /**
     * Clear <tablet_type> value
     *
     * @return \vtgate\ExecuteKeyspaceIdsRequest
     */
    public function clearTabletType(){
      return $this->_clear(6);
    }
    
    /**
     * Get <tablet_type> value
     *
     * @return int - \topodata\TabletType
     */
    public function getTabletType(){
      return $this->_get(6);
    }
    
    /**
     * Set <tablet_type> value
     *
     * @param int - \topodata\TabletType $value
     * @return \vtgate\ExecuteKeyspaceIdsRequest
     */
    public function setTabletType( $value){
      return $this->_set(6, $value);
    }
    
    /**
     * Check if <not_in_transaction> has a value
     *
     * @return boolean
     */
    public function hasNotInTransaction(){
      return $this->_has(7);
    }
    
    /**
     * Clear <not_in_transaction> value
     *
     * @return \vtgate\ExecuteKeyspaceIdsRequest
     */
    public function clearNotInTransaction(){
      return $this->_clear(7);
    }
    
    /**
     * Get <not_in_transaction> value
     *
     * @return boolean
     */
    public function getNotInTransaction(){
      return $this->_get(7);
    }
    
    /**
     * Set <not_in_transaction> value
     *
     * @param boolean $value
     * @return \vtgate\ExecuteKeyspaceIdsRequest
     */
    public function setNotInTransaction( $value){
      return $this->_set(7, $value);
    }
  }
}

namespace vtgate {

  class ExecuteKeyspaceIdsResponse extends \DrSlump\Protobuf\Message {

    /**  @var \vtrpc\RPCError */
    public $error = null;
    
    /**  @var \vtgate\Session */
    public $session = null;
    
    /**  @var \query\QueryResult */
    public $result = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, 'vtgate.ExecuteKeyspaceIdsResponse');

      // OPTIONAL MESSAGE error = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "error";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\vtrpc\RPCError';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE session = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "session";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\vtgate\Session';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE result = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "result";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\query\QueryResult';
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <error> has a value
     *
     * @return boolean
     */
    public function hasError(){
      return $this->_has(1);
    }
    
    /**
     * Clear <error> value
     *
     * @return \vtgate\ExecuteKeyspaceIdsResponse
     */
    public function clearError(){
      return $this->_clear(1);
    }
    
    /**
     * Get <error> value
     *
     * @return \vtrpc\RPCError
     */
    public function getError(){
      return $this->_get(1);
    }
    
    /**
     * Set <error> value
     *
     * @param \vtrpc\RPCError $value
     * @return \vtgate\ExecuteKeyspaceIdsResponse
     */
    public function setError(\vtrpc\RPCError $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <session> has a value
     *
     * @return boolean
     */
    public function hasSession(){
      return $this->_has(2);
    }
    
    /**
     * Clear <session> value
     *
     * @return \vtgate\ExecuteKeyspaceIdsResponse
     */
    public function clearSession(){
      return $this->_clear(2);
    }
    
    /**
     * Get <session> value
     *
     * @return \vtgate\Session
     */
    public function getSession(){
      return $this->_get(2);
    }
    
    /**
     * Set <session> value
     *
     * @param \vtgate\Session $value
     * @return \vtgate\ExecuteKeyspaceIdsResponse
     */
    public function setSession(\vtgate\Session $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <result> has a value
     *
     * @return boolean
     */
    public function hasResult(){
      return $this->_has(3);
    }
    
    /**
     * Clear <result> value
     *
     * @return \vtgate\ExecuteKeyspaceIdsResponse
     */
    public function clearResult(){
      return $this->_clear(3);
    }
    
    /**
     * Get <result> value
     *
     * @return \query\QueryResult
     */
    public function getResult(){
      return $this->_get(3);
    }
    
    /**
     * Set <result> value
     *
     * @param \query\QueryResult $value
     * @return \vtgate\ExecuteKeyspaceIdsResponse
     */
    public function setResult(\query\QueryResult $value){
      return $this->_set(3, $value);
    }
  }
}

namespace vtgate {

  class ExecuteKeyRangesRequest extends \DrSlump\Protobuf\Message {

    /**  @var \vtrpc\CallerID */
    public $caller_id = null;
    
    /**  @var \vtgate\Session */
    public $session = null;
    
    /**  @var \query\BoundQuery */
    public $query = null;
    
    /**  @var string */
    public $keyspace = null;
    
    /**  @var \topodata\KeyRange[]  */
    public $key_ranges = array();
    
    /**  @var int - \topodata\TabletType */
    public $tablet_type = null;
    
    /**  @var boolean */
    public $not_in_transaction = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, 'vtgate.ExecuteKeyRangesRequest');

      // OPTIONAL MESSAGE caller_id = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "caller_id";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\vtrpc\CallerID';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE session = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "session";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\vtgate\Session';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE query = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "query";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\query\BoundQuery';
      $descriptor->addField($f);

      // OPTIONAL STRING keyspace = 4
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 4;
      $f->name      = "keyspace";
      $f->type      = \DrSlump\Protobuf::TYPE_STRING;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // REPEATED MESSAGE key_ranges = 5
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 5;
      $f->name      = "key_ranges";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_REPEATED;
      $f->reference = '\topodata\KeyRange';
      $descriptor->addField($f);

      // OPTIONAL ENUM tablet_type = 6
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 6;
      $f->name      = "tablet_type";
      $f->type      = \DrSlump\Protobuf::TYPE_ENUM;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\topodata\TabletType';
      $descriptor->addField($f);

      // OPTIONAL BOOL not_in_transaction = 7
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 7;
      $f->name      = "not_in_transaction";
      $f->type      = \DrSlump\Protobuf::TYPE_BOOL;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <caller_id> has a value
     *
     * @return boolean
     */
    public function hasCallerId(){
      return $this->_has(1);
    }
    
    /**
     * Clear <caller_id> value
     *
     * @return \vtgate\ExecuteKeyRangesRequest
     */
    public function clearCallerId(){
      return $this->_clear(1);
    }
    
    /**
     * Get <caller_id> value
     *
     * @return \vtrpc\CallerID
     */
    public function getCallerId(){
      return $this->_get(1);
    }
    
    /**
     * Set <caller_id> value
     *
     * @param \vtrpc\CallerID $value
     * @return \vtgate\ExecuteKeyRangesRequest
     */
    public function setCallerId(\vtrpc\CallerID $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <session> has a value
     *
     * @return boolean
     */
    public function hasSession(){
      return $this->_has(2);
    }
    
    /**
     * Clear <session> value
     *
     * @return \vtgate\ExecuteKeyRangesRequest
     */
    public function clearSession(){
      return $this->_clear(2);
    }
    
    /**
     * Get <session> value
     *
     * @return \vtgate\Session
     */
    public function getSession(){
      return $this->_get(2);
    }
    
    /**
     * Set <session> value
     *
     * @param \vtgate\Session $value
     * @return \vtgate\ExecuteKeyRangesRequest
     */
    public function setSession(\vtgate\Session $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <query> has a value
     *
     * @return boolean
     */
    public function hasQuery(){
      return $this->_has(3);
    }
    
    /**
     * Clear <query> value
     *
     * @return \vtgate\ExecuteKeyRangesRequest
     */
    public function clearQuery(){
      return $this->_clear(3);
    }
    
    /**
     * Get <query> value
     *
     * @return \query\BoundQuery
     */
    public function getQuery(){
      return $this->_get(3);
    }
    
    /**
     * Set <query> value
     *
     * @param \query\BoundQuery $value
     * @return \vtgate\ExecuteKeyRangesRequest
     */
    public function setQuery(\query\BoundQuery $value){
      return $this->_set(3, $value);
    }
    
    /**
     * Check if <keyspace> has a value
     *
     * @return boolean
     */
    public function hasKeyspace(){
      return $this->_has(4);
    }
    
    /**
     * Clear <keyspace> value
     *
     * @return \vtgate\ExecuteKeyRangesRequest
     */
    public function clearKeyspace(){
      return $this->_clear(4);
    }
    
    /**
     * Get <keyspace> value
     *
     * @return string
     */
    public function getKeyspace(){
      return $this->_get(4);
    }
    
    /**
     * Set <keyspace> value
     *
     * @param string $value
     * @return \vtgate\ExecuteKeyRangesRequest
     */
    public function setKeyspace( $value){
      return $this->_set(4, $value);
    }
    
    /**
     * Check if <key_ranges> has a value
     *
     * @return boolean
     */
    public function hasKeyRanges(){
      return $this->_has(5);
    }
    
    /**
     * Clear <key_ranges> value
     *
     * @return \vtgate\ExecuteKeyRangesRequest
     */
    public function clearKeyRanges(){
      return $this->_clear(5);
    }
    
    /**
     * Get <key_ranges> value
     *
     * @param int $idx
     * @return \topodata\KeyRange
     */
    public function getKeyRanges($idx = NULL){
      return $this->_get(5, $idx);
    }
    
    /**
     * Set <key_ranges> value
     *
     * @param \topodata\KeyRange $value
     * @return \vtgate\ExecuteKeyRangesRequest
     */
    public function setKeyRanges(\topodata\KeyRange $value, $idx = NULL){
      return $this->_set(5, $value, $idx);
    }
    
    /**
     * Get all elements of <key_ranges>
     *
     * @return \topodata\KeyRange[]
     */
    public function getKeyRangesList(){
     return $this->_get(5);
    }
    
    /**
     * Add a new element to <key_ranges>
     *
     * @param \topodata\KeyRange $value
     * @return \vtgate\ExecuteKeyRangesRequest
     */
    public function addKeyRanges(\topodata\KeyRange $value){
     return $this->_add(5, $value);
    }
    
    /**
     * Check if <tablet_type> has a value
     *
     * @return boolean
     */
    public function hasTabletType(){
      return $this->_has(6);
    }
    
    /**
     * Clear <tablet_type> value
     *
     * @return \vtgate\ExecuteKeyRangesRequest
     */
    public function clearTabletType(){
      return $this->_clear(6);
    }
    
    /**
     * Get <tablet_type> value
     *
     * @return int - \topodata\TabletType
     */
    public function getTabletType(){
      return $this->_get(6);
    }
    
    /**
     * Set <tablet_type> value
     *
     * @param int - \topodata\TabletType $value
     * @return \vtgate\ExecuteKeyRangesRequest
     */
    public function setTabletType( $value){
      return $this->_set(6, $value);
    }
    
    /**
     * Check if <not_in_transaction> has a value
     *
     * @return boolean
     */
    public function hasNotInTransaction(){
      return $this->_has(7);
    }
    
    /**
     * Clear <not_in_transaction> value
     *
     * @return \vtgate\ExecuteKeyRangesRequest
     */
    public function clearNotInTransaction(){
      return $this->_clear(7);
    }
    
    /**
     * Get <not_in_transaction> value
     *
     * @return boolean
     */
    public function getNotInTransaction(){
      return $this->_get(7);
    }
    
    /**
     * Set <not_in_transaction> value
     *
     * @param boolean $value
     * @return \vtgate\ExecuteKeyRangesRequest
     */
    public function setNotInTransaction( $value){
      return $this->_set(7, $value);
    }
  }
}

namespace vtgate {

  class ExecuteKeyRangesResponse extends \DrSlump\Protobuf\Message {

    /**  @var \vtrpc\RPCError */
    public $error = null;
    
    /**  @var \vtgate\Session */
    public $session = null;
    
    /**  @var \query\QueryResult */
    public $result = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, 'vtgate.ExecuteKeyRangesResponse');

      // OPTIONAL MESSAGE error = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "error";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\vtrpc\RPCError';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE session = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "session";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\vtgate\Session';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE result = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "result";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\query\QueryResult';
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <error> has a value
     *
     * @return boolean
     */
    public function hasError(){
      return $this->_has(1);
    }
    
    /**
     * Clear <error> value
     *
     * @return \vtgate\ExecuteKeyRangesResponse
     */
    public function clearError(){
      return $this->_clear(1);
    }
    
    /**
     * Get <error> value
     *
     * @return \vtrpc\RPCError
     */
    public function getError(){
      return $this->_get(1);
    }
    
    /**
     * Set <error> value
     *
     * @param \vtrpc\RPCError $value
     * @return \vtgate\ExecuteKeyRangesResponse
     */
    public function setError(\vtrpc\RPCError $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <session> has a value
     *
     * @return boolean
     */
    public function hasSession(){
      return $this->_has(2);
    }
    
    /**
     * Clear <session> value
     *
     * @return \vtgate\ExecuteKeyRangesResponse
     */
    public function clearSession(){
      return $this->_clear(2);
    }
    
    /**
     * Get <session> value
     *
     * @return \vtgate\Session
     */
    public function getSession(){
      return $this->_get(2);
    }
    
    /**
     * Set <session> value
     *
     * @param \vtgate\Session $value
     * @return \vtgate\ExecuteKeyRangesResponse
     */
    public function setSession(\vtgate\Session $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <result> has a value
     *
     * @return boolean
     */
    public function hasResult(){
      return $this->_has(3);
    }
    
    /**
     * Clear <result> value
     *
     * @return \vtgate\ExecuteKeyRangesResponse
     */
    public function clearResult(){
      return $this->_clear(3);
    }
    
    /**
     * Get <result> value
     *
     * @return \query\QueryResult
     */
    public function getResult(){
      return $this->_get(3);
    }
    
    /**
     * Set <result> value
     *
     * @param \query\QueryResult $value
     * @return \vtgate\ExecuteKeyRangesResponse
     */
    public function setResult(\query\QueryResult $value){
      return $this->_set(3, $value);
    }
  }
}

namespace vtgate\ExecuteEntityIdsRequest {

  class EntityId extends \DrSlump\Protobuf\Message {

    /**  @var int - \query\Type */
    public $xid_type = null;
    
    /**  @var string */
    public $xid_value = null;
    
    /**  @var string */
    public $keyspace_id = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, 'vtgate.ExecuteEntityIdsRequest.EntityId');

      // OPTIONAL ENUM xid_type = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "xid_type";
      $f->type      = \DrSlump\Protobuf::TYPE_ENUM;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\query\Type';
      $descriptor->addField($f);

      // OPTIONAL BYTES xid_value = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "xid_value";
      $f->type      = \DrSlump\Protobuf::TYPE_BYTES;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL BYTES keyspace_id = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "keyspace_id";
      $f->type      = \DrSlump\Protobuf::TYPE_BYTES;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <xid_type> has a value
     *
     * @return boolean
     */
    public function hasXidType(){
      return $this->_has(1);
    }
    
    /**
     * Clear <xid_type> value
     *
     * @return \vtgate\ExecuteEntityIdsRequest\EntityId
     */
    public function clearXidType(){
      return $this->_clear(1);
    }
    
    /**
     * Get <xid_type> value
     *
     * @return int - \query\Type
     */
    public function getXidType(){
      return $this->_get(1);
    }
    
    /**
     * Set <xid_type> value
     *
     * @param int - \query\Type $value
     * @return \vtgate\ExecuteEntityIdsRequest\EntityId
     */
    public function setXidType( $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <xid_value> has a value
     *
     * @return boolean
     */
    public function hasXidValue(){
      return $this->_has(2);
    }
    
    /**
     * Clear <xid_value> value
     *
     * @return \vtgate\ExecuteEntityIdsRequest\EntityId
     */
    public function clearXidValue(){
      return $this->_clear(2);
    }
    
    /**
     * Get <xid_value> value
     *
     * @return string
     */
    public function getXidValue(){
      return $this->_get(2);
    }
    
    /**
     * Set <xid_value> value
     *
     * @param string $value
     * @return \vtgate\ExecuteEntityIdsRequest\EntityId
     */
    public function setXidValue( $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <keyspace_id> has a value
     *
     * @return boolean
     */
    public function hasKeyspaceId(){
      return $this->_has(3);
    }
    
    /**
     * Clear <keyspace_id> value
     *
     * @return \vtgate\ExecuteEntityIdsRequest\EntityId
     */
    public function clearKeyspaceId(){
      return $this->_clear(3);
    }
    
    /**
     * Get <keyspace_id> value
     *
     * @return string
     */
    public function getKeyspaceId(){
      return $this->_get(3);
    }
    
    /**
     * Set <keyspace_id> value
     *
     * @param string $value
     * @return \vtgate\ExecuteEntityIdsRequest\EntityId
     */
    public function setKeyspaceId( $value){
      return $this->_set(3, $value);
    }
  }
}

namespace vtgate {

  class ExecuteEntityIdsRequest extends \DrSlump\Protobuf\Message {

    /**  @var \vtrpc\CallerID */
    public $caller_id = null;
    
    /**  @var \vtgate\Session */
    public $session = null;
    
    /**  @var \query\BoundQuery */
    public $query = null;
    
    /**  @var string */
    public $keyspace = null;
    
    /**  @var string */
    public $entity_column_name = null;
    
    /**  @var \vtgate\ExecuteEntityIdsRequest\EntityId[]  */
    public $entity_keyspace_ids = array();
    
    /**  @var int - \topodata\TabletType */
    public $tablet_type = null;
    
    /**  @var boolean */
    public $not_in_transaction = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, 'vtgate.ExecuteEntityIdsRequest');

      // OPTIONAL MESSAGE caller_id = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "caller_id";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\vtrpc\CallerID';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE session = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "session";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\vtgate\Session';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE query = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "query";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\query\BoundQuery';
      $descriptor->addField($f);

      // OPTIONAL STRING keyspace = 4
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 4;
      $f->name      = "keyspace";
      $f->type      = \DrSlump\Protobuf::TYPE_STRING;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL STRING entity_column_name = 5
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 5;
      $f->name      = "entity_column_name";
      $f->type      = \DrSlump\Protobuf::TYPE_STRING;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // REPEATED MESSAGE entity_keyspace_ids = 6
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 6;
      $f->name      = "entity_keyspace_ids";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_REPEATED;
      $f->reference = '\vtgate\ExecuteEntityIdsRequest\EntityId';
      $descriptor->addField($f);

      // OPTIONAL ENUM tablet_type = 7
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 7;
      $f->name      = "tablet_type";
      $f->type      = \DrSlump\Protobuf::TYPE_ENUM;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\topodata\TabletType';
      $descriptor->addField($f);

      // OPTIONAL BOOL not_in_transaction = 8
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 8;
      $f->name      = "not_in_transaction";
      $f->type      = \DrSlump\Protobuf::TYPE_BOOL;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <caller_id> has a value
     *
     * @return boolean
     */
    public function hasCallerId(){
      return $this->_has(1);
    }
    
    /**
     * Clear <caller_id> value
     *
     * @return \vtgate\ExecuteEntityIdsRequest
     */
    public function clearCallerId(){
      return $this->_clear(1);
    }
    
    /**
     * Get <caller_id> value
     *
     * @return \vtrpc\CallerID
     */
    public function getCallerId(){
      return $this->_get(1);
    }
    
    /**
     * Set <caller_id> value
     *
     * @param \vtrpc\CallerID $value
     * @return \vtgate\ExecuteEntityIdsRequest
     */
    public function setCallerId(\vtrpc\CallerID $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <session> has a value
     *
     * @return boolean
     */
    public function hasSession(){
      return $this->_has(2);
    }
    
    /**
     * Clear <session> value
     *
     * @return \vtgate\ExecuteEntityIdsRequest
     */
    public function clearSession(){
      return $this->_clear(2);
    }
    
    /**
     * Get <session> value
     *
     * @return \vtgate\Session
     */
    public function getSession(){
      return $this->_get(2);
    }
    
    /**
     * Set <session> value
     *
     * @param \vtgate\Session $value
     * @return \vtgate\ExecuteEntityIdsRequest
     */
    public function setSession(\vtgate\Session $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <query> has a value
     *
     * @return boolean
     */
    public function hasQuery(){
      return $this->_has(3);
    }
    
    /**
     * Clear <query> value
     *
     * @return \vtgate\ExecuteEntityIdsRequest
     */
    public function clearQuery(){
      return $this->_clear(3);
    }
    
    /**
     * Get <query> value
     *
     * @return \query\BoundQuery
     */
    public function getQuery(){
      return $this->_get(3);
    }
    
    /**
     * Set <query> value
     *
     * @param \query\BoundQuery $value
     * @return \vtgate\ExecuteEntityIdsRequest
     */
    public function setQuery(\query\BoundQuery $value){
      return $this->_set(3, $value);
    }
    
    /**
     * Check if <keyspace> has a value
     *
     * @return boolean
     */
    public function hasKeyspace(){
      return $this->_has(4);
    }
    
    /**
     * Clear <keyspace> value
     *
     * @return \vtgate\ExecuteEntityIdsRequest
     */
    public function clearKeyspace(){
      return $this->_clear(4);
    }
    
    /**
     * Get <keyspace> value
     *
     * @return string
     */
    public function getKeyspace(){
      return $this->_get(4);
    }
    
    /**
     * Set <keyspace> value
     *
     * @param string $value
     * @return \vtgate\ExecuteEntityIdsRequest
     */
    public function setKeyspace( $value){
      return $this->_set(4, $value);
    }
    
    /**
     * Check if <entity_column_name> has a value
     *
     * @return boolean
     */
    public function hasEntityColumnName(){
      return $this->_has(5);
    }
    
    /**
     * Clear <entity_column_name> value
     *
     * @return \vtgate\ExecuteEntityIdsRequest
     */
    public function clearEntityColumnName(){
      return $this->_clear(5);
    }
    
    /**
     * Get <entity_column_name> value
     *
     * @return string
     */
    public function getEntityColumnName(){
      return $this->_get(5);
    }
    
    /**
     * Set <entity_column_name> value
     *
     * @param string $value
     * @return \vtgate\ExecuteEntityIdsRequest
     */
    public function setEntityColumnName( $value){
      return $this->_set(5, $value);
    }
    
    /**
     * Check if <entity_keyspace_ids> has a value
     *
     * @return boolean
     */
    public function hasEntityKeyspaceIds(){
      return $this->_has(6);
    }
    
    /**
     * Clear <entity_keyspace_ids> value
     *
     * @return \vtgate\ExecuteEntityIdsRequest
     */
    public function clearEntityKeyspaceIds(){
      return $this->_clear(6);
    }
    
    /**
     * Get <entity_keyspace_ids> value
     *
     * @param int $idx
     * @return \vtgate\ExecuteEntityIdsRequest\EntityId
     */
    public function getEntityKeyspaceIds($idx = NULL){
      return $this->_get(6, $idx);
    }
    
    /**
     * Set <entity_keyspace_ids> value
     *
     * @param \vtgate\ExecuteEntityIdsRequest\EntityId $value
     * @return \vtgate\ExecuteEntityIdsRequest
     */
    public function setEntityKeyspaceIds(\vtgate\ExecuteEntityIdsRequest\EntityId $value, $idx = NULL){
      return $this->_set(6, $value, $idx);
    }
    
    /**
     * Get all elements of <entity_keyspace_ids>
     *
     * @return \vtgate\ExecuteEntityIdsRequest\EntityId[]
     */
    public function getEntityKeyspaceIdsList(){
     return $this->_get(6);
    }
    
    /**
     * Add a new element to <entity_keyspace_ids>
     *
     * @param \vtgate\ExecuteEntityIdsRequest\EntityId $value
     * @return \vtgate\ExecuteEntityIdsRequest
     */
    public function addEntityKeyspaceIds(\vtgate\ExecuteEntityIdsRequest\EntityId $value){
     return $this->_add(6, $value);
    }
    
    /**
     * Check if <tablet_type> has a value
     *
     * @return boolean
     */
    public function hasTabletType(){
      return $this->_has(7);
    }
    
    /**
     * Clear <tablet_type> value
     *
     * @return \vtgate\ExecuteEntityIdsRequest
     */
    public function clearTabletType(){
      return $this->_clear(7);
    }
    
    /**
     * Get <tablet_type> value
     *
     * @return int - \topodata\TabletType
     */
    public function getTabletType(){
      return $this->_get(7);
    }
    
    /**
     * Set <tablet_type> value
     *
     * @param int - \topodata\TabletType $value
     * @return \vtgate\ExecuteEntityIdsRequest
     */
    public function setTabletType( $value){
      return $this->_set(7, $value);
    }
    
    /**
     * Check if <not_in_transaction> has a value
     *
     * @return boolean
     */
    public function hasNotInTransaction(){
      return $this->_has(8);
    }
    
    /**
     * Clear <not_in_transaction> value
     *
     * @return \vtgate\ExecuteEntityIdsRequest
     */
    public function clearNotInTransaction(){
      return $this->_clear(8);
    }
    
    /**
     * Get <not_in_transaction> value
     *
     * @return boolean
     */
    public function getNotInTransaction(){
      return $this->_get(8);
    }
    
    /**
     * Set <not_in_transaction> value
     *
     * @param boolean $value
     * @return \vtgate\ExecuteEntityIdsRequest
     */
    public function setNotInTransaction( $value){
      return $this->_set(8, $value);
    }
  }
}

namespace vtgate {

  class ExecuteEntityIdsResponse extends \DrSlump\Protobuf\Message {

    /**  @var \vtrpc\RPCError */
    public $error = null;
    
    /**  @var \vtgate\Session */
    public $session = null;
    
    /**  @var \query\QueryResult */
    public $result = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, 'vtgate.ExecuteEntityIdsResponse');

      // OPTIONAL MESSAGE error = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "error";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\vtrpc\RPCError';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE session = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "session";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\vtgate\Session';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE result = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "result";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\query\QueryResult';
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <error> has a value
     *
     * @return boolean
     */
    public function hasError(){
      return $this->_has(1);
    }
    
    /**
     * Clear <error> value
     *
     * @return \vtgate\ExecuteEntityIdsResponse
     */
    public function clearError(){
      return $this->_clear(1);
    }
    
    /**
     * Get <error> value
     *
     * @return \vtrpc\RPCError
     */
    public function getError(){
      return $this->_get(1);
    }
    
    /**
     * Set <error> value
     *
     * @param \vtrpc\RPCError $value
     * @return \vtgate\ExecuteEntityIdsResponse
     */
    public function setError(\vtrpc\RPCError $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <session> has a value
     *
     * @return boolean
     */
    public function hasSession(){
      return $this->_has(2);
    }
    
    /**
     * Clear <session> value
     *
     * @return \vtgate\ExecuteEntityIdsResponse
     */
    public function clearSession(){
      return $this->_clear(2);
    }
    
    /**
     * Get <session> value
     *
     * @return \vtgate\Session
     */
    public function getSession(){
      return $this->_get(2);
    }
    
    /**
     * Set <session> value
     *
     * @param \vtgate\Session $value
     * @return \vtgate\ExecuteEntityIdsResponse
     */
    public function setSession(\vtgate\Session $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <result> has a value
     *
     * @return boolean
     */
    public function hasResult(){
      return $this->_has(3);
    }
    
    /**
     * Clear <result> value
     *
     * @return \vtgate\ExecuteEntityIdsResponse
     */
    public function clearResult(){
      return $this->_clear(3);
    }
    
    /**
     * Get <result> value
     *
     * @return \query\QueryResult
     */
    public function getResult(){
      return $this->_get(3);
    }
    
    /**
     * Set <result> value
     *
     * @param \query\QueryResult $value
     * @return \vtgate\ExecuteEntityIdsResponse
     */
    public function setResult(\query\QueryResult $value){
      return $this->_set(3, $value);
    }
  }
}

namespace vtgate {

  class BoundShardQuery extends \DrSlump\Protobuf\Message {

    /**  @var \query\BoundQuery */
    public $query = null;
    
    /**  @var string */
    public $keyspace = null;
    
    /**  @var string[]  */
    public $shards = array();
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, 'vtgate.BoundShardQuery');

      // OPTIONAL MESSAGE query = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "query";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\query\BoundQuery';
      $descriptor->addField($f);

      // OPTIONAL STRING keyspace = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "keyspace";
      $f->type      = \DrSlump\Protobuf::TYPE_STRING;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // REPEATED STRING shards = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "shards";
      $f->type      = \DrSlump\Protobuf::TYPE_STRING;
      $f->rule      = \DrSlump\Protobuf::RULE_REPEATED;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <query> has a value
     *
     * @return boolean
     */
    public function hasQuery(){
      return $this->_has(1);
    }
    
    /**
     * Clear <query> value
     *
     * @return \vtgate\BoundShardQuery
     */
    public function clearQuery(){
      return $this->_clear(1);
    }
    
    /**
     * Get <query> value
     *
     * @return \query\BoundQuery
     */
    public function getQuery(){
      return $this->_get(1);
    }
    
    /**
     * Set <query> value
     *
     * @param \query\BoundQuery $value
     * @return \vtgate\BoundShardQuery
     */
    public function setQuery(\query\BoundQuery $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <keyspace> has a value
     *
     * @return boolean
     */
    public function hasKeyspace(){
      return $this->_has(2);
    }
    
    /**
     * Clear <keyspace> value
     *
     * @return \vtgate\BoundShardQuery
     */
    public function clearKeyspace(){
      return $this->_clear(2);
    }
    
    /**
     * Get <keyspace> value
     *
     * @return string
     */
    public function getKeyspace(){
      return $this->_get(2);
    }
    
    /**
     * Set <keyspace> value
     *
     * @param string $value
     * @return \vtgate\BoundShardQuery
     */
    public function setKeyspace( $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <shards> has a value
     *
     * @return boolean
     */
    public function hasShards(){
      return $this->_has(3);
    }
    
    /**
     * Clear <shards> value
     *
     * @return \vtgate\BoundShardQuery
     */
    public function clearShards(){
      return $this->_clear(3);
    }
    
    /**
     * Get <shards> value
     *
     * @param int $idx
     * @return string
     */
    public function getShards($idx = NULL){
      return $this->_get(3, $idx);
    }
    
    /**
     * Set <shards> value
     *
     * @param string $value
     * @return \vtgate\BoundShardQuery
     */
    public function setShards( $value, $idx = NULL){
      return $this->_set(3, $value, $idx);
    }
    
    /**
     * Get all elements of <shards>
     *
     * @return string[]
     */
    public function getShardsList(){
     return $this->_get(3);
    }
    
    /**
     * Add a new element to <shards>
     *
     * @param string $value
     * @return \vtgate\BoundShardQuery
     */
    public function addShards( $value){
     return $this->_add(3, $value);
    }
  }
}

namespace vtgate {

  class ExecuteBatchShardsRequest extends \DrSlump\Protobuf\Message {

    /**  @var \vtrpc\CallerID */
    public $caller_id = null;
    
    /**  @var \vtgate\Session */
    public $session = null;
    
    /**  @var \vtgate\BoundShardQuery[]  */
    public $queries = array();
    
    /**  @var int - \topodata\TabletType */
    public $tablet_type = null;
    
    /**  @var boolean */
    public $as_transaction = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, 'vtgate.ExecuteBatchShardsRequest');

      // OPTIONAL MESSAGE caller_id = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "caller_id";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\vtrpc\CallerID';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE session = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "session";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\vtgate\Session';
      $descriptor->addField($f);

      // REPEATED MESSAGE queries = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "queries";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_REPEATED;
      $f->reference = '\vtgate\BoundShardQuery';
      $descriptor->addField($f);

      // OPTIONAL ENUM tablet_type = 4
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 4;
      $f->name      = "tablet_type";
      $f->type      = \DrSlump\Protobuf::TYPE_ENUM;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\topodata\TabletType';
      $descriptor->addField($f);

      // OPTIONAL BOOL as_transaction = 5
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 5;
      $f->name      = "as_transaction";
      $f->type      = \DrSlump\Protobuf::TYPE_BOOL;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <caller_id> has a value
     *
     * @return boolean
     */
    public function hasCallerId(){
      return $this->_has(1);
    }
    
    /**
     * Clear <caller_id> value
     *
     * @return \vtgate\ExecuteBatchShardsRequest
     */
    public function clearCallerId(){
      return $this->_clear(1);
    }
    
    /**
     * Get <caller_id> value
     *
     * @return \vtrpc\CallerID
     */
    public function getCallerId(){
      return $this->_get(1);
    }
    
    /**
     * Set <caller_id> value
     *
     * @param \vtrpc\CallerID $value
     * @return \vtgate\ExecuteBatchShardsRequest
     */
    public function setCallerId(\vtrpc\CallerID $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <session> has a value
     *
     * @return boolean
     */
    public function hasSession(){
      return $this->_has(2);
    }
    
    /**
     * Clear <session> value
     *
     * @return \vtgate\ExecuteBatchShardsRequest
     */
    public function clearSession(){
      return $this->_clear(2);
    }
    
    /**
     * Get <session> value
     *
     * @return \vtgate\Session
     */
    public function getSession(){
      return $this->_get(2);
    }
    
    /**
     * Set <session> value
     *
     * @param \vtgate\Session $value
     * @return \vtgate\ExecuteBatchShardsRequest
     */
    public function setSession(\vtgate\Session $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <queries> has a value
     *
     * @return boolean
     */
    public function hasQueries(){
      return $this->_has(3);
    }
    
    /**
     * Clear <queries> value
     *
     * @return \vtgate\ExecuteBatchShardsRequest
     */
    public function clearQueries(){
      return $this->_clear(3);
    }
    
    /**
     * Get <queries> value
     *
     * @param int $idx
     * @return \vtgate\BoundShardQuery
     */
    public function getQueries($idx = NULL){
      return $this->_get(3, $idx);
    }
    
    /**
     * Set <queries> value
     *
     * @param \vtgate\BoundShardQuery $value
     * @return \vtgate\ExecuteBatchShardsRequest
     */
    public function setQueries(\vtgate\BoundShardQuery $value, $idx = NULL){
      return $this->_set(3, $value, $idx);
    }
    
    /**
     * Get all elements of <queries>
     *
     * @return \vtgate\BoundShardQuery[]
     */
    public function getQueriesList(){
     return $this->_get(3);
    }
    
    /**
     * Add a new element to <queries>
     *
     * @param \vtgate\BoundShardQuery $value
     * @return \vtgate\ExecuteBatchShardsRequest
     */
    public function addQueries(\vtgate\BoundShardQuery $value){
     return $this->_add(3, $value);
    }
    
    /**
     * Check if <tablet_type> has a value
     *
     * @return boolean
     */
    public function hasTabletType(){
      return $this->_has(4);
    }
    
    /**
     * Clear <tablet_type> value
     *
     * @return \vtgate\ExecuteBatchShardsRequest
     */
    public function clearTabletType(){
      return $this->_clear(4);
    }
    
    /**
     * Get <tablet_type> value
     *
     * @return int - \topodata\TabletType
     */
    public function getTabletType(){
      return $this->_get(4);
    }
    
    /**
     * Set <tablet_type> value
     *
     * @param int - \topodata\TabletType $value
     * @return \vtgate\ExecuteBatchShardsRequest
     */
    public function setTabletType( $value){
      return $this->_set(4, $value);
    }
    
    /**
     * Check if <as_transaction> has a value
     *
     * @return boolean
     */
    public function hasAsTransaction(){
      return $this->_has(5);
    }
    
    /**
     * Clear <as_transaction> value
     *
     * @return \vtgate\ExecuteBatchShardsRequest
     */
    public function clearAsTransaction(){
      return $this->_clear(5);
    }
    
    /**
     * Get <as_transaction> value
     *
     * @return boolean
     */
    public function getAsTransaction(){
      return $this->_get(5);
    }
    
    /**
     * Set <as_transaction> value
     *
     * @param boolean $value
     * @return \vtgate\ExecuteBatchShardsRequest
     */
    public function setAsTransaction( $value){
      return $this->_set(5, $value);
    }
  }
}

namespace vtgate {

  class ExecuteBatchShardsResponse extends \DrSlump\Protobuf\Message {

    /**  @var \vtrpc\RPCError */
    public $error = null;
    
    /**  @var \vtgate\Session */
    public $session = null;
    
    /**  @var \query\QueryResult[]  */
    public $results = array();
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, 'vtgate.ExecuteBatchShardsResponse');

      // OPTIONAL MESSAGE error = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "error";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\vtrpc\RPCError';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE session = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "session";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\vtgate\Session';
      $descriptor->addField($f);

      // REPEATED MESSAGE results = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "results";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_REPEATED;
      $f->reference = '\query\QueryResult';
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <error> has a value
     *
     * @return boolean
     */
    public function hasError(){
      return $this->_has(1);
    }
    
    /**
     * Clear <error> value
     *
     * @return \vtgate\ExecuteBatchShardsResponse
     */
    public function clearError(){
      return $this->_clear(1);
    }
    
    /**
     * Get <error> value
     *
     * @return \vtrpc\RPCError
     */
    public function getError(){
      return $this->_get(1);
    }
    
    /**
     * Set <error> value
     *
     * @param \vtrpc\RPCError $value
     * @return \vtgate\ExecuteBatchShardsResponse
     */
    public function setError(\vtrpc\RPCError $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <session> has a value
     *
     * @return boolean
     */
    public function hasSession(){
      return $this->_has(2);
    }
    
    /**
     * Clear <session> value
     *
     * @return \vtgate\ExecuteBatchShardsResponse
     */
    public function clearSession(){
      return $this->_clear(2);
    }
    
    /**
     * Get <session> value
     *
     * @return \vtgate\Session
     */
    public function getSession(){
      return $this->_get(2);
    }
    
    /**
     * Set <session> value
     *
     * @param \vtgate\Session $value
     * @return \vtgate\ExecuteBatchShardsResponse
     */
    public function setSession(\vtgate\Session $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <results> has a value
     *
     * @return boolean
     */
    public function hasResults(){
      return $this->_has(3);
    }
    
    /**
     * Clear <results> value
     *
     * @return \vtgate\ExecuteBatchShardsResponse
     */
    public function clearResults(){
      return $this->_clear(3);
    }
    
    /**
     * Get <results> value
     *
     * @param int $idx
     * @return \query\QueryResult
     */
    public function getResults($idx = NULL){
      return $this->_get(3, $idx);
    }
    
    /**
     * Set <results> value
     *
     * @param \query\QueryResult $value
     * @return \vtgate\ExecuteBatchShardsResponse
     */
    public function setResults(\query\QueryResult $value, $idx = NULL){
      return $this->_set(3, $value, $idx);
    }
    
    /**
     * Get all elements of <results>
     *
     * @return \query\QueryResult[]
     */
    public function getResultsList(){
     return $this->_get(3);
    }
    
    /**
     * Add a new element to <results>
     *
     * @param \query\QueryResult $value
     * @return \vtgate\ExecuteBatchShardsResponse
     */
    public function addResults(\query\QueryResult $value){
     return $this->_add(3, $value);
    }
  }
}

namespace vtgate {

  class BoundKeyspaceIdQuery extends \DrSlump\Protobuf\Message {

    /**  @var \query\BoundQuery */
    public $query = null;
    
    /**  @var string */
    public $keyspace = null;
    
    /**  @var string[]  */
    public $keyspace_ids = array();
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, 'vtgate.BoundKeyspaceIdQuery');

      // OPTIONAL MESSAGE query = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "query";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\query\BoundQuery';
      $descriptor->addField($f);

      // OPTIONAL STRING keyspace = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "keyspace";
      $f->type      = \DrSlump\Protobuf::TYPE_STRING;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // REPEATED BYTES keyspace_ids = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "keyspace_ids";
      $f->type      = \DrSlump\Protobuf::TYPE_BYTES;
      $f->rule      = \DrSlump\Protobuf::RULE_REPEATED;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <query> has a value
     *
     * @return boolean
     */
    public function hasQuery(){
      return $this->_has(1);
    }
    
    /**
     * Clear <query> value
     *
     * @return \vtgate\BoundKeyspaceIdQuery
     */
    public function clearQuery(){
      return $this->_clear(1);
    }
    
    /**
     * Get <query> value
     *
     * @return \query\BoundQuery
     */
    public function getQuery(){
      return $this->_get(1);
    }
    
    /**
     * Set <query> value
     *
     * @param \query\BoundQuery $value
     * @return \vtgate\BoundKeyspaceIdQuery
     */
    public function setQuery(\query\BoundQuery $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <keyspace> has a value
     *
     * @return boolean
     */
    public function hasKeyspace(){
      return $this->_has(2);
    }
    
    /**
     * Clear <keyspace> value
     *
     * @return \vtgate\BoundKeyspaceIdQuery
     */
    public function clearKeyspace(){
      return $this->_clear(2);
    }
    
    /**
     * Get <keyspace> value
     *
     * @return string
     */
    public function getKeyspace(){
      return $this->_get(2);
    }
    
    /**
     * Set <keyspace> value
     *
     * @param string $value
     * @return \vtgate\BoundKeyspaceIdQuery
     */
    public function setKeyspace( $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <keyspace_ids> has a value
     *
     * @return boolean
     */
    public function hasKeyspaceIds(){
      return $this->_has(3);
    }
    
    /**
     * Clear <keyspace_ids> value
     *
     * @return \vtgate\BoundKeyspaceIdQuery
     */
    public function clearKeyspaceIds(){
      return $this->_clear(3);
    }
    
    /**
     * Get <keyspace_ids> value
     *
     * @param int $idx
     * @return string
     */
    public function getKeyspaceIds($idx = NULL){
      return $this->_get(3, $idx);
    }
    
    /**
     * Set <keyspace_ids> value
     *
     * @param string $value
     * @return \vtgate\BoundKeyspaceIdQuery
     */
    public function setKeyspaceIds( $value, $idx = NULL){
      return $this->_set(3, $value, $idx);
    }
    
    /**
     * Get all elements of <keyspace_ids>
     *
     * @return string[]
     */
    public function getKeyspaceIdsList(){
     return $this->_get(3);
    }
    
    /**
     * Add a new element to <keyspace_ids>
     *
     * @param string $value
     * @return \vtgate\BoundKeyspaceIdQuery
     */
    public function addKeyspaceIds( $value){
     return $this->_add(3, $value);
    }
  }
}

namespace vtgate {

  class ExecuteBatchKeyspaceIdsRequest extends \DrSlump\Protobuf\Message {

    /**  @var \vtrpc\CallerID */
    public $caller_id = null;
    
    /**  @var \vtgate\Session */
    public $session = null;
    
    /**  @var \vtgate\BoundKeyspaceIdQuery[]  */
    public $queries = array();
    
    /**  @var int - \topodata\TabletType */
    public $tablet_type = null;
    
    /**  @var boolean */
    public $as_transaction = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, 'vtgate.ExecuteBatchKeyspaceIdsRequest');

      // OPTIONAL MESSAGE caller_id = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "caller_id";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\vtrpc\CallerID';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE session = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "session";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\vtgate\Session';
      $descriptor->addField($f);

      // REPEATED MESSAGE queries = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "queries";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_REPEATED;
      $f->reference = '\vtgate\BoundKeyspaceIdQuery';
      $descriptor->addField($f);

      // OPTIONAL ENUM tablet_type = 4
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 4;
      $f->name      = "tablet_type";
      $f->type      = \DrSlump\Protobuf::TYPE_ENUM;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\topodata\TabletType';
      $descriptor->addField($f);

      // OPTIONAL BOOL as_transaction = 5
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 5;
      $f->name      = "as_transaction";
      $f->type      = \DrSlump\Protobuf::TYPE_BOOL;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <caller_id> has a value
     *
     * @return boolean
     */
    public function hasCallerId(){
      return $this->_has(1);
    }
    
    /**
     * Clear <caller_id> value
     *
     * @return \vtgate\ExecuteBatchKeyspaceIdsRequest
     */
    public function clearCallerId(){
      return $this->_clear(1);
    }
    
    /**
     * Get <caller_id> value
     *
     * @return \vtrpc\CallerID
     */
    public function getCallerId(){
      return $this->_get(1);
    }
    
    /**
     * Set <caller_id> value
     *
     * @param \vtrpc\CallerID $value
     * @return \vtgate\ExecuteBatchKeyspaceIdsRequest
     */
    public function setCallerId(\vtrpc\CallerID $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <session> has a value
     *
     * @return boolean
     */
    public function hasSession(){
      return $this->_has(2);
    }
    
    /**
     * Clear <session> value
     *
     * @return \vtgate\ExecuteBatchKeyspaceIdsRequest
     */
    public function clearSession(){
      return $this->_clear(2);
    }
    
    /**
     * Get <session> value
     *
     * @return \vtgate\Session
     */
    public function getSession(){
      return $this->_get(2);
    }
    
    /**
     * Set <session> value
     *
     * @param \vtgate\Session $value
     * @return \vtgate\ExecuteBatchKeyspaceIdsRequest
     */
    public function setSession(\vtgate\Session $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <queries> has a value
     *
     * @return boolean
     */
    public function hasQueries(){
      return $this->_has(3);
    }
    
    /**
     * Clear <queries> value
     *
     * @return \vtgate\ExecuteBatchKeyspaceIdsRequest
     */
    public function clearQueries(){
      return $this->_clear(3);
    }
    
    /**
     * Get <queries> value
     *
     * @param int $idx
     * @return \vtgate\BoundKeyspaceIdQuery
     */
    public function getQueries($idx = NULL){
      return $this->_get(3, $idx);
    }
    
    /**
     * Set <queries> value
     *
     * @param \vtgate\BoundKeyspaceIdQuery $value
     * @return \vtgate\ExecuteBatchKeyspaceIdsRequest
     */
    public function setQueries(\vtgate\BoundKeyspaceIdQuery $value, $idx = NULL){
      return $this->_set(3, $value, $idx);
    }
    
    /**
     * Get all elements of <queries>
     *
     * @return \vtgate\BoundKeyspaceIdQuery[]
     */
    public function getQueriesList(){
     return $this->_get(3);
    }
    
    /**
     * Add a new element to <queries>
     *
     * @param \vtgate\BoundKeyspaceIdQuery $value
     * @return \vtgate\ExecuteBatchKeyspaceIdsRequest
     */
    public function addQueries(\vtgate\BoundKeyspaceIdQuery $value){
     return $this->_add(3, $value);
    }
    
    /**
     * Check if <tablet_type> has a value
     *
     * @return boolean
     */
    public function hasTabletType(){
      return $this->_has(4);
    }
    
    /**
     * Clear <tablet_type> value
     *
     * @return \vtgate\ExecuteBatchKeyspaceIdsRequest
     */
    public function clearTabletType(){
      return $this->_clear(4);
    }
    
    /**
     * Get <tablet_type> value
     *
     * @return int - \topodata\TabletType
     */
    public function getTabletType(){
      return $this->_get(4);
    }
    
    /**
     * Set <tablet_type> value
     *
     * @param int - \topodata\TabletType $value
     * @return \vtgate\ExecuteBatchKeyspaceIdsRequest
     */
    public function setTabletType( $value){
      return $this->_set(4, $value);
    }
    
    /**
     * Check if <as_transaction> has a value
     *
     * @return boolean
     */
    public function hasAsTransaction(){
      return $this->_has(5);
    }
    
    /**
     * Clear <as_transaction> value
     *
     * @return \vtgate\ExecuteBatchKeyspaceIdsRequest
     */
    public function clearAsTransaction(){
      return $this->_clear(5);
    }
    
    /**
     * Get <as_transaction> value
     *
     * @return boolean
     */
    public function getAsTransaction(){
      return $this->_get(5);
    }
    
    /**
     * Set <as_transaction> value
     *
     * @param boolean $value
     * @return \vtgate\ExecuteBatchKeyspaceIdsRequest
     */
    public function setAsTransaction( $value){
      return $this->_set(5, $value);
    }
  }
}

namespace vtgate {

  class ExecuteBatchKeyspaceIdsResponse extends \DrSlump\Protobuf\Message {

    /**  @var \vtrpc\RPCError */
    public $error = null;
    
    /**  @var \vtgate\Session */
    public $session = null;
    
    /**  @var \query\QueryResult[]  */
    public $results = array();
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, 'vtgate.ExecuteBatchKeyspaceIdsResponse');

      // OPTIONAL MESSAGE error = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "error";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\vtrpc\RPCError';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE session = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "session";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\vtgate\Session';
      $descriptor->addField($f);

      // REPEATED MESSAGE results = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "results";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_REPEATED;
      $f->reference = '\query\QueryResult';
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <error> has a value
     *
     * @return boolean
     */
    public function hasError(){
      return $this->_has(1);
    }
    
    /**
     * Clear <error> value
     *
     * @return \vtgate\ExecuteBatchKeyspaceIdsResponse
     */
    public function clearError(){
      return $this->_clear(1);
    }
    
    /**
     * Get <error> value
     *
     * @return \vtrpc\RPCError
     */
    public function getError(){
      return $this->_get(1);
    }
    
    /**
     * Set <error> value
     *
     * @param \vtrpc\RPCError $value
     * @return \vtgate\ExecuteBatchKeyspaceIdsResponse
     */
    public function setError(\vtrpc\RPCError $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <session> has a value
     *
     * @return boolean
     */
    public function hasSession(){
      return $this->_has(2);
    }
    
    /**
     * Clear <session> value
     *
     * @return \vtgate\ExecuteBatchKeyspaceIdsResponse
     */
    public function clearSession(){
      return $this->_clear(2);
    }
    
    /**
     * Get <session> value
     *
     * @return \vtgate\Session
     */
    public function getSession(){
      return $this->_get(2);
    }
    
    /**
     * Set <session> value
     *
     * @param \vtgate\Session $value
     * @return \vtgate\ExecuteBatchKeyspaceIdsResponse
     */
    public function setSession(\vtgate\Session $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <results> has a value
     *
     * @return boolean
     */
    public function hasResults(){
      return $this->_has(3);
    }
    
    /**
     * Clear <results> value
     *
     * @return \vtgate\ExecuteBatchKeyspaceIdsResponse
     */
    public function clearResults(){
      return $this->_clear(3);
    }
    
    /**
     * Get <results> value
     *
     * @param int $idx
     * @return \query\QueryResult
     */
    public function getResults($idx = NULL){
      return $this->_get(3, $idx);
    }
    
    /**
     * Set <results> value
     *
     * @param \query\QueryResult $value
     * @return \vtgate\ExecuteBatchKeyspaceIdsResponse
     */
    public function setResults(\query\QueryResult $value, $idx = NULL){
      return $this->_set(3, $value, $idx);
    }
    
    /**
     * Get all elements of <results>
     *
     * @return \query\QueryResult[]
     */
    public function getResultsList(){
     return $this->_get(3);
    }
    
    /**
     * Add a new element to <results>
     *
     * @param \query\QueryResult $value
     * @return \vtgate\ExecuteBatchKeyspaceIdsResponse
     */
    public function addResults(\query\QueryResult $value){
     return $this->_add(3, $value);
    }
  }
}

namespace vtgate {

  class StreamExecuteRequest extends \DrSlump\Protobuf\Message {

    /**  @var \vtrpc\CallerID */
    public $caller_id = null;
    
    /**  @var \query\BoundQuery */
    public $query = null;
    
    /**  @var int - \topodata\TabletType */
    public $tablet_type = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, 'vtgate.StreamExecuteRequest');

      // OPTIONAL MESSAGE caller_id = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "caller_id";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\vtrpc\CallerID';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE query = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "query";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\query\BoundQuery';
      $descriptor->addField($f);

      // OPTIONAL ENUM tablet_type = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "tablet_type";
      $f->type      = \DrSlump\Protobuf::TYPE_ENUM;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\topodata\TabletType';
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <caller_id> has a value
     *
     * @return boolean
     */
    public function hasCallerId(){
      return $this->_has(1);
    }
    
    /**
     * Clear <caller_id> value
     *
     * @return \vtgate\StreamExecuteRequest
     */
    public function clearCallerId(){
      return $this->_clear(1);
    }
    
    /**
     * Get <caller_id> value
     *
     * @return \vtrpc\CallerID
     */
    public function getCallerId(){
      return $this->_get(1);
    }
    
    /**
     * Set <caller_id> value
     *
     * @param \vtrpc\CallerID $value
     * @return \vtgate\StreamExecuteRequest
     */
    public function setCallerId(\vtrpc\CallerID $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <query> has a value
     *
     * @return boolean
     */
    public function hasQuery(){
      return $this->_has(2);
    }
    
    /**
     * Clear <query> value
     *
     * @return \vtgate\StreamExecuteRequest
     */
    public function clearQuery(){
      return $this->_clear(2);
    }
    
    /**
     * Get <query> value
     *
     * @return \query\BoundQuery
     */
    public function getQuery(){
      return $this->_get(2);
    }
    
    /**
     * Set <query> value
     *
     * @param \query\BoundQuery $value
     * @return \vtgate\StreamExecuteRequest
     */
    public function setQuery(\query\BoundQuery $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <tablet_type> has a value
     *
     * @return boolean
     */
    public function hasTabletType(){
      return $this->_has(3);
    }
    
    /**
     * Clear <tablet_type> value
     *
     * @return \vtgate\StreamExecuteRequest
     */
    public function clearTabletType(){
      return $this->_clear(3);
    }
    
    /**
     * Get <tablet_type> value
     *
     * @return int - \topodata\TabletType
     */
    public function getTabletType(){
      return $this->_get(3);
    }
    
    /**
     * Set <tablet_type> value
     *
     * @param int - \topodata\TabletType $value
     * @return \vtgate\StreamExecuteRequest
     */
    public function setTabletType( $value){
      return $this->_set(3, $value);
    }
  }
}

namespace vtgate {

  class StreamExecuteResponse extends \DrSlump\Protobuf\Message {

    /**  @var \query\QueryResult */
    public $result = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, 'vtgate.StreamExecuteResponse');

      // OPTIONAL MESSAGE result = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "result";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\query\QueryResult';
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <result> has a value
     *
     * @return boolean
     */
    public function hasResult(){
      return $this->_has(1);
    }
    
    /**
     * Clear <result> value
     *
     * @return \vtgate\StreamExecuteResponse
     */
    public function clearResult(){
      return $this->_clear(1);
    }
    
    /**
     * Get <result> value
     *
     * @return \query\QueryResult
     */
    public function getResult(){
      return $this->_get(1);
    }
    
    /**
     * Set <result> value
     *
     * @param \query\QueryResult $value
     * @return \vtgate\StreamExecuteResponse
     */
    public function setResult(\query\QueryResult $value){
      return $this->_set(1, $value);
    }
  }
}

namespace vtgate {

  class StreamExecuteShardsRequest extends \DrSlump\Protobuf\Message {

    /**  @var \vtrpc\CallerID */
    public $caller_id = null;
    
    /**  @var \query\BoundQuery */
    public $query = null;
    
    /**  @var string */
    public $keyspace = null;
    
    /**  @var string[]  */
    public $shards = array();
    
    /**  @var int - \topodata\TabletType */
    public $tablet_type = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, 'vtgate.StreamExecuteShardsRequest');

      // OPTIONAL MESSAGE caller_id = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "caller_id";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\vtrpc\CallerID';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE query = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "query";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\query\BoundQuery';
      $descriptor->addField($f);

      // OPTIONAL STRING keyspace = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "keyspace";
      $f->type      = \DrSlump\Protobuf::TYPE_STRING;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // REPEATED STRING shards = 4
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 4;
      $f->name      = "shards";
      $f->type      = \DrSlump\Protobuf::TYPE_STRING;
      $f->rule      = \DrSlump\Protobuf::RULE_REPEATED;
      $descriptor->addField($f);

      // OPTIONAL ENUM tablet_type = 5
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 5;
      $f->name      = "tablet_type";
      $f->type      = \DrSlump\Protobuf::TYPE_ENUM;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\topodata\TabletType';
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <caller_id> has a value
     *
     * @return boolean
     */
    public function hasCallerId(){
      return $this->_has(1);
    }
    
    /**
     * Clear <caller_id> value
     *
     * @return \vtgate\StreamExecuteShardsRequest
     */
    public function clearCallerId(){
      return $this->_clear(1);
    }
    
    /**
     * Get <caller_id> value
     *
     * @return \vtrpc\CallerID
     */
    public function getCallerId(){
      return $this->_get(1);
    }
    
    /**
     * Set <caller_id> value
     *
     * @param \vtrpc\CallerID $value
     * @return \vtgate\StreamExecuteShardsRequest
     */
    public function setCallerId(\vtrpc\CallerID $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <query> has a value
     *
     * @return boolean
     */
    public function hasQuery(){
      return $this->_has(2);
    }
    
    /**
     * Clear <query> value
     *
     * @return \vtgate\StreamExecuteShardsRequest
     */
    public function clearQuery(){
      return $this->_clear(2);
    }
    
    /**
     * Get <query> value
     *
     * @return \query\BoundQuery
     */
    public function getQuery(){
      return $this->_get(2);
    }
    
    /**
     * Set <query> value
     *
     * @param \query\BoundQuery $value
     * @return \vtgate\StreamExecuteShardsRequest
     */
    public function setQuery(\query\BoundQuery $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <keyspace> has a value
     *
     * @return boolean
     */
    public function hasKeyspace(){
      return $this->_has(3);
    }
    
    /**
     * Clear <keyspace> value
     *
     * @return \vtgate\StreamExecuteShardsRequest
     */
    public function clearKeyspace(){
      return $this->_clear(3);
    }
    
    /**
     * Get <keyspace> value
     *
     * @return string
     */
    public function getKeyspace(){
      return $this->_get(3);
    }
    
    /**
     * Set <keyspace> value
     *
     * @param string $value
     * @return \vtgate\StreamExecuteShardsRequest
     */
    public function setKeyspace( $value){
      return $this->_set(3, $value);
    }
    
    /**
     * Check if <shards> has a value
     *
     * @return boolean
     */
    public function hasShards(){
      return $this->_has(4);
    }
    
    /**
     * Clear <shards> value
     *
     * @return \vtgate\StreamExecuteShardsRequest
     */
    public function clearShards(){
      return $this->_clear(4);
    }
    
    /**
     * Get <shards> value
     *
     * @param int $idx
     * @return string
     */
    public function getShards($idx = NULL){
      return $this->_get(4, $idx);
    }
    
    /**
     * Set <shards> value
     *
     * @param string $value
     * @return \vtgate\StreamExecuteShardsRequest
     */
    public function setShards( $value, $idx = NULL){
      return $this->_set(4, $value, $idx);
    }
    
    /**
     * Get all elements of <shards>
     *
     * @return string[]
     */
    public function getShardsList(){
     return $this->_get(4);
    }
    
    /**
     * Add a new element to <shards>
     *
     * @param string $value
     * @return \vtgate\StreamExecuteShardsRequest
     */
    public function addShards( $value){
     return $this->_add(4, $value);
    }
    
    /**
     * Check if <tablet_type> has a value
     *
     * @return boolean
     */
    public function hasTabletType(){
      return $this->_has(5);
    }
    
    /**
     * Clear <tablet_type> value
     *
     * @return \vtgate\StreamExecuteShardsRequest
     */
    public function clearTabletType(){
      return $this->_clear(5);
    }
    
    /**
     * Get <tablet_type> value
     *
     * @return int - \topodata\TabletType
     */
    public function getTabletType(){
      return $this->_get(5);
    }
    
    /**
     * Set <tablet_type> value
     *
     * @param int - \topodata\TabletType $value
     * @return \vtgate\StreamExecuteShardsRequest
     */
    public function setTabletType( $value){
      return $this->_set(5, $value);
    }
  }
}

namespace vtgate {

  class StreamExecuteShardsResponse extends \DrSlump\Protobuf\Message {

    /**  @var \query\QueryResult */
    public $result = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, 'vtgate.StreamExecuteShardsResponse');

      // OPTIONAL MESSAGE result = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "result";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\query\QueryResult';
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <result> has a value
     *
     * @return boolean
     */
    public function hasResult(){
      return $this->_has(1);
    }
    
    /**
     * Clear <result> value
     *
     * @return \vtgate\StreamExecuteShardsResponse
     */
    public function clearResult(){
      return $this->_clear(1);
    }
    
    /**
     * Get <result> value
     *
     * @return \query\QueryResult
     */
    public function getResult(){
      return $this->_get(1);
    }
    
    /**
     * Set <result> value
     *
     * @param \query\QueryResult $value
     * @return \vtgate\StreamExecuteShardsResponse
     */
    public function setResult(\query\QueryResult $value){
      return $this->_set(1, $value);
    }
  }
}

namespace vtgate {

  class StreamExecuteKeyspaceIdsRequest extends \DrSlump\Protobuf\Message {

    /**  @var \vtrpc\CallerID */
    public $caller_id = null;
    
    /**  @var \query\BoundQuery */
    public $query = null;
    
    /**  @var string */
    public $keyspace = null;
    
    /**  @var string[]  */
    public $keyspace_ids = array();
    
    /**  @var int - \topodata\TabletType */
    public $tablet_type = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, 'vtgate.StreamExecuteKeyspaceIdsRequest');

      // OPTIONAL MESSAGE caller_id = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "caller_id";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\vtrpc\CallerID';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE query = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "query";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\query\BoundQuery';
      $descriptor->addField($f);

      // OPTIONAL STRING keyspace = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "keyspace";
      $f->type      = \DrSlump\Protobuf::TYPE_STRING;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // REPEATED BYTES keyspace_ids = 4
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 4;
      $f->name      = "keyspace_ids";
      $f->type      = \DrSlump\Protobuf::TYPE_BYTES;
      $f->rule      = \DrSlump\Protobuf::RULE_REPEATED;
      $descriptor->addField($f);

      // OPTIONAL ENUM tablet_type = 5
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 5;
      $f->name      = "tablet_type";
      $f->type      = \DrSlump\Protobuf::TYPE_ENUM;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\topodata\TabletType';
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <caller_id> has a value
     *
     * @return boolean
     */
    public function hasCallerId(){
      return $this->_has(1);
    }
    
    /**
     * Clear <caller_id> value
     *
     * @return \vtgate\StreamExecuteKeyspaceIdsRequest
     */
    public function clearCallerId(){
      return $this->_clear(1);
    }
    
    /**
     * Get <caller_id> value
     *
     * @return \vtrpc\CallerID
     */
    public function getCallerId(){
      return $this->_get(1);
    }
    
    /**
     * Set <caller_id> value
     *
     * @param \vtrpc\CallerID $value
     * @return \vtgate\StreamExecuteKeyspaceIdsRequest
     */
    public function setCallerId(\vtrpc\CallerID $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <query> has a value
     *
     * @return boolean
     */
    public function hasQuery(){
      return $this->_has(2);
    }
    
    /**
     * Clear <query> value
     *
     * @return \vtgate\StreamExecuteKeyspaceIdsRequest
     */
    public function clearQuery(){
      return $this->_clear(2);
    }
    
    /**
     * Get <query> value
     *
     * @return \query\BoundQuery
     */
    public function getQuery(){
      return $this->_get(2);
    }
    
    /**
     * Set <query> value
     *
     * @param \query\BoundQuery $value
     * @return \vtgate\StreamExecuteKeyspaceIdsRequest
     */
    public function setQuery(\query\BoundQuery $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <keyspace> has a value
     *
     * @return boolean
     */
    public function hasKeyspace(){
      return $this->_has(3);
    }
    
    /**
     * Clear <keyspace> value
     *
     * @return \vtgate\StreamExecuteKeyspaceIdsRequest
     */
    public function clearKeyspace(){
      return $this->_clear(3);
    }
    
    /**
     * Get <keyspace> value
     *
     * @return string
     */
    public function getKeyspace(){
      return $this->_get(3);
    }
    
    /**
     * Set <keyspace> value
     *
     * @param string $value
     * @return \vtgate\StreamExecuteKeyspaceIdsRequest
     */
    public function setKeyspace( $value){
      return $this->_set(3, $value);
    }
    
    /**
     * Check if <keyspace_ids> has a value
     *
     * @return boolean
     */
    public function hasKeyspaceIds(){
      return $this->_has(4);
    }
    
    /**
     * Clear <keyspace_ids> value
     *
     * @return \vtgate\StreamExecuteKeyspaceIdsRequest
     */
    public function clearKeyspaceIds(){
      return $this->_clear(4);
    }
    
    /**
     * Get <keyspace_ids> value
     *
     * @param int $idx
     * @return string
     */
    public function getKeyspaceIds($idx = NULL){
      return $this->_get(4, $idx);
    }
    
    /**
     * Set <keyspace_ids> value
     *
     * @param string $value
     * @return \vtgate\StreamExecuteKeyspaceIdsRequest
     */
    public function setKeyspaceIds( $value, $idx = NULL){
      return $this->_set(4, $value, $idx);
    }
    
    /**
     * Get all elements of <keyspace_ids>
     *
     * @return string[]
     */
    public function getKeyspaceIdsList(){
     return $this->_get(4);
    }
    
    /**
     * Add a new element to <keyspace_ids>
     *
     * @param string $value
     * @return \vtgate\StreamExecuteKeyspaceIdsRequest
     */
    public function addKeyspaceIds( $value){
     return $this->_add(4, $value);
    }
    
    /**
     * Check if <tablet_type> has a value
     *
     * @return boolean
     */
    public function hasTabletType(){
      return $this->_has(5);
    }
    
    /**
     * Clear <tablet_type> value
     *
     * @return \vtgate\StreamExecuteKeyspaceIdsRequest
     */
    public function clearTabletType(){
      return $this->_clear(5);
    }
    
    /**
     * Get <tablet_type> value
     *
     * @return int - \topodata\TabletType
     */
    public function getTabletType(){
      return $this->_get(5);
    }
    
    /**
     * Set <tablet_type> value
     *
     * @param int - \topodata\TabletType $value
     * @return \vtgate\StreamExecuteKeyspaceIdsRequest
     */
    public function setTabletType( $value){
      return $this->_set(5, $value);
    }
  }
}

namespace vtgate {

  class StreamExecuteKeyspaceIdsResponse extends \DrSlump\Protobuf\Message {

    /**  @var \query\QueryResult */
    public $result = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, 'vtgate.StreamExecuteKeyspaceIdsResponse');

      // OPTIONAL MESSAGE result = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "result";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\query\QueryResult';
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <result> has a value
     *
     * @return boolean
     */
    public function hasResult(){
      return $this->_has(1);
    }
    
    /**
     * Clear <result> value
     *
     * @return \vtgate\StreamExecuteKeyspaceIdsResponse
     */
    public function clearResult(){
      return $this->_clear(1);
    }
    
    /**
     * Get <result> value
     *
     * @return \query\QueryResult
     */
    public function getResult(){
      return $this->_get(1);
    }
    
    /**
     * Set <result> value
     *
     * @param \query\QueryResult $value
     * @return \vtgate\StreamExecuteKeyspaceIdsResponse
     */
    public function setResult(\query\QueryResult $value){
      return $this->_set(1, $value);
    }
  }
}

namespace vtgate {

  class StreamExecuteKeyRangesRequest extends \DrSlump\Protobuf\Message {

    /**  @var \vtrpc\CallerID */
    public $caller_id = null;
    
    /**  @var \query\BoundQuery */
    public $query = null;
    
    /**  @var string */
    public $keyspace = null;
    
    /**  @var \topodata\KeyRange[]  */
    public $key_ranges = array();
    
    /**  @var int - \topodata\TabletType */
    public $tablet_type = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, 'vtgate.StreamExecuteKeyRangesRequest');

      // OPTIONAL MESSAGE caller_id = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "caller_id";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\vtrpc\CallerID';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE query = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "query";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\query\BoundQuery';
      $descriptor->addField($f);

      // OPTIONAL STRING keyspace = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "keyspace";
      $f->type      = \DrSlump\Protobuf::TYPE_STRING;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // REPEATED MESSAGE key_ranges = 4
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 4;
      $f->name      = "key_ranges";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_REPEATED;
      $f->reference = '\topodata\KeyRange';
      $descriptor->addField($f);

      // OPTIONAL ENUM tablet_type = 5
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 5;
      $f->name      = "tablet_type";
      $f->type      = \DrSlump\Protobuf::TYPE_ENUM;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\topodata\TabletType';
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <caller_id> has a value
     *
     * @return boolean
     */
    public function hasCallerId(){
      return $this->_has(1);
    }
    
    /**
     * Clear <caller_id> value
     *
     * @return \vtgate\StreamExecuteKeyRangesRequest
     */
    public function clearCallerId(){
      return $this->_clear(1);
    }
    
    /**
     * Get <caller_id> value
     *
     * @return \vtrpc\CallerID
     */
    public function getCallerId(){
      return $this->_get(1);
    }
    
    /**
     * Set <caller_id> value
     *
     * @param \vtrpc\CallerID $value
     * @return \vtgate\StreamExecuteKeyRangesRequest
     */
    public function setCallerId(\vtrpc\CallerID $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <query> has a value
     *
     * @return boolean
     */
    public function hasQuery(){
      return $this->_has(2);
    }
    
    /**
     * Clear <query> value
     *
     * @return \vtgate\StreamExecuteKeyRangesRequest
     */
    public function clearQuery(){
      return $this->_clear(2);
    }
    
    /**
     * Get <query> value
     *
     * @return \query\BoundQuery
     */
    public function getQuery(){
      return $this->_get(2);
    }
    
    /**
     * Set <query> value
     *
     * @param \query\BoundQuery $value
     * @return \vtgate\StreamExecuteKeyRangesRequest
     */
    public function setQuery(\query\BoundQuery $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <keyspace> has a value
     *
     * @return boolean
     */
    public function hasKeyspace(){
      return $this->_has(3);
    }
    
    /**
     * Clear <keyspace> value
     *
     * @return \vtgate\StreamExecuteKeyRangesRequest
     */
    public function clearKeyspace(){
      return $this->_clear(3);
    }
    
    /**
     * Get <keyspace> value
     *
     * @return string
     */
    public function getKeyspace(){
      return $this->_get(3);
    }
    
    /**
     * Set <keyspace> value
     *
     * @param string $value
     * @return \vtgate\StreamExecuteKeyRangesRequest
     */
    public function setKeyspace( $value){
      return $this->_set(3, $value);
    }
    
    /**
     * Check if <key_ranges> has a value
     *
     * @return boolean
     */
    public function hasKeyRanges(){
      return $this->_has(4);
    }
    
    /**
     * Clear <key_ranges> value
     *
     * @return \vtgate\StreamExecuteKeyRangesRequest
     */
    public function clearKeyRanges(){
      return $this->_clear(4);
    }
    
    /**
     * Get <key_ranges> value
     *
     * @param int $idx
     * @return \topodata\KeyRange
     */
    public function getKeyRanges($idx = NULL){
      return $this->_get(4, $idx);
    }
    
    /**
     * Set <key_ranges> value
     *
     * @param \topodata\KeyRange $value
     * @return \vtgate\StreamExecuteKeyRangesRequest
     */
    public function setKeyRanges(\topodata\KeyRange $value, $idx = NULL){
      return $this->_set(4, $value, $idx);
    }
    
    /**
     * Get all elements of <key_ranges>
     *
     * @return \topodata\KeyRange[]
     */
    public function getKeyRangesList(){
     return $this->_get(4);
    }
    
    /**
     * Add a new element to <key_ranges>
     *
     * @param \topodata\KeyRange $value
     * @return \vtgate\StreamExecuteKeyRangesRequest
     */
    public function addKeyRanges(\topodata\KeyRange $value){
     return $this->_add(4, $value);
    }
    
    /**
     * Check if <tablet_type> has a value
     *
     * @return boolean
     */
    public function hasTabletType(){
      return $this->_has(5);
    }
    
    /**
     * Clear <tablet_type> value
     *
     * @return \vtgate\StreamExecuteKeyRangesRequest
     */
    public function clearTabletType(){
      return $this->_clear(5);
    }
    
    /**
     * Get <tablet_type> value
     *
     * @return int - \topodata\TabletType
     */
    public function getTabletType(){
      return $this->_get(5);
    }
    
    /**
     * Set <tablet_type> value
     *
     * @param int - \topodata\TabletType $value
     * @return \vtgate\StreamExecuteKeyRangesRequest
     */
    public function setTabletType( $value){
      return $this->_set(5, $value);
    }
  }
}

namespace vtgate {

  class StreamExecuteKeyRangesResponse extends \DrSlump\Protobuf\Message {

    /**  @var \query\QueryResult */
    public $result = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, 'vtgate.StreamExecuteKeyRangesResponse');

      // OPTIONAL MESSAGE result = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "result";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\query\QueryResult';
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <result> has a value
     *
     * @return boolean
     */
    public function hasResult(){
      return $this->_has(1);
    }
    
    /**
     * Clear <result> value
     *
     * @return \vtgate\StreamExecuteKeyRangesResponse
     */
    public function clearResult(){
      return $this->_clear(1);
    }
    
    /**
     * Get <result> value
     *
     * @return \query\QueryResult
     */
    public function getResult(){
      return $this->_get(1);
    }
    
    /**
     * Set <result> value
     *
     * @param \query\QueryResult $value
     * @return \vtgate\StreamExecuteKeyRangesResponse
     */
    public function setResult(\query\QueryResult $value){
      return $this->_set(1, $value);
    }
  }
}

namespace vtgate {

  class BeginRequest extends \DrSlump\Protobuf\Message {

    /**  @var \vtrpc\CallerID */
    public $caller_id = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, 'vtgate.BeginRequest');

      // OPTIONAL MESSAGE caller_id = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "caller_id";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\vtrpc\CallerID';
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <caller_id> has a value
     *
     * @return boolean
     */
    public function hasCallerId(){
      return $this->_has(1);
    }
    
    /**
     * Clear <caller_id> value
     *
     * @return \vtgate\BeginRequest
     */
    public function clearCallerId(){
      return $this->_clear(1);
    }
    
    /**
     * Get <caller_id> value
     *
     * @return \vtrpc\CallerID
     */
    public function getCallerId(){
      return $this->_get(1);
    }
    
    /**
     * Set <caller_id> value
     *
     * @param \vtrpc\CallerID $value
     * @return \vtgate\BeginRequest
     */
    public function setCallerId(\vtrpc\CallerID $value){
      return $this->_set(1, $value);
    }
  }
}

namespace vtgate {

  class BeginResponse extends \DrSlump\Protobuf\Message {

    /**  @var \vtgate\Session */
    public $session = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, 'vtgate.BeginResponse');

      // OPTIONAL MESSAGE session = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "session";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\vtgate\Session';
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <session> has a value
     *
     * @return boolean
     */
    public function hasSession(){
      return $this->_has(1);
    }
    
    /**
     * Clear <session> value
     *
     * @return \vtgate\BeginResponse
     */
    public function clearSession(){
      return $this->_clear(1);
    }
    
    /**
     * Get <session> value
     *
     * @return \vtgate\Session
     */
    public function getSession(){
      return $this->_get(1);
    }
    
    /**
     * Set <session> value
     *
     * @param \vtgate\Session $value
     * @return \vtgate\BeginResponse
     */
    public function setSession(\vtgate\Session $value){
      return $this->_set(1, $value);
    }
  }
}

namespace vtgate {

  class CommitRequest extends \DrSlump\Protobuf\Message {

    /**  @var \vtrpc\CallerID */
    public $caller_id = null;
    
    /**  @var \vtgate\Session */
    public $session = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, 'vtgate.CommitRequest');

      // OPTIONAL MESSAGE caller_id = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "caller_id";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\vtrpc\CallerID';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE session = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "session";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\vtgate\Session';
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <caller_id> has a value
     *
     * @return boolean
     */
    public function hasCallerId(){
      return $this->_has(1);
    }
    
    /**
     * Clear <caller_id> value
     *
     * @return \vtgate\CommitRequest
     */
    public function clearCallerId(){
      return $this->_clear(1);
    }
    
    /**
     * Get <caller_id> value
     *
     * @return \vtrpc\CallerID
     */
    public function getCallerId(){
      return $this->_get(1);
    }
    
    /**
     * Set <caller_id> value
     *
     * @param \vtrpc\CallerID $value
     * @return \vtgate\CommitRequest
     */
    public function setCallerId(\vtrpc\CallerID $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <session> has a value
     *
     * @return boolean
     */
    public function hasSession(){
      return $this->_has(2);
    }
    
    /**
     * Clear <session> value
     *
     * @return \vtgate\CommitRequest
     */
    public function clearSession(){
      return $this->_clear(2);
    }
    
    /**
     * Get <session> value
     *
     * @return \vtgate\Session
     */
    public function getSession(){
      return $this->_get(2);
    }
    
    /**
     * Set <session> value
     *
     * @param \vtgate\Session $value
     * @return \vtgate\CommitRequest
     */
    public function setSession(\vtgate\Session $value){
      return $this->_set(2, $value);
    }
  }
}

namespace vtgate {

  class CommitResponse extends \DrSlump\Protobuf\Message {


    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, 'vtgate.CommitResponse');

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }
  }
}

namespace vtgate {

  class RollbackRequest extends \DrSlump\Protobuf\Message {

    /**  @var \vtrpc\CallerID */
    public $caller_id = null;
    
    /**  @var \vtgate\Session */
    public $session = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, 'vtgate.RollbackRequest');

      // OPTIONAL MESSAGE caller_id = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "caller_id";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\vtrpc\CallerID';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE session = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "session";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\vtgate\Session';
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <caller_id> has a value
     *
     * @return boolean
     */
    public function hasCallerId(){
      return $this->_has(1);
    }
    
    /**
     * Clear <caller_id> value
     *
     * @return \vtgate\RollbackRequest
     */
    public function clearCallerId(){
      return $this->_clear(1);
    }
    
    /**
     * Get <caller_id> value
     *
     * @return \vtrpc\CallerID
     */
    public function getCallerId(){
      return $this->_get(1);
    }
    
    /**
     * Set <caller_id> value
     *
     * @param \vtrpc\CallerID $value
     * @return \vtgate\RollbackRequest
     */
    public function setCallerId(\vtrpc\CallerID $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <session> has a value
     *
     * @return boolean
     */
    public function hasSession(){
      return $this->_has(2);
    }
    
    /**
     * Clear <session> value
     *
     * @return \vtgate\RollbackRequest
     */
    public function clearSession(){
      return $this->_clear(2);
    }
    
    /**
     * Get <session> value
     *
     * @return \vtgate\Session
     */
    public function getSession(){
      return $this->_get(2);
    }
    
    /**
     * Set <session> value
     *
     * @param \vtgate\Session $value
     * @return \vtgate\RollbackRequest
     */
    public function setSession(\vtgate\Session $value){
      return $this->_set(2, $value);
    }
  }
}

namespace vtgate {

  class RollbackResponse extends \DrSlump\Protobuf\Message {


    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, 'vtgate.RollbackResponse');

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }
  }
}

namespace vtgate {

  class SplitQueryRequest extends \DrSlump\Protobuf\Message {

    /**  @var \vtrpc\CallerID */
    public $caller_id = null;
    
    /**  @var string */
    public $keyspace = null;
    
    /**  @var \query\BoundQuery */
    public $query = null;
    
    /**  @var string */
    public $split_column = null;
    
    /**  @var int */
    public $split_count = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, 'vtgate.SplitQueryRequest');

      // OPTIONAL MESSAGE caller_id = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "caller_id";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\vtrpc\CallerID';
      $descriptor->addField($f);

      // OPTIONAL STRING keyspace = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "keyspace";
      $f->type      = \DrSlump\Protobuf::TYPE_STRING;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL MESSAGE query = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "query";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\query\BoundQuery';
      $descriptor->addField($f);

      // OPTIONAL STRING split_column = 4
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 4;
      $f->name      = "split_column";
      $f->type      = \DrSlump\Protobuf::TYPE_STRING;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // OPTIONAL INT64 split_count = 5
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 5;
      $f->name      = "split_count";
      $f->type      = \DrSlump\Protobuf::TYPE_INT64;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <caller_id> has a value
     *
     * @return boolean
     */
    public function hasCallerId(){
      return $this->_has(1);
    }
    
    /**
     * Clear <caller_id> value
     *
     * @return \vtgate\SplitQueryRequest
     */
    public function clearCallerId(){
      return $this->_clear(1);
    }
    
    /**
     * Get <caller_id> value
     *
     * @return \vtrpc\CallerID
     */
    public function getCallerId(){
      return $this->_get(1);
    }
    
    /**
     * Set <caller_id> value
     *
     * @param \vtrpc\CallerID $value
     * @return \vtgate\SplitQueryRequest
     */
    public function setCallerId(\vtrpc\CallerID $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <keyspace> has a value
     *
     * @return boolean
     */
    public function hasKeyspace(){
      return $this->_has(2);
    }
    
    /**
     * Clear <keyspace> value
     *
     * @return \vtgate\SplitQueryRequest
     */
    public function clearKeyspace(){
      return $this->_clear(2);
    }
    
    /**
     * Get <keyspace> value
     *
     * @return string
     */
    public function getKeyspace(){
      return $this->_get(2);
    }
    
    /**
     * Set <keyspace> value
     *
     * @param string $value
     * @return \vtgate\SplitQueryRequest
     */
    public function setKeyspace( $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <query> has a value
     *
     * @return boolean
     */
    public function hasQuery(){
      return $this->_has(3);
    }
    
    /**
     * Clear <query> value
     *
     * @return \vtgate\SplitQueryRequest
     */
    public function clearQuery(){
      return $this->_clear(3);
    }
    
    /**
     * Get <query> value
     *
     * @return \query\BoundQuery
     */
    public function getQuery(){
      return $this->_get(3);
    }
    
    /**
     * Set <query> value
     *
     * @param \query\BoundQuery $value
     * @return \vtgate\SplitQueryRequest
     */
    public function setQuery(\query\BoundQuery $value){
      return $this->_set(3, $value);
    }
    
    /**
     * Check if <split_column> has a value
     *
     * @return boolean
     */
    public function hasSplitColumn(){
      return $this->_has(4);
    }
    
    /**
     * Clear <split_column> value
     *
     * @return \vtgate\SplitQueryRequest
     */
    public function clearSplitColumn(){
      return $this->_clear(4);
    }
    
    /**
     * Get <split_column> value
     *
     * @return string
     */
    public function getSplitColumn(){
      return $this->_get(4);
    }
    
    /**
     * Set <split_column> value
     *
     * @param string $value
     * @return \vtgate\SplitQueryRequest
     */
    public function setSplitColumn( $value){
      return $this->_set(4, $value);
    }
    
    /**
     * Check if <split_count> has a value
     *
     * @return boolean
     */
    public function hasSplitCount(){
      return $this->_has(5);
    }
    
    /**
     * Clear <split_count> value
     *
     * @return \vtgate\SplitQueryRequest
     */
    public function clearSplitCount(){
      return $this->_clear(5);
    }
    
    /**
     * Get <split_count> value
     *
     * @return int
     */
    public function getSplitCount(){
      return $this->_get(5);
    }
    
    /**
     * Set <split_count> value
     *
     * @param int $value
     * @return \vtgate\SplitQueryRequest
     */
    public function setSplitCount( $value){
      return $this->_set(5, $value);
    }
  }
}

namespace vtgate\SplitQueryResponse {

  class KeyRangePart extends \DrSlump\Protobuf\Message {

    /**  @var string */
    public $keyspace = null;
    
    /**  @var \topodata\KeyRange[]  */
    public $key_ranges = array();
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, 'vtgate.SplitQueryResponse.KeyRangePart');

      // OPTIONAL STRING keyspace = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "keyspace";
      $f->type      = \DrSlump\Protobuf::TYPE_STRING;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // REPEATED MESSAGE key_ranges = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "key_ranges";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_REPEATED;
      $f->reference = '\topodata\KeyRange';
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <keyspace> has a value
     *
     * @return boolean
     */
    public function hasKeyspace(){
      return $this->_has(1);
    }
    
    /**
     * Clear <keyspace> value
     *
     * @return \vtgate\SplitQueryResponse\KeyRangePart
     */
    public function clearKeyspace(){
      return $this->_clear(1);
    }
    
    /**
     * Get <keyspace> value
     *
     * @return string
     */
    public function getKeyspace(){
      return $this->_get(1);
    }
    
    /**
     * Set <keyspace> value
     *
     * @param string $value
     * @return \vtgate\SplitQueryResponse\KeyRangePart
     */
    public function setKeyspace( $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <key_ranges> has a value
     *
     * @return boolean
     */
    public function hasKeyRanges(){
      return $this->_has(2);
    }
    
    /**
     * Clear <key_ranges> value
     *
     * @return \vtgate\SplitQueryResponse\KeyRangePart
     */
    public function clearKeyRanges(){
      return $this->_clear(2);
    }
    
    /**
     * Get <key_ranges> value
     *
     * @param int $idx
     * @return \topodata\KeyRange
     */
    public function getKeyRanges($idx = NULL){
      return $this->_get(2, $idx);
    }
    
    /**
     * Set <key_ranges> value
     *
     * @param \topodata\KeyRange $value
     * @return \vtgate\SplitQueryResponse\KeyRangePart
     */
    public function setKeyRanges(\topodata\KeyRange $value, $idx = NULL){
      return $this->_set(2, $value, $idx);
    }
    
    /**
     * Get all elements of <key_ranges>
     *
     * @return \topodata\KeyRange[]
     */
    public function getKeyRangesList(){
     return $this->_get(2);
    }
    
    /**
     * Add a new element to <key_ranges>
     *
     * @param \topodata\KeyRange $value
     * @return \vtgate\SplitQueryResponse\KeyRangePart
     */
    public function addKeyRanges(\topodata\KeyRange $value){
     return $this->_add(2, $value);
    }
  }
}

namespace vtgate\SplitQueryResponse {

  class ShardPart extends \DrSlump\Protobuf\Message {

    /**  @var string */
    public $keyspace = null;
    
    /**  @var string[]  */
    public $shards = array();
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, 'vtgate.SplitQueryResponse.ShardPart');

      // OPTIONAL STRING keyspace = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "keyspace";
      $f->type      = \DrSlump\Protobuf::TYPE_STRING;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      // REPEATED STRING shards = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "shards";
      $f->type      = \DrSlump\Protobuf::TYPE_STRING;
      $f->rule      = \DrSlump\Protobuf::RULE_REPEATED;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <keyspace> has a value
     *
     * @return boolean
     */
    public function hasKeyspace(){
      return $this->_has(1);
    }
    
    /**
     * Clear <keyspace> value
     *
     * @return \vtgate\SplitQueryResponse\ShardPart
     */
    public function clearKeyspace(){
      return $this->_clear(1);
    }
    
    /**
     * Get <keyspace> value
     *
     * @return string
     */
    public function getKeyspace(){
      return $this->_get(1);
    }
    
    /**
     * Set <keyspace> value
     *
     * @param string $value
     * @return \vtgate\SplitQueryResponse\ShardPart
     */
    public function setKeyspace( $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <shards> has a value
     *
     * @return boolean
     */
    public function hasShards(){
      return $this->_has(2);
    }
    
    /**
     * Clear <shards> value
     *
     * @return \vtgate\SplitQueryResponse\ShardPart
     */
    public function clearShards(){
      return $this->_clear(2);
    }
    
    /**
     * Get <shards> value
     *
     * @param int $idx
     * @return string
     */
    public function getShards($idx = NULL){
      return $this->_get(2, $idx);
    }
    
    /**
     * Set <shards> value
     *
     * @param string $value
     * @return \vtgate\SplitQueryResponse\ShardPart
     */
    public function setShards( $value, $idx = NULL){
      return $this->_set(2, $value, $idx);
    }
    
    /**
     * Get all elements of <shards>
     *
     * @return string[]
     */
    public function getShardsList(){
     return $this->_get(2);
    }
    
    /**
     * Add a new element to <shards>
     *
     * @param string $value
     * @return \vtgate\SplitQueryResponse\ShardPart
     */
    public function addShards( $value){
     return $this->_add(2, $value);
    }
  }
}

namespace vtgate\SplitQueryResponse {

  class Part extends \DrSlump\Protobuf\Message {

    /**  @var \query\BoundQuery */
    public $query = null;
    
    /**  @var \vtgate\SplitQueryResponse\KeyRangePart */
    public $key_range_part = null;
    
    /**  @var \vtgate\SplitQueryResponse\ShardPart */
    public $shard_part = null;
    
    /**  @var int */
    public $size = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, 'vtgate.SplitQueryResponse.Part');

      // OPTIONAL MESSAGE query = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "query";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\query\BoundQuery';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE key_range_part = 2
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 2;
      $f->name      = "key_range_part";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\vtgate\SplitQueryResponse\KeyRangePart';
      $descriptor->addField($f);

      // OPTIONAL MESSAGE shard_part = 3
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 3;
      $f->name      = "shard_part";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\vtgate\SplitQueryResponse\ShardPart';
      $descriptor->addField($f);

      // OPTIONAL INT64 size = 4
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 4;
      $f->name      = "size";
      $f->type      = \DrSlump\Protobuf::TYPE_INT64;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <query> has a value
     *
     * @return boolean
     */
    public function hasQuery(){
      return $this->_has(1);
    }
    
    /**
     * Clear <query> value
     *
     * @return \vtgate\SplitQueryResponse\Part
     */
    public function clearQuery(){
      return $this->_clear(1);
    }
    
    /**
     * Get <query> value
     *
     * @return \query\BoundQuery
     */
    public function getQuery(){
      return $this->_get(1);
    }
    
    /**
     * Set <query> value
     *
     * @param \query\BoundQuery $value
     * @return \vtgate\SplitQueryResponse\Part
     */
    public function setQuery(\query\BoundQuery $value){
      return $this->_set(1, $value);
    }
    
    /**
     * Check if <key_range_part> has a value
     *
     * @return boolean
     */
    public function hasKeyRangePart(){
      return $this->_has(2);
    }
    
    /**
     * Clear <key_range_part> value
     *
     * @return \vtgate\SplitQueryResponse\Part
     */
    public function clearKeyRangePart(){
      return $this->_clear(2);
    }
    
    /**
     * Get <key_range_part> value
     *
     * @return \vtgate\SplitQueryResponse\KeyRangePart
     */
    public function getKeyRangePart(){
      return $this->_get(2);
    }
    
    /**
     * Set <key_range_part> value
     *
     * @param \vtgate\SplitQueryResponse\KeyRangePart $value
     * @return \vtgate\SplitQueryResponse\Part
     */
    public function setKeyRangePart(\vtgate\SplitQueryResponse\KeyRangePart $value){
      return $this->_set(2, $value);
    }
    
    /**
     * Check if <shard_part> has a value
     *
     * @return boolean
     */
    public function hasShardPart(){
      return $this->_has(3);
    }
    
    /**
     * Clear <shard_part> value
     *
     * @return \vtgate\SplitQueryResponse\Part
     */
    public function clearShardPart(){
      return $this->_clear(3);
    }
    
    /**
     * Get <shard_part> value
     *
     * @return \vtgate\SplitQueryResponse\ShardPart
     */
    public function getShardPart(){
      return $this->_get(3);
    }
    
    /**
     * Set <shard_part> value
     *
     * @param \vtgate\SplitQueryResponse\ShardPart $value
     * @return \vtgate\SplitQueryResponse\Part
     */
    public function setShardPart(\vtgate\SplitQueryResponse\ShardPart $value){
      return $this->_set(3, $value);
    }
    
    /**
     * Check if <size> has a value
     *
     * @return boolean
     */
    public function hasSize(){
      return $this->_has(4);
    }
    
    /**
     * Clear <size> value
     *
     * @return \vtgate\SplitQueryResponse\Part
     */
    public function clearSize(){
      return $this->_clear(4);
    }
    
    /**
     * Get <size> value
     *
     * @return int
     */
    public function getSize(){
      return $this->_get(4);
    }
    
    /**
     * Set <size> value
     *
     * @param int $value
     * @return \vtgate\SplitQueryResponse\Part
     */
    public function setSize( $value){
      return $this->_set(4, $value);
    }
  }
}

namespace vtgate {

  class SplitQueryResponse extends \DrSlump\Protobuf\Message {

    /**  @var \vtgate\SplitQueryResponse\Part[]  */
    public $splits = array();
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, 'vtgate.SplitQueryResponse');

      // REPEATED MESSAGE splits = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "splits";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_REPEATED;
      $f->reference = '\vtgate\SplitQueryResponse\Part';
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <splits> has a value
     *
     * @return boolean
     */
    public function hasSplits(){
      return $this->_has(1);
    }
    
    /**
     * Clear <splits> value
     *
     * @return \vtgate\SplitQueryResponse
     */
    public function clearSplits(){
      return $this->_clear(1);
    }
    
    /**
     * Get <splits> value
     *
     * @param int $idx
     * @return \vtgate\SplitQueryResponse\Part
     */
    public function getSplits($idx = NULL){
      return $this->_get(1, $idx);
    }
    
    /**
     * Set <splits> value
     *
     * @param \vtgate\SplitQueryResponse\Part $value
     * @return \vtgate\SplitQueryResponse
     */
    public function setSplits(\vtgate\SplitQueryResponse\Part $value, $idx = NULL){
      return $this->_set(1, $value, $idx);
    }
    
    /**
     * Get all elements of <splits>
     *
     * @return \vtgate\SplitQueryResponse\Part[]
     */
    public function getSplitsList(){
     return $this->_get(1);
    }
    
    /**
     * Add a new element to <splits>
     *
     * @param \vtgate\SplitQueryResponse\Part $value
     * @return \vtgate\SplitQueryResponse
     */
    public function addSplits(\vtgate\SplitQueryResponse\Part $value){
     return $this->_add(1, $value);
    }
  }
}

namespace vtgate {

  class GetSrvKeyspaceRequest extends \DrSlump\Protobuf\Message {

    /**  @var string */
    public $keyspace = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, 'vtgate.GetSrvKeyspaceRequest');

      // OPTIONAL STRING keyspace = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "keyspace";
      $f->type      = \DrSlump\Protobuf::TYPE_STRING;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <keyspace> has a value
     *
     * @return boolean
     */
    public function hasKeyspace(){
      return $this->_has(1);
    }
    
    /**
     * Clear <keyspace> value
     *
     * @return \vtgate\GetSrvKeyspaceRequest
     */
    public function clearKeyspace(){
      return $this->_clear(1);
    }
    
    /**
     * Get <keyspace> value
     *
     * @return string
     */
    public function getKeyspace(){
      return $this->_get(1);
    }
    
    /**
     * Set <keyspace> value
     *
     * @param string $value
     * @return \vtgate\GetSrvKeyspaceRequest
     */
    public function setKeyspace( $value){
      return $this->_set(1, $value);
    }
  }
}

namespace vtgate {

  class GetSrvKeyspaceResponse extends \DrSlump\Protobuf\Message {

    /**  @var \topodata\SrvKeyspace */
    public $srv_keyspace = null;
    

    /** @var \Closure[] */
    protected static $__extensions = array();

    public static function descriptor()
    {
      $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, 'vtgate.GetSrvKeyspaceResponse');

      // OPTIONAL MESSAGE srv_keyspace = 1
      $f = new \DrSlump\Protobuf\Field();
      $f->number    = 1;
      $f->name      = "srv_keyspace";
      $f->type      = \DrSlump\Protobuf::TYPE_MESSAGE;
      $f->rule      = \DrSlump\Protobuf::RULE_OPTIONAL;
      $f->reference = '\topodata\SrvKeyspace';
      $descriptor->addField($f);

      foreach (self::$__extensions as $cb) {
        $descriptor->addField($cb(), true);
      }

      return $descriptor;
    }

    /**
     * Check if <srv_keyspace> has a value
     *
     * @return boolean
     */
    public function hasSrvKeyspace(){
      return $this->_has(1);
    }
    
    /**
     * Clear <srv_keyspace> value
     *
     * @return \vtgate\GetSrvKeyspaceResponse
     */
    public function clearSrvKeyspace(){
      return $this->_clear(1);
    }
    
    /**
     * Get <srv_keyspace> value
     *
     * @return \topodata\SrvKeyspace
     */
    public function getSrvKeyspace(){
      return $this->_get(1);
    }
    
    /**
     * Set <srv_keyspace> value
     *
     * @param \topodata\SrvKeyspace $value
     * @return \vtgate\GetSrvKeyspaceResponse
     */
    public function setSrvKeyspace(\topodata\SrvKeyspace $value){
      return $this->_set(1, $value);
    }
  }
}

